<!DOCTYPE html><html lang="en" ><head ><title >Please help me test this opengl stuff</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Please help me test this opengl stuff</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Please help me test this opengl stuff</a><br><br>
<a name="1234417"></a>

<a name="1234418"></a>

<a name="1234419"></a>

<a name="1234456"></a>

<a name="1234584"></a>

<a name="1235449"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi! Im messing around a bit with opengl atm, trying to figure out whats the best way to do things. I did a simple 2d scene to have something to compare with.<br><br>Both should draw the same thing, and print fps regularly to the console/output. Id like to see some figures from other people, and know if it works (at all!).<br><br>GLMax2D:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

SetGraphicsDriver GLMax2DDriver()
Graphics 800, 600, 0

Type TParticle

	Global list:TList

	Field x:Float
	Field y:Float
	Field size:Float
	Field d:Float
	
	Function Create:TParticle(px:Float, py:Float, psize:Float, pd:Float)
	
		Local this:TParticle=New TParticle
		
		this.x=px
		this.y=py
		this.size=psize
		this.d=pd
		
		If list=Null Then
			list=New TList
		EndIf
		
		list.AddLast(this)
		
		Return this
		
	End Function
	
	Function Update()
	End Function
	
	Function Draw()
		
		If list=Null Then
			Return
		EndIf
		
		SetBlend LIGHTBLEND
		SetAlpha 0.15
		
		For Local o:TParticle=EachIn list
		
			o.d:-1
			
			Local dx:Float=o.x-400
			Local dy:Float=o.y-300
			
			Local m:Float=Sqr(dx*dx+dy*dy)
			
			If m&lt;1.0 Then
				m=1.0
			EndIf
			
			m:*0.1
			
			If m&gt;255.0 Then
				m=255.0
			EndIf
			
			SetColor 0.25*m, 0.5*m, m
		
			DrawRect o.x-o.size*0.5, o.y-o.size*0.5, o.size, o.size
		
		Next
		
		SetAlpha 1
		SetBlend SOLIDBLEND
		
	End Function

End Type

For Local i:Int=1 To 20000
	TParticle.Create(Rand(800), Rand(600), Rnd(2, 15), Rand(360))
Next

Local angle:Float=0

Local curfps:Int=0
Local fps:Int=0
Local time:Int=MilliSecs()+1000

Repeat

	Local ms:Int

	If MilliSecs()&gt;time Then
		time:+1000
		fps=curfps+1
		curfps=0
		Print "FPS: "+fps
	Else
		curfps:+1
	EndIf

	angle:+0.1
	
	If angle&gt;=360 Then
		angle=0
	EndIf

	TParticle.Update()

	SetClsColor 0, 0, 0
	Cls
	
	' draw a gradient background with lines
	ms=MilliSecs()	

	For Local y:Int=0 To 600
		
		SetColor 31.5+Cos(angle+y*0.1)*31.5, 63.5+Cos(angle+y*0.1)*63.5, 127.5+Cos(angle+y*0.1)*127.5
		DrawLine 0, y, 800, y
		
	Next
	
	ms=MilliSecs()-ms
	'Print "lines: "+ms
	
	' draw a bunch of rectangles with various alpha values on top
	
	ms=MilliSecs()
	
	TParticle.Draw()
	
	ms=MilliSecs()-ms
	'Print "particles: "+ms
	
	' plot a dense spiral on top
	
	SetBlend LIGHTBLEND
	SetAlpha 0.25
	SetColor 32, 64, 128
	
	For Local i:Int=1 To 50000
	
		Local x:Float=400.0+Cos(angle+i)*(Float(i)*0.01)
		Local y:Float=300.0+Sin(angle+i)*(Float(i)*0.01)
		
		Plot x, y
	
	Next
	
	SetAlpha 1
	SetBlend SOLIDBLEND
	
	Flip(False)

Until KeyHit(KEY_ESCAPE)=True

EndGraphics
End
</textarea><br><br>Custom OpenGL:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

Framework BRL.GLGraphics

Import BRL.StandardIO
Import BRL.Random
Import BRL.LinkedList

Import PUB.OpenGL
Import PUB.Glew

Const OPENGL_ES2_TARGET:Int=1
Const OPENGL_3_TARGET:Int=2

'Global OPENGL_TARGET:Int=OPENGL_ES2_TARGET
Global OPENGL_TARGET:Int=OPENGL_3_TARGET

Const BATCHSIZE:Int=65536 ' how many entries that can be stored in batch before a draw call is required

Const SOLIDBLEND:Int=1
Const LIGHTBLEND:Int=2
Const ALPHABLEND:Int=3

Type opengl

	' constants for primitive rendering
	
	Const PRIMITIVE_PLAIN_TRIANGLE:Int=1
	Const PRIMITIVE_DOT:Int=2
	Const PRIMITIVE_LINE:Int=3
	Const PRIMITIVE_IMAGE:Int=4

	Global pmatrix:TMatrix
	
	Global vert_buffer:Int
	Global uv_buffer:Int
	Global col_buffer:Int
	Global element_buffer:Int
	
	' current color for drawing
	
	Global red:Float
	Global green:Float
	Global blue:Float
	Global alpha:Float
	
	' current z layer for drawing
	
	Global layer:Float
	
	' shader
	
	Global active:Int
	Global plain:Int
	Global texture:Int
	
	Global attrib_pos:Int
	Global attrib_uv:Int
	Global attrib_col:Int
	
	Global unif_projection:Int
	Global unif_tex:Int
	
	' batch rendering
	
	Global vert_array:Float[BATCHSIZE*3]
	Global uv_array:Float[BATCHSIZE*2]
	Global col_array:Float[BATCHSIZE*4]
	
	Global index:Int
	
	Global element_array:Int[BATCHSIZE*2]
	Global element_index:Int
	
	Global primitive:Int
	Global texture_id:Int
	
	' functions
	
	Function Initialize()
	
		' init basic opengl
	
		glewInit()
		
		glEnable(GL_DEPTH_TEST)
		glDepthFunc(GL_LEQUAL)
		
		glEnable(GL_BLEND)
		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
	
		' validate target
		
		Local glsl_version:String=String.FromCString(glGetString(GL_SHADING_LANGUAGE_VERSION))
	
		Select OPENGL_TARGET
		Case OPENGL_ES2_TARGET
			Print "(Initialize) OpenGL ES2 Target"
			Print "(Initialize) GLSL: "+glsl_version+" (1.00 required)"
		Case OPENGL_3_TARGET
			Print "(Initialize) OpenGL 3 Target"
			Print "(Initialize) GLSL: "+glsl_version+" (1.20 required)"
		Default
			Print "(Initialize) No OpenGL Target!"
			End
		End Select
	
		' set up projection matrix for 2d rendering
	
		Local pw:Int=GraphicsWidth()
		Local ph:Int=GraphicsHeight()
	
		pmatrix=New TMatrix
		pmatrix.SetOrthographic(0, pw, 0, ph, -1, 1)
		
		Print "(Initialize) Matrix Debug:"
		pmatrix.Debug()
		
		' set up layer
		
		layer=-1.0
		
		' set up colors
		
		Print "(Initialize) Setting colors to &lt;1, 1, 1, 1&gt;"
		
		red=1.0
		green=1.0
		blue=1.0
		alpha=1.0
		
		' set up shaders
		
		Local vs:Int
		Local fs:Int
		
		vs=CompileShader(PlainVShaderSource(), GL_VERTEX_SHADER)
		fs=CompileShader(PlainFShaderSource(), GL_FRAGMENT_SHADER)
		
		plain=CreateShaderProgram(vs, fs)
		If glIsProgram(plain) Then
			Print "(Initialize) Created plain shader program!"
		EndIf
		
		vs=CompileShader(TextureVShaderSource(), GL_VERTEX_SHADER)
		fs=CompileShader(TextureFShaderSource(), GL_FRAGMENT_SHADER)
		
		texture=CreateShaderProgram(vs, fs)
		If glIsProgram(texture) Then
			Print "(Initialize) Created texture shader program!"
		EndIf
		
		' set up batch
		
		index=0
		primitive=0
		texture_id=-1
	
	End Function
	
	Function UpdateBuffers()
	
		If vert_buffer=0 Then glGenBuffers(1, Varptr vert_buffer)
		If uv_buffer=0 Then glGenBuffers(1, Varptr uv_buffer)
		If col_buffer=0 Then glGenbuffers(1, Varptr col_buffer)
		If element_buffer=0 Then glGenbuffers(1, Varptr element_buffer)
		
		glBindBuffer(GL_ARRAY_BUFFER, vert_buffer)
		glBufferData(GL_ARRAY_BUFFER, index*8, vert_array, GL_DYNAMIC_DRAW)
		
		glBindBuffer(GL_ARRAY_BUFFER, uv_buffer)
		glBufferData(GL_ARRAY_BUFFER, index*8, uv_array, GL_DYNAMIC_DRAW)
		
		glBindBuffer(GL_ARRAY_BUFFER, col_buffer)
		glBufferData(GL_ARRAY_BUFFER, index*16, col_array, GL_DYNAMIC_DRAW)
		
		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, element_buffer)
		glBufferData(GL_ELEMENT_ARRAY_BUFFER, element_index*12, element_array, GL_DYNAMIC_DRAW)
			
	End Function
	
	Function UpdateShaderLayout()
	
		If Not glIsProgram(active) Then
			Print "(UpdateShaderLayout) Active is not a valid shader program!"
			Return
		EndIf
		
		attrib_pos=glGetAttribLocation(active, "vertex_pos")
		attrib_uv=glGetAttribLocation(active, "vertex_uv")
		attrib_col=glGetAttribLocation(active, "vertex_col")
		
		unif_projection=glGetUniformLocation(active, "pmatrix")
		unif_tex=glGetUniformLocation(active, "texture")
		
		Print "(UpdateShaderLayout) attrib_pos: "+attrib_pos
		Print "(UpdateShaderLayout) attrib_uv: "+attrib_uv
		Print "(UpdateShaderLayout) attrib_col: "+attrib_col
		
		Print "(UpdateShaderLayout) unif_projection: "+unif_projection
		Print "(UpdateShaderLayout) unif_tex: "+unif_tex
	
	End Function
	
	Function EnableShaderData()
	
		If attrib_pos&gt;=0 Then
			glEnableVertexAttribArray(attrib_pos)
			glBindBuffer(GL_ARRAY_BUFFER, vert_buffer)
			glVertexAttribPointer(attrib_pos, 2, GL_FLOAT, GL_FALSE, 0, Null)
		EndIf
		
		If attrib_uv&gt;=0 Then
			glEnableVertexAttribArray(attrib_uv)
			glBindBuffer(GL_ARRAY_BUFFER, uv_buffer)
			glVertexAttribPointer(attrib_uv, 2, GL_FLOAT, GL_FALSE, 0, Null)
		EndIf
		
		If attrib_col&gt;=0 Then
			glEnableVertexAttribArray(attrib_col)
			glBindBuffer(GL_ARRAY_BUFFER, col_buffer)
			glVertexAttribPointer(attrib_col, 4, GL_FLOAT, GL_FALSE, 0, Null)
		EndIf
		
		If unif_projection&gt;=0 Then
			'glUniformMatrix4fv(unif_projection, 16, False, pmatrix.grid) ' bad
			glUniformMatrix4fv(unif_projection, 1, False, Varptr pmatrix.grid[0])
		EndIf
		
		If unif_tex&gt;=0 Then
			glUniform1i(unif_tex, 0)
		EndIf
		
	End Function
	
	Function DisableShaderData()
	
		If attrib_pos&gt;=0 Then
			glDisableVertexAttribArray(attrib_pos)
		EndIf
		
		If attrib_uv&gt;=0 Then
			glDisableVertexAttribArray(attrib_uv)
		EndIf
		
		If attrib_col&gt;=0 Then
			glDisableVertexAttribArray(attrib_col)
		EndIf
	
	End Function
	
	' fence. force a draw of whatever is currently stored in batch arrays
	
	Function Fence()
	
		Select primitive
		Case PRIMITIVE_PLAIN_TRIANGLE
			If active&lt;&gt;plain Then
				active=plain
				glUseProgram(active)
				UpdateShaderLayout()
			EndIf
		Case PRIMITIVE_DOT
			If active&lt;&gt;plain Then
				active=plain
				glUseProgram(active)
				UpdateShaderLayout()
			EndIf
		Case PRIMITIVE_LINE
			If active&lt;&gt;plain Then
				active=plain
				glUseProgram(active)
				UpdateShaderLayout()
			EndIf
		End Select
		
		UpdateBuffers()
		EnableShaderData()
		
		' additional tests. validate shaderprogram and buffer. shader program validation takes
		' context into consideration, so do it right before drawing
		
		ValidateShaderProgram(active)
		
		' somewhat interesting? default framebuffer should not return any errors
		' NOTE: 36062 seems to be an erroneous error code (ie opengl returns something it shouldnt)
		Local status:Int=glCheckFramebufferStatus(GL_FRAMEBUFFER)
		Select status
		Case GL_FRAMEBUFFER_COMPLETE
			'Print "valid framebuffer"
		Default
			Print "status: "+status
		End Select
		
		Select primitive
		Case PRIMITIVE_PLAIN_TRIANGLE
			glDrawArrays(GL_TRIANGLES, 0, index)
		Case PRIMITIVE_DOT
			glDrawArrays(GL_POINTS, 0, index)
		Case PRIMITIVE_LINE
			glDrawArrays(GL_LINES, 0, index)
		End Select
		
		DisableShaderData()
		
		index=0
		element_index=0
	
	End Function
	
	' set color
	
	Function SetColor(pr:Float, pg:Float, pb:Float)
		red=pr/255
		green=pg/255
		blue=pb/255
	End Function
	
	' set alpha
	
	Function SetAlpha(pa:Float)
		alpha=pa
	End Function
	
	Function SetBlend(pmode:Int)
		Select pmode
		Case ALPHABLEND
			glEnable(GL_BLEND)
			glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
		Case LIGHTBLEND
			glEnable(GL_BLEND)
			glBlendFunc(GL_SRC_ALPHA, GL_ONE)
		Case SOLIDBLEND
			glDisable(GL_BLEND)
		End Select
	End Function	
	
	' draw a line on screen
	
	Function DrawLine(px1:Float, py1:Float, px2:Float, py2:Float)
	
		If primitive&lt;&gt;PRIMITIVE_LINE Or index&gt;BATCHSIZE-256 Or texture_id&gt;-1 Then
			Fence()
			primitive=PRIMITIVE_LINE
		EndIf
		
		Local in:Int
		
		in=index*2
		
		vert_array[in+0]=px1
		vert_array[in+1]=py1
		
		vert_array[in+2]=px2
		vert_array[in+3]=py2
		
		in=index*4
		
		col_array[in+00]=red
		col_array[in+01]=green
		col_array[in+02]=blue
		col_array[in+03]=alpha
		
		col_array[in+04]=red
		col_array[in+05]=green
		col_array[in+06]=blue
		col_array[in+07]=alpha
		
		index:+2
	
	End Function
	
	' draw a point on screen
	
	Function Plot(px:Float, py:Float)
	
		If primitive&lt;&gt;PRIMITIVE_DOT Or index&gt;BATCHSIZE-256 Or texture_id&gt;-1 Then
			Fence()
			primitive=PRIMITIVE_DOT
		EndIf
		
		Local in:Int
		
		in=index*2
		
		vert_array[in+0]=px
		vert_array[in+1]=py
		
		in=index*4
		
		col_array[in+00]=red
		col_array[in+01]=green
		col_array[in+02]=blue
		col_array[in+03]=alpha		
		
		index:+1
	
	End Function
	
	' draw rectangle on screen
	
	Function DrawRect(px:Float, py:Float, pw:Float, ph:Float)
		
		' append data to batch arrays
		
		If primitive&lt;&gt;PRIMITIVE_PLAIN_TRIANGLE Or index&gt;BATCHSIZE-256 Or texture_id&gt;-1 Then
			Fence()
			primitive=PRIMITIVE_PLAIN_TRIANGLE
		EndIf
		
		Local in:Int
		
		in=index*2
		
		vert_array[in+00]=px
		vert_array[in+01]=py
		
		vert_array[in+02]=px+pw
		vert_array[in+03]=py
		
		vert_array[in+04]=px+pw
		vert_array[in+05]=py+ph
		
		vert_array[in+06]=px+pw
		vert_array[in+07]=py+ph
		
		vert_array[in+08]=px
		vert_array[in+09]=py+ph
		
		vert_array[in+10]=px
		vert_array[in+11]=py
		
		in=index*4

		col_array[in+00]=red
		col_array[in+01]=green
		col_array[in+02]=blue
		col_array[in+03]=alpha
		
		col_array[in+04]=red
		col_array[in+05]=green
		col_array[in+06]=blue
		col_array[in+07]=alpha
		
		col_array[in+08]=red
		col_array[in+09]=green
		col_array[in+10]=blue
		col_array[in+11]=alpha
		
		col_array[in+12]=red
		col_array[in+13]=green
		col_array[in+14]=blue
		col_array[in+15]=alpha
		
		col_array[in+16]=red
		col_array[in+17]=green
		col_array[in+18]=blue
		col_array[in+19]=alpha
		
		col_array[in+20]=red
		col_array[in+21]=green
		col_array[in+22]=blue
		col_array[in+23]=alpha

		index:+6
		
	End Function
	
End Type

' ///////////////////////////////////////////////////////////////////////////////////////
' matrix.bmx

Type TMatrix

	Field grid:Float[16]
	
	Method SetOrthographic(pl:Float, pr:Float, pt:Float, pb:Float, pn:Float, pf:Float)
		LoadIdentity()
		grid[00] = 2.0/(pr-pl)
		grid[05] = 2.0/(pt-pb)
		grid[10] =-2.0/(pf-pn)
		grid[15] = 1.0
		grid[12]=-((pr+pl)/(pr-pl))
		grid[13]=-((pt+pb)/(pt-pb))
		grid[14]=-((pf+pn)/(pf-pn))
	End Method
	
	Method Clear()
		For Local i:Int=0 To 15
			grid[i]=0.0
		Next
	End Method
	
	Method LoadIdentity()
		Clear()
		grid[00]=1.0
		grid[05]=1.0
		grid[10]=1.0
		grid[15]=1.0
	End Method
	
	Method Debug()
		Print "Matrix 4x4:"
		For Local j:Int=0 To 3
			For Local i:Int=0 To 3
				WriteStdout grid[j*4+i]
				If i&lt;3 Then
					WriteStdout ", "
				EndIf
			Next
			WriteStdout "~n"
		Next
	End Method

End Type

' ///////////////////////////////////////////////////////////////////////////////////////
' shader.bmx

Function CompileShader:Int(psource:String, ptype:Int)
	
	If psource="" Then
		Print "ERROR (CompileShader) No shader source!"
		Return 0
	EndIf
	
	Select ptype
	Case GL_VERTEX_SHADER
		Print "(CompileShader) Compiling vertex shader"
	Case GL_FRAGMENT_SHADER
		Print "(CompileShader) Compiling fragment shader"
	Default 
		Print "(CompileShader) Invalid shader type!"
		Return 0
	End Select
	
	Local id:Int=glCreateShader(ptype)
	Local cstring:Byte Ptr=psource.ToCString()
	
	glShaderSource(id, 1, Varptr cstring, Null)
	glCompileShader(id)
	
	Local success:Int=0
	glGetShaderiv(id, GL_COMPILE_STATUS, Varptr success)
	
	If Not success Then
		Print GetShaderErrorLog(id)
		Return 0
	EndIf
	
	Print "(CompileShader) Successfully compiled shader!"
	Return id
	
End Function

Function GetShaderErrorLog:String(pid:Int)

	Local logsize:Int=0
	glGetShaderiv(pid, GL_INFO_LOG_LENGTH, Varptr logsize)
	
	Local msg:Byte[logsize]
	Local size:Int=0
	
	glGetShaderInfoLog(pid, logsize, Varptr size, Varptr msg[0])
	
	Local str:String=""
	
	For Local i:Int=0 To msg.length-1
		str:+Chr(msg[i])
	Next
	
	Return str

End Function

Function CreateShaderProgram:Int(pvshader:Int, pfshader:Int)
	
	If glIsShader(pvshader)=GL_FALSE Then 
		Print "ERROR (CreateShaderProgram) pvshader is not a valid shader!"
		Return 0
	EndIf
	
	If glIsShader(pfshader)=GL_FALSE Then
		Print "ERROR (CreateShaderProgram) pfshader is not a valid shader!"
		Return 0
	EndIf
	
	Local id:Int=glCreateProgram()
	
	glAttachShader(id, pvshader)
	glAttachShader(id, pfshader)
	
	glLinkProgram(id)
	
	Return id
	
End Function

Function ValidateShaderProgram(pid:Int)

	If glIsProgram(pid)=GL_FALSE Then
		Print "ERROR (ValidateShaderProgram) Supplied id is not a shader program!"
		Return
	EndIf
	
	Local status:Int
	
	glValidateProgram(pid)
	glGetProgramiv(pid, GL_VALIDATE_STATUS, Varptr status)
	
	If status=GL_FALSE Then
		Print "ERROR (ValidateShaderprogram) Supplied program is not valid! (in context)"
		Return
	EndIf
	
	Return

End Function

' ///////////////////////////////////////////////////////////////////////////////////////
' shadersource.bmx

Function PlainVShaderSource:String()

	Local str:String=""

	If OPENGL_TARGET=OPENGL_ES2_TARGET Then
	
		str:+"#version 100~n"
		str:+"attribute vec2 vertex_pos;~n"
		str:+"attribute vec4 vertex_col;~n"
		str:+"varying vec4 f_col;~n"
	
	Else ' OPENGL_TARGET=OPENGL_3_TARGET
	
		str:+"#version 120~n"
		str:+"attribute vec2 vertex_pos;~n"
		str:+"attribute vec4 vertex_col;~n"
		str:+"varying vec4 f_col;~n"
	
	EndIf

	str:+"uniform mat4 pmatrix;~n"
	str:+"void main(void) {~n"
	str:+"	gl_Position=pmatrix*vec4(vertex_pos, -1.0, 1.0);~n"
	str:+"	f_col=vertex_col;~n"
	str:+"}"
	
	Return str

End Function

Function PlainFShaderSource:String()

	Local str:String=""
	
	If OPENGL_TARGET=OPENGL_ES2_TARGET Then
	
		str:+"#version 100~n"
		str:+"precision mediump float;~n"
		str:+"varying vec4 f_col;~n"
		str:+"void main(void) {~n"
		str:+"	gl_FragColor=vec4(f_col);~n"
		str:+"}~n"
	
	Else ' OPENGL_TARGET=OPENGL_3_TARGET
	
		str:+"#version 120~n"
		str:+"varying vec4 f_col;~n"
		str:+"void main(void) {~n"
		str:+"	gl_FragColor=f_col;~n"
		str:+"}~n"
	
	EndIf
	
	Return str

End Function

Function TextureVShaderSource:String()
End Function

Function TextureFShaderSource:String()
End Function

' ///////////////////////////////////////////////////////////////////////////////////////

SetGraphicsDriver GLGraphicsDriver()
GLGraphics 800, 600, 0, 60, GRAPHICS_BACKBUFFER|GRAPHICS_DEPTHBUFFER

opengl.Initialize()

Type TParticle

	Global list:TList

	Field x:Float
	Field y:Float
	Field size:Float
	Field d:Float
	
	Function Create:TParticle(px:Float, py:Float, psize:Float, pd:Float)
	
		Local this:TParticle=New TParticle
		
		this.x=px
		this.y=py
		this.size=psize
		this.d=pd
		
		If list=Null Then
			list=New TList
		EndIf
		
		list.AddLast(this)
		
		Return this
		
	End Function
	
	Function Update()
	End Function
	
	Function Draw()
		
		If list=Null Then
			Return
		EndIf
		
		opengl.SetBlend LIGHTBLEND
		opengl.SetAlpha 0.15
		
		For Local o:TParticle=EachIn list
		
			o.d:-1
			
			Local dx:Float=o.x-400
			Local dy:Float=o.y-300
			
			Local m:Float=Sqr(dx*dx+dy*dy)
			
			If m&lt;1.0 Then
				m=1.0
			EndIf
			
			m:*0.1
			
			If m&gt;255.0 Then
				m=255.0
			EndIf
			
			opengl.SetColor 0.25*m, 0.5*m, m
			opengl.DrawRect o.x-o.size*0.5, o.y-o.size*0.5, o.size, o.size
		
		Next
		
		opengl.SetAlpha 1
		opengl.SetBlend SOLIDBLEND
		
	End Function

End Type

For Local i:Int=1 To 20000
	TParticle.Create(Rand(800), Rand(600), Rnd(2, 15), Rand(360))
Next

Local curfps:Int
Local fps:Int
Local curtime:Int=MilliSecs()+1000

Local angle:Float=0

Repeat

	angle:+0.1
	If angle&gt;=360 Then
		angle=0
	EndIf

	If MilliSecs()&gt;curtime Then
		curtime:+1000
		fps=curfps+1
		curfps=0
		Print "FPS: "+fps
	Else
		curfps:+1
	EndIf

	glClearColor(0, 0, 0, 0)
	glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)
	
	' draw gradient background with lines
	
	opengl.SetBlend SOLIDBLEND
	opengl.SetAlpha 1
	
	For Local y:Int=0 To 600
	
		opengl.SetColor 31.5+Cos(angle+y*0.1)*31.5, 63+5+Cos(angle+y*0.1)*63.5, 127.5+Cos(angle+y*0.1)*127.5
		opengl.DrawLine 0, y, 800, y
	
	Next
	
	' draw rectangle cloud
	
	TParticle.Draw()
	
	' plot a dense spiral
	
	opengl.SetBlend LIGHTBLEND
	
	opengl.SetAlpha 0.25
	opengl.SetColor 32, 64, 128 
	
	For Local i:Int=1 To 50000
		Local x:Float=400.0+Cos(angle+i)*(Float(i)*0.01)
		Local y:Float=300.0+Sin(angle+i)*(Float(i)*0.01)
		opengl.Plot x, y
	Next
	
	opengl.Fence()
	
	Flip(False)

Until KeyHit(KEY_ESCAPE)=True

EndGraphics
End
</textarea><br><br>EDIT: Codeboxes are wonderful little things :) <br><br></td></tr></table><br>
<a name="1234441"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok, first thing is your shader code - It's not glsl (not sure, possibly hlsl?)<br>you need to change to the following:<br><pre class=code>
Function PlainVShaderSource:String()

	Local str:String=""
	
	str:+"#version 120~n"
	str:+"uniform vec2 vertex_pos;~n"
	str:+"uniform vec4 vertex_col;~n"
	str:+"uniform mat4 pmatrix;~n"
	str:+"varying vec4 f_col;~n"
	str:+"void main(void) {~n"
	str:+"	gl_Position=pmatrix*vec4(vertex_pos, -1.0, 1.0);~n"
	str:+"	f_col=vertex_col;~n"
	str:+"}"
	
	Return str

End Function

Function PlainFShaderSource:String()

	Local str:String=""
	
	str:+"#version 120~n"
	str:+"varying vec4 f_col;~n"
	str:+"void main(void) {~n"
	str:+"gl_FragColor=vec4(f_col);~n"
	str:+"}~n"
	
	Return str

End Function
</pre><br><br>then you have no texture shaders, so it reports an error.<br>Suggestion here is to drop any thoughts of textures until you get the basic colour shader to work, then add textures later :) <br><br></td></tr></table><br>
<a name="1234457"></a>

<a name="1234459"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi! Updated the shaders to something like you suggested. Im using a reference card for ogl es 2 from krhonos along with google. Havent done any shader coding before, so Im not too sure about what Im doing. <br><br>The sample is not using textures so that part is not a problem :)<br><br>EDIT: Your supposed to see a slowly changing gradient background, a whole lot of low alpha rectangles on top of that, and a spiral of dots slowly spinning. Everything should be some shade of blue/black. <br><br></td></tr></table><br>
<a name="1234467"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> I just realized your probably not supposed to try and do this with desktop opengl :o hmm. <br><br></td></tr></table><br>
<a name="1234585"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Updated the code again to hopefully work with ogl3/glsl 1.5. <br><br></td></tr></table><br>
<a name="1234586"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> first off. you are going to have issues with anything over glsl 120.<br><br>So for compatibility - you'll have to stick with #version 120<br><br>This make even more sense as you are not using anything remotely 150 related. always go for the lowest compatible<br><br>lordy!!!!!!<br><br>attribute!<br>in!<br>out!<br><br>These are NOT GLSL - it won't work. period! See above<br><br>once corrected - still no output on desktop<br><br>for testing purposes. I would suggest either starting from scratch and just displaying a single triangle, then adding the shader.<br>Or<br>stripping out everything apart from a single triangle and possible shader support.<br><br>Hint: OpenGL is notoriously difficult to debug. If you can't see anything, it could be all sorts of issues - better to start with something that works and go forward :) <br><br></td></tr></table><br>
<a name="1234617"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well, it all works perfectly fine for me. Im a bit stumped with this, since the shader code is based on various glsl examples for es/desktop Ive found via google. <br><br>I wont have time for a few days to mess around, but would you have a reference to a official glsl spec? <br><br></td></tr></table><br>
<a name="1234622"></a>

<a name="1234623"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> SDL has some examples of "default" shaders : <a href="https://github.com/eddieringle/SDL/blob/master/src/render/opengles2/SDL_shaders_gles2.c" target="_blank">https://github.com/eddieringle/SDL/blob/master/src/render/opengles2/SDL_shaders_gles2.c</a><br><br>I also have a BaH.glslopt module (GLSL Optimizer), that you can use to optimize your code. <br><br></td></tr></table><br>
<a name="1234655"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Henri</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hello,<br><br>you mentioned something about desktop, but I tried it anyway.<br><br>-----------------------------------------------------------------<br>Setup:    Intel Quad core 2, Ati Radeon HD 3400, Win 7<br><br>Result:   Both ran fine.<br><br>GLMax    -&gt; 17 FPS<br><br>Custom: -&gt; 25 FPS<br><br><br>-Henri <br><br></td></tr></table><br>
<a name="1234665"></a>

<a name="1234666"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks. Im trying to get it to work on the standard blitzmax targets first, but I only have a win7 box (HD 6870 card) myself to test on. <br><br>I thought i could get away with using the ES2 spec for desktop too, since its supposed to be a subset of desktop opengl. It should be fine for the opengl part, but it turned out that ES uses a completely different version of glsl. <br><br>@AdamStrange<br>Ive been using this spec: <a href="http://www.opengl.org/registry/doc/GLSLangSpec.1.50.11.pdf" target="_blank">http://www.opengl.org/registry/doc/GLSLangSpec.1.50.11.pdf</a> and it says in/out are perfectly fine glsl. Exactly how do the sample program fail for you? <br><br></td></tr></table><br>
<a name="1234685"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> for a start 1.20 is the max that a mac can do OpenGL. An as you are not using anything 1.50 related - use the lowest for compatibility.<br><br>regarding the in/out variable situation. I used what was available on the net - and all references to them do not exist.<br>But, more worrying, the mac just bombs out on encountering those. so I would expect them to not be there - and need to remove them before any shaders will compile.<br><br>I've always found that specs are usually a bad starting point. Much better to use a tutorial that you know works. Getting your hands dirty is much more productive, I've found?<br><br>OK, so once the shaders compile, the window appears, and it's just black. That is what I mean by starting with something small that works and adding - OpenGL is not easy to debug - that's why I didn't try :) <br><br></td></tr></table><br>
<a name="1234722"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Dunno about you, but some of these glsl things are rather splendid : <a href="http://glsl.heroku.com/e#18709.0" target="_blank">http://glsl.heroku.com/e#18709.0</a><br><br>ooooerr.... <br><br></td></tr></table><br>
<a name="1234723"></a>

<a name="1234724"></a>

<a name="1234728"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here's some quick 1.20 glsl shaders according to spec if you want to try them Adam. Otherwise I should have access to a mac in a few days, which should make this much more straightforward to fix. <br><br>Sorry for being stubborn with this code, Ill do something simpler when I have time for it. <br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

Framework BRL.GLGraphics

Import BRL.StandardIO
Import BRL.Random
Import BRL.LinkedList

Import PUB.OpenGL
Import PUB.Glew

Const OPENGL_ES2_TARGET:Int=1
Const OPENGL_3_TARGET:Int=2

'Global OPENGL_TARGET:Int=OPENGL_ES2_TARGET
Global OPENGL_TARGET:Int=OPENGL_3_TARGET

Const BATCHSIZE:Int=65536 ' how many entries that can be stored in batch before a draw call is required

Const SOLIDBLEND:Int=1
Const LIGHTBLEND:Int=2
Const ALPHABLEND:Int=3

Type opengl

	' constants for primitive rendering
	
	Const PRIMITIVE_PLAIN_TRIANGLE:Int=1
	Const PRIMITIVE_DOT:Int=2
	Const PRIMITIVE_LINE:Int=3
	Const PRIMITIVE_IMAGE:Int=4

	Global pmatrix:TMatrix
	
	Global vert_buffer:Int
	Global uv_buffer:Int
	Global col_buffer:Int
	Global element_buffer:Int
	
	' current color for drawing
	
	Global red:Float
	Global green:Float
	Global blue:Float
	Global alpha:Float
	
	' current z layer for drawing
	
	Global layer:Float
	
	' shader
	
	Global active:Int
	Global plain:Int
	Global texture:Int
	
	Global attrib_pos:Int
	Global attrib_uv:Int
	Global attrib_col:Int
	
	Global unif_projection:Int
	Global unif_tex:Int
	
	' batch rendering
	
	Global vert_array:Float[BATCHSIZE*3]
	Global uv_array:Float[BATCHSIZE*2]
	Global col_array:Float[BATCHSIZE*4]
	
	Global index:Int
	
	Global element_array:Int[BATCHSIZE*2]
	Global element_index:Int
	
	Global primitive:Int
	Global texture_id:Int
	
	' functions
	
	Function Initialize()
	
		' validate target
		
		Local glsl_version:String=String.FromCString(glGetString(GL_SHADING_LANGUAGE_VERSION))
	
		Select OPENGL_TARGET
		Case OPENGL_ES2_TARGET
			Print "(Initialize) OpenGL ES2 Target"
			Print "(Initialize) GLSL: "+glsl_version+" (1.00 required)"
		Case OPENGL_3_TARGET
			Print "(Initialize) OpenGL 3 Target"
			Print "(Initialize) GLSL: "+glsl_version+" (1.50 required)"
		Default
			Print "(Initialize) No OpenGL Target!"
			End
		End Select
	
		' set up projection matrix for 2d rendering
	
		Local pw:Int=GraphicsWidth()
		Local ph:Int=GraphicsHeight()
	
		pmatrix=New TMatrix
		pmatrix.SetOrthographic(0, pw, 0, ph, -1, 1)
		
		Print "(Initialize) Matrix Debug:"
		pmatrix.Debug()
		
		' set up layer
		
		layer=-1.0
		
		' set up colors
		
		Print "(Initialize) Setting colors to &lt;1, 1, 1, 1&gt;"
		
		red=1.0
		green=1.0
		blue=1.0
		alpha=1.0
		
		' set up shaders
		
		Local vs:Int
		Local fs:Int
		
		vs=CompileShader(PlainVShaderSource(), GL_VERTEX_SHADER)
		fs=CompileShader(PlainFShaderSource(), GL_FRAGMENT_SHADER)
		
		plain=CreateShaderProgram(vs, fs)
		If glIsProgram(plain) Then
			Print "(Initialize) Created plain shader program!"
		EndIf
		
		vs=CompileShader(TextureVShaderSource(), GL_VERTEX_SHADER)
		fs=CompileShader(TextureFShaderSource(), GL_FRAGMENT_SHADER)
		
		texture=CreateShaderProgram(vs, fs)
		If glIsProgram(texture) Then
			Print "(Initialize) Created texture shader program!"
		EndIf
		
		' set up batch
		
		index=0
		primitive=0
		texture_id=-1
	
	End Function
	
	Function UpdateBuffers()
	
		If vert_buffer=0 Then glGenBuffers(1, Varptr vert_buffer)
		If uv_buffer=0 Then glGenBuffers(1, Varptr uv_buffer)
		If col_buffer=0 Then glGenbuffers(1, Varptr col_buffer)
		If element_buffer=0 Then glGenbuffers(1, Varptr element_buffer)
		
		glBindBuffer(GL_ARRAY_BUFFER, vert_buffer)
		glBufferData(GL_ARRAY_BUFFER, index*8, vert_array, GL_DYNAMIC_DRAW)
		
		glBindBuffer(GL_ARRAY_BUFFER, uv_buffer)
		glBufferData(GL_ARRAY_BUFFER, index*8, uv_array, GL_DYNAMIC_DRAW)
		
		glBindBuffer(GL_ARRAY_BUFFER, col_buffer)
		glBufferData(GL_ARRAY_BUFFER, index*16, col_array, GL_DYNAMIC_DRAW)
		
		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, element_buffer)
		glBufferData(GL_ELEMENT_ARRAY_BUFFER, element_index*12, element_array, GL_DYNAMIC_DRAW)
			
	End Function
	
	Function UpdateShaderLayout()
	
		If Not glIsProgram(active) Then
			Print "(UpdateShaderLayout) Active is not a valid shader program!"
			Return
		EndIf
		
		attrib_pos=glGetAttribLocation(active, "vertex_pos")
		attrib_uv=glGetAttribLocation(active, "vertex_uv")
		attrib_col=glGetAttribLocation(active, "vertex_col")
		
		unif_projection=glGetUniformLocation(active, "pmatrix")
		unif_tex=glGetUniformLocation(active, "texture")
		
		Print "(UpdateShaderLayout) attrib_pos: "+attrib_pos
		Print "(UpdateShaderLayout) attrib_uv: "+attrib_uv
		Print "(UpdateShaderLayout) attrib_col: "+attrib_col
		
		Print "(UpdateShaderLayout) unif_projection: "+unif_projection
		Print "(UpdateShaderLayout) unif_tex: "+unif_tex
	
	End Function
	
	Function EnableShaderData()
	
		If attrib_pos&gt;=0 Then
			glEnableVertexAttribArray(attrib_pos)
			glBindBuffer(GL_ARRAY_BUFFER, vert_buffer)
			glVertexAttribPointer(attrib_pos, 2, GL_FLOAT, GL_FALSE, 0, Null)
		EndIf
		
		If attrib_uv&gt;=0 Then
			glEnableVertexAttribArray(attrib_uv)
			glBindBuffer(GL_ARRAY_BUFFER, uv_buffer)
			glVertexAttribPointer(attrib_uv, 2, GL_FLOAT, GL_FALSE, 0, Null)
		EndIf
		
		If attrib_col&gt;=0 Then
			glEnableVertexAttribArray(attrib_col)
			glBindBuffer(GL_ARRAY_BUFFER, col_buffer)
			glVertexAttribPointer(attrib_col, 4, GL_FLOAT, GL_FALSE, 0, Null)
		EndIf
		
		If unif_projection&gt;=0 Then
			glUniformMatrix4fv(unif_projection, 16, False, pmatrix.grid)
		EndIf
		
		If unif_tex&gt;=0 Then
			glUniform1i(unif_tex, 0)
		EndIf
		
	End Function
	
	Function DisableShaderData()
	
		If attrib_pos&gt;=0 Then
			glDisableVertexAttribArray(attrib_pos)
		EndIf
		
		If attrib_uv&gt;=0 Then
			glDisableVertexAttribArray(attrib_uv)
		EndIf
		
		If attrib_col&gt;=0 Then
			glDisableVertexAttribArray(attrib_col)
		EndIf
	
	End Function
	
	' fence. force a draw of whatever is currently stored in batch arrays
	
	Function Fence()
	
		Select primitive
		Case PRIMITIVE_PLAIN_TRIANGLE
			If active&lt;&gt;plain Then
				active=plain
				glUseProgram(active)
				UpdateShaderLayout()
			EndIf
		Case PRIMITIVE_DOT
			If active&lt;&gt;plain Then
				active=plain
				glUseProgram(active)
				UpdateShaderLayout()
			EndIf
		Case PRIMITIVE_LINE
			If active&lt;&gt;plain Then
				active=plain
				glUseProgram(active)
				UpdateShaderLayout()
			EndIf
		End Select
		
		UpdateBuffers()
		EnableShaderData()
		
		Select primitive
		Case PRIMITIVE_PLAIN_TRIANGLE
			glDrawArrays(GL_TRIANGLES, 0, index)
		Case PRIMITIVE_DOT
			glDrawArrays(GL_POINTS, 0, index)
		Case PRIMITIVE_LINE
			glDrawArrays(GL_LINES, 0, index)
		End Select
		
		DisableShaderData()
		
		index=0
		element_index=0
	
	End Function
	
	' set color
	
	Function SetColor(pr:Float, pg:Float, pb:Float)
		red=pr/255
		green=pg/255
		blue=pb/255
	End Function
	
	' set alpha
	
	Function SetAlpha(pa:Float)
		alpha=pa
	End Function
	
	Function SetBlend(pmode:Int)
		Select pmode
		Case ALPHABLEND
			glEnable(GL_BLEND)
			glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
		Case LIGHTBLEND
			glEnable(GL_BLEND)
			glBlendFunc(GL_SRC_ALPHA, GL_ONE)
		Case SOLIDBLEND
			glDisable(GL_BLEND)
		End Select
	End Function	
	
	' draw a line on screen
	
	Function DrawLine(px1:Float, py1:Float, px2:Float, py2:Float)
	
		If primitive&lt;&gt;PRIMITIVE_LINE Or index&gt;BATCHSIZE-256 Or texture_id&gt;-1 Then
			Fence()
			primitive=PRIMITIVE_LINE
		EndIf
		
		Local in:Int
		
		in=index*2
		
		vert_array[in+0]=px1
		vert_array[in+1]=py1
		
		vert_array[in+2]=px2
		vert_array[in+3]=py2
		
		in=index*4
		
		col_array[in+00]=red
		col_array[in+01]=green
		col_array[in+02]=blue
		col_array[in+03]=alpha
		
		col_array[in+04]=red
		col_array[in+05]=green
		col_array[in+06]=blue
		col_array[in+07]=alpha
		
		index:+2
	
	End Function
	
	' draw a point on screen
	
	Function Plot(px:Float, py:Float)
	
		If primitive&lt;&gt;PRIMITIVE_DOT Or index&gt;BATCHSIZE-256 Or texture_id&gt;-1 Then
			Fence()
			primitive=PRIMITIVE_DOT
		EndIf
		
		Local in:Int
		
		in=index*2
		
		vert_array[in+0]=px
		vert_array[in+1]=py
		
		in=index*4
		
		col_array[in+00]=red
		col_array[in+01]=green
		col_array[in+02]=blue
		col_array[in+03]=alpha		
		
		index:+1
	
	End Function
	
	' draw rectangle on screen
	
	Function DrawRect(px:Float, py:Float, pw:Float, ph:Float)
		
		' append data to batch arrays
		
		If primitive&lt;&gt;PRIMITIVE_PLAIN_TRIANGLE Or index&gt;BATCHSIZE-256 Or texture_id&gt;-1 Then
			Fence()
			primitive=PRIMITIVE_PLAIN_TRIANGLE
		EndIf
		
		Local in:Int
		
		in=index*2
		
		vert_array[in+00]=px
		vert_array[in+01]=py
		
		vert_array[in+02]=px+pw
		vert_array[in+03]=py
		
		vert_array[in+04]=px+pw
		vert_array[in+05]=py+ph
		
		vert_array[in+06]=px+pw
		vert_array[in+07]=py+ph
		
		vert_array[in+08]=px
		vert_array[in+09]=py+ph
		
		vert_array[in+10]=px
		vert_array[in+11]=py
		
		in=index*4
		
		col_array[in+00]=red
		col_array[in+01]=green
		col_array[in+02]=blue
		col_array[in+03]=alpha
		
		col_array[in+04]=red
		col_array[in+05]=green
		col_array[in+06]=blue
		col_array[in+07]=alpha
		
		col_array[in+08]=red
		col_array[in+09]=green
		col_array[in+10]=blue
		col_array[in+11]=alpha
		
		col_array[in+12]=red
		col_array[in+13]=green
		col_array[in+14]=blue
		col_array[in+15]=alpha
		
		col_array[in+16]=red
		col_array[in+17]=green
		col_array[in+18]=blue
		col_array[in+19]=alpha
		
		col_array[in+20]=red
		col_array[in+21]=green
		col_array[in+22]=blue
		col_array[in+23]=alpha
		
		index:+6
		
	End Function
	
End Type

' ///////////////////////////////////////////////////////////////////////////////////////
' matrix.bmx

Type TMatrix

	Field grid:Float[16]
	
	Method SetOrthographic(pl:Float, pr:Float, pt:Float, pb:Float, pn:Float, pf:Float)
		LoadIdentity()
		grid[00] = 2.0/(pr-pl)
		grid[05] = 2.0/(pt-pb)
		grid[10] =-2.0/(pf-pn)
		grid[15] = 1.0
		grid[12]=-(pr+pl)/(pr-pl)
		grid[13]=-(pt+pb)/(pt-pb)
		grid[14]=-(pf+pn)/(pf-pn)
	End Method
	
	Method Clear()
		For Local i:Int=0 To 15
			grid[i]=0.0
		Next
	End Method
	
	Method LoadIdentity()
		Clear()
		grid[00]=1.0
		grid[05]=1.0
		grid[10]=1.0
		grid[15]=1.0
	End Method
	
	Method Debug()
		Print "Matrix 4x4:"
		For Local j:Int=0 To 3
			For Local i:Int=0 To 3
				WriteStdout grid[j*4+i]
				If i&lt;3 Then
					WriteStdout ", "
				EndIf
			Next
			WriteStdout "~n"
		Next
	End Method

End Type

' ///////////////////////////////////////////////////////////////////////////////////////
' shader.bmx

Function CompileShader:Int(psource:String, ptype:Int)
	
	If psource="" Then
		Print "ERROR (CompileShader) No shader source!"
		Return 0
	EndIf
	
	Select ptype
	Case GL_VERTEX_SHADER
		Print "(CompileShader) Compiling vertex shader"
	Case GL_FRAGMENT_SHADER
		Print "(CompileShader) Compiling fragment shader"
	End Select
	
	Local id:Int=glCreateShader(ptype)
	Local cstring:Byte Ptr=psource.ToCString()
	
	glShaderSource(id, 1, Varptr cstring, Null)
	glCompileShader(id)
	
	Local success:Int=0
	glGetShaderiv(id, GL_COMPILE_STATUS, Varptr success)
	
	If Not success Then
		Print GetShaderErrorLog(id)
		Return 0
	EndIf
	
	Print "(CompileShader) Successfully compiled shader!"
	Return id
	
End Function

Function GetShaderErrorLog:String(pid:Int)

	Local logsize:Int=0
	glGetShaderiv(pid, GL_INFO_LOG_LENGTH, Varptr logsize)
	
	Local msg:Byte[logsize]
	Local size:Int=0
	
	glGetShaderInfoLog(pid, logsize, Varptr size, Varptr msg[0])
	
	Local str:String=""
	
	For Local i:Int=0 To msg.length-1
		str:+Chr(msg[i])
	Next
	
	Return str

End Function

Function CreateShaderProgram:Int(pvshader:Int, pfshader:Int)
	
	If pvshader=0 Or pfshader=0 Then
		Print "ERROR (CreateShaderProgram) Bad shader handles!"
		Return 0
	EndIf
	
	Local id:Int=glCreateProgram()
	
	glAttachShader(id, pvshader)
	glAttachShader(id, pfshader)
	
	glLinkProgram(id)
	
	Local valid:Int
	
	glValidateProgram(id)
	glGetprogramiv(id, GL_VALIDATE_STATUS, Varptr valid)
	
	If Not valid Then
		Print "ERROR (CreateShaderProgram) Invalid program!"
		Return 0
	EndIf
	
	Return id
	
End Function

' ///////////////////////////////////////////////////////////////////////////////////////
' shadersource.bmx

Function PlainVShaderSource:String()

	Local str:String=""

	If OPENGL_TARGET=OPENGL_ES2_TARGET Then
	
		str:+"#version 100~n"
		str:+"attribute vec2 vertex_pos;~n"
		str:+"attribute vec4 vertex_col;~n"
		str:+"varying vec4 f_col;~n"
	
	Else ' OPENGL_TARGET=OPENGL_3_TARGET
	
		str:+"#version 120~n"
		str:+"attribute vec2 vertex_pos;~n"
		str:+"attribute vec4 vertex_col;~n"
		str:+"varying vec4 f_col;~n"
	
	EndIf

	str:+"uniform mat4 pmatrix;~n"
	str:+"void main(void) {~n"
	str:+"	gl_Position=pmatrix*vec4(vertex_pos, -1.0, 1.0);~n"
	str:+"	f_col=vertex_col;~n"
	str:+"}"
	
	Return str

End Function

Function PlainFShaderSource:String()

	Local str:String=""
	
	If OPENGL_TARGET=OPENGL_ES2_TARGET Then
	
		str:+"#version 100~n"
		str:+"precision mediump float;~n"
		str:+"varying vec4 f_col;~n"
		str:+"void main(void) {~n"
		str:+"	gl_FragColor=vec4(f_col);~n"
		str:+"}~n"
	
	Else ' OPENGL_TARGET=OPENGL_3_TARGET
	
		str:+"#version 120~n"
		str:+"varying vec4 f_col;~n"
		str:+"void main(void) {~n"
		str:+"	gl_FragColor=f_col;~n"
		str:+"}~n"
	
	EndIf
	
	Return str

End Function

Function TextureVShaderSource:String()
End Function

Function TextureFShaderSource:String()
End Function

' ///////////////////////////////////////////////////////////////////////////////////////

SetGraphicsDriver GLGraphicsDriver()
GLGraphics 800, 600, 0, 60, GRAPHICS_BACKBUFFER|GRAPHICS_DEPTHBUFFER

glewInit()

glEnable(GL_DEPTH_TEST)
glDepthFunc(GL_LEQUAL)

glEnable(GL_BLEND)
glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)

opengl.Initialize()

Type TParticle

	Global list:TList

	Field x:Float
	Field y:Float
	Field size:Float
	Field d:Float
	
	Function Create:TParticle(px:Float, py:Float, psize:Float, pd:Float)
	
		Local this:TParticle=New TParticle
		
		this.x=px
		this.y=py
		this.size=psize
		this.d=pd
		
		If list=Null Then
			list=New TList
		EndIf
		
		list.AddLast(this)
		
		Return this
		
	End Function
	
	Function Update()
	End Function
	
	Function Draw()
		
		If list=Null Then
			Return
		EndIf
		
		opengl.SetBlend LIGHTBLEND
		opengl.SetAlpha 0.15
		
		For Local o:TParticle=EachIn list
		
			o.d:-1
			
			Local dx:Float=o.x-400
			Local dy:Float=o.y-300
			
			Local m:Float=Sqr(dx*dx+dy*dy)
			
			If m&lt;1.0 Then
				m=1.0
			EndIf
			
			m:*0.1
			
			If m&gt;255.0 Then
				m=255.0
			EndIf
			
			opengl.SetColor 0.25*m, 0.5*m, m
		
			opengl.DrawRect o.x-o.size*0.5, o.y-o.size*0.5, o.size, o.size
		
		Next
		
		opengl.SetAlpha 1
		opengl.SetBlend SOLIDBLEND
		
	End Function

End Type

For Local i:Int=1 To 20000
	TParticle.Create(Rand(800), Rand(600), Rnd(2, 15), Rand(360))
Next

Local curfps:Int
Local fps:Int
Local curtime:Int=MilliSecs()+1000

Local angle:Float=0

Repeat

	angle:+0.1
	If angle&gt;=360 Then
		angle=0
	EndIf

	If MilliSecs()&gt;curtime Then
		curtime:+1000
		fps=curfps+1
		curfps=0
		Print "FPS: "+fps
	Else
		curfps:+1
	EndIf

	glClearColor(0, 0, 0, 0)
	glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)
	
	' draw gradient background with lines
	
	opengl.SetBlend SOLIDBLEND
	opengl.SetAlpha 1
	
	For Local y:Int=0 To 600
	
		opengl.SetColor 31.5+Cos(angle+y*0.1)*31.5, 63+5+Cos(angle+y*0.1)*63.5, 127.5+Cos(angle+y*0.1)*127.5
		opengl.DrawLine 0, y, 800, y
	
	Next
	
	' draw rectangle cloud
	
	TParticle.Draw()
	
	' plot a dense spiral
	
	opengl.SetBlend(LIGHTBLEND)
	
	opengl.SetAlpha 0.25
	opengl.SetColor 32, 64, 128 
	
	For Local i:Int=1 To 50000
		Local x:Float=400.0+Cos(angle+i)*(Float(i)*0.01)
		Local y:Float=300.0+Sin(angle+i)*(Float(i)*0.01)
		opengl.Plot x, y
	Next
	
	opengl.Fence()
	
	Flip(False)

Until KeyHit(KEY_ESCAPE)=True

EndGraphics
End
</textarea> <br><br></td></tr></table><br>
<a name="1234729"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Output:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
(Initialize) OpenGL 3 Target
(Initialize) GLSL: 1.20 (1.50 required)
(Initialize) Matrix Debug:
Matrix 4x4:
0.00249999994, 0.00000000, 0.00000000, 0.00000000
0.00000000, -0.00333333341, 0.00000000, 0.00000000
0.00000000, 0.00000000, -1.00000000, 0.00000000
-1.00000000, 1.00000000, -0.00000000, 1.00000000
(Initialize) Setting colors to &lt;1, 1, 1, 1&gt;
(CompileShader) Compiling vertex shader
(CompileShader) Successfully compiled shader!
(CompileShader) Compiling fragment shader
ERROR: 0:3: Invalid qualifiers 'out' in global variable context

ERROR (CreateShaderProgram) Bad shader handles!
ERROR (CompileShader) No shader source!
ERROR (CompileShader) No shader source!
ERROR (CreateShaderProgram) Bad shader handles!
</textarea><br>and a black window...<br><br>FPS ticks down the output. <br><br></td></tr></table><br>
<a name="1234731"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Can you try it again Brucey? I had a stray line left in the fragment shader code, and that error message suggests you copied the code before i made a ninja-edit :p <br><br></td></tr></table><br>
<a name="1234751"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> compiles ok<br>shaders ok<br>output = black <br><br></td></tr></table><br>
<a name="1234754"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Can you try it again Brucey?  <br></div><br>Yeah, I'd tried it again after commenting out that line, and had the same result as Mr Strange.<br><br>I've yet to try it on the Raspberry Pi though. <br><br></td></tr></table><br>
<a name="1235376"></a>

<a name="1235377"></a>

<a name="1235379"></a>

<a name="1235388"></a>

<a name="1235409"></a>

<a name="1235413"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well, didnt get my hands on a mac for testing.<br><br>Heres a simple example, should draw a green triangle on a purple background. Id be interested in the console output. <br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

' ///////////////////////////////////////////////////////////////////////

SuperStrict

Framework BRL.GLGraphics
Import BRL.StandardIO

Import PUB.OpenGL
Import PUB.Glew

' ///////////////////////////////////////////////////////////////////////

Type TMatrix

	Field grid:Float[16]
	
	Method SetOrthographic(pl:Float, pr:Float, pt:Float, pb:Float, pn:Float, pf:Float)
		LoadIdentity()
		grid[00] = 2.0/(pr-pl)
		grid[05] = 2.0/(pt-pb)
		grid[10] =-2.0/(pf-pn)
		grid[15] = 1.0
		grid[12]=-((pr+pl)/(pr-pl)) ' changed from -(a+b)/(a-b) to -((a+b)/(a-b))
		grid[13]=-((pt+pb)/(pt-pb))
		grid[14]=-((pf+pn)/(pf-pn))
	End Method
	
	Method Clear()
		For Local i:Int=0 To 15
			grid[i]=0.0
		Next
	End Method
	
	Method LoadIdentity()
		Clear()
		grid[00]=1.0
		grid[05]=1.0
		grid[10]=1.0
		grid[15]=1.0
	End Method
	
	Method Debug()
		Print "Matrix 4x4:"
		For Local j:Int=0 To 3
			For Local i:Int=0 To 3
				WriteStdout grid[j*4+i]
				If i&lt;3 Then
					WriteStdout ", "
				EndIf
			Next
			WriteStdout "~n"
		Next
	End Method

End Type

Function CompileShader:Int(psource:String, ptype:Int)
	
	Local id:Int=glCreateShader(ptype)
	Local cstring:Byte Ptr=psource.ToCString()
	
	glShaderSource(id, 1, Varptr cstring, Null)
	CatchError("CompileShader 1")
	
	glCompileShader(id)
	CatchError("CompileShader 2")
	
	Local success:Int=0
	glGetShaderiv(id, GL_COMPILE_STATUS, Varptr success)
	CatchError("CompileShader 3")
	
	If Not success Then
		Print GetShaderErrorLog(id)
		Return 0
	EndIf

	Return id
	
End Function

Function GetShaderErrorLog:String(pid:Int)

	Local logsize:Int=0
	glGetShaderiv(pid, GL_INFO_LOG_LENGTH, Varptr logsize)
	CatchError("GetShaderErrorLog 1")
	
	Local msg:Byte[logsize]
	Local size:Int=0
	
	glGetShaderInfoLog(pid, logsize, Varptr size, Varptr msg[0])
	CatchError("GetShaderErrorLog 2")
	
	Local str:String=""
	
	For Local i:Int=0 To msg.length-1
		str:+Chr(msg[i])
	Next
	
	Return str

End Function

Function CreateShaderProgram:Int(pvshader:Int, pfshader:Int)
	
	If glIsShader(pvshader)=GL_FALSE Then 
		Print "ERROR (CreateShaderProgram) pvshader is not a valid shader!"
		Return 0
	EndIf
	
	If glIsShader(pfshader)=GL_FALSE Then
		Print "ERROR (CreateShaderProgram) pfshader is not a valid shader!"
		Return 0
	EndIf
	
	Local id:Int=glCreateProgram()
	
	glAttachShader(id, pvshader)
	CatchError("CreateShaderProgram 1")
	
	glAttachShader(id, pfshader)
	CatchError("CreateShaderProgram 2")
	
	glLinkProgram(id)
	CatchError("CreateShaderProgram 3")
	
	Return id
	
End Function

Function VShaderSource:String()

	Local str:String=""
	
	str:+"#version 120~n"
	str:+"attribute vec2 vertex_pos;~n"
	str:+"uniform mat4 projection;~n"
	str:+"void main(void) {~n"
	str:+"  gl_Position=projection*vec4(vertex_pos, -1, 1);~n"
	str:+"}~n"

	Return str

End Function

Function FShaderSource:String()

	Local str:String=""
	
	str:+"#version 120~n"
	str:+"void main(void) {~n"
	str:+"  gl_FragColor=vec4(0,1,0,1);~n"
	str:+"}~n"
	
	Return str

End Function

Function CatchError(append:String)
	Local error:Int=glGetError()
	If error&lt;&gt;0 Then
		WriteStdout append+" : "+error
		Select error
		Case GL_INVALID_ENUM
			WriteStdout " GL_INVALID_ENUM "
		Case GL_INVALID_VALUE
			WriteStdout " GL_INVALID_VALUE "
		Case GL_INVALID_OPERATION
			WriteStdout " GL_INVALID_OPERATION "
		End Select
		WriteStdout "~n"
	EndIf
End Function

' ///////////////////////////////////////////////////////////////////////

SetGraphicsDriver GLGraphicsDriver()
GLGraphics 800, 600, 0, 60, GRAPHICS_BACKBUFFER|GRAPHICS_DEPTHBUFFER

glewInit()

Local matrix:TMatrix=New TMatrix
matrix.SetOrthographic(0, 800, 0, 600, -1, 1)

matrix.Debug()

Local vshader:Int=CompileShader(VShaderSource(), GL_VERTEX_SHADER)
Local fshader:Int=CompileShader(FShaderSource(), GL_FRAGMENT_SHADER)

Print "vertex shader id: "+vshader
Print "fragment shader id: "+fshader

Local program:Int=CreateShaderProgram(vshader, fshader)

If Not glIsProgram(program) Then
	Print "failed to create program"
EndIf

glUseProgram(program)
CatchError("glUseProgram")

Local attrib_pos:Int=glGetAttribLocation(program, "vertex_pos")
Local projection:Int=glGetUniformLocation(program, "projection")

Print "attribute pos index: "+attrib_pos
Print "uniform projection index: "+projection

Local verts:Float[]=[50.0, 50.0, 250.0, 50.0, 250.0, 250.0]

Local vertex_buffer:Int

glGenBuffers(1, Varptr vertex_buffer)
CatchError("glGenBuffers")

glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer)
CatchError("glBindBuffer 1")

glBufferdata(GL_ARRAY_BUFFER, 24, verts, GL_STATIC_DRAW)
CatchError("glBufferData")

If glIsBuffer(vertex_buffer) Then
	Print "successfully created buffer"
Else
	Print "failed to create buffer"
EndIf

Print ""
Print "Entering main loop"
Print ""

Repeat

	glClearColor(1, 0, 1, 0)
	CatchError("glClearColor")
	
	glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)
	CatchError("glClear")

	glEnableVertexAttribArray(attrib_pos)
	CatchError("glEnableVertexAttribArray")
	
	glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer)
	CatchError("glBindBuffer 2")
	
	glVertexAttribPointer(attrib_pos, 2, GL_FLOAT, GL_FALSE, 0, Null)
	CatchError("glVertexAttribPointer")
	
	glUniformMatrix4fv(projection, 1, False, Varptr matrix.grid[0])
	CatchError("glUniformMatrix4fv")
	
	Local status:Int
	glValidateProgram(program)
	CatchError("glValidateProgram")
	
	glGetProgramiv(program, GL_VALIDATE_STATUS, Varptr status)
	CatchError("glGetProgramiv")
	
	If status=GL_FALSE Then
		Print "program is not valid in context"
	EndIf
	
	glDrawArrays(GL_TRIANGLES, 0, 6)
	CatchError("glDrawArrays")
	
	glDisableVertexAttribArray(attrib_pos)
	CatchError("glDisableVertexAttribArray")
	
	Flip
	
Until KeyHit(KEY_ESCAPE)=True

EndGraphics
End
</textarea> <br><br></td></tr></table><br>
<a name="1235385"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Kind of like a very pink background... no triangle.<br><pre class=code>
Building untitled1
Executing:untitled1
Matrix 4x4:
0.00249999994, 0.00000000, 0.00000000, 0.00000000
0.00000000, -0.00333333341, 0.00000000, 0.00000000
0.00000000, 0.00000000, -1.00000000, 0.00000000
-1.00000000, 1.00000000, -0.00000000, 1.00000000
vertex shader id: 1
fragment shader id: 2
attribute pos index: 0
uniform projection index: 0
successfully created buffer

Entering main loop

glUniformMatrix4fv : 0
glUniformMatrix4fv : 0
... lots of these
</pre><br>Maybe your RGB is mixed up :-)<br><br>GPU on my Mac Mini : AMD Radeon HD 6630M 256 MB <br><br></td></tr></table><br>
<a name="1235390"></a>

<a name="1235397"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well i guess that part is a bit subjective. Anyways, that helps a bunch. Updated the code with some relevant error tests, so please try it again :)<br><br>EDIT: On a bit of a side note, I saw that AMD offers native ES support on desktop via this <a href="http://developer.amd.com/tools-and-sdks/graphics-development/amd-opengl-es-sdk/" target="_blank">http://developer.amd.com/tools-and-sdks/graphics-development/amd-opengl-es-sdk/</a> . Would that be possible to wrap for blitzmax? <br><br></td></tr></table><br>
<a name="1235405"></a>

<a name="1235411"></a>

<a name="1235412"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Similar to Brucey, output is<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Matrix 4x4:
0.00249999994, 0.000000000, 0.000000000, 0.000000000
0.000000000, -0.00333333341, 0.000000000, 0.000000000
0.000000000, 0.000000000, -1.00000000, 0.000000000
-1.00000000, 1.00000000, -0.000000000, 1.00000000
vertex shader id: 1
fragment shader id: 2
attribute pos index: 0
uniform projection index: 23724032
successfully created buffer

Entering main loop

glUniformMatrix4fv : 1282 GL_INVALID_OPERATION 
glUniformMatrix4fv : 1282 GL_INVALID_OPERATION 
glUniformMatrix4fv : 1282 GL_INVALID_OPERATION 
etc
</textarea><br><br>Initial thoughts are the matrix doesnt look correct but I'm used to looking at 3d ones on d3d lately so I could be talking out of my ....<br><br>Shouldn't the math be<br><br>grid[12]=<b>-(</b>(pr+pl)/(pr-pl)<b>)</b><br>grid[13]=<b>-(</b>(pt+pb)/(pt-pb)<b>)</b><br>grid[14]=<b>-(</b>(pf+pn)/(pf-pn)<b>)</b><br> <br>That wont stop the error though as you're telling ogl that you're passing in 16 matrices when in fact theres only 1.<br><br>Try<br><br><b>glUniformMatrix4fv(projection, 1, False,matrix.grid)</b><br><br>and see how you get on with those adjustments. <br><br></td></tr></table><br>
<a name="1235414"></a>

<a name="1235415"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks a bunch! Updated the latest code to these changes. The matrix code was from some tutorial, and I just assumed it was to specify 16 elements, so didnt bother looking it up in the specs, but it seem you are correct :) Funny that it wouldnt bomb out on windows. Changed the matrix code too, altough it gives the same result. <br><br></td></tr></table><br>
<a name="1235418"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> I now see a green triangle on the bright pink background ;-) <br><br></td></tr></table><br>
<a name="1235439"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> pink background green triangle here too :)<br><br>Hint: be very careful with windows and opengl. MS tried everything they could to not have it, so it is no surprise that it is not compliant.<br><br>Macs only have opengl so their spec is much stricter <br><br></td></tr></table><br>
<a name="1235448"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah, the impression ive been getting is that while the opengl spec works on most things if you keep to it, different vendors/os'es will tolerate different kinds of stray errors like this, which is not really helpful. <br><br>Anyways, I updated the first code samples that i posted, hoping that this was the offending thing for you guys :) <br><br></td></tr></table><br>
<a name="1235451"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> different vendors/os'es will tolerate different kinds of stray errors like this, which is not really helpful.  <br></div><br>In which case, you should try to develop on the least tolerant system ;-) <br><br></td></tr></table><br>
<a name="1235452"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> It is called "Monkey X"-approach :p<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1235455"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah well, I wouldnt complain if someone donated a mac to me, but Ill have to work with what I have :)<br><br>Reiterating these: <br><br>Max2D:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

SetGraphicsDriver GLMax2DDriver()
Graphics 800, 600, 0

Type TParticle

	Global list:TList

	Field x:Float
	Field y:Float
	Field size:Float
	Field d:Float
	
	Function Create:TParticle(px:Float, py:Float, psize:Float, pd:Float)
	
		Local this:TParticle=New TParticle
		
		this.x=px
		this.y=py
		this.size=psize
		this.d=pd
		
		If list=Null Then
			list=New TList
		EndIf
		
		list.AddLast(this)
		
		Return this
		
	End Function
	
	Function Update()
	End Function
	
	Function Draw()
		
		If list=Null Then
			Return
		EndIf
		
		SetBlend LIGHTBLEND
		SetAlpha 0.15
		
		For Local o:TParticle=EachIn list
		
			o.d:-1
			
			Local dx:Float=o.x-400
			Local dy:Float=o.y-300
			
			Local m:Float=Sqr(dx*dx+dy*dy)
			
			If m&lt;1.0 Then
				m=1.0
			EndIf
			
			m:*0.1
			
			If m&gt;255.0 Then
				m=255.0
			EndIf
			
			SetColor 0.25*m, 0.5*m, m
		
			DrawRect o.x-o.size*0.5, o.y-o.size*0.5, o.size, o.size
		
		Next
		
		SetAlpha 1
		SetBlend SOLIDBLEND
		
	End Function

End Type

For Local i:Int=1 To 20000
	TParticle.Create(Rand(800), Rand(600), Rnd(2, 15), Rand(360))
Next

Local angle:Float=0

Local curfps:Int=0
Local fps:Int=0
Local time:Int=MilliSecs()+1000

Repeat

	Local ms:Int

	If MilliSecs()&gt;time Then
		time:+1000
		fps=curfps+1
		curfps=0
		Print "FPS: "+fps
	Else
		curfps:+1
	EndIf

	angle:+0.1
	
	If angle&gt;=360 Then
		angle=0
	EndIf

	TParticle.Update()

	SetClsColor 0, 0, 0
	Cls
	
	' draw a gradient background with lines
	ms=MilliSecs()	

	For Local y:Int=0 To 600
		
		SetColor 31.5+Cos(angle+y*0.1)*31.5, 63.5+Cos(angle+y*0.1)*63.5, 127.5+Cos(angle+y*0.1)*127.5
		DrawLine 0, y, 800, y
		
	Next
	
	ms=MilliSecs()-ms
	'Print "lines: "+ms
	
	' draw a bunch of rectangles with various alpha values on top
	
	ms=MilliSecs()
	
	TParticle.Draw()
	
	ms=MilliSecs()-ms
	'Print "particles: "+ms
	
	' plot a dense spiral on top
	
	SetBlend LIGHTBLEND
	SetAlpha 0.25
	SetColor 32, 64, 128
	
	For Local i:Int=1 To 50000
	
		Local x:Float=400.0+Cos(angle+i)*(Float(i)*0.01)
		Local y:Float=300.0+Sin(angle+i)*(Float(i)*0.01)
		
		Plot x, y
	
	Next
	
	SetAlpha 1
	SetBlend SOLIDBLEND
	
	Flip(False)

Until KeyHit(KEY_ESCAPE)=True

EndGraphics
End
</textarea><br><br>Custom OpenGL:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

Framework BRL.GLGraphics

Import BRL.StandardIO
Import BRL.Random
Import BRL.LinkedList

Import PUB.OpenGL
Import PUB.Glew

Const OPENGL_ES2_TARGET:Int=1
Const OPENGL_3_TARGET:Int=2

'Global OPENGL_TARGET:Int=OPENGL_ES2_TARGET
Global OPENGL_TARGET:Int=OPENGL_3_TARGET

Const BATCHSIZE:Int=65536 ' how many entries that can be stored in batch before a draw call is required

Const SOLIDBLEND:Int=1
Const LIGHTBLEND:Int=2
Const ALPHABLEND:Int=3

Type opengl

	' constants for primitive rendering
	
	Const PRIMITIVE_PLAIN_TRIANGLE:Int=1
	Const PRIMITIVE_DOT:Int=2
	Const PRIMITIVE_LINE:Int=3
	Const PRIMITIVE_IMAGE:Int=4

	Global pmatrix:TMatrix
	
	Global vert_buffer:Int
	Global uv_buffer:Int
	Global col_buffer:Int
	Global element_buffer:Int
	
	' current color for drawing
	
	Global red:Float
	Global green:Float
	Global blue:Float
	Global alpha:Float
	
	' current z layer for drawing
	
	Global layer:Float
	
	' shader
	
	Global active:Int
	Global plain:Int
	Global texture:Int
	
	Global attrib_pos:Int
	Global attrib_uv:Int
	Global attrib_col:Int
	
	Global unif_projection:Int
	Global unif_tex:Int
	
	' batch rendering
	
	Global vert_array:Float[BATCHSIZE*3]
	Global uv_array:Float[BATCHSIZE*2]
	Global col_array:Float[BATCHSIZE*4]
	
	Global index:Int
	
	Global element_array:Int[BATCHSIZE*2]
	Global element_index:Int
	
	Global primitive:Int
	Global texture_id:Int
	
	' functions
	
	Function Initialize()
	
		' init basic opengl
	
		glewInit()
		
		glEnable(GL_DEPTH_TEST)
		glDepthFunc(GL_LEQUAL)
		
		glEnable(GL_BLEND)
		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
	
		' validate target
		
		Local glsl_version:String=String.FromCString(glGetString(GL_SHADING_LANGUAGE_VERSION))
	
		Select OPENGL_TARGET
		Case OPENGL_ES2_TARGET
			Print "(Initialize) OpenGL ES2 Target"
			Print "(Initialize) GLSL: "+glsl_version+" (1.00 required)"
		Case OPENGL_3_TARGET
			Print "(Initialize) OpenGL 3 Target"
			Print "(Initialize) GLSL: "+glsl_version+" (1.20 required)"
		Default
			Print "(Initialize) No OpenGL Target!"
			End
		End Select
	
		' set up projection matrix for 2d rendering
	
		Local pw:Int=GraphicsWidth()
		Local ph:Int=GraphicsHeight()
	
		pmatrix=New TMatrix
		pmatrix.SetOrthographic(0, pw, 0, ph, -1, 1)
		
		Print "(Initialize) Matrix Debug:"
		pmatrix.Debug()
		
		' set up layer
		
		layer=-1.0
		
		' set up colors
		
		Print "(Initialize) Setting colors to &lt;1, 1, 1, 1&gt;"
		
		red=1.0
		green=1.0
		blue=1.0
		alpha=1.0
		
		' set up shaders
		
		Local vs:Int
		Local fs:Int
		
		vs=CompileShader(PlainVShaderSource(), GL_VERTEX_SHADER)
		fs=CompileShader(PlainFShaderSource(), GL_FRAGMENT_SHADER)
		
		plain=CreateShaderProgram(vs, fs)
		If glIsProgram(plain) Then
			Print "(Initialize) Created plain shader program!"
		EndIf
		
		vs=CompileShader(TextureVShaderSource(), GL_VERTEX_SHADER)
		fs=CompileShader(TextureFShaderSource(), GL_FRAGMENT_SHADER)
		
		texture=CreateShaderProgram(vs, fs)
		If glIsProgram(texture) Then
			Print "(Initialize) Created texture shader program!"
		EndIf
		
		' set up batch
		
		index=0
		primitive=0
		texture_id=-1
	
	End Function
	
	Function UpdateBuffers()
	
		If vert_buffer=0 Then glGenBuffers(1, Varptr vert_buffer)
		If uv_buffer=0 Then glGenBuffers(1, Varptr uv_buffer)
		If col_buffer=0 Then glGenbuffers(1, Varptr col_buffer)
		If element_buffer=0 Then glGenbuffers(1, Varptr element_buffer)
		
		glBindBuffer(GL_ARRAY_BUFFER, vert_buffer)
		glBufferData(GL_ARRAY_BUFFER, index*8, vert_array, GL_DYNAMIC_DRAW)
		
		glBindBuffer(GL_ARRAY_BUFFER, uv_buffer)
		glBufferData(GL_ARRAY_BUFFER, index*8, uv_array, GL_DYNAMIC_DRAW)
		
		glBindBuffer(GL_ARRAY_BUFFER, col_buffer)
		glBufferData(GL_ARRAY_BUFFER, index*16, col_array, GL_DYNAMIC_DRAW)
		
		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, element_buffer)
		glBufferData(GL_ELEMENT_ARRAY_BUFFER, element_index*12, element_array, GL_DYNAMIC_DRAW)
			
	End Function
	
	Function UpdateShaderLayout()
	
		If Not glIsProgram(active) Then
			Print "(UpdateShaderLayout) Active is not a valid shader program!"
			Return
		EndIf
		
		attrib_pos=glGetAttribLocation(active, "vertex_pos")
		attrib_uv=glGetAttribLocation(active, "vertex_uv")
		attrib_col=glGetAttribLocation(active, "vertex_col")
		
		unif_projection=glGetUniformLocation(active, "pmatrix")
		unif_tex=glGetUniformLocation(active, "texture")
		
		Print "(UpdateShaderLayout) attrib_pos: "+attrib_pos
		Print "(UpdateShaderLayout) attrib_uv: "+attrib_uv
		Print "(UpdateShaderLayout) attrib_col: "+attrib_col
		
		Print "(UpdateShaderLayout) unif_projection: "+unif_projection
		Print "(UpdateShaderLayout) unif_tex: "+unif_tex
	
	End Function
	
	Function EnableShaderData()
	
		If attrib_pos&gt;=0 Then
			glEnableVertexAttribArray(attrib_pos)
			glBindBuffer(GL_ARRAY_BUFFER, vert_buffer)
			glVertexAttribPointer(attrib_pos, 2, GL_FLOAT, GL_FALSE, 0, Null)
		EndIf
		
		If attrib_uv&gt;=0 Then
			glEnableVertexAttribArray(attrib_uv)
			glBindBuffer(GL_ARRAY_BUFFER, uv_buffer)
			glVertexAttribPointer(attrib_uv, 2, GL_FLOAT, GL_FALSE, 0, Null)
		EndIf
		
		If attrib_col&gt;=0 Then
			glEnableVertexAttribArray(attrib_col)
			glBindBuffer(GL_ARRAY_BUFFER, col_buffer)
			glVertexAttribPointer(attrib_col, 4, GL_FLOAT, GL_FALSE, 0, Null)
		EndIf
		
		If unif_projection&gt;=0 Then
			'glUniformMatrix4fv(unif_projection, 16, False, pmatrix.grid) ' bad
			glUniformMatrix4fv(unif_projection, 1, False, Varptr pmatrix.grid[0])
		EndIf
		
		If unif_tex&gt;=0 Then
			glUniform1i(unif_tex, 0)
		EndIf
		
	End Function
	
	Function DisableShaderData()
	
		If attrib_pos&gt;=0 Then
			glDisableVertexAttribArray(attrib_pos)
		EndIf
		
		If attrib_uv&gt;=0 Then
			glDisableVertexAttribArray(attrib_uv)
		EndIf
		
		If attrib_col&gt;=0 Then
			glDisableVertexAttribArray(attrib_col)
		EndIf
	
	End Function
	
	' fence. force a draw of whatever is currently stored in batch arrays
	
	Function Fence()
	
		Select primitive
		Case PRIMITIVE_PLAIN_TRIANGLE
			If active&lt;&gt;plain Then
				active=plain
				glUseProgram(active)
				UpdateShaderLayout()
			EndIf
		Case PRIMITIVE_DOT
			If active&lt;&gt;plain Then
				active=plain
				glUseProgram(active)
				UpdateShaderLayout()
			EndIf
		Case PRIMITIVE_LINE
			If active&lt;&gt;plain Then
				active=plain
				glUseProgram(active)
				UpdateShaderLayout()
			EndIf
		End Select
		
		UpdateBuffers()
		EnableShaderData()
		
		' additional tests. validate shaderprogram and buffer. shader program validation takes
		' context into consideration, so do it right before drawing
		
		ValidateShaderProgram(active)
		
		' somewhat interesting? default framebuffer should not return any errors
		' NOTE: 36062 seems to be an erroneous error code (ie opengl returns something it shouldnt)
		Local status:Int=glCheckFramebufferStatus(GL_FRAMEBUFFER)
		Select status
		Case GL_FRAMEBUFFER_COMPLETE
			'Print "valid framebuffer"
		Default
			Print "status: "+status
		End Select
		
		Select primitive
		Case PRIMITIVE_PLAIN_TRIANGLE
			glDrawArrays(GL_TRIANGLES, 0, index)
		Case PRIMITIVE_DOT
			glDrawArrays(GL_POINTS, 0, index)
		Case PRIMITIVE_LINE
			glDrawArrays(GL_LINES, 0, index)
		End Select
		
		DisableShaderData()
		
		index=0
		element_index=0
	
	End Function
	
	' set color
	
	Function SetColor(pr:Float, pg:Float, pb:Float)
		red=pr/255
		green=pg/255
		blue=pb/255
	End Function
	
	' set alpha
	
	Function SetAlpha(pa:Float)
		alpha=pa
	End Function
	
	Function SetBlend(pmode:Int)
		Select pmode
		Case ALPHABLEND
			glEnable(GL_BLEND)
			glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
		Case LIGHTBLEND
			glEnable(GL_BLEND)
			glBlendFunc(GL_SRC_ALPHA, GL_ONE)
		Case SOLIDBLEND
			glDisable(GL_BLEND)
		End Select
	End Function	
	
	' draw a line on screen
	
	Function DrawLine(px1:Float, py1:Float, px2:Float, py2:Float)
	
		If primitive&lt;&gt;PRIMITIVE_LINE Or index&gt;BATCHSIZE-256 Or texture_id&gt;-1 Then
			Fence()
			primitive=PRIMITIVE_LINE
		EndIf
		
		Local in:Int
		
		in=index*2
		
		vert_array[in+0]=px1
		vert_array[in+1]=py1
		
		vert_array[in+2]=px2
		vert_array[in+3]=py2
		
		in=index*4
		
		col_array[in+00]=red
		col_array[in+01]=green
		col_array[in+02]=blue
		col_array[in+03]=alpha
		
		col_array[in+04]=red
		col_array[in+05]=green
		col_array[in+06]=blue
		col_array[in+07]=alpha
		
		index:+2
	
	End Function
	
	' draw a point on screen
	
	Function Plot(px:Float, py:Float)
	
		If primitive&lt;&gt;PRIMITIVE_DOT Or index&gt;BATCHSIZE-256 Or texture_id&gt;-1 Then
			Fence()
			primitive=PRIMITIVE_DOT
		EndIf
		
		Local in:Int
		
		in=index*2
		
		vert_array[in+0]=px
		vert_array[in+1]=py
		
		in=index*4
		
		col_array[in+00]=red
		col_array[in+01]=green
		col_array[in+02]=blue
		col_array[in+03]=alpha		
		
		index:+1
	
	End Function
	
	' draw rectangle on screen
	
	Function DrawRect(px:Float, py:Float, pw:Float, ph:Float)
		
		' append data to batch arrays
		
		If primitive&lt;&gt;PRIMITIVE_PLAIN_TRIANGLE Or index&gt;BATCHSIZE-256 Or texture_id&gt;-1 Then
			Fence()
			primitive=PRIMITIVE_PLAIN_TRIANGLE
		EndIf
		
		Local in:Int
		
		in=index*2
		
		vert_array[in+00]=px
		vert_array[in+01]=py
		
		vert_array[in+02]=px+pw
		vert_array[in+03]=py
		
		vert_array[in+04]=px+pw
		vert_array[in+05]=py+ph
		
		vert_array[in+06]=px+pw
		vert_array[in+07]=py+ph
		
		vert_array[in+08]=px
		vert_array[in+09]=py+ph
		
		vert_array[in+10]=px
		vert_array[in+11]=py
		
		in=index*4

		col_array[in+00]=red
		col_array[in+01]=green
		col_array[in+02]=blue
		col_array[in+03]=alpha
		
		col_array[in+04]=red
		col_array[in+05]=green
		col_array[in+06]=blue
		col_array[in+07]=alpha
		
		col_array[in+08]=red
		col_array[in+09]=green
		col_array[in+10]=blue
		col_array[in+11]=alpha
		
		col_array[in+12]=red
		col_array[in+13]=green
		col_array[in+14]=blue
		col_array[in+15]=alpha
		
		col_array[in+16]=red
		col_array[in+17]=green
		col_array[in+18]=blue
		col_array[in+19]=alpha
		
		col_array[in+20]=red
		col_array[in+21]=green
		col_array[in+22]=blue
		col_array[in+23]=alpha

		index:+6
		
	End Function
	
End Type

' ///////////////////////////////////////////////////////////////////////////////////////
' matrix.bmx

Type TMatrix

	Field grid:Float[16]
	
	Method SetOrthographic(pl:Float, pr:Float, pt:Float, pb:Float, pn:Float, pf:Float)
		LoadIdentity()
		grid[00] = 2.0/(pr-pl)
		grid[05] = 2.0/(pt-pb)
		grid[10] =-2.0/(pf-pn)
		grid[15] = 1.0
		grid[12]=-((pr+pl)/(pr-pl))
		grid[13]=-((pt+pb)/(pt-pb))
		grid[14]=-((pf+pn)/(pf-pn))
	End Method
	
	Method Clear()
		For Local i:Int=0 To 15
			grid[i]=0.0
		Next
	End Method
	
	Method LoadIdentity()
		Clear()
		grid[00]=1.0
		grid[05]=1.0
		grid[10]=1.0
		grid[15]=1.0
	End Method
	
	Method Debug()
		Print "Matrix 4x4:"
		For Local j:Int=0 To 3
			For Local i:Int=0 To 3
				WriteStdout grid[j*4+i]
				If i&lt;3 Then
					WriteStdout ", "
				EndIf
			Next
			WriteStdout "~n"
		Next
	End Method

End Type

' ///////////////////////////////////////////////////////////////////////////////////////
' shader.bmx

Function CompileShader:Int(psource:String, ptype:Int)
	
	If psource="" Then
		Print "ERROR (CompileShader) No shader source!"
		Return 0
	EndIf
	
	Select ptype
	Case GL_VERTEX_SHADER
		Print "(CompileShader) Compiling vertex shader"
	Case GL_FRAGMENT_SHADER
		Print "(CompileShader) Compiling fragment shader"
	Default 
		Print "(CompileShader) Invalid shader type!"
		Return 0
	End Select
	
	Local id:Int=glCreateShader(ptype)
	Local cstring:Byte Ptr=psource.ToCString()
	
	glShaderSource(id, 1, Varptr cstring, Null)
	glCompileShader(id)
	
	Local success:Int=0
	glGetShaderiv(id, GL_COMPILE_STATUS, Varptr success)
	
	If Not success Then
		Print GetShaderErrorLog(id)
		Return 0
	EndIf
	
	Print "(CompileShader) Successfully compiled shader!"
	Return id
	
End Function

Function GetShaderErrorLog:String(pid:Int)

	Local logsize:Int=0
	glGetShaderiv(pid, GL_INFO_LOG_LENGTH, Varptr logsize)
	
	Local msg:Byte[logsize]
	Local size:Int=0
	
	glGetShaderInfoLog(pid, logsize, Varptr size, Varptr msg[0])
	
	Local str:String=""
	
	For Local i:Int=0 To msg.length-1
		str:+Chr(msg[i])
	Next
	
	Return str

End Function

Function CreateShaderProgram:Int(pvshader:Int, pfshader:Int)
	
	If glIsShader(pvshader)=GL_FALSE Then 
		Print "ERROR (CreateShaderProgram) pvshader is not a valid shader!"
		Return 0
	EndIf
	
	If glIsShader(pfshader)=GL_FALSE Then
		Print "ERROR (CreateShaderProgram) pfshader is not a valid shader!"
		Return 0
	EndIf
	
	Local id:Int=glCreateProgram()
	
	glAttachShader(id, pvshader)
	glAttachShader(id, pfshader)
	
	glLinkProgram(id)
	
	Return id
	
End Function

Function ValidateShaderProgram(pid:Int)

	If glIsProgram(pid)=GL_FALSE Then
		Print "ERROR (ValidateShaderProgram) Supplied id is not a shader program!"
		Return
	EndIf
	
	Local status:Int
	
	glValidateProgram(pid)
	glGetProgramiv(pid, GL_VALIDATE_STATUS, Varptr status)
	
	If status=GL_FALSE Then
		Print "ERROR (ValidateShaderprogram) Supplied program is not valid! (in context)"
		Return
	EndIf
	
	Return

End Function

' ///////////////////////////////////////////////////////////////////////////////////////
' shadersource.bmx

Function PlainVShaderSource:String()

	Local str:String=""

	If OPENGL_TARGET=OPENGL_ES2_TARGET Then
	
		str:+"#version 100~n"
		str:+"attribute vec2 vertex_pos;~n"
		str:+"attribute vec4 vertex_col;~n"
		str:+"varying vec4 f_col;~n"
	
	Else ' OPENGL_TARGET=OPENGL_3_TARGET
	
		str:+"#version 120~n"
		str:+"attribute vec2 vertex_pos;~n"
		str:+"attribute vec4 vertex_col;~n"
		str:+"varying vec4 f_col;~n"
	
	EndIf

	str:+"uniform mat4 pmatrix;~n"
	str:+"void main(void) {~n"
	str:+"	gl_Position=pmatrix*vec4(vertex_pos, -1.0, 1.0);~n"
	str:+"	f_col=vertex_col;~n"
	str:+"}"
	
	Return str

End Function

Function PlainFShaderSource:String()

	Local str:String=""
	
	If OPENGL_TARGET=OPENGL_ES2_TARGET Then
	
		str:+"#version 100~n"
		str:+"precision mediump float;~n"
		str:+"varying vec4 f_col;~n"
		str:+"void main(void) {~n"
		str:+"	gl_FragColor=vec4(f_col);~n"
		str:+"}~n"
	
	Else ' OPENGL_TARGET=OPENGL_3_TARGET
	
		str:+"#version 120~n"
		str:+"varying vec4 f_col;~n"
		str:+"void main(void) {~n"
		str:+"	gl_FragColor=f_col;~n"
		str:+"}~n"
	
	EndIf
	
	Return str

End Function

Function TextureVShaderSource:String()
End Function

Function TextureFShaderSource:String()
End Function

' ///////////////////////////////////////////////////////////////////////////////////////

SetGraphicsDriver GLGraphicsDriver()
GLGraphics 800, 600, 0, 60, GRAPHICS_BACKBUFFER|GRAPHICS_DEPTHBUFFER

opengl.Initialize()

Type TParticle

	Global list:TList

	Field x:Float
	Field y:Float
	Field size:Float
	Field d:Float
	
	Function Create:TParticle(px:Float, py:Float, psize:Float, pd:Float)
	
		Local this:TParticle=New TParticle
		
		this.x=px
		this.y=py
		this.size=psize
		this.d=pd
		
		If list=Null Then
			list=New TList
		EndIf
		
		list.AddLast(this)
		
		Return this
		
	End Function
	
	Function Update()
	End Function
	
	Function Draw()
		
		If list=Null Then
			Return
		EndIf
		
		opengl.SetBlend LIGHTBLEND
		opengl.SetAlpha 0.15
		
		For Local o:TParticle=EachIn list
		
			o.d:-1
			
			Local dx:Float=o.x-400
			Local dy:Float=o.y-300
			
			Local m:Float=Sqr(dx*dx+dy*dy)
			
			If m&lt;1.0 Then
				m=1.0
			EndIf
			
			m:*0.1
			
			If m&gt;255.0 Then
				m=255.0
			EndIf
			
			opengl.SetColor 0.25*m, 0.5*m, m
			opengl.DrawRect o.x-o.size*0.5, o.y-o.size*0.5, o.size, o.size
		
		Next
		
		opengl.SetAlpha 1
		opengl.SetBlend SOLIDBLEND
		
	End Function

End Type

For Local i:Int=1 To 20000
	TParticle.Create(Rand(800), Rand(600), Rnd(2, 15), Rand(360))
Next

Local curfps:Int
Local fps:Int
Local curtime:Int=MilliSecs()+1000

Local angle:Float=0

Repeat

	angle:+0.1
	If angle&gt;=360 Then
		angle=0
	EndIf

	If MilliSecs()&gt;curtime Then
		curtime:+1000
		fps=curfps+1
		curfps=0
		Print "FPS: "+fps
	Else
		curfps:+1
	EndIf

	glClearColor(0, 0, 0, 0)
	glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)
	
	' draw gradient background with lines
	
	opengl.SetBlend SOLIDBLEND
	opengl.SetAlpha 1
	
	For Local y:Int=0 To 600
	
		opengl.SetColor 31.5+Cos(angle+y*0.1)*31.5, 63+5+Cos(angle+y*0.1)*63.5, 127.5+Cos(angle+y*0.1)*127.5
		opengl.DrawLine 0, y, 800, y
	
	Next
	
	' draw rectangle cloud
	
	TParticle.Draw()
	
	' plot a dense spiral
	
	opengl.SetBlend LIGHTBLEND
	
	opengl.SetAlpha 0.25
	opengl.SetColor 32, 64, 128 
	
	For Local i:Int=1 To 50000
		Local x:Float=400.0+Cos(angle+i)*(Float(i)*0.01)
		Local y:Float=300.0+Sin(angle+i)*(Float(i)*0.01)
		opengl.Plot x, y
	Next
	
	opengl.Fence()
	
	Flip(False)

Until KeyHit(KEY_ESCAPE)=True

EndGraphics
End
</textarea> <br><br></td></tr></table><br>
<a name="1235456"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> And if anyone is interested, In release mode i get ~45fps on the Max2D version, and ~132fps on the custom one. <br><br></td></tr></table><br>
<a name="1235457"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> You can emulate Mac OS X in VirtualBox (works on AMD but Intel is preferred because you then do not need a modified bootloader).<br><br>Snow Leopard (&lt; Mountain Lion which is 10.8) works really good here (except "restart" having segfaults in the vm and therefore "restart" means "cold start" for me :D). Of course slower than on real hardware, but it might save you some time. Of course you have to buy a licence for Mac OS X somewhere to stay at least a bit more legal (according to the country you live the EULA of apple is valid for you and you only are allowed to use Mac OS X on real hardware or whatever).<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1235461"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> debug:<br>max2d 21-23<br>custom 30-31<br><br>release:<br>max2d 61-65<br>custom 167-174 <br><br></td></tr></table><br>
<a name="1235462"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> Err, The above i wrote in was on Win7 :-)<br><br>The latest test -<br>debug<br>natve: ~25<br>custom: ~37<br><br>and release<br>native: ~56<br>custom: ~117<br><br><br>with your custom code i get this report for debug and release<br><pre class=code>
(Initialize) OpenGL 3 Target
(Initialize) GLSL: 3.30 - Intel Build 8.15.10.2696 (1.20 required)
(Initialize) Matrix Debug:
Matrix 4x4:
0.00249999994, 0.000000000, 0.000000000, 0.000000000
0.000000000, -0.00333333341, 0.000000000, 0.000000000
0.000000000, 0.000000000, -1.00000000, 0.000000000
-1.00000000, 1.00000000, -0.000000000, 1.00000000
(Initialize) Setting colors to &lt;1, 1, 1, 1&gt;
(CompileShader) Compiling vertex shader
(CompileShader) Successfully compiled shader!
(CompileShader) Compiling fragment shader
(CompileShader) Successfully compiled shader!
(Initialize) Created plain shader program!
ERROR (CompileShader) No shader source!
ERROR (CompileShader) No shader source!
(Initialize) Created texture shader program!
ERROR (ValidateShaderprogram) Supplied program is not valid! (in context)
(UpdateShaderLayout) attrib_pos: 0
(UpdateShaderLayout) attrib_uv: -1
(UpdateShaderLayout) attrib_col: 1
(UpdateShaderLayout) unif_projection: 23724032
(UpdateShaderLayout) unif_tex: -1
</pre> <br><br></td></tr></table><br>
<a name="1235488"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Dave<br><br>Dont happen to have a nvidia card then? Anyways, those errors are for texturing stuff thats not used, so it looks ok to me. <br><br>@Derron<br><br>I didnt think about that, Ill have to take a look at setting that up sometime. <br><br><br>Anyways, the batch thing seems to work fairly well, at least for this simple scene. It can also be hidden away completely in a max2d driver. Sadly though for single draw calls the deprecated immediate mode seems to be a lot faster (~2x for me). Also, Max2D is doing transformations while my code is not.<br><br>Gonna try and get some more test code for other aspects together in the next few days. <br><br></td></tr></table><br>
<a name="1235492"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> It even works in 64-bit :-)<br><br><b><a href="http://brucey.net/programming/blitz/bmx_ng/demos/shader_test64_osx.zip" target="_blank">shader_test64_osx.zip</a></b> 286kb<br><br><div class="quote">  Also, Max2D is doing transformations while my code is not. <br></div><br>Can't that be done in the shader? <br><br></td></tr></table><br>
<a name="1235493"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, but 2d transformations are so straightforward Im not sure if that will give a performance boost or not. Its up for testing sooner or later though :) <br><br></td></tr></table><br>
<a name="1235494"></a>

<a name="1235506"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>Dont happen to have a nvidia card then?<br> <br></div><br><br>The laptop I use is blessed with an nvidia and an ati. Great for testing :)<br><br>edit: to optimise for batching you could try setting everything up for the batch before you enter the main loop ( maybe using some kind of pooling ), during setup you do all the checks for validity so then in the main loop you can then make the assumption that all data is valid and just blast it to the gpu ( your ogl calls ). In the latest code the main loop is checking for shader validity, your changing state several times for each iteration of drawing a particle. Ultimately try to keep all objects using the same state together to keep state changing to a minimum number as possible. <br><br></td></tr></table><br>
<a name="1240433"></a>

<a name="1240434"></a>

<a name="1240436"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> Reviving this post. This is a quick module hack (written before the code posted above) to test if I could get a new max2d driver up and running. Changed the issues from the above example, so it *should* run. It do run the digesteroids sample fine on my windows 7 box, but it'd be nice to see if it works for anyone else.<br><br>It should do plot, line, rect and image commands fine. Lacking some blendmodes etc, and anything poly wont work. <br><br>This is in no way a good example of opengl programming, since im not really familiar with it, I settled for something that works as good enough.<br><br>Basically posting it here for Brucey and co :)<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' modified version of the official brl.glmax2d, to use opengl3/es2 compatible render methods.

SuperStrict

Rem
bbdoc: Graphics/OpenGL Max2D
about:
The OpenGL Max2D module provides an OpenGL driver for #Max2D.
End Rem
Module BRL.GLTestMax2D

Rem
ModuleInfo "Version: 1.13"
ModuleInfo "Author: Mark Sibly"
ModuleInfo "License: zlib/libpng"
ModuleInfo "Copyright: Blitz Research Ltd"
ModuleInfo "Modserver: BRL"

ModuleInfo "History: 1.13 Release"
ModuleInfo "History: Cleaned up SetGraphics"
ModuleInfo "History: 1.12 Release"
ModuleInfo "History: Fixed filtered image min filters"
ModuleInfo "History: 1.11 Release"
ModuleInfo "History: Fixed texture delete logic"
ModuleInfo "History: 1.10 Release"
ModuleInfo "History: Add SetColor/SetClsColor clamping"
ModuleInfo "History: 1.09 Release"
ModuleInfo "History: Fixed DrawPixmap using current blend mode - now always uses SOLIDBLEND"
ModuleInfo "History: 1.08 Release"
ModuleInfo "History: Added MIPMAPPEDIMAGE support"
ModuleInfo "History: 1.07 Release"
ModuleInfo "History: Now default driver for MacOS/Linux only (D3D7 for windows)"
ModuleInfo "History: 1.06 Release"
ModuleInfo "History: Ripped out a bunch of dead code"
ModuleInfo "History: 1.05 Release"
ModuleInfo "History: Added checks to prevent invalid textures deletes"
End Rem

Import PUB.OpenGL
Import PUB.Glew

Import BRL.Max2D
Import BRL.GLGraphics
Import BRL.StandardIO

Import BRL.PNGLoader

' /////////////////////////////////////////////////////////////////////////////////////////////////

Private

Global _driver:TGLTestMax2DDriver
Global _projection_matrix:TMatrix4

Global _shaderprogram:Int
Global _shaderprogram_plain:Int
Global _shaderprogram_texture:Int

Global _attrib_position:Int
Global _attrib_uv:Int

Global _uniform_projection:Int
Global _uniform_color:Int
Global _uniform_texture:Int

Global _vertex_buffer:Int
Global _uv_buffer:Int

Global _texture:Int

Global rgba:Float[]=[1.0, 1.0, 1.0, 1.0]
Global ix:Float, iy:Float, jx:Float, jy:Float
Global state_blend:Int

' ///////////////////////////////////////////////////////////////////////////////////////////

' renderer.bmx

' set shader program to use. automatically updates attribute and uniform pointers. 
' -1 means whatever was not present in shader code.
Function SetShaderProgram(pprogram:Int)

	_shaderprogram=pprogram
	glUseProgram(_shaderprogram)
	
	_attrib_position=glGetAttribLocation(_shaderprogram, "vertex_position")
	_attrib_uv=glGetAttribLocation(_shaderprogram, "vertex_uv")
	
	_uniform_projection=glGetUniformLocation(_shaderprogram, "projection_matrix")
	_uniform_color=glGetUniformLocation(_shaderprogram, "color")
	_uniform_texture=glGetUniformLocation(_shaderprogram, "Texture")
	
End Function

Function SetPlainShaderProgram(pprogram:Int)
	_shaderprogram_plain=pprogram
End Function

Function SetTextureShaderProgram(pprogram:Int)
	_shaderprogram_texture=pprogram
End Function

' enable all shader data
Function EnableShaderData()

	If _attrib_position&gt;=0 Then
	
		glEnableVertexAttribArray(_attrib_position)
		glBindBuffer(GL_ARRAY_BUFFER, _vertex_buffer)
		glVertexAttribPointer(_attrib_position, 3, GL_FLOAT, GL_FALSE, 0, Null)
		
	EndIf
	
	If _attrib_uv&gt;=0 Then
		
		glEnableVertexAttribArray(_attrib_uv)
		glBindBuffer(GL_ARRAY_BUFFER, _uv_buffer)
		glVertexAttribPointer(_attrib_uv, 2, GL_FLOAT, GL_FALSE, 0, Null)
		
	EndIf

	If _uniform_projection&gt;=0 Then glUniformMatrix4fv(_uniform_projection, 1, False, _projection_matrix.e)
	If _uniform_color&gt;=0 Then glUniform4fv(_uniform_color, 4, rgba)
	
	If _uniform_texture&gt;=0 And _texture&lt;&gt;0 Then
	
		glActiveTexture(GL_TEXTURE0)
		glBindTexture(GL_TEXTURE_2D, _texture)
		glUniform1i(_uniform_texture, 0)
		
	EndIf
	
End Function
	
' disable all shader data
Function DisableShaderData()

	If _attrib_position&gt;=0 Then glDisableVertexAttribArray(_attrib_position)
	If _attrib_uv&gt;=0 Then glDisableVertexAttribArray(_attrib_uv)

End Function

' update buffer data to given arrays. create new buffers if needed.
Function UpdateVertexBuffer(pvertices:Float[])

	If _vertex_buffer=0 Then
		glGenBuffers(1, Varptr _vertex_buffer)
	EndIf
	
	glBindBuffer(GL_ARRAY_BUFFER, _vertex_buffer)
	glBufferData(GL_ARRAY_BUFFER, SizeOf(pvertices), pvertices, GL_STATIC_DRAW)
	
	Return
	
End Function

Function UpdateUVBuffer(puvs:Float[])

	If _uv_buffer=0 Then
		glGenBuffers(1, Varptr _uv_buffer)
	EndIf
	
	glBindBuffer(GL_ARRAY_BUFFER, _uv_buffer)
	glBufferData(GL_ARRAY_BUFFER, SizeOf(puvs), puvs, GL_STATIC_DRAW)
	
	Return

End Function

' ///////////////////////////////////////////////////////////////////////////////////////////

' matrix4.bmx

Type TMatrix4

	Field e:Float[16]
	
	Method SetOrthographic(pl:Float, pr:Float, pt:Float, pb:Float, pn:Float, pf:Float)
	
		LoadIdentity()
		
		e[00] = 2.0/(pr-pl)
		e[05] = 2.0/(pt-pb)
		e[10] =-2.0/(pf-pn)
		e[15] = 1.0
		
		e[12]=-(pr+pl)/(pr-pl)
		e[13]=-(pt+pb)/(pt-pb)
		e[14]=-(pf+pn)/(pf-pn)
	
	End Method

	Method LoadIdentity()
		For Local i:Int=0 To e.length-1
			e[i]=0.0
			If (i Mod 4)=i/4 Then
				e[i]=1.0
			EndIf
		Next
	End Method
	
	Method Debug()
		
		Print "Matrix4:"
		
		For Local j:Int=0 To 3
			For Local i:Int=0 To 3
		
				WriteStdout e[j*4+i]
				If i&lt;3 Then
					WriteStdout ", "
				EndIf
			
			Next
			WriteStdout "~n"
		Next
		
	End Method

End Type

' ///////////////////////////////////////////////////////////////////////////////////////////

' utility.bmx

Function LoadFileAsString:String(ppath:String)

	ppath="C:/BlitzMax/mod/zzz.mod/glesmax2d.mod/"+ppath

	Local s:String=""
	Local stream:TStream=ReadFile(ppath)
	
	If stream=Null Then
		Notify "failed to open file '"+ppath+"'"
		Return ""
	EndIf
	
	Repeat
		s:+ReadLine(stream)+"~n"
	Until Eof(stream)
	
	CloseFile(stream)
	Return s

End Function

' ///////////////////////////////////////////////////////////////////////////////////////////

' shader.bmx

Function CompileVertexShader:Int(psource:String)
	Return CompileShader(psource, GL_VERTEX_SHADER)
End Function

Function CompileFragmentShader:Int(psource:String)
	Return CompileShader(psource, GL_FRAGMENT_SHADER)
End Function

Function CompileShader:Int(psource:String, ptype:Int)

	Print "compiling shader '"+psource+"'"

	Local id:Int=glCreateShader(ptype)
	Local cstring:Byte Ptr=psource.ToCString()
	
	glShaderSource(id, 1, Varptr cstring, Null)
	glCompileShader(id)
	
	Local success:Int=0
	glGetShaderiv(id, GL_COMPILE_STATUS, Varptr success)
	
	If Not success Then
		Print GetShaderErrorLog(id)
		Return 0
	EndIf
	
	Print "done!"
	Return id	

End Function

Function GetShaderErrorLog:String(pid:Int)

	Local logsize:Int=0
	glGetShaderiv(pid, GL_INFO_LOG_LENGTH, Varptr logsize)
	
	Local msg:Byte[logsize]
	Local size:Int=0
	
	glGetShaderInfoLog(pid, logsize, Varptr size, Varptr msg[0])
	
	Local str:String=""
	
	For Local i:Int=0 To msg.length-1
		str:+Chr(msg[i])
	Next
	
	Return str

End Function

Function CreateShaderProgram:Int(pvertexshader:Int, pfragmentshader:Int)

	Local id:Int=glCreateProgram()
	
	glAttachShader(id, pvertexshader)
	glAttachShader(id, pfragmentshader)
	
	glLinkProgram(id)
	
	Print "anything wrong with shaderprogram?"+glGetError()
	
	Return id

End Function

' ///////////////////////////////////////////////////////////////////////////////////////////

Function DeleteTexture(name:Int, seq:Int)
End Function

Function Pow2Size:Int(n:Int)
	Local t:Int=1
	While t&lt;n
		t:*2
	Wend
	Return t
End Function

Function AdjustTexSize( width:Int Var,height:Int Var )
	'calc texture size
	width=Pow2Size( width )
	height=Pow2Size( height )
	Repeat
		Local t:Int
		glTexImage2D GL_PROXY_TEXTURE_2D,0,4,width,height,0,GL_RGBA,GL_UNSIGNED_BYTE,Null
		glGetTexLevelParameteriv GL_PROXY_TEXTURE_2D,0,GL_TEXTURE_WIDTH,Varptr t
		If t Return
		If width=1 And height=1 RuntimeError "Unable to calculate tex size"
		If width&gt;1 width:/2
		If height&gt;1 height:/2
	Forever
End Function

' /////////////////////////////////////////////////////////////////////////////////////////////////

Public

Type TGLESImageFrame Extends TImageFrame

	Field u0:Float, v0:Float, u1:Float, v1:Float, uscale:Float, vscale:Float
	
	Field name:Int
	Field seq:Int
	
	Method New()
		WriteStdout "new texture?~n"
		seq=GraphicsSeq
	End Method
	
	Method Delete()
		If Not seq Then
			Return
		EndIf
		DeleteTexture(name, seq)
		seq=0
	End Method
	
	Method Draw(x0:Float, y0:Float, x1:Float, y1:Float, tx:Float, ty:Float, sx:Float, sy:Float, sw:Float, sh:Float)
	
		If _shaderprogram&lt;&gt;_shaderprogram_texture Or _texture&lt;&gt;name Then
			
			_texture=name
			SetShaderProgram(_shaderprogram_texture)
			
		EndIf
		
		Local tu0:Float=sx*uscale
		Local tv0:Float=sy*vscale
		Local tu1:Float=(sx+sw)*uscale
		Local tv1:Float=(sy+sh)*vscale
		
		Local vertices:Float[]=[x0*ix+y0*iy+tx, x0*jx+y0*jy+ty, -1.0, x1*ix+y0*iy+tx, x1*jx+y0*jy+ty, -1.0, x1*ix+y1*iy+tx, x1*jx+y1*jy+ty, -1.0,  x1*ix+y1*iy+tx, x1*jx+y1*jy+ty, -1.0, x0*ix+y1*iy+tx, x0*jx+y1*jy+ty, -1.0, x0*ix+y0*iy+tx, x0*jx+y0*jy+ty, -1.0]
		Local uvs:Float[]=[tu0, tv0, tu1, tv0, tu1, tv1, tu1, tv1, tu0, tv1, tu0, tv0]
		
		UpdateVertexBuffer(vertices)
		UpdateUVBuffer(uvs)
		
		EnableShaderData()
		glDrawArrays(GL_TRIANGLES, 0, 6)
		DisableShaderData()
	
		Return	
			
	End Method
	
	Function CreateFromPixmap:TGLESImageFrame(src:TPixmap, flags:Int)
	
		Local tex_w:Int=src.width
		Local tex_h:Int=src.height
		AdjustTexSize tex_w, tex_h
		
		Local width:Int=Min(src.width, tex_w)
		Local height:Int=Min(src.height, tex_h)
		If src.width&lt;&gt;width Or src.height&lt;&gt;height Then src=ResizePixmap(src, width, height)
	
		Local texture:TPixmap=CopyPixmap(src)
		
		texture=ConvertPixmap(texture, PF_RGBA8888)
		texture=ResizePixmap(texture, width, height)
		
		Local id:Int
		
		glGenTextures(1, Varptr id)
		glBindTexture(GL_TEXTURE_2D, id)
		
		WriteStdout "error: "+glGetError()+"~n"
		WriteStdout "texture bound to "+id+"~n"
		
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)
		
		WriteStdout "error: "+glGetError()+"~n"
		
		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, texture.width, texture.height, 0, GL_RGBA, GL_UNSIGNED_BYTE, texture.pixels)
		
		SavePixmapPNG(texture, "C:\Users\zlacker\Desktop\blitzmax ogl es 2.0\out.png")
		
		If glGetError() Then
			WriteStdout "something went wrong..~n"
		EndIf
		
		Local frame:TGLESImageFrame=New TGLESImageFrame
		
		Print tex_w+" "+width
		Print tex_h+" "+height
		
		frame.name=id
		frame.uscale=1.0/width
		frame.vscale=1.0/height
		frame.u0=0.0
		frame.v0=0.0
		frame.u1=src.width*frame.uscale
		frame.v1=src.height*frame.vscale
		
		Print frame.uscale+", "+frame.vscale
		Print frame.u0+", "+frame.v0
		Print frame.u1+", "+frame.v1
		
		Return frame
		
	End Function

End Type

' gl es driver. copied from brl glmax2ddriver and then heavily modified. 

Type TGLTestMax2DDriver Extends TMax2DDriver

	Method Create:TGLTestMax2DDriver()
		If Not GLGraphicsDriver() Then
			Return Null
		EndIf
		Return Self
	End Method

	Method GraphicsModes:TGraphicsMode[]()
		Return GLGraphicsDriver().GraphicsModes()
	End Method
	
	Method AttachGraphics:TMax2DGraphics(widget:Int, flags:Int)
		Local g:TGLGraphics=GLGraphicsDriver().AttachGraphics(widget, flags)
		If g Then
			Return TMax2DGraphics.Create(g, Self)
		EndIf
	End Method
	
	Method CreateGraphics:TMax2DGraphics(width:Int, height:Int, depth:Int, hertz:Int, flags:Int)
		flags=GRAPHICS_BACKBUFFER|GRAPHICS_DEPTHBUFFER
		Local g:TGLGraphics=GLGraphicsDriver().CreateGraphics(width, height, depth, hertz, flags)
		If Not g Then
			Return Null
		EndIf
		Return TMax2DGraphics.Create(g, Self)
	End Method
	
	Method SetGraphics(g:TGraphics)
		If Not g Then
			TMax2DGraphics.ClearCurrent()
			GLGraphicsDriver().SetGraphics(Null)
			Return
		EndIf
		Local t:TMax2DGraphics=TMax2DGraphics(g)
		Assert t And TGLGraphics(t._graphics)
		GLGraphicsDriver().SetGraphics(t._graphics)
		ResetGLContext(t)
		t.MakeCurrent()
	End Method
	
	Method ResetGLContext(g:TGraphics)
	
		Local width:Int, height:Int, depth:Int, hertz:Int, flags:Int
		g.GetSettings(width, height, depth, hertz, flags)
	
		'set up ogl 
		
		glewInit()
		
		glEnable(GL_DEPTH_TEST)
		glDepthFunc(GL_LEQUAL)
		
		glEnable(GL_BLEND)
		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
		
		_projection_matrix=New TMatrix4
		_projection_matrix.SetOrthographic(0, width, 0, height, 0.1, 100.0)
		
		Local vertshader:Int
		Local fragshader:Int
		
		'vertshader=CompileShader(LoadFileAsString("shaders/vertex_plain.vert"), GL_VERTEX_SHADER)
		'fragshader=CompileShader(LoadFileAsString("shaders/fragment_plain.frag"), GL_FRAGMENT_SHADER)
		
		vertshader=CompileShader(GetDefaultVertexShader(), GL_VERTEX_SHADER)
		fragshader=CompileShader(GetDefaultFragmentShader(), GL_FRAGMENT_SHADER)
		
		_shaderprogram_plain=CreateShaderProgram(vertshader, fragshader)
		
		'vertshader=CompileShader(LoadFileAsString("shaders/vertex_texture.vert"), GL_VERTEX_SHADER)
		'fragshader=CompileShader(LoadFileAsString("shaders/fragment_texture.frag"), GL_FRAGMENT_SHADER)
		
		vertshader=CompileShader(GetTextureVertexShader(), GL_VERTEX_SHADER)
		fragshader=CompileShader(GetTextureFragmentShader(), GL_FRAGMENT_SHADER)
		
		_shaderprogram_texture=CreateShaderProgram(vertshader, fragshader)
		
		'done
	End Method
	
	Method Flip(sync:Int)
		GLGraphicsDriver().Flip(sync)
	End Method

	Method CreateFrameFromPixmap:TImageFrame(pixmap:TPixmap, flags:Int)
		Local frame:TGLESImageFrame
		frame=TGLESImageFrame.CreateFromPixmap(pixmap, flags)
		Return frame
	End Method
	
	Method SetBlend(blend:Int)
	
		If blend=state_blend Then
			Return
		EndIf
		state_blend=blend
		Select blend
		Case SOLIDBLEND
			glDisable(GL_BLEND)
		Case ALPHABLEND
			glEnable(GL_BLEND)
			glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
		Case LIGHTBLEND
			glEnable(GL_BLEND)
			glBlendFunc(GL_SRC_ALPHA, GL_ONE)
		Default
			glDisable(GL_BLEND)
		End Select
	
		Return
		
	End Method
	
	Method SetAlpha(alpha:Float)
		If alpha&lt;0.0 Then alpha=0.0
		If alpha&gt;1.0 Then alpha=1.0
		rgba[3]=alpha
	End Method

	Method SetColor(red:Int, green:Int, blue:Int)
		
		If red&lt;0 Then red=0
		If red&gt;255 Then red=255
		
		If green&lt;0 Then green=0
		If green&gt;255 Then green=255
		
		If blue&lt;0 Then blue=0
		If blue&gt;255 Then blue=255
		
		rgba[0]=Float(red)/255.0
		rgba[1]=Float(green)/255.0
		rgba[2]=Float(blue)/255.0
		
	End Method
	
	Method SetClsColor(red:Int, green:Int, blue:Int)
		
		If red&lt;0 Then red=0
		If red&gt;255 Then red=255
		
		If green&lt;0 Then green=0
		If green&gt;255 Then green=255
		
		If blue&lt;0 Then blue=0
		If blue&gt;255 Then blue=255
		
		glClearColor(Float(red)/255.0, Float(green)/255.0, Float(blue)/255.0, 1.0)
		
	End Method
	
	Method SetViewport(x:Int, y:Int, width:Int, height:Int)
	End Method
	
	Method SetTransform(xx:Float, xy:Float, yx:Float, yy:Float)
		ix=xx
		iy=xy
		jx=yx
		jy=yy
	End Method
	
	Method SetLineWidth(width:Float)
	End Method
	
	Method Cls()
		glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)
	End Method
	
	Method Plot(x:Float, y:Float)
	
		If _shaderprogram&lt;&gt;_shaderprogram_plain Then SetShaderProgram(_shaderprogram_plain)

		Local vertices:Float[]=[x+0.5, y+0.5, -1.0]
		Local uvs:Float[]=[0.0, 0.0]

		UpdateVertexBuffer(vertices)
		UpdateUVBuffer(uvs)
		
		EnableShaderData()
		glDrawArrays(GL_POINTS, 0, 2)
		DisableShaderData()
	
		Return
		
	End Method
	
	Method DrawLine(x0:Float, y0:Float, x1:Float, y1:Float, tx:Float, ty:Float)
	
		If _shaderprogram&lt;&gt;_shaderprogram_plain Then SetShaderProgram(_shaderprogram_plain)

		Local vertices:Float[]=[x0*ix+y0*iy+tx+.5, x0*jx+y0*jy+ty+.5, -1.0, x1*ix+y1*iy+tx+.5, x1*jx+y1*jy+ty+.5, -1.0]
		Local uvs:Float[]=[0.0, 0.0, 1.0, 1.0]

		UpdateVertexBuffer(vertices)
		UpdateUVBuffer(uvs)
		
		EnableShaderData()
		glDrawArrays(GL_LINES, 0, 4)
		DisableShaderData()
	
		Return
		
	End Method
	
	Method DrawRect(x0:Float, y0:Float, x1:Float, y1:Float, tx:Float, ty:Float)
	
		If _shaderprogram&lt;&gt;_shaderprogram_plain Then SetShaderProgram(_shaderprogram_plain)

		Local vertices:Float[]=[x0*ix+y0*iy+tx, x0*jx+y0*jy+ty, -1.0, x1*ix+y0*iy+tx, x1*jx+y0*jy+ty, -1.0, x1*ix+y1*iy+tx, x1*jx+y1*jy+ty, -1.0, x1*ix+y1*iy+tx, x1*jx+y1*jy+ty, -1.0, x0*ix+y1*iy+tx, x0*jx+y1*jy+ty, -1.0, x0*ix+y0*iy+tx, x0*jx+y0*jy+ty, -1.0]
		Local uvs:Float[]=[0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0]

		UpdateVertexBuffer(vertices)
		UpdateUVBuffer(uvs)
		
		EnableShaderData()
		glDrawArrays(GL_TRIANGLES, 0, 6)
		DisableShaderData()
	
		Return
		
	End Method
	
	Method DrawOval(x0:Float, y0:Float, x1:Float, y1:Float, tx:Float, ty:Float)
		Return
	End Method
	
	Method DrawPoly(xy:Float[], handlex:Float, handley:Float, originx:Float, originy:Float)
		Return
	End Method
	
	Method DrawPixmap(pixmap:TPixmap, x:Int, y:Int)
		Return
	End Method
	
	Method GrabPixmap:TPixmap(x:Int, y:Int, width:Int, height:Int)
		Return Null
	End Method
	
	Method SetResolution(width:Float, height:Float)
		_projection_matrix.SetOrthographic(0.0, width, 0.0, height, -1.0, 1.0)
	End Method
	
End Type

Rem
bbdoc: Get OpenGL Max2D Driver
about:
The returned driver can be used with #SetGraphicsDriver to enable OpenGL Max2D 
rendering.
End Rem
Function GLTestMax2DDriver:TGLTestMax2DDriver()
	Global _done:Int
	If Not _done:Int
		_driver:TGLTestMax2DDriver=New TGLTestMax2DDriver.Create()
		_done=True
	EndIf
	Return _driver
End Function

Local driver:TGLTestMax2DDriver=GLTestMax2DDriver()
If driver Then
	SetGraphicsDriver(driver)
EndIf

Function GetDefaultVertexShader:String()

	Local str:String
	
	str:+"#version 120~n"
	str:+"attribute vec3 vertex_position;~n"
	str:+"uniform mat4 projection_matrix;~n"
	str:+"uniform vec4 color;~n"
	str:+"varying vec4 fragment_color;~n"
	str:+"void main(void)~n"
	str:+"{~n"
	str:+"	gl_Position=projection_matrix*vec4(vertex_position, 1.0);~n"
	str:+"	fragment_color=color;~n"
	str:+"}~n"
	
	Return str

End Function

Function GetDefaultFragmentShader:String()
	
	Local str:String
	
	str:+"#version 120~n"
	str:+"varying vec4 fragment_color;~n"
	str:+"void main(void)~n"
	str:+"{~n"
	str:+"	gl_FragColor=fragment_color;~n"
	str:+"}~n"
	
	Return str
	
End Function

Function GetTextureVertexShader:String()

	Local str:String
	
	str:+"#version 120~n"
	str:+"attribute vec3 vertex_position;~n"
	str:+"attribute vec2 vertex_uv;~n"
	str:+"uniform mat4 projection_matrix;~n"
	str:+"uniform vec4 color;~n"
	str:+"varying vec4 fragment_color;~n"
	str:+"varying vec2 uv;~n"
	str:+"void main(void)~n"
	str:+"{~n"
	str:+"	gl_Position=projection_matrix*vec4(vertex_position, 1.0);~n"
	str:+"	fragment_color=color;~n"
	str:+"	uv=vertex_uv;~n"
	str:+"}~n"
	
	Return str
	
End Function

Function GetTextureFragmentShader:String()

	Local str:String
	
	str:+"#version 120~n"
	str:+"varying vec4 fragment_color;~n"
	str:+"varying vec2 uv;~n"
	str:+"uniform sampler2D Texture;~n"
	str:+"void main(void)~n"
	str:+"{~n"
	str:+"	gl_FragColor=fragment_color*texture2D(Texture, uv);~n"
	str:+"}~n"
	
	Return str

End Function
</textarea> <br><br></td></tr></table><br>
<a name="1240497"></a>

<a name="1240498"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just get a black screen in my demoapp.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
./bmk makeapp -t console -r -x "Dig.git/samples/demoapp/demoapp.bmx"
Executing:demoapp
compiling shader '#version 120
attribute vec3 vertex_position;
uniform mat4 projection_matrix;
uniform vec4 color;
varying vec4 fragment_color;
void main(void)
{
	gl_Position=projection_matrix*vec4(vertex_position, 1.0);
	fragment_color=color;
}
'
done!
compiling shader '#version 120
varying vec4 fragment_color;
void main(void)
{
	gl_FragColor=fragment_color;
}
'
done!
anything wrong with shaderprogram?0
compiling shader '#version 120
attribute vec3 vertex_position;
attribute vec2 vertex_uv;
uniform mat4 projection_matrix;
uniform vec4 color;
varying vec4 fragment_color;
varying vec2 uv;
void main(void)
{
	gl_Position=projection_matrix*vec4(vertex_position, 1.0);
	fragment_color=color;
	uv=vertex_uv;
}
'
done!
compiling shader '#version 120
varying vec4 fragment_color;
varying vec2 uv;
uniform sampler2D Texture;
void main(void)
{
	gl_FragColor=fragment_color*texture2D(Texture, uv);
}
'
done!
anything wrong with shaderprogram?0
compiling shader '#version 120
attribute vec3 vertex_position;
uniform mat4 projection_matrix;
uniform vec4 color;
varying vec4 fragment_color;
void main(void)
{
	gl_Position=projection_matrix*vec4(vertex_position, 1.0);
	fragment_color=color;
}
'
done!
compiling shader '#version 120
varying vec4 fragment_color;
void main(void)
{
	gl_FragColor=fragment_color;
}
'
done!
anything wrong with shaderprogram?0
compiling shader '#version 120
attribute vec3 vertex_position;
attribute vec2 vertex_uv;
uniform mat4 projection_matrix;
uniform vec4 color;
varying vec4 fragment_color;
varying vec2 uv;
void main(void)
{
	gl_Position=projection_matrix*vec4(vertex_position, 1.0);
	fragment_color=color;
	uv=vertex_uv;
}
'
done!
compiling shader '#version 120
varying vec4 fragment_color;
varying vec2 uv;
uniform sampler2D Texture;
void main(void)
{
	gl_FragColor=fragment_color*texture2D(Texture, uv);
}
'
done!
anything wrong with shaderprogram?0
error: 0
texture bound to 1
error: 0
new texture?
1024 800
1024 600
0.00124999997, 0.00166666671
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 2
error: 0
new texture?
256 219
256 182
0.00456620986, 0.00549450563
0.00000000, 0.00000000
0.999999940, 1.00000000
error: 1282
texture bound to 3
error: 0
new texture?
512 512
512 512
0.00195312500, 0.00195312500
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 4
error: 0
new texture?
256 256
128 128
0.00390625000, 0.00781250000
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 5
error: 0
new texture?
256 256
128 128
0.00390625000, 0.00781250000
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 6
error: 0
new texture?
256 256
128 128
0.00390625000, 0.00781250000
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 7
error: 0
new texture?
256 156
64 41
0.00641025649, 0.0243902430
0.00000000, 0.00000000
1.00000000, 0.999999940
error: 1282
texture bound to 8
error: 0
new texture?
256 256
128 128
0.00390625000, 0.00781250000
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 9
error: 0
new texture?
256 256
128 128
0.00390625000, 0.00781250000
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 10
error: 0
new texture?
8 8
16 16
0.125000000, 0.0625000000
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 11
error: 0
new texture?
8 8
16 16
0.125000000, 0.0625000000
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 12
error: 0
new texture?
8 8
16 16
0.125000000, 0.0625000000
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 13
error: 0
new texture?
8 8
16 16
0.125000000, 0.0625000000
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 14
error: 0
new texture?
8 8
16 16
0.125000000, 0.0625000000
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 15
error: 0
new texture?
8 8
16 16
0.125000000, 0.0625000000
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 16
error: 0
new texture?
8 8
16 16
0.125000000, 0.0625000000
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 17
error: 0
new texture?
8 8
16 16
0.125000000, 0.0625000000
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 18
error: 0
new texture?
8 8
16 16
0.125000000, 0.0625000000
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 19
error: 0
new texture?
8 8
16 16
0.125000000, 0.0625000000
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 20
error: 0
new texture?
8 8
16 16
0.125000000, 0.0625000000
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 21
error: 0
new texture?
8 8
16 16
0.125000000, 0.0625000000
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 22
error: 0
new texture?
8 8
16 16
0.125000000, 0.0625000000
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 23
error: 0
new texture?
8 8
16 16
0.125000000, 0.0625000000
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 24
error: 0
new texture?
8 8
16 16
0.125000000, 0.0625000000
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 25
error: 0
new texture?
8 8
16 16
0.125000000, 0.0625000000
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 26
error: 0
new texture?
8 8
16 16
0.125000000, 0.0625000000
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 27
error: 0
new texture?
8 8
16 16
0.125000000, 0.0625000000
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 28
error: 0
new texture?
8 8
16 16
0.125000000, 0.0625000000
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 29
error: 0
new texture?
8 8
16 16
0.125000000, 0.0625000000
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 30
error: 0
new texture?
8 8
16 16
0.125000000, 0.0625000000
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 31
error: 0
new texture?
8 8
16 16
0.125000000, 0.0625000000
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 32
error: 0
new texture?
8 8
16 16
0.125000000, 0.0625000000
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 33
error: 0
new texture?
8 8
16 16
0.125000000, 0.0625000000
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 34
error: 0
new texture?
8 8
16 16
0.125000000, 0.0625000000
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 35
error: 0
new texture?
128 96
32 32
0.0104166670, 0.0312500000
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 36
error: 0
new texture?
8 8
16 16
0.125000000, 0.0625000000
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 37
error: 0
new texture?
8 8
16 16
0.125000000, 0.0625000000
0.00000000, 0.00000000
1.00000000, 1.00000000
error: 1282
texture bound to 38
error: 0
new texture?
8 8
16 16
0.125000000, 0.0625000000
0.00000000, 0.00000000
1.00000000, 1.00000000
exit now
App shutdown completed. Bye.
</textarea><br><br><br>My app uses no special GL-Commands or so.<br><br><br>Same error when running a simple sample:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

Framework BRL.standardIO
Import Brl.Random
Import "../external/gltestmax2d.bmx"


Graphics 800, 600
SetGraphicsDriver GLTestMax2DDriver()

Repeat
	Cls
	SetColor 255,255,255
	DrawRect(100+Rand(100),100,100,100)
	Flip 1
Until KeyHit(KEY_ESCAPE)
</textarea><br>-&gt; blackscreen.<br><br>Log of this sample:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
./bmk makeapp -t console -r -x "samples/gltestmax2d.bmx"
Compiling:gltestmax2d.bmx
flat assembler  version 1.68  (1048560 kilobytes memory)
3 passes, 1152 bytes.
Linking:gltestmax2d
Executing:gltestmax2d
compiling shader '#version 120
attribute vec3 vertex_position;
uniform mat4 projection_matrix;
uniform vec4 color;
varying vec4 fragment_color;
void main(void)
{
	gl_Position=projection_matrix*vec4(vertex_position, 1.0);
	fragment_color=color;
}
'
done!
compiling shader '#version 120
varying vec4 fragment_color;
void main(void)
{
	gl_FragColor=fragment_color;
}
'
done!
anything wrong with shaderprogram?0
compiling shader '#version 120
attribute vec3 vertex_position;
attribute vec2 vertex_uv;
uniform mat4 projection_matrix;
uniform vec4 color;
varying vec4 fragment_color;
varying vec2 uv;
void main(void)
{
	gl_Position=projection_matrix*vec4(vertex_position, 1.0);
	fragment_color=color;
	uv=vertex_uv;
}
'
done!
compiling shader '#version 120
varying vec4 fragment_color;
varying vec2 uv;
uniform sampler2D Texture;
void main(void)
{
	gl_FragColor=fragment_color*texture2D(Texture, uv);
}
'
done!
anything wrong with shaderprogram?0
</textarea><br><br><br><br>I am on Linux Mint, 64Bit, Amd LLano CPU/GPU - using one of the proprietary AMD drivers.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1240519"></a>

<a name="1240522"></a>

<a name="1240523"></a>

<a name="1240529"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, Ill repost it with a bunch of error checking later today.<br><br>Would you mind testing if your simple example can change clear color?<br><br>EDIT: Version with more error checks:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' modified version of the official brl.glmax2d, to use opengl3/es2 compatible render methods.

SuperStrict

Rem
bbdoc: Graphics/OpenGL Max2D
about:
The OpenGL Max2D module provides an OpenGL driver for #Max2D.
End Rem
Module BRL.GLTestMax2D

Rem
ModuleInfo "Version: 1.13"
ModuleInfo "Author: Mark Sibly"
ModuleInfo "License: zlib/libpng"
ModuleInfo "Copyright: Blitz Research Ltd"
ModuleInfo "Modserver: BRL"

ModuleInfo "History: 1.13 Release"
ModuleInfo "History: Cleaned up SetGraphics"
ModuleInfo "History: 1.12 Release"
ModuleInfo "History: Fixed filtered image min filters"
ModuleInfo "History: 1.11 Release"
ModuleInfo "History: Fixed texture delete logic"
ModuleInfo "History: 1.10 Release"
ModuleInfo "History: Add SetColor/SetClsColor clamping"
ModuleInfo "History: 1.09 Release"
ModuleInfo "History: Fixed DrawPixmap using current blend mode - now always uses SOLIDBLEND"
ModuleInfo "History: 1.08 Release"
ModuleInfo "History: Added MIPMAPPEDIMAGE support"
ModuleInfo "History: 1.07 Release"
ModuleInfo "History: Now default driver for MacOS/Linux only (D3D7 for windows)"
ModuleInfo "History: 1.06 Release"
ModuleInfo "History: Ripped out a bunch of dead code"
ModuleInfo "History: 1.05 Release"
ModuleInfo "History: Added checks to prevent invalid textures deletes"
End Rem

Import PUB.OpenGL
Import PUB.Glew

Import BRL.Max2D
Import BRL.GLGraphics
Import BRL.StandardIO

Import BRL.PNGLoader

' /////////////////////////////////////////////////////////////////////////////////////////////////

Private

Global _driver:TGLTestMax2DDriver
Global _projection_matrix:TMatrix4

Global _shaderprogram:Int
Global _shaderprogram_plain:Int
Global _shaderprogram_texture:Int

Global _attrib_position:Int
Global _attrib_uv:Int

Global _uniform_projection:Int
Global _uniform_color:Int
Global _uniform_texture:Int

Global _vertex_buffer:Int
Global _uv_buffer:Int

Global _texture:Int

Global rgba:Float[]=[1.0, 1.0, 1.0, 1.0]
Global ix:Float, iy:Float, jx:Float, jy:Float
Global state_blend:Int

' ///////////////////////////////////////////////////////////////////////////////////////////

' renderer.bmx

' set shader program to use. automatically updates attribute and uniform pointers. 
' -1 means whatever was not present in shader code.
Function SetShaderProgram(pprogram:Int)

	_shaderprogram=pprogram
	
	glUseProgram(_shaderprogram)
	CatchError("SetShaderProgram-glUseProgram")
	
	_attrib_position=glGetAttribLocation(_shaderprogram, "vertex_position")
	CatchError("SetShaderProgram-glGetAttribLocation-1")
	
	_attrib_uv=glGetAttribLocation(_shaderprogram, "vertex_uv")
	CatchError("SetShaderProgram-glGetAttribLocation-2")
	
	_uniform_projection=glGetUniformLocation(_shaderprogram, "projection_matrix")
	CatchError("SetShaderProgram-glGetUniformLocation-1")
	
	_uniform_color=glGetUniformLocation(_shaderprogram, "color")
	CatchError("SetShaderProgram-glGetUniformLocation-2")
	
	_uniform_texture=glGetUniformLocation(_shaderprogram, "Texture")
	CatchError("SetShaderProgram-glGetUniformLocation-3")
	
End Function

Function SetPlainShaderProgram(pprogram:Int)
	_shaderprogram_plain=pprogram
End Function

Function SetTextureShaderProgram(pprogram:Int)
	_shaderprogram_texture=pprogram
End Function

' enable all shader data
Function EnableShaderData()

	If _attrib_position&gt;=0 Then
	
		glEnableVertexAttribArray(_attrib_position)
		CatchError("EnableShaderData-glEnableVertexAttribArray-1")
		glBindBuffer(GL_ARRAY_BUFFER, _vertex_buffer)
		CatchError("EnableShaderData-glBindBuffer-2")
		glVertexAttribPointer(_attrib_position, 3, GL_FLOAT, GL_FALSE, 0, Null)
		CatchError("EnableShaderData-glVertexAttribPointer")
		
	EndIf
	
	If _attrib_uv&gt;=0 Then
		
		glEnableVertexAttribArray(_attrib_uv)
		CatchError("EnableShaderData-glEnableVertexAttribArray-2")
		glBindBuffer(GL_ARRAY_BUFFER, _uv_buffer)
		CatchError("EnableShaderData-glBindBuffer-2")
		glVertexAttribPointer(_attrib_uv, 2, GL_FLOAT, GL_FALSE, 0, Null)
		CatchError("EnableShaderData-glVertexAttribPointer-2")
		
	EndIf

	If _uniform_projection&gt;=0 Then
		glUniformMatrix4fv(_uniform_projection, 1, False, _projection_matrix.e)
		CatchError("EnableShaderData-glUniformMatrix4fv")
	EndIf
	
	If _uniform_color&gt;=0 Then
		glUniform4fv(_uniform_color, 4, rgba)
		CatchError("EnableShaderData-glUniform4fv")
	EndIf
	
	If _uniform_texture&gt;=0 And _texture&lt;&gt;0 Then
	
		glActiveTexture(GL_TEXTURE0)
		CatchError("EnableShaderData-glActiveTexture")
		glBindTexture(GL_TEXTURE_2D, _texture)
		CatchError("EnableShaderData-glBindTexture")
		glUniform1i(_uniform_texture, 0)
		CatchError("EnableShaderData-glUniform1i")
		
	EndIf
	
End Function
	
' disable all shader data
Function DisableShaderData()

	If _attrib_position&gt;=0 Then
		glDisableVertexAttribArray(_attrib_position)
		CatchError("DisableShaderData-glDisableVertexAttribArray-1")
	EndIf
	
	If _attrib_uv&gt;=0 Then
		glDisableVertexAttribArray(_attrib_uv)
		CatchError("DisableShaderData-glDisableVertexAttribArray-2")
	EndIf
	
End Function

' update buffer data to given arrays. create new buffers if needed.
Function UpdateVertexBuffer(pvertices:Float[])

	If _vertex_buffer=0 Then
		glGenBuffers(1, Varptr _vertex_buffer)
		CatchError("UpdateVertexBuffer-glGenBuffers")
	EndIf
	
	glBindBuffer(GL_ARRAY_BUFFER, _vertex_buffer)
	CatchError("UpdateVertexBuffer-glBindBuffer")
	glBufferData(GL_ARRAY_BUFFER, SizeOf(pvertices), pvertices, GL_STATIC_DRAW)
	CatchError("UpdateVertexBuffer-glBufferData")
	
	Return
	
End Function

Function UpdateUVBuffer(puvs:Float[])

	If _uv_buffer=0 Then
		glGenBuffers(1, Varptr _uv_buffer)
		CatchError("UpdateUVBUffer-glGenBuffers")
	EndIf
	
	glBindBuffer(GL_ARRAY_BUFFER, _uv_buffer)
	CatchError("UpdateUVBuffer-glBindBuffer")
	glBufferData(GL_ARRAY_BUFFER, SizeOf(puvs), puvs, GL_STATIC_DRAW)
	CatchError("UpdateUVBuffer-glBufferData")
	
	Return

End Function

' ///////////////////////////////////////////////////////////////////////////////////////////

' matrix4.bmx

Type TMatrix4

	Field e:Float[16]
	
	Method SetOrthographic(pl:Float, pr:Float, pt:Float, pb:Float, pn:Float, pf:Float)
	
		LoadIdentity()
		
		e[00] = 2.0/(pr-pl)
		e[05] = 2.0/(pt-pb)
		e[10] =-2.0/(pf-pn)
		e[15] = 1.0
		
		e[12]=-(pr+pl)/(pr-pl)
		e[13]=-(pt+pb)/(pt-pb)
		e[14]=-(pf+pn)/(pf-pn)
	
	End Method

	Method LoadIdentity()
		For Local i:Int=0 To e.length-1
			e[i]=0.0
			If (i Mod 4)=i/4 Then
				e[i]=1.0
			EndIf
		Next
	End Method
	
	Method Debug()
		
		Print "Matrix4:"
		
		For Local j:Int=0 To 3
			For Local i:Int=0 To 3
		
				WriteStdout e[j*4+i]
				If i&lt;3 Then
					WriteStdout ", "
				EndIf
			
			Next
			WriteStdout "~n"
		Next
		
	End Method

End Type

' ///////////////////////////////////////////////////////////////////////////////////////////

' utility.bmx

Function LoadFileAsString:String(ppath:String)

	ppath="C:/BlitzMax/mod/zzz.mod/glesmax2d.mod/"+ppath

	Local s:String=""
	Local stream:TStream=ReadFile(ppath)
	
	If stream=Null Then
		Notify "failed to open file '"+ppath+"'"
		Return ""
	EndIf
	
	Repeat
		s:+ReadLine(stream)+"~n"
	Until Eof(stream)
	
	CloseFile(stream)
	Return s

End Function

' ///////////////////////////////////////////////////////////////////////////////////////////

' shader.bmx

Function CompileVertexShader:Int(psource:String)
	Return CompileShader(psource, GL_VERTEX_SHADER)
End Function

Function CompileFragmentShader:Int(psource:String)
	Return CompileShader(psource, GL_FRAGMENT_SHADER)
End Function

Function CompileShader:Int(psource:String, ptype:Int)

	Print "compiling shader:~n"+psource+""

	Local id:Int=glCreateShader(ptype)
	CatchError("CompileShader-glCreateShader")
	
	Local cstring:Byte Ptr=psource.ToCString()
	
	glShaderSource(id, 1, Varptr cstring, Null)
	CatchError("CompileShader-glShaderSource")
	glCompileShader(id)
	CatchError("CompileShader-glCompileShader")
	
	Local success:Int=0
	glGetShaderiv(id, GL_COMPILE_STATUS, Varptr success)
	CatchError("CompileShader-glGetShaderiv")
	
	If Not success Then
		Print GetShaderErrorLog(id)
		Return 0
	EndIf
	
	Print "done!"
	Return id	

End Function

Function GetShaderErrorLog:String(pid:Int)

	Local logsize:Int=0
	glGetShaderiv(pid, GL_INFO_LOG_LENGTH, Varptr logsize)
	CatchError("GetShaderErrorLog-glGetShaderiv")
	
	Local msg:Byte[logsize]
	Local size:Int=0
	
	glGetShaderInfoLog(pid, logsize, Varptr size, Varptr msg[0])
	CatchError("GetShaderErrorLog-glGetShaderInfoLog")
	
	Local str:String=""
	
	For Local i:Int=0 To msg.length-1
		str:+Chr(msg[i])
	Next
	
	Return str

End Function

Function CreateShaderProgram:Int(pvertexshader:Int, pfragmentshader:Int)

	Local id:Int=glCreateProgram()
	CatchError("CreateShaderProgram-glCreateProgram")
	
	glAttachShader(id, pvertexshader)
	CatchError("CreateShaderProgram-glAttachShader")
	glAttachShader(id, pfragmentshader)
	CatchError("CreateShaderProgram-glAttachShader")
	
	glLinkProgram(id)
	CatchError("CreateShaderProgram-glLinkProgram")
	
	Return id

End Function

' ///////////////////////////////////////////////////////////////////////////////////////////

Function DeleteTexture(name:Int, seq:Int)
End Function

Function Pow2Size:Int(n:Int)
	Local t:Int=1
	While t&lt;n
		t:*2
	Wend
	Return t
End Function

Function AdjustTexSize( width:Int Var,height:Int Var )
	'calc texture size
	width=Pow2Size( width )
	height=Pow2Size( height )
	Repeat
		Local t:Int
		glTexImage2D GL_PROXY_TEXTURE_2D,0,4,width,height,0,GL_RGBA,GL_UNSIGNED_BYTE,Null
		glGetTexLevelParameteriv GL_PROXY_TEXTURE_2D,0,GL_TEXTURE_WIDTH,Varptr t
		If t Return
		If width=1 And height=1 RuntimeError "Unable to calculate tex size"
		If width&gt;1 width:/2
		If height&gt;1 height:/2
	Forever
End Function

' /////////////////////////////////////////////////////////////////////////////////////////////////

Public

Type TGLESImageFrame Extends TImageFrame

	Field u0:Float, v0:Float, u1:Float, v1:Float, uscale:Float, vscale:Float
	
	Field name:Int
	Field seq:Int
	
	Method New()
		'WriteStdout "new texture?~n"
		seq=GraphicsSeq
	End Method
	
	Method Delete()
		If Not seq Then
			Return
		EndIf
		DeleteTexture(name, seq)
		seq=0
	End Method
	
	Method Draw(x0:Float, y0:Float, x1:Float, y1:Float, tx:Float, ty:Float, sx:Float, sy:Float, sw:Float, sh:Float)
	
		If _shaderprogram&lt;&gt;_shaderprogram_texture Or _texture&lt;&gt;name Then
			
			_texture=name
			SetShaderProgram(_shaderprogram_texture)
			
		EndIf
		
		Local tu0:Float=sx*uscale
		Local tv0:Float=sy*vscale
		Local tu1:Float=(sx+sw)*uscale
		Local tv1:Float=(sy+sh)*vscale
		
		Local vertices:Float[]=[x0*ix+y0*iy+tx, x0*jx+y0*jy+ty, -1.0, x1*ix+y0*iy+tx, x1*jx+y0*jy+ty, -1.0, x1*ix+y1*iy+tx, x1*jx+y1*jy+ty, -1.0,  x1*ix+y1*iy+tx, x1*jx+y1*jy+ty, -1.0, x0*ix+y1*iy+tx, x0*jx+y1*jy+ty, -1.0, x0*ix+y0*iy+tx, x0*jx+y0*jy+ty, -1.0]
		Local uvs:Float[]=[tu0, tv0, tu1, tv0, tu1, tv1, tu1, tv1, tu0, tv1, tu0, tv0]
		
		UpdateVertexBuffer(vertices)
		UpdateUVBuffer(uvs)
		
		EnableShaderData()
		glDrawArrays(GL_TRIANGLES, 0, 6)
		CatchError("TGLESImageFrame.Draw-glDrawArrays")
		DisableShaderData()
	
		Return	
			
	End Method
	
	Function CreateFromPixmap:TGLESImageFrame(src:TPixmap, flags:Int)
	
		Print "Creating new texture from pixmap"
	
		Local tex_w:Int=src.width
		Local tex_h:Int=src.height
		AdjustTexSize tex_w, tex_h
		
		Local width:Int=Min(src.width, tex_w)
		Local height:Int=Min(src.height, tex_h)
		If src.width&lt;&gt;width Or src.height&lt;&gt;height Then src=ResizePixmap(src, width, height)
	
		Local texture:TPixmap=CopyPixmap(src)
		
		texture=ConvertPixmap(texture, PF_RGBA8888)
		texture=ResizePixmap(texture, width, height)
		
		Local id:Int
		
		glGenTextures(1, Varptr id)
		CatchError("TGLESImageFrame.CreateFromPixmap-glGenTextures")
		glBindTexture(GL_TEXTURE_2D, id)
		CatchError("TGLESImageFrame.CreateFromPixmap-glBindTexture")
		
		'WriteStdout "error: "+glGetError()+"~n"
		'WriteStdout "texture bound to "+id+"~n"
		
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
		CatchError("TGLESImageFrame.CreateFromPixmap-glTexParameteri-1")
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
		CatchError("TGLESImageFrame.CreateFromPixmap-glTexParameteri-2")
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)
		CatchError("TGLESImageFrame.CreateFromPixmap-glTexParameteri-3")
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)
		CatchError("TGLESImageFrame.CreateFromPixmap-glTexParameteri-4")
		
		'WriteStdout "error: "+glGetError()+"~n"
		
		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, texture.width, texture.height, 0, GL_RGBA, GL_UNSIGNED_BYTE, texture.pixels)
		CatchError("TGLESImageFrame.CreateFromPixmap-glTexImage2D")
		
		'SavePixmapPNG(texture, "debug.png")
		
		Local frame:TGLESImageFrame=New TGLESImageFrame
		
		Print "width: "+tex_w+" "+width
		Print "height: "+tex_h+" "+height
		
		frame.name=id
		frame.uscale=1.0/width
		frame.vscale=1.0/height
		frame.u0=0.0
		frame.v0=0.0
		frame.u1=src.width*frame.uscale
		frame.v1=src.height*frame.vscale
		
		Print "uscale: "+frame.uscale+", "+frame.vscale
		Print "u0: "+frame.u0+", "+frame.v0
		Print "u1: "+frame.u1+", "+frame.v1
		
		Return frame
		
	End Function

End Type

' gl es driver. copied from brl glmax2ddriver and then heavily modified. 

Type TGLTestMax2DDriver Extends TMax2DDriver

	Method Create:TGLTestMax2DDriver()
		If Not GLGraphicsDriver() Then
			Return Null
		EndIf
		Return Self
	End Method

	Method GraphicsModes:TGraphicsMode[]()
		Return GLGraphicsDriver().GraphicsModes()
	End Method
	
	Method AttachGraphics:TMax2DGraphics(widget:Int, flags:Int)
		Local g:TGLGraphics=GLGraphicsDriver().AttachGraphics(widget, flags)
		If g Then
			Return TMax2DGraphics.Create(g, Self)
		EndIf
	End Method
	
	Method CreateGraphics:TMax2DGraphics(width:Int, height:Int, depth:Int, hertz:Int, flags:Int)
		flags=GRAPHICS_BACKBUFFER|GRAPHICS_DEPTHBUFFER
		Local g:TGLGraphics=GLGraphicsDriver().CreateGraphics(width, height, depth, hertz, flags)
		If Not g Then
			Return Null
		EndIf
		Return TMax2DGraphics.Create(g, Self)
	End Method
	
	Method SetGraphics(g:TGraphics)
		If Not g Then
			TMax2DGraphics.ClearCurrent()
			GLGraphicsDriver().SetGraphics(Null)
			Return
		EndIf
		Local t:TMax2DGraphics=TMax2DGraphics(g)
		Assert t And TGLGraphics(t._graphics)
		GLGraphicsDriver().SetGraphics(t._graphics)
		ResetGLContext(t)
		t.MakeCurrent()
	End Method
	
	Method ResetGLContext(g:TGraphics)
	
		Local width:Int, height:Int, depth:Int, hertz:Int, flags:Int
		g.GetSettings(width, height, depth, hertz, flags)
	
		'set up ogl 
		
		glewInit()
		
		glEnable(GL_DEPTH_TEST)
		glDepthFunc(GL_LEQUAL)
		
		glEnable(GL_BLEND)
		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
		
		_projection_matrix=New TMatrix4
		_projection_matrix.SetOrthographic(0, width, 0, height, 0.1, 100.0)
		_projection_matrix.Debug()
		
		Local vertshader:Int
		Local fragshader:Int
		
		vertshader=CompileShader(GetDefaultVertexShader(), GL_VERTEX_SHADER)
		fragshader=CompileShader(GetDefaultFragmentShader(), GL_FRAGMENT_SHADER)
		
		_shaderprogram_plain=CreateShaderProgram(vertshader, fragshader)
		
		vertshader=CompileShader(GetTextureVertexShader(), GL_VERTEX_SHADER)
		fragshader=CompileShader(GetTextureFragmentShader(), GL_FRAGMENT_SHADER)
		
		_shaderprogram_texture=CreateShaderProgram(vertshader, fragshader)
		
		'done
	End Method
	
	Method Flip(sync:Int)
		GLGraphicsDriver().Flip(sync)
	End Method

	Method CreateFrameFromPixmap:TImageFrame(pixmap:TPixmap, flags:Int)
		Local frame:TGLESImageFrame
		frame=TGLESImageFrame.CreateFromPixmap(pixmap, flags)
		Return frame
	End Method
	
	Method SetBlend(blend:Int)
	
		If blend=state_blend Then
			Return
		EndIf
		state_blend=blend
		Select blend
		Case SOLIDBLEND
			glDisable(GL_BLEND)
		Case ALPHABLEND
			glEnable(GL_BLEND)
			glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
		Case LIGHTBLEND
			glEnable(GL_BLEND)
			glBlendFunc(GL_SRC_ALPHA, GL_ONE)
		Default
			glDisable(GL_BLEND)
		End Select
	
		Return
		
	End Method
	
	Method SetAlpha(alpha:Float)
		If alpha&lt;0.0 Then alpha=0.0
		If alpha&gt;1.0 Then alpha=1.0
		rgba[3]=alpha
	End Method

	Method SetColor(red:Int, green:Int, blue:Int)
		
		If red&lt;0 Then red=0
		If red&gt;255 Then red=255
		
		If green&lt;0 Then green=0
		If green&gt;255 Then green=255
		
		If blue&lt;0 Then blue=0
		If blue&gt;255 Then blue=255
		
		rgba[0]=Float(red)/255.0
		rgba[1]=Float(green)/255.0
		rgba[2]=Float(blue)/255.0
		
	End Method
	
	Method SetClsColor(red:Int, green:Int, blue:Int)
		
		If red&lt;0 Then red=0
		If red&gt;255 Then red=255
		
		If green&lt;0 Then green=0
		If green&gt;255 Then green=255
		
		If blue&lt;0 Then blue=0
		If blue&gt;255 Then blue=255
		
		glClearColor(Float(red)/255.0, Float(green)/255.0, Float(blue)/255.0, 1.0)
		CatchError("TGLTestMax2DDriver.SetClsColor-glClearColor")
		
	End Method
	
	Method SetViewport(x:Int, y:Int, width:Int, height:Int)
	End Method
	
	Method SetTransform(xx:Float, xy:Float, yx:Float, yy:Float)
		ix=xx
		iy=xy
		jx=yx
		jy=yy
	End Method
	
	Method SetLineWidth(width:Float)
	End Method
	
	Method Cls()
		glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)
		CatchError("TGLTestMax2DDriver.Cls-glClear")
	End Method
	
	Method Plot(x:Float, y:Float)
	
		If _shaderprogram&lt;&gt;_shaderprogram_plain Then SetShaderProgram(_shaderprogram_plain)

		Local vertices:Float[]=[x+0.5, y+0.5, -1.0]
		Local uvs:Float[]=[0.0, 0.0]

		UpdateVertexBuffer(vertices)
		UpdateUVBuffer(uvs)
		
		EnableShaderData()
		glDrawArrays(GL_POINTS, 0, 2)
		CatchError("TGLTestMax2DDriver.Plot-glDrawArrays")
		DisableShaderData()
	
		Return
		
	End Method
	
	Method DrawLine(x0:Float, y0:Float, x1:Float, y1:Float, tx:Float, ty:Float)
	
		If _shaderprogram&lt;&gt;_shaderprogram_plain Then SetShaderProgram(_shaderprogram_plain)

		Local vertices:Float[]=[x0*ix+y0*iy+tx+.5, x0*jx+y0*jy+ty+.5, -1.0, x1*ix+y1*iy+tx+.5, x1*jx+y1*jy+ty+.5, -1.0]
		Local uvs:Float[]=[0.0, 0.0, 1.0, 1.0]

		UpdateVertexBuffer(vertices)
		UpdateUVBuffer(uvs)
		
		EnableShaderData()
		glDrawArrays(GL_LINES, 0, 4)
		CatchError("TGLTestMax2DDriver.DrawLine-glDrawArrays")
		DisableShaderData()
	
		Return
		
	End Method
	
	Method DrawRect(x0:Float, y0:Float, x1:Float, y1:Float, tx:Float, ty:Float)
	
		If _shaderprogram&lt;&gt;_shaderprogram_plain Then SetShaderProgram(_shaderprogram_plain)

		Local vertices:Float[]=[x0*ix+y0*iy+tx, x0*jx+y0*jy+ty, -1.0, x1*ix+y0*iy+tx, x1*jx+y0*jy+ty, -1.0, x1*ix+y1*iy+tx, x1*jx+y1*jy+ty, -1.0, x1*ix+y1*iy+tx, x1*jx+y1*jy+ty, -1.0, x0*ix+y1*iy+tx, x0*jx+y1*jy+ty, -1.0, x0*ix+y0*iy+tx, x0*jx+y0*jy+ty, -1.0]
		Local uvs:Float[]=[0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0]

		UpdateVertexBuffer(vertices)
		UpdateUVBuffer(uvs)
		
		EnableShaderData()
		glDrawArrays(GL_TRIANGLES, 0, 6)
		CatchError("TGLTestMax2DDriver.DrawRect-glDrawArrays")
		DisableShaderData()
	
		Return
		
	End Method
	
	Method DrawOval(x0:Float, y0:Float, x1:Float, y1:Float, tx:Float, ty:Float)
		Return
	End Method
	
	Method DrawPoly(xy:Float[], handlex:Float, handley:Float, originx:Float, originy:Float)
		Return
	End Method
	
	Method DrawPixmap(pixmap:TPixmap, x:Int, y:Int)
		Return
	End Method
	
	Method GrabPixmap:TPixmap(x:Int, y:Int, width:Int, height:Int)
		Return Null
	End Method
	
	Method SetResolution(width:Float, height:Float)
		_projection_matrix.SetOrthographic(0.0, width, 0.0, height, -1.0, 1.0)
	End Method
	
End Type

Rem
bbdoc: Get OpenGL Max2D Driver
about:
The returned driver can be used with #SetGraphicsDriver to enable OpenGL Max2D 
rendering.
End Rem
Function GLTestMax2DDriver:TGLTestMax2DDriver()
	Global _done:Int
	If Not _done:Int
		_driver:TGLTestMax2DDriver=New TGLTestMax2DDriver.Create()
		_done=True
	EndIf
	Return _driver
End Function

Local driver:TGLTestMax2DDriver=GLTestMax2DDriver()
If driver Then
	SetGraphicsDriver(driver)
EndIf

Function GetDefaultVertexShader:String()

	Local str:String
	
	str:+"#version 120~n"
	str:+"attribute vec3 vertex_position;~n"
	str:+"uniform mat4 projection_matrix;~n"
	str:+"uniform vec4 color;~n"
	str:+"varying vec4 fragment_color;~n"
	str:+"void main(void)~n"
	str:+"{~n"
	str:+"	gl_Position=projection_matrix*vec4(vertex_position, 1.0);~n"
	str:+"	fragment_color=color;~n"
	str:+"}~n"
	
	Return str

End Function

Function GetDefaultFragmentShader:String()
	
	Local str:String
	
	str:+"#version 120~n"
	str:+"varying vec4 fragment_color;~n"
	str:+"void main(void)~n"
	str:+"{~n"
	str:+"	gl_FragColor=fragment_color;~n"
	str:+"}~n"
	
	Return str
	
End Function

Function GetTextureVertexShader:String()

	Local str:String
	
	str:+"#version 120~n"
	str:+"attribute vec3 vertex_position;~n"
	str:+"attribute vec2 vertex_uv;~n"
	str:+"uniform mat4 projection_matrix;~n"
	str:+"uniform vec4 color;~n"
	str:+"varying vec4 fragment_color;~n"
	str:+"varying vec2 uv;~n"
	str:+"void main(void)~n"
	str:+"{~n"
	str:+"	gl_Position=projection_matrix*vec4(vertex_position, 1.0);~n"
	str:+"	fragment_color=color;~n"
	str:+"	uv=vertex_uv;~n"
	str:+"}~n"
	
	Return str
	
End Function

Function GetTextureFragmentShader:String()

	Local str:String
	
	str:+"#version 120~n"
	str:+"varying vec4 fragment_color;~n"
	str:+"varying vec2 uv;~n"
	str:+"uniform sampler2D tex;~n"
	str:+"void main(void)~n"
	str:+"{~n"
	str:+"	gl_FragColor=fragment_color*texture2D(tex, uv);~n"
	str:+"}~n"
	
	Return str

End Function

Function CatchError(append:String)
	Local error:Int=glGetError()
	If error&lt;&gt;0 Then
		WriteStdout append+" : "+error
		Select error
		Case GL_INVALID_ENUM
			WriteStdout " GL_INVALID_ENUM "
		Case GL_INVALID_VALUE
			WriteStdout " GL_INVALID_VALUE "
		Case GL_INVALID_OPERATION
			WriteStdout " GL_INVALID_OPERATION "
		End Select
		WriteStdout "~n"
		End
	EndIf
End Function
</textarea> <br><br></td></tr></table><br>
<a name="1240547"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#40">[#40]</a></td></tr></table></td></tr><tr ><td class="posttext"> <textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
./bmk makeapp -t console -r -x "samples/gltestmax2d_2.bmx"
Compiling:gltestmax2d.bmx
flat assembler  version 1.68  (1048560 kilobytes memory)
4 passes, 27767 bytes.
Compiling:gltestmax2d_2.bmx
flat assembler  version 1.68  (1048560 kilobytes memory)
3 passes, 1152 bytes.
Linking:gltestmax2d_2
Executing:gltestmax2d_2
Matrix4:
0.00249999994, 0.00000000, 0.00000000, 0.00000000
0.00000000, -0.00333333341, 0.00000000, 0.00000000
0.00000000, 0.00000000, -0.0200200193, 0.00000000
-1.00000000, 1.00000000, -1.00200200, 1.00000000
compiling shader:
#version 120
attribute vec3 vertex_position;
uniform mat4 projection_matrix;
uniform vec4 color;
varying vec4 fragment_color;
void main(void)
{
	gl_Position=projection_matrix*vec4(vertex_position, 1.0);
	fragment_color=color;
}
done!
compiling shader:
#version 120
varying vec4 fragment_color;
void main(void)
{
	gl_FragColor=fragment_color;
}
done!
compiling shader:
#version 120
attribute vec3 vertex_position;
attribute vec2 vertex_uv;
uniform mat4 projection_matrix;
uniform vec4 color;
varying vec4 fragment_color;
varying vec2 uv;
void main(void)
{
	gl_Position=projection_matrix*vec4(vertex_position, 1.0);
	fragment_color=color;
	uv=vertex_uv;
}
done!
compiling shader:
#version 120
varying vec4 fragment_color;
varying vec2 uv;
uniform sampler2D tex;
void main(void)
{
	gl_FragColor=fragment_color*texture2D(tex, uv);
}
done!
EnableShaderData-glUniform4fv : 1282 GL_INVALID_OPERATION

</textarea><br><br><br>nothing gets displayed, window opens, keeps black, and window closes.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1240549"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#41">[#41]</a></td></tr></table></td></tr><tr ><td class="posttext"> That should be easy enough to fix, try this one:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' modified version of the official brl.glmax2d, to use opengl3/es2 compatible render methods.

SuperStrict

Rem
bbdoc: Graphics/OpenGL Max2D
about:
The OpenGL Max2D module provides an OpenGL driver for #Max2D.
End Rem
Module BRL.GLTestMax2D

Rem
ModuleInfo "Version: 1.13"
ModuleInfo "Author: Mark Sibly"
ModuleInfo "License: zlib/libpng"
ModuleInfo "Copyright: Blitz Research Ltd"
ModuleInfo "Modserver: BRL"

ModuleInfo "History: 1.13 Release"
ModuleInfo "History: Cleaned up SetGraphics"
ModuleInfo "History: 1.12 Release"
ModuleInfo "History: Fixed filtered image min filters"
ModuleInfo "History: 1.11 Release"
ModuleInfo "History: Fixed texture delete logic"
ModuleInfo "History: 1.10 Release"
ModuleInfo "History: Add SetColor/SetClsColor clamping"
ModuleInfo "History: 1.09 Release"
ModuleInfo "History: Fixed DrawPixmap using current blend mode - now always uses SOLIDBLEND"
ModuleInfo "History: 1.08 Release"
ModuleInfo "History: Added MIPMAPPEDIMAGE support"
ModuleInfo "History: 1.07 Release"
ModuleInfo "History: Now default driver for MacOS/Linux only (D3D7 for windows)"
ModuleInfo "History: 1.06 Release"
ModuleInfo "History: Ripped out a bunch of dead code"
ModuleInfo "History: 1.05 Release"
ModuleInfo "History: Added checks to prevent invalid textures deletes"
End Rem

Import PUB.OpenGL
Import PUB.Glew

Import BRL.Max2D
Import BRL.GLGraphics
Import BRL.StandardIO

Import BRL.PNGLoader

' /////////////////////////////////////////////////////////////////////////////////////////////////

Private

Global _driver:TGLTestMax2DDriver
Global _projection_matrix:TMatrix4

Global _shaderprogram:Int
Global _shaderprogram_plain:Int
Global _shaderprogram_texture:Int

Global _attrib_position:Int
Global _attrib_uv:Int

Global _uniform_projection:Int
Global _uniform_color:Int
Global _uniform_texture:Int

Global _vertex_buffer:Int
Global _uv_buffer:Int

Global _texture:Int

Global rgba:Float[]=[1.0, 1.0, 1.0, 1.0]
Global ix:Float, iy:Float, jx:Float, jy:Float
Global state_blend:Int

' ///////////////////////////////////////////////////////////////////////////////////////////

' renderer.bmx

' set shader program to use. automatically updates attribute and uniform pointers. 
' -1 means whatever was not present in shader code.
Function SetShaderProgram(pprogram:Int)

	_shaderprogram=pprogram
	
	glUseProgram(_shaderprogram)
	CatchError("SetShaderProgram-glUseProgram")
	
	_attrib_position=glGetAttribLocation(_shaderprogram, "vertex_position")
	CatchError("SetShaderProgram-glGetAttribLocation-1")
	
	_attrib_uv=glGetAttribLocation(_shaderprogram, "vertex_uv")
	CatchError("SetShaderProgram-glGetAttribLocation-2")
	
	_uniform_projection=glGetUniformLocation(_shaderprogram, "projection_matrix")
	CatchError("SetShaderProgram-glGetUniformLocation-1")
	
	_uniform_color=glGetUniformLocation(_shaderprogram, "color")
	CatchError("SetShaderProgram-glGetUniformLocation-2")
	
	_uniform_texture=glGetUniformLocation(_shaderprogram, "Texture")
	CatchError("SetShaderProgram-glGetUniformLocation-3")
	
End Function

Function SetPlainShaderProgram(pprogram:Int)
	_shaderprogram_plain=pprogram
End Function

Function SetTextureShaderProgram(pprogram:Int)
	_shaderprogram_texture=pprogram
End Function

' enable all shader data
Function EnableShaderData()

	If _attrib_position&gt;=0 Then
	
		glEnableVertexAttribArray(_attrib_position)
		CatchError("EnableShaderData-glEnableVertexAttribArray-1")
		glBindBuffer(GL_ARRAY_BUFFER, _vertex_buffer)
		CatchError("EnableShaderData-glBindBuffer-2")
		glVertexAttribPointer(_attrib_position, 3, GL_FLOAT, GL_FALSE, 0, Null)
		CatchError("EnableShaderData-glVertexAttribPointer")
		
	EndIf
	
	If _attrib_uv&gt;=0 Then
		
		glEnableVertexAttribArray(_attrib_uv)
		CatchError("EnableShaderData-glEnableVertexAttribArray-2")
		glBindBuffer(GL_ARRAY_BUFFER, _uv_buffer)
		CatchError("EnableShaderData-glBindBuffer-2")
		glVertexAttribPointer(_attrib_uv, 2, GL_FLOAT, GL_FALSE, 0, Null)
		CatchError("EnableShaderData-glVertexAttribPointer-2")
		
	EndIf

	If _uniform_projection&gt;=0 Then
		glUniformMatrix4fv(_uniform_projection, 1, False, _projection_matrix.e)
		CatchError("EnableShaderData-glUniformMatrix4fv")
	EndIf
	
	If _uniform_color&gt;=0 Then
		glUniform4fv(_uniform_color, 1, rgba)
		CatchError("EnableShaderData-glUniform4fv")
	EndIf
	
	If _uniform_texture&gt;=0 And _texture&lt;&gt;0 Then
	
		glActiveTexture(GL_TEXTURE0)
		CatchError("EnableShaderData-glActiveTexture")
		glBindTexture(GL_TEXTURE_2D, _texture)
		CatchError("EnableShaderData-glBindTexture")
		glUniform1i(_uniform_texture, 0)
		CatchError("EnableShaderData-glUniform1i")
		
	EndIf
	
End Function
	
' disable all shader data
Function DisableShaderData()

	If _attrib_position&gt;=0 Then
		glDisableVertexAttribArray(_attrib_position)
		CatchError("DisableShaderData-glDisableVertexAttribArray-1")
	EndIf
	
	If _attrib_uv&gt;=0 Then
		glDisableVertexAttribArray(_attrib_uv)
		CatchError("DisableShaderData-glDisableVertexAttribArray-2")
	EndIf
	
End Function

' update buffer data to given arrays. create new buffers if needed.
Function UpdateVertexBuffer(pvertices:Float[])

	If _vertex_buffer=0 Then
		glGenBuffers(1, Varptr _vertex_buffer)
		CatchError("UpdateVertexBuffer-glGenBuffers")
	EndIf
	
	glBindBuffer(GL_ARRAY_BUFFER, _vertex_buffer)
	CatchError("UpdateVertexBuffer-glBindBuffer")
	glBufferData(GL_ARRAY_BUFFER, SizeOf(pvertices), pvertices, GL_STATIC_DRAW)
	CatchError("UpdateVertexBuffer-glBufferData")
	
	Return
	
End Function

Function UpdateUVBuffer(puvs:Float[])

	If _uv_buffer=0 Then
		glGenBuffers(1, Varptr _uv_buffer)
		CatchError("UpdateUVBUffer-glGenBuffers")
	EndIf
	
	glBindBuffer(GL_ARRAY_BUFFER, _uv_buffer)
	CatchError("UpdateUVBuffer-glBindBuffer")
	glBufferData(GL_ARRAY_BUFFER, SizeOf(puvs), puvs, GL_STATIC_DRAW)
	CatchError("UpdateUVBuffer-glBufferData")
	
	Return

End Function

' ///////////////////////////////////////////////////////////////////////////////////////////

' matrix4.bmx

Type TMatrix4

	Field e:Float[16]
	
	Method SetOrthographic(pl:Float, pr:Float, pt:Float, pb:Float, pn:Float, pf:Float)
	
		LoadIdentity()
		
		e[00] = 2.0/(pr-pl)
		e[05] = 2.0/(pt-pb)
		e[10] =-2.0/(pf-pn)
		e[15] = 1.0
		
		e[12]=-(pr+pl)/(pr-pl)
		e[13]=-(pt+pb)/(pt-pb)
		e[14]=-(pf+pn)/(pf-pn)
	
	End Method

	Method LoadIdentity()
		For Local i:Int=0 To e.length-1
			e[i]=0.0
			If (i Mod 4)=i/4 Then
				e[i]=1.0
			EndIf
		Next
	End Method
	
	Method Debug()
		
		Print "Matrix4:"
		
		For Local j:Int=0 To 3
			For Local i:Int=0 To 3
		
				WriteStdout e[j*4+i]
				If i&lt;3 Then
					WriteStdout ", "
				EndIf
			
			Next
			WriteStdout "~n"
		Next
		
	End Method

End Type

' ///////////////////////////////////////////////////////////////////////////////////////////

' utility.bmx

Function LoadFileAsString:String(ppath:String)

	ppath="C:/BlitzMax/mod/zzz.mod/glesmax2d.mod/"+ppath

	Local s:String=""
	Local stream:TStream=ReadFile(ppath)
	
	If stream=Null Then
		Notify "failed to open file '"+ppath+"'"
		Return ""
	EndIf
	
	Repeat
		s:+ReadLine(stream)+"~n"
	Until Eof(stream)
	
	CloseFile(stream)
	Return s

End Function

' ///////////////////////////////////////////////////////////////////////////////////////////

' shader.bmx

Function CompileVertexShader:Int(psource:String)
	Return CompileShader(psource, GL_VERTEX_SHADER)
End Function

Function CompileFragmentShader:Int(psource:String)
	Return CompileShader(psource, GL_FRAGMENT_SHADER)
End Function

Function CompileShader:Int(psource:String, ptype:Int)

	Print "compiling shader:~n"+psource+""

	Local id:Int=glCreateShader(ptype)
	CatchError("CompileShader-glCreateShader")
	
	Local cstring:Byte Ptr=psource.ToCString()
	
	glShaderSource(id, 1, Varptr cstring, Null)
	CatchError("CompileShader-glShaderSource")
	glCompileShader(id)
	CatchError("CompileShader-glCompileShader")
	
	Local success:Int=0
	glGetShaderiv(id, GL_COMPILE_STATUS, Varptr success)
	CatchError("CompileShader-glGetShaderiv")
	
	If Not success Then
		Print GetShaderErrorLog(id)
		Return 0
	EndIf
	
	Print "done!"
	Return id	

End Function

Function GetShaderErrorLog:String(pid:Int)

	Local logsize:Int=0
	glGetShaderiv(pid, GL_INFO_LOG_LENGTH, Varptr logsize)
	CatchError("GetShaderErrorLog-glGetShaderiv")
	
	Local msg:Byte[logsize]
	Local size:Int=0
	
	glGetShaderInfoLog(pid, logsize, Varptr size, Varptr msg[0])
	CatchError("GetShaderErrorLog-glGetShaderInfoLog")
	
	Local str:String=""
	
	For Local i:Int=0 To msg.length-1
		str:+Chr(msg[i])
	Next
	
	Return str

End Function

Function CreateShaderProgram:Int(pvertexshader:Int, pfragmentshader:Int)

	Local id:Int=glCreateProgram()
	CatchError("CreateShaderProgram-glCreateProgram")
	
	glAttachShader(id, pvertexshader)
	CatchError("CreateShaderProgram-glAttachShader")
	glAttachShader(id, pfragmentshader)
	CatchError("CreateShaderProgram-glAttachShader")
	
	glLinkProgram(id)
	CatchError("CreateShaderProgram-glLinkProgram")
	
	Return id

End Function

' ///////////////////////////////////////////////////////////////////////////////////////////

Function DeleteTexture(name:Int, seq:Int)
End Function

Function Pow2Size:Int(n:Int)
	Local t:Int=1
	While t&lt;n
		t:*2
	Wend
	Return t
End Function

Function AdjustTexSize( width:Int Var,height:Int Var )
	'calc texture size
	width=Pow2Size( width )
	height=Pow2Size( height )
	Repeat
		Local t:Int
		glTexImage2D GL_PROXY_TEXTURE_2D,0,4,width,height,0,GL_RGBA,GL_UNSIGNED_BYTE,Null
		glGetTexLevelParameteriv GL_PROXY_TEXTURE_2D,0,GL_TEXTURE_WIDTH,Varptr t
		If t Return
		If width=1 And height=1 RuntimeError "Unable to calculate tex size"
		If width&gt;1 width:/2
		If height&gt;1 height:/2
	Forever
End Function

' /////////////////////////////////////////////////////////////////////////////////////////////////

Public

Type TGLESImageFrame Extends TImageFrame

	Field u0:Float, v0:Float, u1:Float, v1:Float, uscale:Float, vscale:Float
	
	Field name:Int
	Field seq:Int
	
	Method New()
		'WriteStdout "new texture?~n"
		seq=GraphicsSeq
	End Method
	
	Method Delete()
		If Not seq Then
			Return
		EndIf
		DeleteTexture(name, seq)
		seq=0
	End Method
	
	Method Draw(x0:Float, y0:Float, x1:Float, y1:Float, tx:Float, ty:Float, sx:Float, sy:Float, sw:Float, sh:Float)
	
		If _shaderprogram&lt;&gt;_shaderprogram_texture Or _texture&lt;&gt;name Then
			
			_texture=name
			SetShaderProgram(_shaderprogram_texture)
			
		EndIf
		
		Local tu0:Float=sx*uscale
		Local tv0:Float=sy*vscale
		Local tu1:Float=(sx+sw)*uscale
		Local tv1:Float=(sy+sh)*vscale
		
		Local vertices:Float[]=[x0*ix+y0*iy+tx, x0*jx+y0*jy+ty, -1.0, x1*ix+y0*iy+tx, x1*jx+y0*jy+ty, -1.0, x1*ix+y1*iy+tx, x1*jx+y1*jy+ty, -1.0,  x1*ix+y1*iy+tx, x1*jx+y1*jy+ty, -1.0, x0*ix+y1*iy+tx, x0*jx+y1*jy+ty, -1.0, x0*ix+y0*iy+tx, x0*jx+y0*jy+ty, -1.0]
		Local uvs:Float[]=[tu0, tv0, tu1, tv0, tu1, tv1, tu1, tv1, tu0, tv1, tu0, tv0]
		
		UpdateVertexBuffer(vertices)
		UpdateUVBuffer(uvs)
		
		EnableShaderData()
		glDrawArrays(GL_TRIANGLES, 0, 6)
		CatchError("TGLESImageFrame.Draw-glDrawArrays")
		DisableShaderData()
	
		Return	
			
	End Method
	
	Function CreateFromPixmap:TGLESImageFrame(src:TPixmap, flags:Int)
	
		Print "Creating new texture from pixmap"
	
		Local tex_w:Int=src.width
		Local tex_h:Int=src.height
		AdjustTexSize tex_w, tex_h
		
		Local width:Int=Min(src.width, tex_w)
		Local height:Int=Min(src.height, tex_h)
		If src.width&lt;&gt;width Or src.height&lt;&gt;height Then src=ResizePixmap(src, width, height)
	
		Local texture:TPixmap=CopyPixmap(src)
		
		texture=ConvertPixmap(texture, PF_RGBA8888)
		texture=ResizePixmap(texture, width, height)
		
		Local id:Int
		
		glGenTextures(1, Varptr id)
		CatchError("TGLESImageFrame.CreateFromPixmap-glGenTextures")
		glBindTexture(GL_TEXTURE_2D, id)
		CatchError("TGLESImageFrame.CreateFromPixmap-glBindTexture")
		
		'WriteStdout "error: "+glGetError()+"~n"
		'WriteStdout "texture bound to "+id+"~n"
		
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
		CatchError("TGLESImageFrame.CreateFromPixmap-glTexParameteri-1")
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
		CatchError("TGLESImageFrame.CreateFromPixmap-glTexParameteri-2")
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)
		CatchError("TGLESImageFrame.CreateFromPixmap-glTexParameteri-3")
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)
		CatchError("TGLESImageFrame.CreateFromPixmap-glTexParameteri-4")
		
		'WriteStdout "error: "+glGetError()+"~n"
		
		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, texture.width, texture.height, 0, GL_RGBA, GL_UNSIGNED_BYTE, texture.pixels)
		CatchError("TGLESImageFrame.CreateFromPixmap-glTexImage2D")
		
		'SavePixmapPNG(texture, "debug.png")
		
		Local frame:TGLESImageFrame=New TGLESImageFrame
		
		Print "width: "+tex_w+" "+width
		Print "height: "+tex_h+" "+height
		
		frame.name=id
		frame.uscale=1.0/width
		frame.vscale=1.0/height
		frame.u0=0.0
		frame.v0=0.0
		frame.u1=src.width*frame.uscale
		frame.v1=src.height*frame.vscale
		
		Print "uscale: "+frame.uscale+", "+frame.vscale
		Print "u0: "+frame.u0+", "+frame.v0
		Print "u1: "+frame.u1+", "+frame.v1
		
		Return frame
		
	End Function

End Type

' gl es driver. copied from brl glmax2ddriver and then heavily modified. 

Type TGLTestMax2DDriver Extends TMax2DDriver

	Method Create:TGLTestMax2DDriver()
		If Not GLGraphicsDriver() Then
			Return Null
		EndIf
		Return Self
	End Method

	Method GraphicsModes:TGraphicsMode[]()
		Return GLGraphicsDriver().GraphicsModes()
	End Method
	
	Method AttachGraphics:TMax2DGraphics(widget:Int, flags:Int)
		Local g:TGLGraphics=GLGraphicsDriver().AttachGraphics(widget, flags)
		If g Then
			Return TMax2DGraphics.Create(g, Self)
		EndIf
	End Method
	
	Method CreateGraphics:TMax2DGraphics(width:Int, height:Int, depth:Int, hertz:Int, flags:Int)
		flags=GRAPHICS_BACKBUFFER|GRAPHICS_DEPTHBUFFER
		Local g:TGLGraphics=GLGraphicsDriver().CreateGraphics(width, height, depth, hertz, flags)
		If Not g Then
			Return Null
		EndIf
		Return TMax2DGraphics.Create(g, Self)
	End Method
	
	Method SetGraphics(g:TGraphics)
		If Not g Then
			TMax2DGraphics.ClearCurrent()
			GLGraphicsDriver().SetGraphics(Null)
			Return
		EndIf
		Local t:TMax2DGraphics=TMax2DGraphics(g)
		Assert t And TGLGraphics(t._graphics)
		GLGraphicsDriver().SetGraphics(t._graphics)
		ResetGLContext(t)
		t.MakeCurrent()
	End Method
	
	Method ResetGLContext(g:TGraphics)
	
		Local width:Int, height:Int, depth:Int, hertz:Int, flags:Int
		g.GetSettings(width, height, depth, hertz, flags)
	
		'set up ogl 
		
		glewInit()
		
		glEnable(GL_DEPTH_TEST)
		glDepthFunc(GL_LEQUAL)
		
		glEnable(GL_BLEND)
		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
		
		_projection_matrix=New TMatrix4
		_projection_matrix.SetOrthographic(0, width, 0, height, 0.1, 100.0)
		_projection_matrix.Debug()
		
		Local vertshader:Int
		Local fragshader:Int
		
		vertshader=CompileShader(GetDefaultVertexShader(), GL_VERTEX_SHADER)
		fragshader=CompileShader(GetDefaultFragmentShader(), GL_FRAGMENT_SHADER)
		
		_shaderprogram_plain=CreateShaderProgram(vertshader, fragshader)
		
		vertshader=CompileShader(GetTextureVertexShader(), GL_VERTEX_SHADER)
		fragshader=CompileShader(GetTextureFragmentShader(), GL_FRAGMENT_SHADER)
		
		_shaderprogram_texture=CreateShaderProgram(vertshader, fragshader)
		
		'done
	End Method
	
	Method Flip(sync:Int)
		GLGraphicsDriver().Flip(sync)
	End Method

	Method CreateFrameFromPixmap:TImageFrame(pixmap:TPixmap, flags:Int)
		Local frame:TGLESImageFrame
		frame=TGLESImageFrame.CreateFromPixmap(pixmap, flags)
		Return frame
	End Method
	
	Method SetBlend(blend:Int)
	
		If blend=state_blend Then
			Return
		EndIf
		state_blend=blend
		Select blend
		Case SOLIDBLEND
			glDisable(GL_BLEND)
		Case ALPHABLEND
			glEnable(GL_BLEND)
			glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
		Case LIGHTBLEND
			glEnable(GL_BLEND)
			glBlendFunc(GL_SRC_ALPHA, GL_ONE)
		Default
			glDisable(GL_BLEND)
		End Select
	
		Return
		
	End Method
	
	Method SetAlpha(alpha:Float)
		If alpha&lt;0.0 Then alpha=0.0
		If alpha&gt;1.0 Then alpha=1.0
		rgba[3]=alpha
	End Method

	Method SetColor(red:Int, green:Int, blue:Int)
		
		If red&lt;0 Then red=0
		If red&gt;255 Then red=255
		
		If green&lt;0 Then green=0
		If green&gt;255 Then green=255
		
		If blue&lt;0 Then blue=0
		If blue&gt;255 Then blue=255
		
		rgba[0]=Float(red)/255.0
		rgba[1]=Float(green)/255.0
		rgba[2]=Float(blue)/255.0
		
	End Method
	
	Method SetClsColor(red:Int, green:Int, blue:Int)
		
		If red&lt;0 Then red=0
		If red&gt;255 Then red=255
		
		If green&lt;0 Then green=0
		If green&gt;255 Then green=255
		
		If blue&lt;0 Then blue=0
		If blue&gt;255 Then blue=255
		
		glClearColor(Float(red)/255.0, Float(green)/255.0, Float(blue)/255.0, 1.0)
		CatchError("TGLTestMax2DDriver.SetClsColor-glClearColor")
		
	End Method
	
	Method SetViewport(x:Int, y:Int, width:Int, height:Int)
	End Method
	
	Method SetTransform(xx:Float, xy:Float, yx:Float, yy:Float)
		ix=xx
		iy=xy
		jx=yx
		jy=yy
	End Method
	
	Method SetLineWidth(width:Float)
	End Method
	
	Method Cls()
		glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)
		CatchError("TGLTestMax2DDriver.Cls-glClear")
	End Method
	
	Method Plot(x:Float, y:Float)
	
		If _shaderprogram&lt;&gt;_shaderprogram_plain Then SetShaderProgram(_shaderprogram_plain)

		Local vertices:Float[]=[x+0.5, y+0.5, -1.0]
		Local uvs:Float[]=[0.0, 0.0]

		UpdateVertexBuffer(vertices)
		UpdateUVBuffer(uvs)
		
		EnableShaderData()
		glDrawArrays(GL_POINTS, 0, 2)
		CatchError("TGLTestMax2DDriver.Plot-glDrawArrays")
		DisableShaderData()
	
		Return
		
	End Method
	
	Method DrawLine(x0:Float, y0:Float, x1:Float, y1:Float, tx:Float, ty:Float)
	
		If _shaderprogram&lt;&gt;_shaderprogram_plain Then SetShaderProgram(_shaderprogram_plain)

		Local vertices:Float[]=[x0*ix+y0*iy+tx+.5, x0*jx+y0*jy+ty+.5, -1.0, x1*ix+y1*iy+tx+.5, x1*jx+y1*jy+ty+.5, -1.0]
		Local uvs:Float[]=[0.0, 0.0, 1.0, 1.0]

		UpdateVertexBuffer(vertices)
		UpdateUVBuffer(uvs)
		
		EnableShaderData()
		glDrawArrays(GL_LINES, 0, 4)
		CatchError("TGLTestMax2DDriver.DrawLine-glDrawArrays")
		DisableShaderData()
	
		Return
		
	End Method
	
	Method DrawRect(x0:Float, y0:Float, x1:Float, y1:Float, tx:Float, ty:Float)
	
		If _shaderprogram&lt;&gt;_shaderprogram_plain Then SetShaderProgram(_shaderprogram_plain)

		Local vertices:Float[]=[x0*ix+y0*iy+tx, x0*jx+y0*jy+ty, -1.0, x1*ix+y0*iy+tx, x1*jx+y0*jy+ty, -1.0, x1*ix+y1*iy+tx, x1*jx+y1*jy+ty, -1.0, x1*ix+y1*iy+tx, x1*jx+y1*jy+ty, -1.0, x0*ix+y1*iy+tx, x0*jx+y1*jy+ty, -1.0, x0*ix+y0*iy+tx, x0*jx+y0*jy+ty, -1.0]
		Local uvs:Float[]=[0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0]

		UpdateVertexBuffer(vertices)
		UpdateUVBuffer(uvs)
		
		EnableShaderData()
		glDrawArrays(GL_TRIANGLES, 0, 6)
		CatchError("TGLTestMax2DDriver.DrawRect-glDrawArrays")
		DisableShaderData()
	
		Return
		
	End Method
	
	Method DrawOval(x0:Float, y0:Float, x1:Float, y1:Float, tx:Float, ty:Float)
		Return
	End Method
	
	Method DrawPoly(xy:Float[], handlex:Float, handley:Float, originx:Float, originy:Float)
		Return
	End Method
	
	Method DrawPixmap(pixmap:TPixmap, x:Int, y:Int)
		Return
	End Method
	
	Method GrabPixmap:TPixmap(x:Int, y:Int, width:Int, height:Int)
		Return Null
	End Method
	
	Method SetResolution(width:Float, height:Float)
		_projection_matrix.SetOrthographic(0.0, width, 0.0, height, -1.0, 1.0)
	End Method
	
End Type

Rem
bbdoc: Get OpenGL Max2D Driver
about:
The returned driver can be used with #SetGraphicsDriver to enable OpenGL Max2D 
rendering.
End Rem
Function GLTestMax2DDriver:TGLTestMax2DDriver()
	Global _done:Int
	If Not _done:Int
		_driver:TGLTestMax2DDriver=New TGLTestMax2DDriver.Create()
		_done=True
	EndIf
	Return _driver
End Function

Local driver:TGLTestMax2DDriver=GLTestMax2DDriver()
If driver Then
	SetGraphicsDriver(driver)
EndIf

Function GetDefaultVertexShader:String()

	Local str:String
	
	str:+"#version 120~n"
	str:+"attribute vec3 vertex_position;~n"
	str:+"uniform mat4 projection_matrix;~n"
	str:+"uniform vec4 color;~n"
	str:+"varying vec4 fragment_color;~n"
	str:+"void main(void)~n"
	str:+"{~n"
	str:+"	gl_Position=projection_matrix*vec4(vertex_position, 1.0);~n"
	str:+"	fragment_color=color;~n"
	str:+"}~n"
	
	Return str

End Function

Function GetDefaultFragmentShader:String()
	
	Local str:String
	
	str:+"#version 120~n"
	str:+"varying vec4 fragment_color;~n"
	str:+"void main(void)~n"
	str:+"{~n"
	str:+"	gl_FragColor=fragment_color;~n"
	str:+"}~n"
	
	Return str
	
End Function

Function GetTextureVertexShader:String()

	Local str:String
	
	str:+"#version 120~n"
	str:+"attribute vec3 vertex_position;~n"
	str:+"attribute vec2 vertex_uv;~n"
	str:+"uniform mat4 projection_matrix;~n"
	str:+"uniform vec4 color;~n"
	str:+"varying vec4 fragment_color;~n"
	str:+"varying vec2 uv;~n"
	str:+"void main(void)~n"
	str:+"{~n"
	str:+"	gl_Position=projection_matrix*vec4(vertex_position, 1.0);~n"
	str:+"	fragment_color=color;~n"
	str:+"	uv=vertex_uv;~n"
	str:+"}~n"
	
	Return str
	
End Function

Function GetTextureFragmentShader:String()

	Local str:String
	
	str:+"#version 120~n"
	str:+"varying vec4 fragment_color;~n"
	str:+"varying vec2 uv;~n"
	str:+"uniform sampler2D tex;~n"
	str:+"void main(void)~n"
	str:+"{~n"
	str:+"	gl_FragColor=fragment_color*texture2D(tex, uv);~n"
	str:+"}~n"
	
	Return str

End Function

Function CatchError(append:String)
	Local error:Int=glGetError()
	If error&lt;&gt;0 Then
		WriteStdout append+" : "+error
		Select error
		Case GL_INVALID_ENUM
			WriteStdout " GL_INVALID_ENUM "
		Case GL_INVALID_VALUE
			WriteStdout " GL_INVALID_VALUE "
		Case GL_INVALID_OPERATION
			WriteStdout " GL_INVALID_OPERATION "
		End Select
		WriteStdout "~n"
		End
	EndIf
End Function
</textarea> <br><br></td></tr></table><br>
<a name="1240550"></a>

<a name="1240551"></a>

<a name="1240553"></a>

<a name="1240554"></a>

<a name="1240555"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#42">[#42]</a></td></tr></table></td></tr><tr ><td class="posttext"> rem<br>removed ... board system does not allow fast editing of the same posting ... it just adds another post.<br>end rem <br><br></td></tr></table><br>
<a name="1240556"></a>

<a name="1240557"></a>

<a name="1240558"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#43">[#43]</a></td></tr></table></td></tr><tr ><td class="posttext"> works.<br><br>Edit: is there some kind of frame limiter? does not matter if flip -1,0 or 1 ... it gets max75 (when using "flip 0", flip -1 is at screen refreshrate, flip 1 even cuts down to 35fps).<br><br>Edit2: as you requested "setClsColor" works too.<br>Edit3: Images work too  - but displaying one image cuts FPS from 75 to 65 ... maybe you recompile things every run (or upload things to gpu ... I do know nothing about that subject).<br><br>PS: I of course removed the "prints" when measuring.<br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1240560"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#44">[#44]</a></td></tr></table></td></tr><tr ><td class="posttext"> Its basically a quick hack I did to see if Id be able to get a ogl3 module up and running at all. Dont expect any kind of performance from it whatsoever :) Posted it here since Brucey were struggling with textures. <br><br></td></tr></table><br>
<a name="1240562"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#45">[#45]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Posted it here since Brucey were struggling with textures.  <br></div><br>Thanks :-) <br><br></td></tr></table><br>
<a name="1240563"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#46">[#46]</a></td></tr></table></td></tr><tr ><td class="posttext"> Might be worth pointing out that the batch example I started this thread with was meant for testing purposes only. The example "scene" is very naive, and its not really working great for more realistic workloads. <br><br>For the module I aimed (still am) to get all the functionality in, and disregard performance until I had everything working. <br><br>Considering performance, its really hard to come up with a system that work for *everything*. A reasonable approach would probably be to rewrite the standard glmax2d module to collect data on pretty much everything it does, and ask people here to run their projects with it and post the results. <br><br></td></tr></table><br>
<a name="1240565"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#47">[#47]</a></td></tr></table></td></tr><tr ><td class="posttext"> Do not "disregard performance" at all ... you might not "optimize" during tinkering with something, but you should keep performance in mind when designing working routines (how batching is done, how "auto batching" could work etc.)<br><br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1240566"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#48">[#48]</a></td></tr></table></td></tr><tr ><td class="posttext"> The problem is that i knew nothing about how opengl3 works, which makes it hard to write efficient code, considering I didnt even know what the code would have to do. As soon as we have a module that does everything that the standard max2d modules do, Ill try and redesign it for performance. <br><br></td></tr></table><br>
<a name="1244904"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zzz</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#49">[#49]</a></td></tr></table></td></tr><tr ><td class="posttext"> Got a small break from school stuff, so tinkered on a bit with the module.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' modified version of the official brl.glmax2d, to use opengl3/es2 compatible render methods.

SuperStrict

Rem
bbdoc: Graphics/OpenGL Max2D
about:
The OpenGL Max2D module provides an OpenGL driver for #Max2D.
End Rem
Module BRL.GLTestMax2D

Rem
ModuleInfo "Version: 1.13"
ModuleInfo "Author: Mark Sibly"
ModuleInfo "License: zlib/libpng"
ModuleInfo "Copyright: Blitz Research Ltd"
ModuleInfo "Modserver: BRL"

ModuleInfo "History: 1.13 Release"
ModuleInfo "History: Cleaned up SetGraphics"
ModuleInfo "History: 1.12 Release"
ModuleInfo "History: Fixed filtered image min filters"
ModuleInfo "History: 1.11 Release"
ModuleInfo "History: Fixed texture delete logic"
ModuleInfo "History: 1.10 Release"
ModuleInfo "History: Add SetColor/SetClsColor clamping"
ModuleInfo "History: 1.09 Release"
ModuleInfo "History: Fixed DrawPixmap using current blend mode - now always uses SOLIDBLEND"
ModuleInfo "History: 1.08 Release"
ModuleInfo "History: Added MIPMAPPEDIMAGE support"
ModuleInfo "History: 1.07 Release"
ModuleInfo "History: Now default driver for MacOS/Linux only (D3D7 for windows)"
ModuleInfo "History: 1.06 Release"
ModuleInfo "History: Ripped out a bunch of dead code"
ModuleInfo "History: 1.05 Release"
ModuleInfo "History: Added checks to prevent invalid textures deletes"
End Rem

Import PUB.OpenGL
Import PUB.Glew

Import BRL.Max2D
Import BRL.GLGraphics
Import BRL.StandardIO

Import BRL.PNGLoader

' /////////////////////////////////////////////////////////////////////////////////////////////////

Private

Global _driver:TGLTestMax2DDriver
Global _projection_matrix:TMatrix4

Global _shaderprogram:Int
Global _shaderprogram_plain:Int
Global _shaderprogram_texture:Int

Global _attrib_position:Int
Global _attrib_uv:Int

Global _uniform_projection:Int
Global _uniform_color:Int
Global _uniform_texture:Int

Global _vertex_buffer:Int
Global _uv_buffer:Int

Global _texture:Int

Global rgba:Float[]=[1.0, 1.0, 1.0, 1.0]
Global ix:Float, iy:Float, jx:Float, jy:Float
Global state_blend:Int

' ///////////////////////////////////////////////////////////////////////////////////////////

' renderer.bmx

' set shader program to use. automatically updates attribute and uniform pointers. 
' -1 means whatever was not present in shader code.
Function SetShaderProgram(pprogram:Int)

	_shaderprogram=pprogram
	
	glUseProgram(_shaderprogram)
	CatchError("SetShaderProgram-glUseProgram")
	
	_attrib_position=glGetAttribLocation(_shaderprogram, "vertex_position")
	CatchError("SetShaderProgram-glGetAttribLocation-1")
	
	_attrib_uv=glGetAttribLocation(_shaderprogram, "vertex_uv")
	CatchError("SetShaderProgram-glGetAttribLocation-2")
	
	_uniform_projection=glGetUniformLocation(_shaderprogram, "projection_matrix")
	CatchError("SetShaderProgram-glGetUniformLocation-1")
	
	_uniform_color=glGetUniformLocation(_shaderprogram, "color")
	CatchError("SetShaderProgram-glGetUniformLocation-2")
	
	_uniform_texture=glGetUniformLocation(_shaderprogram, "Texture")
	CatchError("SetShaderProgram-glGetUniformLocation-3")
	
End Function

Function SetPlainShaderProgram(pprogram:Int)
	_shaderprogram_plain=pprogram
End Function

Function SetTextureShaderProgram(pprogram:Int)
	_shaderprogram_texture=pprogram
End Function

' enable all shader data
Function EnableShaderData()

	If _attrib_position&gt;=0 Then
	
		glEnableVertexAttribArray(_attrib_position)
		CatchError("EnableShaderData-glEnableVertexAttribArray-1")
		glBindBuffer(GL_ARRAY_BUFFER, _vertex_buffer)
		CatchError("EnableShaderData-glBindBuffer-2")
		glVertexAttribPointer(_attrib_position, 3, GL_FLOAT, GL_FALSE, 0, Null)
		CatchError("EnableShaderData-glVertexAttribPointer")
		
	EndIf
	
	If _attrib_uv&gt;=0 Then
		
		glEnableVertexAttribArray(_attrib_uv)
		CatchError("EnableShaderData-glEnableVertexAttribArray-2")
		glBindBuffer(GL_ARRAY_BUFFER, _uv_buffer)
		CatchError("EnableShaderData-glBindBuffer-2")
		glVertexAttribPointer(_attrib_uv, 2, GL_FLOAT, GL_FALSE, 0, Null)
		CatchError("EnableShaderData-glVertexAttribPointer-2")
		
	EndIf

	If _uniform_projection&gt;=0 Then
		glUniformMatrix4fv(_uniform_projection, 1, False, _projection_matrix.e)
		CatchError("EnableShaderData-glUniformMatrix4fv")
	EndIf
	
	If _uniform_color&gt;=0 Then
		glUniform4fv(_uniform_color, 1, rgba)
		CatchError("EnableShaderData-glUniform4fv")
	EndIf
	
	If _uniform_texture&gt;=0 And _texture&lt;&gt;0 Then
	
		glActiveTexture(GL_TEXTURE0)
		CatchError("EnableShaderData-glActiveTexture")
		glBindTexture(GL_TEXTURE_2D, _texture)
		CatchError("EnableShaderData-glBindTexture")
		glUniform1i(_uniform_texture, 0)
		CatchError("EnableShaderData-glUniform1i")
		
	EndIf
	
End Function
	
' disable all shader data
Function DisableShaderData()

	If _attrib_position&gt;=0 Then
		glDisableVertexAttribArray(_attrib_position)
		CatchError("DisableShaderData-glDisableVertexAttribArray-1")
	EndIf
	
	If _attrib_uv&gt;=0 Then
		glDisableVertexAttribArray(_attrib_uv)
		CatchError("DisableShaderData-glDisableVertexAttribArray-2")
	EndIf
	
End Function

' update buffer data to given arrays. create new buffers if needed.
Function UpdateVertexBuffer(pvertices:Float[])

	If _vertex_buffer=0 Then
		glGenBuffers(1, Varptr _vertex_buffer)
		CatchError("UpdateVertexBuffer-glGenBuffers")
	EndIf
	
	glBindBuffer(GL_ARRAY_BUFFER, _vertex_buffer)
	CatchError("UpdateVertexBuffer-glBindBuffer")
	glBufferData(GL_ARRAY_BUFFER, SizeOf(pvertices), pvertices, GL_STATIC_DRAW)
	CatchError("UpdateVertexBuffer-glBufferData")
	
	Return
	
End Function

Function UpdateUVBuffer(puvs:Float[])

	If _uv_buffer=0 Then
		glGenBuffers(1, Varptr _uv_buffer)
		CatchError("UpdateUVBUffer-glGenBuffers")
	EndIf
	
	glBindBuffer(GL_ARRAY_BUFFER, _uv_buffer)
	CatchError("UpdateUVBuffer-glBindBuffer")
	glBufferData(GL_ARRAY_BUFFER, SizeOf(puvs), puvs, GL_STATIC_DRAW)
	CatchError("UpdateUVBuffer-glBufferData")
	
	Return

End Function

' ///////////////////////////////////////////////////////////////////////////////////////////

' matrix4.bmx

Type TMatrix4

	Field e:Float[16]
	
	Method SetOrthographic(pl:Float, pr:Float, pt:Float, pb:Float, pn:Float, pf:Float)
	
		LoadIdentity()
		
		e[00] = 2.0/(pr-pl)
		e[05] = 2.0/(pt-pb)
		e[10] =-2.0/(pf-pn)
		e[15] = 1.0
		
		e[12]=-(pr+pl)/(pr-pl)
		e[13]=-(pt+pb)/(pt-pb)
		e[14]=-(pf+pn)/(pf-pn)
	
	End Method

	Method LoadIdentity()
		For Local i:Int=0 To e.length-1
			e[i]=0.0
			If (i Mod 4)=i/4 Then
				e[i]=1.0
			EndIf
		Next
	End Method
	
	Method Debug()
		
		Print "Matrix4:"
		
		For Local j:Int=0 To 3
			For Local i:Int=0 To 3
		
				WriteStdout e[j*4+i]
				If i&lt;3 Then
					WriteStdout ", "
				EndIf
			
			Next
			WriteStdout "~n"
		Next
		
	End Method

End Type

' ///////////////////////////////////////////////////////////////////////////////////////////

' utility.bmx

Function LoadFileAsString:String(ppath:String)

	ppath="C:/BlitzMax/mod/zzz.mod/glesmax2d.mod/"+ppath

	Local s:String=""
	Local stream:TStream=ReadFile(ppath)
	
	If stream=Null Then
		Notify "failed to open file '"+ppath+"'"
		Return ""
	EndIf
	
	Repeat
		s:+ReadLine(stream)+"~n"
	Until Eof(stream)
	
	CloseFile(stream)
	Return s

End Function

' ///////////////////////////////////////////////////////////////////////////////////////////

' shader.bmx

Function CompileVertexShader:Int(psource:String)
	Return CompileShader(psource, GL_VERTEX_SHADER)
End Function

Function CompileFragmentShader:Int(psource:String)
	Return CompileShader(psource, GL_FRAGMENT_SHADER)
End Function

Function CompileShader:Int(psource:String, ptype:Int)

	Print "compiling shader:~n"+psource+""

	Local id:Int=glCreateShader(ptype)
	CatchError("CompileShader-glCreateShader")
	
	Local cstring:Byte Ptr=psource.ToCString()
	
	glShaderSource(id, 1, Varptr cstring, Null)
	CatchError("CompileShader-glShaderSource")
	glCompileShader(id)
	CatchError("CompileShader-glCompileShader")
	
	Local success:Int=0
	glGetShaderiv(id, GL_COMPILE_STATUS, Varptr success)
	CatchError("CompileShader-glGetShaderiv")
	
	If Not success Then
		Print GetShaderErrorLog(id)
		Return 0
	EndIf
	
	Print "done!"
	Return id	

End Function

Function GetShaderErrorLog:String(pid:Int)

	Local logsize:Int=0
	glGetShaderiv(pid, GL_INFO_LOG_LENGTH, Varptr logsize)
	CatchError("GetShaderErrorLog-glGetShaderiv")
	
	Local msg:Byte[logsize]
	Local size:Int=0
	
	glGetShaderInfoLog(pid, logsize, Varptr size, Varptr msg[0])
	CatchError("GetShaderErrorLog-glGetShaderInfoLog")
	
	Local str:String=""
	
	For Local i:Int=0 To msg.length-1
		str:+Chr(msg[i])
	Next
	
	Return str

End Function

Function CreateShaderProgram:Int(pvertexshader:Int, pfragmentshader:Int)

	Local id:Int=glCreateProgram()
	CatchError("CreateShaderProgram-glCreateProgram")
	
	glAttachShader(id, pvertexshader)
	CatchError("CreateShaderProgram-glAttachShader")
	glAttachShader(id, pfragmentshader)
	CatchError("CreateShaderProgram-glAttachShader")
	
	glLinkProgram(id)
	CatchError("CreateShaderProgram-glLinkProgram")
	
	Return id

End Function

' ///////////////////////////////////////////////////////////////////////////////////////////

Function DeleteTexture(name:Int, seq:Int)
End Function

Function Pow2Size:Int(n:Int)
	Local t:Int=1
	While t&lt;n
		t:*2
	Wend
	Return t
End Function

Function AdjustTexSize( width:Int Var,height:Int Var )
	'calc texture size
	width=Pow2Size( width )
	height=Pow2Size( height )
	Repeat
		Local t:Int
		glTexImage2D GL_PROXY_TEXTURE_2D,0,4,width,height,0,GL_RGBA,GL_UNSIGNED_BYTE,Null
		glGetTexLevelParameteriv GL_PROXY_TEXTURE_2D,0,GL_TEXTURE_WIDTH,Varptr t
		If t Return
		If width=1 And height=1 RuntimeError "Unable to calculate tex size"
		If width&gt;1 width:/2
		If height&gt;1 height:/2
	Forever
End Function

' /////////////////////////////////////////////////////////////////////////////////////////////////

Public

Type TGLESImageFrame Extends TImageFrame

	Field u0:Float, v0:Float, u1:Float, v1:Float, uscale:Float, vscale:Float
	
	Field name:Int
	Field seq:Int
	
	Method New()
		'WriteStdout "new texture?~n"
		seq=GraphicsSeq
	End Method
	
	Method Delete()
		If Not seq Then
			Return
		EndIf
		DeleteTexture(name, seq)
		seq=0
	End Method
	
	Method Draw(x0:Float, y0:Float, x1:Float, y1:Float, tx:Float, ty:Float, sx:Float, sy:Float, sw:Float, sh:Float)
	
		If _shaderprogram&lt;&gt;_shaderprogram_texture Or _texture&lt;&gt;name Then
			
			_texture=name
			SetShaderProgram(_shaderprogram_texture)
			
		EndIf
		
		' enable and bind current texture
		
		glEnable(GL_TEXTURE_2D)
		glActiveTexture(GL_TEXTURE0)
		glBindTexture GL_TEXTURE_2D, name
		
		Local tu0:Float=sx*uscale
		Local tv0:Float=sy*vscale
		Local tu1:Float=(sx+sw)*uscale
		Local tv1:Float=(sy+sh)*vscale
		
		Local vertices:Float[]=[x0*ix+y0*iy+tx, x0*jx+y0*jy+ty, -1.0, x1*ix+y0*iy+tx, x1*jx+y0*jy+ty, -1.0, x1*ix+y1*iy+tx, x1*jx+y1*jy+ty, -1.0,  x1*ix+y1*iy+tx, x1*jx+y1*jy+ty, -1.0, x0*ix+y1*iy+tx, x0*jx+y1*jy+ty, -1.0, x0*ix+y0*iy+tx, x0*jx+y0*jy+ty, -1.0]
		Local uvs:Float[]=[tu0, tv0, tu1, tv0, tu1, tv1, tu1, tv1, tu0, tv1, tu0, tv0]
		
		UpdateVertexBuffer(vertices)
		UpdateUVBuffer(uvs)
		
		EnableShaderData()
		glDrawArrays(GL_TRIANGLES, 0, 6)
		CatchError("TGLESImageFrame.Draw-glDrawArrays")
		DisableShaderData()
	
		Return	
			
	End Method
	
	Function CreateFromPixmap:TGLESImageFrame(src:TPixmap, flags:Int)
	
		Print "Creating new texture from pixmap"
	
		Local tex_w:Int=src.width
		Local tex_h:Int=src.height
		AdjustTexSize tex_w, tex_h
		
		Local width:Int=Min(src.width, tex_w)
		Local height:Int=Min(src.height, tex_h)
		If src.width&lt;&gt;width Or src.height&lt;&gt;height Then src=ResizePixmap(src, width, height)
	
		Local texture:TPixmap=CopyPixmap(src)
		
		texture=ConvertPixmap(texture, PF_RGBA8888)
		texture=ResizePixmap(texture, width, height)
		
		Local id:Int
		
		glGenTextures(1, Varptr id)
		CatchError("TGLESImageFrame.CreateFromPixmap-glGenTextures")
		glBindTexture(GL_TEXTURE_2D, id)
		CatchError("TGLESImageFrame.CreateFromPixmap-glBindTexture")
		
		'WriteStdout "error: "+glGetError()+"~n"
		'WriteStdout "texture bound to "+id+"~n"
		
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
		CatchError("TGLESImageFrame.CreateFromPixmap-glTexParameteri-1")
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
		CatchError("TGLESImageFrame.CreateFromPixmap-glTexParameteri-2")
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)
		CatchError("TGLESImageFrame.CreateFromPixmap-glTexParameteri-3")
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)
		CatchError("TGLESImageFrame.CreateFromPixmap-glTexParameteri-4")
		
		'WriteStdout "error: "+glGetError()+"~n"
		
		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, texture.width, texture.height, 0, GL_RGBA, GL_UNSIGNED_BYTE, texture.pixels)
		CatchError("TGLESImageFrame.CreateFromPixmap-glTexImage2D")
		
		'SavePixmapPNG(texture, "debug.png")
		
		Local frame:TGLESImageFrame=New TGLESImageFrame
		
		Print "width: "+tex_w+" "+width
		Print "height: "+tex_h+" "+height
		
		frame.name=id
		frame.uscale=1.0/width
		frame.vscale=1.0/height
		frame.u0=0.0
		frame.v0=0.0
		frame.u1=src.width*frame.uscale
		frame.v1=src.height*frame.vscale
		
		Print "uscale: "+frame.uscale+", "+frame.vscale
		Print "u0: "+frame.u0+", "+frame.v0
		Print "u1: "+frame.u1+", "+frame.v1
		
		Return frame
		
	End Function

End Type

' gl es driver. copied from brl glmax2ddriver and then heavily modified. 

Type TGLTestMax2DDriver Extends TMax2DDriver

	Method Create:TGLTestMax2DDriver()
		If Not GLGraphicsDriver() Then
			Return Null
		EndIf
		Return Self
	End Method

	Method GraphicsModes:TGraphicsMode[]()
		Return GLGraphicsDriver().GraphicsModes()
	End Method
	
	Method AttachGraphics:TMax2DGraphics(widget:Int, flags:Int)
		Local g:TGLGraphics=GLGraphicsDriver().AttachGraphics(widget, flags)
		If g Then
			Return TMax2DGraphics.Create(g, Self)
		EndIf
	End Method
	
	Method CreateGraphics:TMax2DGraphics(width:Int, height:Int, depth:Int, hertz:Int, flags:Int)
		flags=GRAPHICS_BACKBUFFER|GRAPHICS_DEPTHBUFFER
		Local g:TGLGraphics=GLGraphicsDriver().CreateGraphics(width, height, depth, hertz, flags)
		If Not g Then
			Return Null
		EndIf
		Return TMax2DGraphics.Create(g, Self)
	End Method
	
	Method SetGraphics(g:TGraphics)
		If Not g Then
			TMax2DGraphics.ClearCurrent()
			GLGraphicsDriver().SetGraphics(Null)
			Return
		EndIf
		Local t:TMax2DGraphics=TMax2DGraphics(g)
		Assert t And TGLGraphics(t._graphics)
		GLGraphicsDriver().SetGraphics(t._graphics)
		ResetGLContext(t)
		t.MakeCurrent()
	End Method
	
	Method ResetGLContext(g:TGraphics)
	
		Local width:Int, height:Int, depth:Int, hertz:Int, flags:Int
		g.GetSettings(width, height, depth, hertz, flags)
	
		'set up ogl 
		
		glewInit()
		
		glEnable(GL_DEPTH_TEST)
		glDepthFunc(GL_LEQUAL)
		
		glEnable(GL_BLEND)
		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
		
		_projection_matrix=New TMatrix4
		_projection_matrix.SetOrthographic(0, width, 0, height, 0.1, 100.0)
		_projection_matrix.Debug()
		
		Local vertshader:Int
		Local fragshader:Int
		
		vertshader=CompileShader(GetDefaultVertexShader(), GL_VERTEX_SHADER)
		fragshader=CompileShader(GetDefaultFragmentShader(), GL_FRAGMENT_SHADER)
		
		_shaderprogram_plain=CreateShaderProgram(vertshader, fragshader)
		
		vertshader=CompileShader(GetTextureVertexShader(), GL_VERTEX_SHADER)
		fragshader=CompileShader(GetTextureFragmentShader(), GL_FRAGMENT_SHADER)
		
		_shaderprogram_texture=CreateShaderProgram(vertshader, fragshader)
		
		'done
	End Method
	
	Method Flip(sync:Int)
		GLGraphicsDriver().Flip(sync)
	End Method

	Method CreateFrameFromPixmap:TImageFrame(pixmap:TPixmap, flags:Int)
		Local frame:TGLESImageFrame
		frame=TGLESImageFrame.CreateFromPixmap(pixmap, flags)
		Return frame
	End Method
	
	Method SetBlend(blend:Int)
	
		If blend=state_blend Then
			Return
		EndIf
		state_blend=blend
		Select blend
		Case SOLIDBLEND
			glDisable(GL_BLEND)
		Case ALPHABLEND
			glEnable(GL_BLEND)
			glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
		Case LIGHTBLEND
			glEnable(GL_BLEND)
			glBlendFunc(GL_SRC_ALPHA, GL_ONE)
		Default
			glDisable(GL_BLEND)
		End Select
	
		Return
		
	End Method
	
	Method SetAlpha(alpha:Float)
		If alpha&lt;0.0 Then alpha=0.0
		If alpha&gt;1.0 Then alpha=1.0
		rgba[3]=alpha
	End Method

	Method SetColor(red:Int, green:Int, blue:Int)
		
		If red&lt;0 Then red=0
		If red&gt;255 Then red=255
		
		If green&lt;0 Then green=0
		If green&gt;255 Then green=255
		
		If blue&lt;0 Then blue=0
		If blue&gt;255 Then blue=255
		
		rgba[0]=Float(red)/255.0
		rgba[1]=Float(green)/255.0
		rgba[2]=Float(blue)/255.0
		
	End Method
	
	Method SetClsColor(red:Int, green:Int, blue:Int)
		
		If red&lt;0 Then red=0
		If red&gt;255 Then red=255
		
		If green&lt;0 Then green=0
		If green&gt;255 Then green=255
		
		If blue&lt;0 Then blue=0
		If blue&gt;255 Then blue=255
		
		glClearColor(Float(red)/255.0, Float(green)/255.0, Float(blue)/255.0, 1.0)
		CatchError("TGLTestMax2DDriver.SetClsColor-glClearColor")
		
	End Method
	
	Method SetViewport(x:Int, y:Int, width:Int, height:Int)
	End Method
	
	Method SetTransform(xx:Float, xy:Float, yx:Float, yy:Float)
		ix=xx
		iy=xy
		jx=yx
		jy=yy
	End Method
	
	Method SetLineWidth(width:Float)
		
		' not supported at all afaik
		Return
		
	End Method
	
	Method Cls()
		glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)
		CatchError("TGLTestMax2DDriver.Cls-glClear")
	End Method
	
	Method Plot(x:Float, y:Float)
	
		If _shaderprogram&lt;&gt;_shaderprogram_plain Then SetShaderProgram(_shaderprogram_plain)

		Local vertices:Float[]=[x+0.5, y+0.5, -1.0]
		Local uvs:Float[]=[0.0, 0.0]

		UpdateVertexBuffer(vertices)
		UpdateUVBuffer(uvs)
		
		EnableShaderData()
		glDrawArrays(GL_POINTS, 0, 2)
		CatchError("TGLTestMax2DDriver.Plot-glDrawArrays")
		DisableShaderData()
	
		Return
		
	End Method
	
	Method DrawLine(x0:Float, y0:Float, x1:Float, y1:Float, tx:Float, ty:Float)
	
		If _shaderprogram&lt;&gt;_shaderprogram_plain Then SetShaderProgram(_shaderprogram_plain)

		Local vertices:Float[]=[x0*ix+y0*iy+tx+.5, x0*jx+y0*jy+ty+.5, -1.0, x1*ix+y1*iy+tx+.5, x1*jx+y1*jy+ty+.5, -1.0]
		Local uvs:Float[]=[0.0, 0.0, 1.0, 1.0]

		UpdateVertexBuffer(vertices)
		UpdateUVBuffer(uvs)
		
		EnableShaderData()
		glDrawArrays(GL_LINES, 0, 4)
		CatchError("TGLTestMax2DDriver.DrawLine-glDrawArrays")
		DisableShaderData()
	
		Return
		
	End Method
	
	Method DrawRect(x0:Float, y0:Float, x1:Float, y1:Float, tx:Float, ty:Float)
	
		If _shaderprogram&lt;&gt;_shaderprogram_plain Then SetShaderProgram(_shaderprogram_plain)

		Local vertices:Float[]=[x0*ix+y0*iy+tx, x0*jx+y0*jy+ty, -1.0, x1*ix+y0*iy+tx, x1*jx+y0*jy+ty, -1.0, x1*ix+y1*iy+tx, x1*jx+y1*jy+ty, -1.0, x1*ix+y1*iy+tx, x1*jx+y1*jy+ty, -1.0, x0*ix+y1*iy+tx, x0*jx+y1*jy+ty, -1.0, x0*ix+y0*iy+tx, x0*jx+y0*jy+ty, -1.0]
		Local uvs:Float[]=[0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0]

		UpdateVertexBuffer(vertices)
		UpdateUVBuffer(uvs)
		
		EnableShaderData()
		glDrawArrays(GL_TRIANGLES, 0, 6)
		CatchError("TGLTestMax2DDriver.DrawRect-glDrawArrays")
		DisableShaderData()
	
		Return
		
	End Method
	
	Method DrawOval(x0:Float, y0:Float, x1:Float, y1:Float, tx:Float, ty:Float)
	
		Local xy:Float[]
	
		Local xr:Float = (x1 - x0) * 0.5
		Local yr:Float = (y1 - y0) * 0.5
		Local segs:Int = Abs(xr) + Abs(yr)
		
		segs=Max(segs,12) &amp; ~3
		
		x0:+xr
		y0:+yr
		
		Local oldx:Float = x0 + xr
		Local oldy:Float = y0
		
		For Local i:Int = 0 Until segs
		
			Local th:Float = i * 360.0 / segs
			Local x:Float = x0 + Cos(th) * xr
			Local y:Float = y0 + Sin(th) * yr
			
			'glVertex2f x * ix + y * iy + txm x * jx + y * jy + ty
			
			xy:+[x * ix + y * iy + tx]
			xy:+[x * jx + y * jy + ty]
		
		Next
	
		DrawPoly(xy, 0, 0, 0, 0)
	
		Return
	
	End Method
	
	Method DrawPoly(xy:Float[], handlex:Float, handley:Float, originx:Float, originy:Float)
	
		If xy.length&lt;6 Or (xy.length&amp;1) Return
		
		DebugLog ""
		DebugLog "drawpoly:"
		For Local i:Int=0 To xy.length-1 Step 2
			DebugLog xy[i+0]+", "+xy[i+1]
		Next
		DebugLog ""
		
		'DisableTex
		'glBegin GL_POLYGON
		'For Local i=0 Until Len xy Step 2
		'	Local x#=xy[i+0]+handle_x
		'	Local y#=xy[i+1]+handle_y
		'	glVertex2f x*ix+y*iy+origin_x,x*jx+y*jy+origin_y
		'Next
		'glEnd
	
		' cant do the above, need to unwind and draw using triangles or polygons...
		
		If _shaderprogram &lt;&gt; _shaderprogram_plain Then
			SetShaderProgram(_shaderprogram_plain)
		EndIf
		
		Local verts:Float[3*3]
		Local uvs:Float[3*2]
		
		For Local i:Int = 0 Until xy.length Step 2
		
			If i=0 Or i=1 Then
				Continue
			EndIf
		
			verts[0] = xy[0]
			verts[1] = xy[1]
			verts[2] = -1.0
			
			verts[3] = xy[i+0]
			verts[4] = xy[i+1]
			verts[5] = -1.0
			
			verts[6] = xy[i-2]
			verts[7] = xy[i-1]
			verts[8] = -1.0
		
			DebugLog ""
			DebugLog "drawing triangle:"
			
			For Local j:Int=0 To 2
				DebugLog verts[j*2+0]+", "+verts[j*2+1]
			Next
		
			UpdateVertexBuffer(verts)
			UpdateUVBuffer(uvs)
			
			EnableShaderData()
			glDrawArrays(GL_TRIANGLES, 0, 3)
			CatchError("TGLTestMax2DDriver.DrawPoly-glDrawArrays")
			DisableShaderData()
			
		Next
	
		Return
	
	End Method
	
	Method DrawPixmap(pixmap:TPixmap, x:Int, y:Int)
	
		If Not pixmap Then
			Return
		EndIf
		
		Local p:TPixmap = ConvertPixmap(pixmap, PF_RGBA8888)
		
		If Not p Then
			Return
		EndIf
	
		Local image:TImage = LoadImage(p)
		
		If Not image Then
			Return
		EndIf
		
		DrawImage image, x, y
	
		Return
	
	End Method
	
	Method GrabPixmap:TPixmap(x:Int, y:Int, width:Int, height:Int)
		Return Null
	End Method
	
	Method SetResolution(width:Float, height:Float)
		_projection_matrix.SetOrthographic(0.0, width, 0.0, height, -1.0, 1.0)
	End Method
	
End Type

Rem
bbdoc: Get OpenGL Max2D Driver
about:
The returned driver can be used with #SetGraphicsDriver to enable OpenGL Max2D 
rendering.
End Rem
Function GLTestMax2DDriver:TGLTestMax2DDriver()
	Global _done:Int
	If Not _done:Int
		_driver:TGLTestMax2DDriver=New TGLTestMax2DDriver.Create()
		_done=True
	EndIf
	Return _driver
End Function

Local driver:TGLTestMax2DDriver=GLTestMax2DDriver()
If driver Then
	SetGraphicsDriver(driver)
EndIf

Function GetDefaultVertexShader:String()

	Local str:String
	
	str:+"#version 120~n"
	str:+"attribute vec3 vertex_position;~n"
	str:+"uniform mat4 projection_matrix;~n"
	str:+"uniform vec4 color;~n"
	str:+"varying vec4 fragment_color;~n"
	str:+"void main(void)~n"
	str:+"{~n"
	str:+"	gl_Position=projection_matrix*vec4(vertex_position, 1.0);~n"
	str:+"	fragment_color=color;~n"
	str:+"}~n"
	
	Return str

End Function

Function GetDefaultFragmentShader:String()
	
	Local str:String
	
	str:+"#version 120~n"
	str:+"varying vec4 fragment_color;~n"
	str:+"void main(void)~n"
	str:+"{~n"
	str:+"	gl_FragColor=fragment_color;~n"
	str:+"}~n"
	
	Return str
	
End Function

Function GetTextureVertexShader:String()

	Local str:String
	
	str:+"#version 120~n"
	str:+"attribute vec3 vertex_position;~n"
	str:+"attribute vec2 vertex_uv;~n"
	str:+"uniform mat4 projection_matrix;~n"
	str:+"uniform vec4 color;~n"
	str:+"varying vec4 fragment_color;~n"
	str:+"varying vec2 uv;~n"
	str:+"void main(void)~n"
	str:+"{~n"
	str:+"	gl_Position=projection_matrix*vec4(vertex_position, 1.0);~n"
	str:+"	fragment_color=color;~n"
	str:+"	uv=vertex_uv;~n"
	str:+"}~n"
	
	Return str
	
End Function

Function GetTextureFragmentShader:String()

	Local str:String
	
	str:+"#version 120~n"
	str:+"varying vec4 fragment_color;~n"
	str:+"varying vec2 uv;~n"
	str:+"uniform sampler2D tex;~n"
	str:+"void main(void)~n"
	str:+"{~n"
	str:+"	gl_FragColor=fragment_color*texture2D(tex, uv);~n"
	str:+"}~n"
	
	Return str

End Function

Function CatchError(append:String)
	Local error:Int=glGetError()
	If error&lt;&gt;0 Then
		WriteStdout append+" : "+error
		Select error
		Case GL_INVALID_ENUM
			WriteStdout " GL_INVALID_ENUM "
		Case GL_INVALID_VALUE
			WriteStdout " GL_INVALID_VALUE "
		Case GL_INVALID_OPERATION
			WriteStdout " GL_INVALID_OPERATION "
		End Select
		WriteStdout "~n"
		End
	EndIf
End Function
</textarea><br><br>It should now do multiple images and pixmaps properly, and i think i got polygons working (drawoval uses drawpoly now). Please test and report any weird things :) <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
