<!DOCTYPE html><html lang="en" ><head ><title >Multithread this</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Multithread this</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Multithread this</a><br><br>
<a name="948285"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here's a routine that could be multithreaded.  It reads through a directory and loads all files into a TMap.  How would I go about creating different threads to make the process faster?:<br><pre class=code>Global AbstractFileMap:TMap=New TMap

Function RegisterAbstractPath(filepath:String)	
	Local name:String,filename:String,d:int
	filepath=RealPath(filepath)
	d=ReadDir(filepath)
	If Not d Return
	If Right(filepath,1)="/" filepath=Left(filepath,Len(filepath)-1)
	If Right(filepath,1)="\" filepath=Left(filepath,Len(filepath)-1)
	Repeat
		filename:String=NextFile(d)
		If filename="" Exit
		Select FileType(filepath+"/"+filename)
			Case 0
				Exit
			Case 1
				name=StripDir(filename).tolower()
				AbstractFileMap.insert(name,RealPath(filepath+"/"+filename).tolower())
			Case 2
				If filename&lt;&gt;"." And filename&lt;&gt;".."
					RegisterAbstractPath(filepath+"/"+filename)
				EndIf
		EndSelect
	Forever
	CloseDir d
EndFunction</pre> <br><br></td></tr></table><br>
<a name="948292"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gabriel</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Are you sure this is worth multithreading? On the face of it, it seems like your bottleneck here is going to be the hard drive, not the CPU. Like when you open two Windows Explorer searches at once and they take the same amount of time as running them one after the other. At least, they do for me. <br><br></td></tr></table><br>
<a name="948293"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> I don't know, but it would be a good example to learn how it works. <br><br></td></tr></table><br>
<a name="948296"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gabriel</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh, I see, just a theoretical exercise to get some practice in. Fair enough.<br><br>Well as I see it, you have two options. You can't split the entire job into two because you will kill any performance gains checking which files the other thread had done. <br><br>So one way would be to run through the entire directory with ReadDir and a loop of NextFile() to give yourself a list before you start. Put that into an array or something. Then slice the array in two/more and give a part of the array to each thread to process further.<br><br>Another way to do it would be to have one thread processing all the files with NextFile() and putting the filenames in a list/array. Then another thread could look to see which files have been found with NextFile and do the rest of the processing.<br><br>With the second way though, I guess you would need some kind of locking to prevent the processing thread from accessing the list of found files while the file reading thread was writing to it. In the first way, each thread would have its own data to work on and there would be no crossover. Therefore nothing to lock. <br><br></td></tr></table><br>
<a name="948305"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> because you will kill any performance gains checking which files the other thread had done. <br></div><br>Why would you need to do that?  You can just assign new directories to a thread and let them work out the sub-hierarchy.  The only time the threads have to be locked is when the global TMap is added to. <br><br></td></tr></table><br>
<a name="948310"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gabriel</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh ok, I don't think I've understood you very well. I assumed this was a function you called once or twice and everything was off of one or two main folder paths. So I thought you want to use multiple threads each time the function was called.<br><br>But you're actually suggesting that you might call this dozens of time with different folders and you want each separate call of the function to use its own thread? Have I got that right now? <br><br></td></tr></table><br>
<a name="948312"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kurator</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> i would not partition the function, just put the function in a own 'background' thread. <br><br>this is a clearly i/o bound function, splitting it to more than one thread would simply create more i/o syscalls, causing the hardrive doing some funny things - like trying to read different sectors at the same time - which causes the in longer response time.<br><br>partitioning a problem domain will give you a speedgain on calculation intense algorithms, or algortithms that are not i/o (hd, dvd...) bound. <br><br></td></tr></table><br>
<a name="948316"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is just an example of a simpler hierarchal problem.  The interaction of the threads is minimal, so I want to use this to learn from. <br><br></td></tr></table><br>
<a name="948330"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kurator</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> So here some short pseudocode:<br><br>Let the map being  a global, define a mutex for it, to avoid concurrent access to the list<br><br>in your function:<br><br>in case 1: do your strip dir, set the mutex, write to the map, release the mutex<br>in case 2: set up a new thread and call your function, after returning destroy it.<br><br>this will create a bunch of threads, but will partition your problem. if you want to keep the amount of threads limited, use a sort of threadpool with a static amount of prepared threads. <br><br></td></tr></table><br>
<a name="948361"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> I agree there isn't a lot you can do to speed up the file access - x amount of file data has to be transferred into memory and it takes y amount of time to seek and read the disk.<br><br>I would at least experiment with trying to read in two directories at once to see if there is any gain - ie if there is any idle time where the disk is not being accessed where another thread could be reading file data.<br><br>If there isn't any idle disk time, then it's going to be more a case of doing some other work while you're waiting for the file data to be read. ie as you read each file into a list, process it somehow while another thread is off reading the next file. File access probably doesn't use all the cpu time so you could gain in that regard so long as you have some other non-file work to do. e.g. read the files in one or two threads, another thread monitors when a file is completely loaded (or maybe starts working on it based on how much is loaded so far), and then perhaps uploads it as a texture to video ram for example. The texture uploads can probably be done in parallel to the file spooling. <br><br></td></tr></table><br>
<a name="948448"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> [EDIT: Got both varieties working but can't be bothered editing all this again!]<br><br>[EDIT 2: Nope, the threaded recursion is getting a smaller number of files. Not sure why yet... I expected more! Will try and figure out... ]<br><br>I did this before realising you wanted to iterate through the same folder list via multiple threads (at least I think so?), but here's an example of using multi-threading to get the directory list in the background, which might help in a different way. The only modification to the function was changing the return type, the parameter type, and adding a local version of filepath:String.<br><br>A mutex isn't necessary here, as the thread calls the function recursively as a normal function, rather than spawning a new thread for each recursion (which I think is what you wanted).<br><br>Anyway, this test opens a window so you can draw with the mouse while obtaining the file list, then closes it and lists the files.<br><br><pre class=code>

Global AbstractFileMap:TMap=New TMap

Function RegisterAbstractPathThreaded:Object (data:Object)
	Local filepath:String = String (data)
	Local name:String,filename:String,d:Int
	filepath=RealPath(filepath)
	d=ReadDir(filepath)
	If Not d Return
	If Right(filepath,1)="/" filepath=Left(filepath,Len(filepath)-1)
	If Right(filepath,1)="\" filepath=Left(filepath,Len(filepath)-1)
	Repeat
		filename:String=NextFile(d)
		If filename="" Exit
		Select FileType(filepath+"/"+filename)
			Case 0
				Exit
			Case 1
				name=StripDir(filename).tolower()
				AbstractFileMap.insert(name,RealPath(filepath+"/"+filename).tolower())
			Case 2
				If filename&lt;&gt;"." And filename&lt;&gt;".."
					RegisterAbstractPathThreaded(filepath+"/"+filename) ' Called as a normal function from same thread, ie. dirs:TThread...
				EndIf
		EndSelect
	Forever
	CloseDir d
EndFunction

' Test...

Graphics 640, 480
SetHandle 16, 16

Print ""
Print "Getting directory list..."

Local dirs:TThread = CreateThread (RegisterAbstractPathThreaded, "C:\Windows") ' Change to suit...

Local threaddone = False

Repeat

	If Not ThreadRunning (dirs)
		Exit ' Exit loop and list dirs...
	EndIf

	Cls
	DrawRect MouseX (), MouseY (), 32, 32
	Flip
	
Until KeyHit (KEY_ESCAPE)

EndGraphics

For p$ = EachIn MapKeys (AbstractFileMap)
	Print String (MapValueForKey (AbstractFileMap, p$))
Next

End
</pre><br><br>To have a new thread for each recursive call, do what Kurator says, though I imagine it will cripple the speed -- you'll also have to discard multiple filename entries, since each call will go through all the same sub-folders, if my logic is working correctly (recursion hurts me).<br><br>Define <i>Global mapmutex:TMutex = CreateMutex ()</i> at the top and call <i>LockMutex/UnlockMutex mapmutex</i> before and after AbstractFileMap.insert (), then each thread will wait if another has the mutex locked. (Just modify the CreateThread line above for your RegisterAbstractPathThreaded call inside the function.)<br><br>Actually, I got curious and just did it, and it's much faster, but it's probably full of duplicates -- I'll leave that for you to deal with as you see fit. Probably quicker to do it afterwards.<br><br>If you add a WaitMouse after the Graphics setup, open Task Manager and add Thread Count to your list (see View menu), you can highlight the program in Task Manager and see the thread count.<br><br><pre class=code>
Global AbstractFileMap:TMap=New TMap
Global MapMutex:TMutex = CreateMutex ()

Function RegisterAbstractPathThreaded:Object (data:Object)
	Local filepath:String = String (data)
	Local name:String,filename:String,d:Int
	filepath=RealPath(filepath)
	d=ReadDir(filepath)
	If Not d Return
	If Right(filepath,1)="/" filepath=Left(filepath,Len(filepath)-1)
	If Right(filepath,1)="\" filepath=Left(filepath,Len(filepath)-1)
	Repeat
		filename:String=NextFile(d)
		If filename="" Exit
		Select FileType(filepath+"/"+filename)
			Case 0
				Exit
			Case 1
				name=StripDir(filename).tolower()
				LockMutex MapMutex
				AbstractFileMap.insert(name,RealPath(filepath+"/"+filename).tolower())
				UnlockMutex MapMutex
			Case 2
				If filename&lt;&gt;"." And filename&lt;&gt;".."
					Local dirs:TThread = CreateThread (RegisterAbstractPathThreaded, filepath+"/"+filename) ' Called as a normal function from same thread, ie. dirs:TThread...
				EndIf
		EndSelect
	Forever
	CloseDir d
EndFunction

' Test...

Graphics 640, 480
SetHandle 16, 16

Print ""
Print "Getting directory list..."

Local dirs:TThread = CreateThread (RegisterAbstractPathThreaded, "C:\Windows") ' Change to suit...

Local threaddone = False

Repeat

	If Not ThreadRunning (dirs)
		Exit ' Exit loop and list dirs...
	EndIf

	Cls
	DrawRect MouseX (), MouseY (), 32, 32
	Flip
	
Until KeyHit (KEY_ESCAPE)

EndGraphics

For p$ = EachIn MapKeys (AbstractFileMap)
	Print String (MapValueForKey (AbstractFileMap, p$))
Next

End
</pre> <br><br></td></tr></table><br>
<a name="948474"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> In case 2, your program just creates the thread and leaves without waiting for it to complete.  Here is a correction:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Global AbstractFileMap:TMap=New TMap
Global MapMutex:TMutex = CreateMutex()

Const THREADED:Int=True

Function RegisterAbstractPathThreaded:Object (data:Object)
	Local filepath:String = String (data)
	Local name:String,filename:String,d:Int
	filepath=RealPath(filepath)
	d=ReadDir(filepath)
	If Not d Return
	If Right(filepath,1)="/" filepath=Left(filepath,Len(filepath)-1)
	If Right(filepath,1)="\" filepath=Left(filepath,Len(filepath)-1)
	Repeat
		filename:String=NextFile(d)
		If filename="" Exit
		Select FileType(filepath+"/"+filename)
			Case 0
				Exit
			Case 1
				name=StripDir(filename).tolower()
				LockMutex MapMutex
				AbstractFileMap.insert(name,RealPath(filepath+"/"+filename).tolower())
				UnlockMutex MapMutex
			Case 2
				If filename&lt;&gt;"." And filename&lt;&gt;".."
					If THREADED
						Local dirs:TThread = CreateThread (RegisterAbstractPathThreaded, filepath+"/"+filename) ' Called as a normal function from same thread, ie. dirs:TThread...
						Repeat
							If Not ThreadRunning (dirs)
								Exit ' Exit loop and list dirs...
							EndIf
							Delay 1
						Forever
					Else
						RegisterAbstractPathThreaded(filepath+"/"+filename)
					EndIf
				EndIf
		EndSelect
	Forever
	CloseDir d
EndFunction

' Test...

Print ""
Print "Getting directory list..."

Local time:Int=MilliSecs()
Local dirs:TThread = CreateThread (RegisterAbstractPathThreaded, "C:\Windows") ' Change to suit...

Repeat
	If Not ThreadRunning (dirs)
		Exit ' Exit loop and list dirs...
	EndIf
	Delay 1
Forever

Print (MilliSecs()-time)+" msecs"

Local n:Int
For p$ = EachIn MapKeys (AbstractFileMap)
	n:+1
Next
Print n+" files found."

End</textarea><br><br>Threaded results:<br>Getting directory list...<br>24446 msecs<br>36843 files found.<br>Process complete<br><br>Non-threaded results:<br>Getting directory list...<br>10554 msecs<br>36843 files found.<br>Process complete<br><br>So obviously there is some overhead in creating a thread and since each thread in this example is doing so little it makes sense it would be slower. <br><br></td></tr></table><br>
<a name="948477"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Now I added a check to keep the thread count at the theoretical optimum count.  I have a quad core so I chose four threads.  Performance is about the same the previous mt attempt:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Global AbstractFileMap:TMap=New TMap
Global MapMutex:TMutex = CreateMutex()

Const THREADED:Int=True
Global ThreadCount:Int
Global ThreadCountMutex:TMutex=CreateMutex()

Function RegisterAbstractPathThreaded:Object (data:Object)
	Local filepath:String = String (data)
	Local name:String,filename:String,d:Int
	filepath=RealPath(filepath)
	d=ReadDir(filepath)
	If Not d Return
	If Right(filepath,1)="/" filepath=Left(filepath,Len(filepath)-1)
	If Right(filepath,1)="\" filepath=Left(filepath,Len(filepath)-1)
	Repeat
		filename:String=NextFile(d)
		If filename="" Exit
		Select FileType(filepath+"/"+filename)
			Case 0
				Exit
			Case 1
				name=StripDir(filename).tolower()
				LockMutex MapMutex
				AbstractFileMap.insert(name,RealPath(filepath+"/"+filename).tolower())
				UnlockMutex MapMutex
			Case 2
				If filename&lt;&gt;"." And filename&lt;&gt;".."
					If THREADED=True And ThreadCount&lt;5
						LockMutex ThreadCountMutex
						ThreadCount:+1
						UnlockMutex ThreadCountMutex
						Local dirs:TThread = CreateThread (RegisterAbstractPathThreaded, filepath+"/"+filename) ' Called as a normal function from same thread, ie. dirs:TThread...
						Repeat
							If Not ThreadRunning (dirs)
								Exit ' Exit loop and list dirs...
							EndIf
							Delay 1
						Forever
						LockMutex ThreadCountMutex
						ThreadCount:-1
						UnlockMutex ThreadCountMutex
					Else
						RegisterAbstractPathThreaded(filepath+"/"+filename)
					EndIf
				EndIf
		EndSelect
	Forever
	CloseDir d
EndFunction

' Test...

Print ""
Print "Getting directory list..."

Local time:Int=MilliSecs()
Local dirs:TThread = CreateThread (RegisterAbstractPathThreaded, "C:\Windows") ' Change to suit...

Repeat
	If Not ThreadRunning (dirs)
		Exit ' Exit loop and list dirs...
	EndIf
	Delay 1
Forever

Print (MilliSecs()-time)+" msecs"

Local n:Int
For p$ = EachIn MapKeys (AbstractFileMap)
	n:+1
Next
Print n+" files found."

End</textarea> <br><br></td></tr></table><br>
<a name="948478"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> And here I set it up so threads are only created in the top-level directory.  So one thread is created for each folder in the Windows directory, and then they are just each left to do all the work for the subfolders:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Global AbstractFileMap:TMap=New TMap
Global MapMutex:TMutex = CreateMutex()

Const THREADED:Int=True
Global ThreadCount:Int
Global ThreadCountMutex:TMutex=CreateMutex()

Global TopLevel:Int=True

Function RegisterAbstractPathThreaded:Object(data:Object)
	Local filepath:String = String (data)
	Local name:String,filename:String,d:Int
	Local top:Int=TopLevel
	TopLevel=False
	filepath=RealPath(filepath)
	d=ReadDir(filepath)
	If Not d Return
	If Right(filepath,1)="/" filepath=Left(filepath,Len(filepath)-1)
	If Right(filepath,1)="\" filepath=Left(filepath,Len(filepath)-1)
	Repeat
		filename:String=NextFile(d)
		If filename="" Exit
		Select FileType(filepath+"/"+filename)
			Case 0
				Exit
			Case 1
				name=StripDir(filename).tolower()
				LockMutex MapMutex
				AbstractFileMap.insert(name,RealPath(filepath+"/"+filename).tolower())
				UnlockMutex MapMutex
			Case 2
				If filename&lt;&gt;"." And filename&lt;&gt;".."
					If THREADED=True And top=True' And ThreadCount&lt;5
						LockMutex ThreadCountMutex
						ThreadCount:+1
						UnlockMutex ThreadCountMutex
						Local dirs:TThread = CreateThread (RegisterAbstractPathThreaded, filepath+"/"+filename) ' Called as a normal function from same thread, ie. dirs:TThread...
						Repeat
							If Not ThreadRunning (dirs)
								Exit ' Exit loop and list dirs...
							EndIf
							Delay 1
						Forever
						LockMutex ThreadCountMutex
						ThreadCount:-1
						UnlockMutex ThreadCountMutex
					Else
						RegisterAbstractPathThreaded(filepath+"/"+filename)
					EndIf
				EndIf
		EndSelect
	Forever
	CloseDir d
EndFunction

' Test...

Print ""
Print "Getting directory list..."

Local time:Int=MilliSecs()
Local dirs:TThread = CreateThread (RegisterAbstractPathThreaded, "C:\Windows") ' Change to suit...

Repeat
	If Not ThreadRunning (dirs)
		Exit ' Exit loop and list dirs...
	EndIf
	Delay 1
Forever

Print (MilliSecs()-time)+" msecs"

Local n:Int
For p$ = EachIn MapKeys (AbstractFileMap)
	n:+1
Next
Print n+" files found."

End</textarea><br><br>Here are the results:<br><br>Getting directory list...<br>10688 msecs<br>36843 files found.<br><br><br>Since we have already determined the limiting step is the hard drive, it seems like just getting the MT version to match the ST version is the goal.  So we see here that the most important thing is dividing the task up intelligently. <br><br></td></tr></table><br>
<a name="948500"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Actually, my <i>If Not ThreadRunning (dirs)</i> loop was just to allow checking while drawing. You can just do this in your modified version (or, for visual clarity, store the CreateThread result as before and WaitThread on that):<br><br><pre class=code>
WaitThread CreateThread (RegisterAbstractPathThreaded, "C:\Windows")
</pre><br><br>However, the file count (even taking directories into account) is not correct for my C:\Windows folder, so something's still not quite right. I have 12,194 files and 1,318 folders, but the result of this program is 9752. How does your output compare with right-click -&gt; Properties on the C:\Windows folder?<br><br>This gets the correct count for me (except for some reason there's a consistent discrepancy of two folders and one file):<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

SuperStrict

Global FileCount:Int
Global FolderCount:Int

Function ParseDir (dir:String)

	If FileType (dir) = FILETYPE_DIR
		If Right (dir, 1) &lt;&gt; "\" And Right (dir, 1) &lt;&gt; "/"
			?Win32
				dir = dir + "\"
			?Else
				dir = dir + "/"
			?
		EndIf
	EndIf

	Local folder:Int = ReadDir (dir)

	If folder
	
		Repeat
		
			Local entry:String = NextFile (folder)
			
			If entry = "" Then Exit
			
			If entry &lt;&gt; "." And entry &lt;&gt; ".."

				If FileType (dir + entry) = FILETYPE_FILE

					FileCount = FileCount + 1

'					Local filepath:String = dir + entry
'					Print filepath
									
				Else
				
					If FileType (dir + entry) = FILETYPE_DIR
					
						If entry &lt;&gt; "." And entry &lt;&gt; ".."

							FolderCount = FolderCount + 1

							Local nextdir:String = dir + entry
							ParseDir (nextdir)
					
						EndIf

					EndIf
			
				EndIf
			
			EndIf
		
		Forever
	
		CloseDir folder
	
	EndIf
	
End Function

ParseDir ("C:\Windows")

Print "Files:   " + FileCount
Print "Folders: " + FolderCount
Print "Both:    " + (FolderCount + FileCount)
</textarea> <br><br></td></tr></table><br>
<a name="948506"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> The reason it is skipping files is your threads created in the function aren't given a chance to complete.<br><br>This has been a good exercise because now I understand mutexes.  It will be interesting to see how this works out with hierarchal culling routines. <br><br></td></tr></table><br>
<a name="948529"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> I mean your final version still doesn't count correctly, and that does wait.<br><br>I'm not totally convinced that you should have to wait for the threads, though -- they should complete regardless once spawned off, surely? Unless there's a weird recursion/queuing effect I can't quite get a mental grasp on. <br><br></td></tr></table><br>
<a name="948614"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> You have to make sure the threads are done before you count files or end the program. <br><br></td></tr></table><br>
<a name="948627"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kurator</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> do not test c:/windows - the count of files may vary while running because of other processes doing some i/o there :)<br><br>do skip the loop for waiting, simply use:<br><br><pre class=code>
Local dirs:TThread = CreateThread (RegisterAbstractPathThreaded, filepath+"/"+filename) ' Called as a normal function from same thread, ie. dirs:TThread...
dirs.Wait()
</pre> <br><br></td></tr></table><br>
<a name="948630"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kurator</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> The difference in count between Josh and your implementation is - the TMap in Josh Code eleminates files with duplicate Filenames :) <br><br></td></tr></table><br>
<a name="948657"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>You have to make sure the threads are done before you count files or end the program<br> <br></div><br><br>Yes, I see now -- I wasn't thinking about that final count/program exit. <br><br>However, your final version <i>is</i> waiting for each thread to exit as far as I can see, but it still isn't returning the correct number of files for multiple levels of folders containing multiple folders. The count from the non-threaded function in my last codebox above is returning the correct number of files and folders (ie. matching Windows' Properties dialog).<br><br>For example, my Downloads folder is reported in Windows Properties as "3,771 Files, 113 Folders". This is what CountFiles, above, returns, while your function (which does wait on its threads) is reporting "3757 files found".<br><br>Kurator, yes, good point regarding TMap -- I did <i>eventually</i> realise myself that the TMap would take care of duplicates! <br><br></td></tr></table><br>
<a name="948727"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kurator</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> I get the same results, i modified Josh' Code a little bit, using AtomicAdd and Thread.Wait(), give it a look:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Global AbstractFileMap:TMap=New TMap
Global MapMutex:TMutex = CreateMutex()
Global Files:Int = 0
Global Directorys:Int = 0

Const THREADED:Int=True
Global ThreadCount:Int

Function RegisterAbstractPathThreaded:Object (data:Object)
	Local filepath:String = String (data)
	Local name:String,filename:String,d:Int
	filepath=RealPath(filepath)
	d=ReadDir(filepath)
	If Not d Return
	If Right(filepath,1)="/" filepath=Left(filepath,Len(filepath)-1)
	If Right(filepath,1)="\" filepath=Left(filepath,Len(filepath)-1)
	Repeat
		filename:String=NextFile(d)
		If filename="" Exit
		Select FileType(filepath+"/"+filename)
			Case 0
				Exit
			Case 1
				name=StripDir(filename).tolower()
				LockMutex MapMutex
				AbstractFileMap.insert(name,RealPath(filepath+"/"+filename).tolower())
				UnlockMutex MapMutex
				AtomicAdd(Files,1)
			Case 2
				If filename&lt;&gt;"." And filename&lt;&gt;".."
					If THREADED=True And ThreadCount&lt;5
						AtomicAdd(ThreadCount, 1)
						Local dirs:TThread = CreateThread (RegisterAbstractPathThreaded, filepath+"/"+filename) ' Called as a normal function from same thread, ie. dirs:TThread...
						dirs.Wait()
						AtomicAdd(ThreadCount, -1)
					Else
						RegisterAbstractPathThreaded(filepath+"/"+filename)
					EndIf
					AtomicAdd(Directorys,1)
				EndIf
		EndSelect
	Forever
	CloseDir d
EndFunction

' Test...

Print ""
Print "Getting directory list..."

Local time:Int=MilliSecs()
Local dirscan:TThread = CreateThread (RegisterAbstractPathThreaded, "D:\Downloads") ' Change to suit...
dirscan.Wait()

Print (MilliSecs()-time)+" msecs"

Local n:Int
For p$ = EachIn MapKeys (AbstractFileMap)
	n:+1
Next
Print n+" filenames found."

Print Files+" files found."
Print Directorys+" folders found."

End
</textarea> <br><br></td></tr></table><br>
<a name="948748"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hmm, didn't know about AtomicAdd. I guess that's similar to doing a LockMutex and modifying the global? My result was...<br><br><pre class=code>
Getting directory list...
366 msecs
345 filenames found.
349 files found.
30 folders found.
</pre><br><br>... which shows the discrepancy. I can't actually see what's causing it though.<br><br>Thread.Wait () is good -- my ThreadRunning loop was only there to allow the main loop in my original demo to keep going, while checking for the thread to finish. I've been doing this:<br><br><pre class=code>
WaitThread CreateThread (RegisterAbstractPathThreaded, "D:\Downloads").
</pre><br><br>Same thing as Thread.Wait () in the end, of course... <br><br></td></tr></table><br>
<a name="948791"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brendane</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> I would just like to point out that the thread.Wait() within the 'scanning' thread is effectively limiting the number of running 'scanning' threads to just 1.<br><br>So it's not actually running multi-threaded as you intended.<br><br>Yes you're creating a number of threads, but each one is immediately going bye-byes until its child has finished its job.. and so on. <br><br></td></tr></table><br>
<a name="948795"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brendane</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> An appropriate model to use here would be to create a pool of worker threads that wait on a semaphore. <br><br>Each time a new folder is needed to be parsed you add it to a list and  release a semaphore. The first worker thread takes the folder off the list and parses it.<br><br>A count of folders being parsed is maintained... a master thread (could be the main thread) waits for this to become 0 and then knows the job is done.  <br><br>Now all that's left is to clean up by terminating the worker thread pool. I would normally set a global 'terminate' flag here and then just release 1 semaphore per thread. The first thing the worker thread should do after picking up a semaphore is test whether this 'terminate' flag is set, if so, it skips it's code and ends naturally. <br><br>The main thread then waits on each worker thread in turn.<br><br>The thread body psuedo code would look something like this<br><br>While Not terminate<br>   WaitSemaphore(semaphore)<br>   If Not terminate<br>        ' take next folder off list and process it<br>        ' decrement global folder count now we've finished with it.<br>   EndIf<br>Wend<br><br>There is also an efficient way to put the main thread to sleep until all is done by having another semaphore that the main thread waits on... each time a worker finishes with a folder and decrements the count it also releases one of these semaphores.<br>When the main thread wakes upon seeing a semaphore it checks the folder count to see if it's 0, if it's not it waits again. At 0 it is time to do the clean up. <br><br></td></tr></table><br>
<a name="948843"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kurator</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yep, you are absolutely right, because of the inner wait there ist never more than one thread working....<br><br>Here a revised approach, but take care - the num. of thread ist not limited in this case :)<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

Global AbstractFileMap:TMap=New TMap
Global MapMutex:TMutex = CreateMutex()
Global Files:Int = 0
Global Directorys:Int = 0

Const THREADED:Int=True

Function RegisterAbstractPathThreaded:Object (data:Object)
	Local filepath:String = String (data)
	Local name:String,filename:String,d:Int
	Local fullName:String
	Local childThreads:TList = New TList

	filepath=RealPath(filepath)
	d=ReadDir(filepath)
	If Not d Return Null
	If Right(filepath,1)="/" filepath=Left(filepath,Len(filepath)-1)
	If Right(filepath,1)="\" filepath=Left(filepath,Len(filepath)-1)
	Repeat
		filename:String=NextFile(d)
		If filename="" Exit
		fullName = filepath+"/"+filename
		Select FileType(fullName)
			Case 0
				Exit
			Case 1
				name=StripDir(filename).tolower()
				LockMutex MapMutex
				AbstractFileMap.insert(name,RealPath(fullName).tolower())
				UnlockMutex MapMutex
				AtomicAdd(Files,1)
			Case 2
				If filename&lt;&gt;"." And filename&lt;&gt;".."
					If THREADED=True
						Local dirs:TThread = CreateThread (RegisterAbstractPathThreaded, fullName) ' Called as a normal function from same thread, ie. dirs:TThread...
						childThreads.AddLast(dirs)
					Else
						RegisterAbstractPathThreaded(fullName)
					EndIf
					AtomicAdd(Directorys,1)
				EndIf
		EndSelect
	Forever
	CloseDir d
	For Local t:TThread=EachIn childThreads
		t.Wait()
		childThreads.Remove(t)
	Next	
EndFunction

' Test...

Print ""
Print "Getting directory list..."

Local time:Int=MilliSecs()
Local dirscan:TThread = CreateThread (RegisterAbstractPathThreaded, "C:\Windows") ' Change to suit...
dirscan.wait()


Print (MilliSecs()-time)+" msecs"

Local n:Int
Local p:String
For p = EachIn MapKeys (AbstractFileMap)
	n:+1
Next
Print n+" filenames found."

Print Files+" files found."
Print Directorys+" folders found."

End

</textarea> <br><br></td></tr></table><br>
<a name="948899"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> That worked really quickly. On my C:\Windows folder I saw 61 threads in the Task Manager! I imagine that if they were limited it would be faster, but as this thread has shown... who knows? It's also shown how much attention we need to pay when trying to multi-thread programs... <br><br></td></tr></table><br>
<a name="1177375"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >virtlands</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is an interesting 4-year old topic.<br><br>Though it is a great experiment in learning threading techniques, <br>I think you should not apply this to disk 'reads' since <u>simultaneous</u> disk reads (for directory purposes) <br>will tend to thrash your hard drive, and wear it out. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
