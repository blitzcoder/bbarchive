<!DOCTYPE html><html lang="en" ><head ><title >On-the-fly image edit, OpenGL Pros wanted</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >On-the-fly image edit, OpenGL Pros wanted</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >On-the-fly image edit, OpenGL Pros wanted</a><br><br>
<a name="751270"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dubious Drewski</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Using the search, I can see that many people have wanted to<br>manipulate pixels on the fly.  Many have suggested "Maybe <br>you could use some clever OpenGL"<br><br>Well <i>I</i> would love to manipulate pixels on the fly using <br>some clever OpenGL.  And I would be ever so grateful if <br>someone could give me some hints as to what OpenGL commands <br>will allow me to manipulate the pixels of a TImage?<br><br>Something like <br>glbindtexture to select my image<br>then maybe glEnable(GL_TEXTURE_2D) to allow for texturing...<br>Is that good so far?  Then what could I do?<br><br>Something like<br><br>glColor3ub(r,g,b)<br>glTexCoord2f(x,y)<br><br>?<br><br>Any advice would be nice.<br><br>[edit] I've always been very disappointed that Bmax can't edit images <br>without going through the fatally-slow process of converting to pixmaps. <br><br></td></tr></table><br>
<a name="751271"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dubious Drewski</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Can glReadPixels help? <br><br></td></tr></table><br>
<a name="751324"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Chris C</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> What are you *actually* trying to achieve, what specific effect? <br><br></td></tr></table><br>
<a name="751404"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dubious Drewski</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> I have a single image as a background with entities running <br>around on this, digging, etc.  So this background image (which <br>is at screen resolution) needs to be editable in realtime.<br><br><a href="/posts.php?topic=67145" target="_blank">In this thread, </a>I drew a nice explanation in photoshop which<br>explains exactly what I'm after (pics near the bottom).<br><br>Lockimage creates a pixmap of the entire image, and <br>loadImage(pixmap) is the part that's dreadfully slow.  What <br>I could settle for is a Timage-to-Pixmap function that only <br>grabs a specified chunk of an image.<br><br>I think that's what I can do with glReadPixels, I just need <br>some help figuring out how to write a function that takes an<br>image and pastes it <i>into</i> another larger image afterwards. <br><br></td></tr></table><br>
<a name="751419"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> In OpenGL, there is a thing called the `current texture object` which is sort of like an internal state that says which texture is the `current` one to use. To set that variable, ie to select what the current texture is, you `bind` (associate) a given texture with that current texture variable. The way they do it in OpenGL is to say that you bind a given texture handle to one of the `current` variables, ie if you do glBindTexture(MyTexture,GL_TEXTURE_2D) it is the same thing in basic as saying CurrentTexture=MyTexture. So you have to do that to set a current texture before you can start to draw textured objects. Reason being that when it comes to drawing a textured object, you don't want to have to pass a parameter for every polygon saying which texture to use. It uses whatever is the current one - ie which one you bound to the 2d-texturing selection.<br><br>Then to allow textures to be used in the coloring of pixels, you have to do glEnable(GL_TEXTURE_2D), like you said. This swithes texturing on, and uses whatever the GL_TEXTURE_2D says is the current texture.<br><br>To then draw, say, a textured quad/rectangle, you first start by telling OpenGL that you are starting the definition of a quad, as follows:<br><br><pre class=code>
glBegin(GL_QUADS)
...
glEnd(GL_QUADS)
</pre><br>Then between these two commands, you put the definition of each vertex ie each corner of the quad. Usually you should define them in an anticlockwise direction, or at least be consistent with which way you do it.<br><br>When you use glColor to set a color, it doesn't actually DO anything other than say `CurrentColor=xyz`. You won't see the effect of it until you draw something. You can either define the color inside the quad declaration or outside it or on a per-quad basis (you can define more than one within the glbegin/glend). Normally, for the color to have no effect on what color the pixels end up as, and since it acts as a `tint` (as in SetColor r,g,b), if you just want the pixels to be the color they are in the texture then you just set the color to white. I usually use glColor4ub(r,g,b,a) (ub means unsigned byte). Don't use `b` byte because it's signed and will screw up your colors. On the other hand if you  want to give each corner of the rectangle a different tint, you can set the color (before defining the each corner) just prior to the glVertex() command, which is what defines the actual corner. You can also give each corner a different ALPHA value, and so long as you SetBlend AlphaBlend it should let you make each corner have a different transparency. Since Max is set up by default to have smooth blending across the rectangle (gauraud shading/interpolation), the amount of color and the amount of alpha value will gradually smoothly transition across the whole rectangle based on the values at each corner.<br><br>The second thing you'll want to do is set the `current texture coordinate` that will be applied to the current corner. Remember that texture space has a coordinate system of 0 to 1.0. It doesn't go in pixel values. So if your texture is 640 pixels width, to refer to a coordinate on the far right edge would be 1.0, whereas the left edge is 0. I think the top edge is also 1.0 and bottom edge is 0 (it has a bottom left origin). So let's say you wanted to make the top left corner of your rectangle be in the top left corner of the screen, you'd set the texture coordinate to 0,1.0 and then when you draw the rectangle, 0,1 in the texture will be `locked onto` wherever you say the top left corner of the rectangle is. glTexCoord2f() defines the coordinate within the texture, within the 0-1.0 coordinate system, based on two floats (x and y).<br><br>The third step is to then define the coordinates of the corner of the rectangle. I usually do it in the order topleft,bottomleft,bottomright,topright anticlockwise. It has to be in sequence. So you say glVertex2f(x,y) which for the top left corner of the screen would be glVertex2f(0,0). Remember the vertex coordinates are (as set up in blitzmax by default) pixel coordinates. That's because BlitzMax told the system that the topleft corner is 0,0 and the bottom right is screenwidth,screenheight (it doesn't have to be that way, but that makes sense from a 2d point of view). glVertex2f means define a vertex (a point/corner) using 2 floats.<br><br>So it looks something like this:<br><br><pre class=code>
glBindTexture(MyTextureHandle,GL_TEXTURE_2D) 'set current texture to use
glEnable(GL_TEXTURE_2D) 'switch on using textures for drawing pixels
glBegin(GL_QUADS) 'start defining some rectangles
   glColor4ub($FF,$FF,$FF,$FF) 'set current color to white
   glTexCoord2f(0,1.0) 'anchor topleft corner of texture to this corner
   glVertex2f(0,0) 'Define corner of rectangle in current color and anchored to the current texture coordinate
   '(so that pixel within that texture appears at this coordinate on the screen)
   'And continue with the other 3 corners...
   glColor4ub($FF,$0,$0,$FF) 'set current color to red
   glTexCoord2f(0,0) 'anchor bottom left of texture to this corner
   glVertex2f(0,ScreenHeight-1) 'Define bottom left with current color &amp; texture coord
   glColor4ub($0,$FF,$0,$80) 'set current color to transparent green
   glTexCoord2f(1.0,0) 'anchor bottom right of texture to this corner
   glVertex2f(ScreenWidth-1,ScreenHeight-1) 'Define bottom right corner
   glColor4ub($0,$0,$FF,$FF) 'set current color to blue
   glTexCoord2f(1.0,1.0) 'anchore top right of texture to this corner
   glVertex2f(ScreenWidth-1,0) 'Define top right corner
glEnd()
Flip()
</pre><br>That should draw a texture mapped onto a rectangle covering the whole screen with different colors at each corner and different alpha values at each corner.<br><br>The nice thing then is if you move around the coordinates that you pass to glVertex2f, without changing the texture coordinates, the texture will stretch/shrink/warp to fill the new shape, because the corners of the texture are still anchored to the corners of the rectangle. If you wanted to make an irregular shaped quad and keep your texture from stretching, you have to position your texture coordinates to match.<br><br>This will enable you to draw the texture. What you need is to be able to modify the texture and to be able to draw the modified texture again in the next frame. Since you can't preserve the backbuffer content itself between frames you have to get the backbuffer into a texture. Either you can use extensions that allow you to draw directly to textures, which is somewhat more advanced and not as widely supported, or you draw the current `land` to the backbuffer and then draw the changes to it and then re-grab it back into a texture. That's what GrabImage does. To do it yourself with OpenGL you use glCopyTexSubImage2d(). This copies an area of the backbuffer (which doesn't have to be the whole thing) into the currently bound texture at given coordinates. You may have to refer to glRasterPos() to set where within the backbuffer you read from and then you define where within the texture you copy it to. This saves your changes. You should save changes before you start drawing other objects and game characters on top of it. Then the next frame when you draw your texture again as your background it will have the changes from the last frame. glCopyTexSubImage2d() is the fastest OpenGL 1.1-supported non-extension-oriented way of getting pixels into a texture.<br><br>You really should avoid using glReadPixels or glDrawPixels or use of pixmaps. Since you said you only have one screen of graphics and no scrolling you can easily just use one texture to contain the whole `level` of your game. You do not want to be transferring quantities of pixels over the graphics bus between main memory and the graphics card which is what you would be doing using pixmaps. It is slow because it has overhead and because the bus transfer is nowhere near as fast as the transfer of texture data from video ram to the backbuffer in video ram, by the hardware. glReadPixels, glDrawPixels, and indeed GrabPixmap or DrawPixmap, all use the CPU to transfer the data and does not use the graphics hardware. ie Slow. On my iMac drawing pixmaps from main memory is at least 10 times slower than drawing a texture from video ram. The faster your graphics card is the faster it will draw textures and also the grab is much faster too. You should be able to grab the whole screen into a texture on a per-frame basis and still maintain a high framerate 30-60fps at least.<br><br>The only other different from not using pixmaps is you use graphics commands to have the hardware draw your changes to what is being dug and so on, which in itself is faster and easier than writing your own pixmap modification code. If you do use pixmaps look at using pointers to change stuff, it's faster than WritePixel and ReadPixel. But once you try the above OpenGL technique I don't think you'll think twice about using pixmaps for this type of engine. <br><br></td></tr></table><br>
<a name="751429"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FlameDuck</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I could settle for is a Timage-to-Pixmap function that only grabs a specified chunk of an image. <br></div>Here's an idea. Split up your background into tiles. You probably don't want to be loading "images" much bigger than 1024 x 1024 into memory anyway. <br><br></td></tr></table><br>
<a name="751585"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dubious Drewski</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Flameduck: I thought of that, and it is a fallback option. I <br>want to avoid it because of the complications that would arise<br>when a single terrain-edit affects two or more adjacent tiles <br>at once.  It's still an option, for sure, but I want to see if<br>this (probably simpler) method will work first.<br><br>@AngelDaniel:  Holy wow.  Thank you for the effort!  I'm now <br>going to have a read through that monster post of yours before<br>I can respond to you.  Give me a minute or two (or 20). <br><br></td></tr></table><br>
<a name="751619"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Chris C</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> looking at that other post I'd go the tile route, You can the also use the tiles for your a* map, you can use alpha blending on the edges and theres no reason why some tiles couldn't have several layers.<br><br>You could look at opengl render to texture tutorials, but tbh I wouldn't recommend it, the technique does slow things down and not all 3d cards can manage &gt; 256x256 textures... <br><br></td></tr></table><br>
<a name="751721"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FlameDuck</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> but I want to see if this (probably simpler) method will work first. <br></div>It won't. Why? Because you're editing too large an amount of memory to do it effectively. <br><br></td></tr></table><br>
<a name="751775"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> If texture size is a problem just break the process down into several steps with smaller textures. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
