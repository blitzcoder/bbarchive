<!DOCTYPE html><html lang="en" ><head ><title >Mode 7, How to do it properly?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Mode 7, How to do it properly?</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Mode 7, How to do it properly?</a><br><br>
<a name="918969"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Drakim</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hia!<br><br>For my own wicked reasons, I want to create a mode 7 like graphics, including 2d sprites for objects instead of 3d models.<br><br>The basic principle of how to make mode 7 like graphics can be seen in this image:<br><img src="http://img517.imageshack.us/img517/9123/kartstripskg5.png"><br><br>I tried coding it, and did indeed get a mode 7 like effect. However, it came to my notice that the perspective of my graphics was wrong in some aspects. I highly suspect that it's because I use faulty math for the transformation of the image. Allow me to explain:<br><br>Pitch is the value that represents at what angle you are viewing the mode 7 image. If you have 0 pitch, you are looking straight down at the image like a map. As you add pitch, this image "tilts" more and more, in a 3d like way. Here are 3 images from my engine with 3 different pitch values:<br><img src="http://img145.imageshack.us/img145/4377/pitchll8.png"><br><br>My pitch system was pretty simple. Pitch is the number that is used to determine how much smaller each graphical line is to be as you go "into" the image (as seen in the first image). My pitch system fails as you try large amounts of pitch. As you can see in the second image, it appears as if you are closer to the ground the more pitch you have. But to be close enough to the ground to give the illusion that you are standing on it (like in F-Zero or Mario Kart), the graphics screws up.<br><br>You'll also notice that as you add pitch to the image, a horizon is starting to show up. And it's supposed to be that way, after all, if you think logically about it. However, the horizon in the image is fake. It's simply a forced horizon put there by me, on an estimation based on the current level of pitch. If you pitch a lot, it's noticeable that it doesn't really follow the "3d flow" of the image as it should.<br><br>I had to conclude that my idea for how to transform the image was wrong. It just appears right as long as you don't test the engine too much.<br><br>After much searching on the net on the proper way to do it, I came up with pretty much nothing. The few mode 7 tutorials I found was either for a specific console (like the GBA), using commands and structure only available to that console, or, tutorials aimed for flash, in flash format, which I am unable to open and read (I don't have any flash creator).<br><br>I did find this live example of mode 7 like graphics, instead of a tutorial:<br><a href="http://blog.nihilogic.dk/2008/05/javascript-super-mario-kart.html" target="_blank">http://blog.nihilogic.dk/2008/05/javascript-super-mario-kart.html</a><br><br>Which was exactly what I needed. I searched though the sourcecode, only to find that indeed, this guy did the math for calculating the transformation of the image completely different. I sent him an email asking him for an explanation (the math part of the code isn't well commented), but have gotten no reply.<br><br><br>So, long post aside, I now turn to you. Does anybody here know what I'm seeking for? I need to know how exactly I'm supposed to scale the image lines, how the horizon is supposed to appear and work, and how to align 2d sprite objects according to the map.<br><br>I know I'm asking for a lot, but, if somebody knows, it would be most brilliant if they could share their knowledge.<br><br>(I don't have my source right now, but I dunno if I even should be showing it. It's a complete mess, full of errors, and is more likely to just throw you on the wrong track) <br><br></td></tr></table><br>
<a name="918992"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ima747</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Been a while since I've toyed with mode7, but it's quite fun.<br><br>Some basic ideas that might get you going:<br><br>Horizon is basicly a looped image, drawn from the top of the "ground" and going up. your offset it along the X axis based on how far you've turned left or right (remember, it's gotta loop, so when you get to the end it re-draws the begining...) The way I would handle that in bmax in essence. I would set the image handle to the bottom left corner of the image, and draw it at the top of the "ground". Since the handle would be at the bottom of the horizon space image then the more you pitch, the lower the edge of the ground will be and the lower the bottom of the horizon will be. Then for turning if the right side of the image is being draw then draw another one next to the first to fill that space and create the loop, and the same on the other side for left. hope that makes sense<br><br>The ground is where the complicated things really are. you need to do 2 scales and a rotation.<br><br>First you need to turn the image based on the rotation of the view. If again modifying the concept for blitz, if you set the image handle to the position of the view point (i.e. where the player is standing) and draw the image centered at the bottom of the screen, everything "behind" the view point will be off the bottom and thus behind you.<br><br>Next is where the cutting the image into horizontal slices comes in. You can scale each slice along it's X and Y axis based on it's distance from the the view point, which is relative to the pitch. Past a certain point things will be scaled to a size too small to be rellevent and can be culled out.<br><br>Since splitting and image in blitz is hard, I would start with viewports and drawimagerect instead of actually Slicing the image up. So, you set the view port to the height the slice needs to be based on it's distance, and full width because you want it to fill the screen. Next you need to figure out where the slice starts based on the image rotation and distance of the slice, and set the image handle to that point, DrawImageRect at the bottom of the view port and the rect you're drawing into is the X and Y scaled size of the image for the depth you're at.<br><br>As for objects. Generally in mode 7 they're handled as an after thought to save time, since making the background is so time consuming. Scale them vertically based on pitch, or set up an array of angles for pitch. Similarly you need an array for angles based on the rotation of the object relative to the view point. And scale x and y based on distance. This is where your art assest creation time gets eaten. You need x number of images based on how many angles you want (more angles = smoother rotation of objects) usually 36, times however many frames of animation, and then multiplied by any pitch angles (usually not used) so that's why the animation is usually so basic on mode7 games, as well as why things turn in a "chunky" fashion. Assuming you only had 3 frames of animation (in mario kart, guy turning left, right or going straight ahead) and 10 degrees of rotation, no pitch images, and 10 different racers, you have 1080 sprites... plus misc objects like trees etc.<br><br>That's a lot to take in and I may have gotten some stuff wrong, but hopefully that's a good starting point.<br><br>The method I would probably use for a mode 7 like game would be to fake mode 7 in real 3D. Using MiniB3D as the basis I would create sprite objects for all of my sprites, and another sprite object for the ground. The 3D engine will take care of all the scaling and rotating etc. It would be smoother than real mode 7, MUCH faster, but still give you that billboard/popup look that makes mode 7 charming. <br><br></td></tr></table><br>
<a name="918999"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Drakim</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thank you for the reply.<br><br>Although you explained it nicely, I already knew most of this. I already have my engine up and running (the second image, which demonstrates 3 levels of pitch), so that aspect, with the image slicing and such, isn't a problem.<br><br>The problem is that I don't know what math formulas and such to use when determining various things like scale. For example, how do I determine how big to scale a sprite object compared to the pitch of the map? As you can see in the second image, I tried with the trees. They get bigger as you pitch down, but it's pretty clear that they don't get bigger in the same ratio as the terrain gets bigger.<br><br>Right now, my engine runs on guesses and hacks. And I really want the straight math on it, so not only that the proportions become right, but also so I get a better understanding of how it all works. <br><br></td></tr></table><br>
<a name="919009"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ima747</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hmmm don't know the exact math, but it's relative to the distance from the view point. It's distance will change based on the pitch. Using A squared + B squared = C squared. A would be the height of the view point, B would be the distance along the ground image from the viewpoint to the sprite's position.<br><br>Blitz's square root function is sqr<br><br>sqr( (Height * Height) + (2Ddistance + 2Ddistance) ) = 3D distance<br><br>To Convert the distance into a scale<br><br>(distance/DistanceAtWhichStuffIs1to1scale) = Scale Percent<br><br>if you don't want to figure out your pitch based on a height setting then 2D distance may be a close enough fudge for mode 7. Alternatively if all you have is a pitch angle, and not a height you can use right angle triangle calculation to figure out what your height is.<br><br>Google turned up<br><br><a href="http://www.csgnetwork.com/righttricalc.html" target="_blank">http://www.csgnetwork.com/righttricalc.html</a><br><br>as a starting point for that <br><br></td></tr></table><br>
<a name="919010"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Drakim</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thank you! This was the stuff I was looking for. Now I have some actual formulas to follow.<br><br>I'll use this thread when I run into other math related problems (which is bound to show up). <br><br></td></tr></table><br>
<a name="919034"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Drakim</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Okay, so, after some thinking, I realized that this approach you described has some problems.<br><img src="http://img241.imageshack.us/img241/7401/97446659rg1.png"><br><br>Here I've drawn how the situation would be. I'd have a height (A), and distance (B) of a camera, and by those values, we can calculate our way to the 3d distance (C) which we use to scale stuff.<br><br>But then I started wondering. What if I want to move the camera upwards? Like, for the camera to ascend up into the sky, without changing any angle? If I changed the height (A) value, then the effect would be that the camera changes it's angle downwards, constantly looking down upon the ground.<br><br>What my demo does (but not well), is allowing you to move the camera's X,Y and Z position, AND adjust it's pitch. <br><br></td></tr></table><br>
<a name="919039"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ima747</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> if you ascend into the sky (increase A) and B remains the same, then C will increase, giving you the apropriate distance and from the distance you can calculate the scale, the angle makes no difference to the scale the element should be drawn at. HOWEVER if the element is below the camera view it shouldn't be drawn at all... i.e. your height is going to determine how much of the ground directly bellow you is visible, and by extension how FAR an object has to be to be seen.<br><br>for example. If you are looking straight ahead you can't see your feet. If you were looking at a 90 degree angle downwards however you'd be looking straight at your feet. the scale your feet would be weather you can see them or not doesn't change, only whether they fall within your field of view based on the angle of your head.<br><br>Expanding on that example, if your head were at a 45% downward angle, your feet would be the same size, but still out of your field of vision. If you were to crouch down however then your toes would come into view because their scale relative to your view point would change.<br><br>Throughout all of that your feet are in the same place as is your head (along X and Y of the floor plane), and your altitude, and by extension their scale, only change when you crouch down.<br><br>Essentially when you move your head you move the View Port (not to be confused with the view point). If everything is drawn relative to the view port then anything falling off the screen is out of your view and isn't drawn (things behind you, things bellow you if you're not looking down far enough, or things in front of you if you're looking down too far). Regardless their scale is just a factor of their distance from the view point to them.<br><br>Hope that made sense... <br><br></td></tr></table><br>
<a name="919045"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Drakim</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ah, yes, that's true.<br><br>Still, I still have some trouble understanding everything here.<br><br>For example, if one wanted to see the map completely, with no pitch (like the second picture on this page, square one), then what values would you have to give to A and B? <br><br></td></tr></table><br>
<a name="919046"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MGE</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Let's see a demo! :) <br><br></td></tr></table><br>
<a name="919055"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ima747</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> If you wanted to see the whole map straight down if you will, like picture 2, first frame.<br><br>the view point postion as well as the target position would both be the center of the ground picture. B would be 0, as you would be looking at the same place (x/y speaking) that you are, and A would have to be a height sufficient to scale the whole map to fit on the screen. and then crucially the pitch would have to be 90 degrees forward, to be looking straight down (see the above example where you can look at your own feet by tilting your head) <br><br></td></tr></table><br>
<a name="919059"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Drakim</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> MGE:<br>I don't have the source here, and I won't for several days I'm afraid. But I'm trying to build a new one based on these specifications.<br><br>ima747:<br>Hmm, buuuut....<br><br>Perhaps I'm confused, but isn't B the direct sky length from camera to any object? (and thus not something you can simply set to 0)<br><br>Could we try to use more down to earth terms, like camera x and y positions?<br><br>And at the end of your post, you start talking about the pitch being 90 degrees. But none of the math or examples we talked about earlier in your solution has any value named "pitch". It's simply A and B, and C which is their result. <br><br></td></tr></table><br>
<a name="919083"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ima747</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> correct, B is the "sky length" if you will, or the 2 dimensional distance from the view point to the object you're trying to focus on. When trying to focus on the ground you're trying to focus on the ground directly bellow the view point, so the distance of B is 0 since the difference in X and Y along the sky/ground plane is 0.<br><br>Pitch wasn't mentioned before because we were only talking about scale, which is only a function of distance. The further something is the smaller it is, the closer, the larger. Something's scale is independent of weather or not it is visible... i.e. if something is 10 feet infront of you, it's the same visual size as if it were 10 feet behind you, but if it's behind you it's out of your view port and therefore you can't see it. Pitch affects the view port, not the scale.<br><br>When I say pitch I mean the same as your second picture frames 2 and 3, "some pitch" and "more pitch". Pitch, Roll, and Yaw are the rotations of an object, in the same way that an object in 3 dimensions can be described with height, width and depth.<br><br>Pitch is the up-down tilt. Like tilting your head back to look up, or forward to look down.<br><br>Roll is the horizontal pitch if you will. Like tilting your head to the side so your ears are pointing to the cieling and the floor. Roll is not used in mode 7, but you could simulate it by rotating your final image before displaying it if you really wanted it...<br><br>Yaw is the side to side rotation. Like turning your head left or right. You will use that to determine how to rotate images before creating the mode 7 background, and also the yaw of one object relative to another will determine which angle image you need to display for it.<br><br>Rotations are around a circle, so 360 degrees to go full circle. So pitching your head forward 90 degrees would be looking straight down, pitching it back 90 would be straight up. Forward 45 degrees would be looking at the ground infront of you. 180 degrees forward or back would have you upside down looking behind yourself. 360 degrees either direction is the same as 0, and has you looking straight ahead.<br><br>Lets see if I can re-state the way you get an overhead view (picture 2, "no pitch". Which is actually 90 degrees of pitch...) First your camera X and camera Y are at world 0, the dead center of the ground. Then your pitch is 90 degrees forward so instead of looking at the horizon (which would be 0 degrees) it's looking straight down. the point it's looking at is world 0 as well so that's why B is 0, there's no difference in the 2d plane between where the camera is and where it's looking. The only difference is A, the height of the camera (camera Z if we're sticking with 2d based coordinates) which will determine how far away from the ground the camera is, which since B = 0, then C will be the same as A, because there's no 2d distance making the math all complicated, ( A squared + B squared = C squared still works to figure out C, so you don't need a new equation or anything ) and as we discussed before, scale is relative to distance (C) so you scale the whole of the ground based on that and you're done. <br>The end result is if you're looking straight down, and you're 2 feet off the ground, you're going to get a close up of some grass, if you're 200 feet off the ground you may see empty space around the ground because it's so far away, depending on your scale factor that is.<br><br>If I haven't mentioned before, generally the ground graphic is MUCH bigger than the screen resolution... because you don't want it to be massively pixellated when you're close to it (say just above the ground following a go kart...) <br><br></td></tr></table><br>
<a name="919236"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Drakim</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ah, I get it now. Thank you. ^_^<br><br>What I think my old code did, was calculating my way to C without A and B, but another hacky method. It looked okay at some values, but if you went far out or close up, it was pretty obvious that the distance formula wasn't correct. <br><br></td></tr></table><br>
<a name="919280"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Drakim</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Okay, I'm well into the code now, and, I'm starting to wonder, is the formula really:<br>sqr( (Height * Height) + (2Ddistance + 2Ddistance) ) = 3D distance<br><br>Considering that you described the formula more abstractly as:<br>A squared + B squared = C squared<br><br>I don't see why you use Height*Height but only 2Ddistance+2Ddistance. Where do you get the difference in the above simplified formula? Aren't both supposed to be multiplied?<br><br>Edit: Also, things aren't going too well. I just can't seem to put this math into use like it's supposed to. Scaling the sprite objects is easy enough, but when it comes to the map itself, I'm lost.<br><br>You talked as if you had done something like this before. You don't happen to have the source for that, for me to look at? <br><br></td></tr></table><br>
<a name="919313"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Karja</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just a quick comment: yep, it should be 2Ddistance*2Ddistance, as far as I can tell. Pythagorean theorem, and all that.<br><br>Good luck getting it all into shape! <br><br></td></tr></table><br>
<a name="919316"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ima747</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> yea, my bad, typo there, 2d * 2d... Karja to the rescue! <br><br></td></tr></table><br>
<a name="919318"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ima747</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sadly I have no source as I made it in C about 8 or 9 years ago... and it was awful.<br><br>Where are you getting lost on the ground? base scale, pitch, etc? <br><br></td></tr></table><br>
<a name="919349"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Drakim</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hm, let's see. How exactly am I to get the 2d distance? Because, as we see in any pitched image (such as the second image, frame 3), the distance varies depending on where on the camera display the object stands on.<br><br>If there was a tree just right at the bottom, it would be pretty big. If it was just at the horizon, it should be small.<br><br>Yet, in my code right now, I'm not pretty sure I don't take this into account, I simply just use the camera position, which is a simple x,y position. <br><br></td></tr></table><br>
<a name="919396"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MGE</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> How would rotate for turns, etc? Hell.. I'm not doing any math or anything, just rendering segments larger than the next. In my stoopid demo you can use the arrow keys left/right/up/down but I think all I coded was something like the floor in Street Fighter. lol.. Maybe could be used for platform game though. lol.<br><br><a href="http://jgoware.com/mge/testm7.exe" target="_blank">http://jgoware.com/mge/testm7.exe</a> <br><br></td></tr></table><br>
<a name="919411"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Why would you try to fake a three dimensional view of a plane when you can actually get the hardware to look at a plane three dimensionally with proper perspective for you? You don't need to even think about the math involved or drawing it in segments or strips.<br><br>All you need to do is write a bit of your own OpenGL or DX code. It just needs to set up a perspective projection in the projection matrix (instead of the standard Orthographic projection), then rotate the modelview matrix around the x and y axis as needed (ie push it forward 90 degrees in y) and maybe translate it so that you can move around the landscape, and then draw all of your objects as normal, even with normal Max2D drawimage commands.<br><br>The hardware will take care of the perspective projection/translation and scaling and rotation like it's supposed to. How to do Mode7 properly is to realize that mode7 came along as a very early form of texturemapping, before you really had proper rotatable matrices and all that hardware jazz. We have WAY moved on since then. Now all you need to do is draw quads on a ground plane. <br><br></td></tr></table><br>
<a name="919420"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rone</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> All you need is miniB3d...just disable texture filtering for a great oldschool look:<br><br><br><img src="http://www.ronecon.com/smc.png"> <br><br></td></tr></table><br>
<a name="919428"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ima747</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> The point of doing this with emulated mode 7 is just to do it I think. It would be much much easier to just use a real 3d engine but just because it doesn't make sense doesn't mean it can't be done ;0)<br><br><br>If you're talking about the distance of the ground at say 45 degrees of pitch, that's where slicing the ground up comes into play. you need the distance to each slice, and then you scale that slice...<br><br>MGE can you post your code? It looks like you're close except it looks like it's scaling the ground rather than moving when you press foward etc. I'm curious :0)<br><br>That's all that needs to be done for the distance calculation is scale each slice based on how far away it is.<br><br>As for rotation, you need to rotate the image then takes slices from it's rotation. So if you're facing straight forward, or north if you will, across the track, there's no rotation, you just slice it horizontally and you're set. If you want to turn the camera to the right, you actually rotate the ground to the left since the camera can't move, since it's not really a camera, just a point off which you reference other things to do your drawing. Once you turn the ground you then slice the rotated image. Reference the first frame of the first picture, first post. The lines are on an angle. If you open that in a pain program and rotate it so that the lines are horizontal, that is the rotation the ground would be when you took those slices.<br><br><br>Rone's pictures are what you could expect to get from a real 3D engine in practically no time, and it would be hardware accelerated, but I still like the masocism of doin it "old school" :0) <br><br></td></tr></table><br>
<a name="919452"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> here see if this help:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict
Type MODE_7_PARAMS

    Field space_z:Double 				' this is the height of the camera above the plane
    Field horizon:Int;				' this is the number of pixels line 0 is below the horizon
    Field scale_x:Double, scale_y:Double 	' this determines the scale of space coordinates
    								' To screen coordinates
End Type

Function mode_7 (bmp:TPixmap, tile:TPixmap, angle:Double, cx:Double, cy:Double, params:MODE_7_PARAMS)

    ' current screen position
    Local screen_x:Int, screen_y:Int

    ' the distance And horizontal scale of the line we are drawing
    Local  distance:Double, horizontal_scale:Double

    ' masks To make sure we don't read pixels outside the tile
    Local mask_x:Int = (tile.width - 1);
    Local mask_y:Int = (tile.height - 1);

    ' Step For points in space between two pixels on a horizontal line
    Local line_dx:Double, line_dy:Double;

    ' current space position
    Local space_x:Double, space_y:Double;

    For screen_y = 0 Until bmp.height
    
        ' first calculate the distance of the line we are drawing
        distance = (params.space_z * params.scale_y) /..
            (Double(screen_y) + Double(params.horizon))
        ' Then calculate the horizontal scale, Or the distance between
        ' space points on this horizontal line
        horizontal_scale = (distance / params.scale_x);

        ' calculate the dx And dy of points in space when we Step
        ' through all points on this line
        line_dx =  (-Sin(angle) * horizontal_scale);
        line_dy =  (Cos(angle) * horizontal_scale);

        ' calculate the starting position
        space_x = cx + (distance * Cos(angle)) - bmp.width/2 * line_dx;
        space_y = cy + (distance * Sin(angle)) - bmp.width/2 * line_dy;

        ' go through all points in this screen line
        For screen_x = 0 Until bmp.width
        
            ' get a pixel from the tile And put it on the screen
           WritePixel (bmp, screen_x, screen_y,..
                ReadPixel (tile,..
                    Int(space_x) &amp; mask_x,..
                    Int(space_y) &amp; mask_y));
            ' advance To the Next position in space
            space_x :+ line_dx;
            space_y :+ line_dy;
        Next
    Next
End Function


Local par:MODE_7_PARAMS = New MODE_7_PARAMS

par.space_Z = 200
par.horizon = 02
par.scale_x = 512
par.scale_y = 512
Global tile:TPixmap 
Tile = LoadPixmap("desert2.png")
Graphics 256,256
Local buffer:TPixmap = CreatePixmap(tile.width,tile.height,Tile.format)
Local ang:Float =0
Local cx:Float = 0
Local cy:Float = 0
Repeat
	Cls
	mode_7(buffer,Tile,ang,cx,cy,par)
	DrawPixmap buffer,0,0
	ang = (ang-.5) Mod 360
	cx = (cx+1) Mod 2048 '
	cy = (cy-1) Mod 2048
	Flip()
Until KeyDown(key_escape)
</textarea><br> use a base 2 square image <br><br></td></tr></table><br>
<a name="919461"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> self made tiles:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

Rem MODE_7_PARAMS is a struct containing all the different parameters
that are relevant For Mode 7, so you can pass them To the functions
as a single unit 

End Rem

Type MODE_7_PARAMS

    Field space_z:Float; ' this is the height of the camera above the plane
    Field horizon:Int; ' this is the number of pixels line 0 is below the horizon
    Field scale_x:Float 
    Field scale_y:Float; ' this determines the scale of space coordinates
    ' To screen coordinates
    Field obj_scale_x:Float
    Field obj_scale_y:Float ' this determines the relative size of
    						' the objects
End Type 

Rem 
draw_object just draws a single Object at a fixed position, although
this can easily be modified To allow For more objects.
bmp = bitmap To draw To. obj = sprite For the Object.
angle, cx, cy define the camera position.
End Rem
Function  draw_object (bmp:TPixmap, obj:TPixmap, angle:Float, cx:Float, cy:Float, params:MODE_7_PARAMS)

    Local width:Int, height:Int
    Local screen_y:Int, screen_x:Int;

    ' The Object in this Case is at a fixed position of (160, 100).
    ' Calculate the position relative To the camera.
    Local obj_x:Float = 160 - cx;
    Local obj_y:Float = 100 - cy;

    ' use a rotation transformation To rotate the Object by the camera
    ' angle
    Local space_x:Float =  (obj_x * Cos (angle)) + (obj_y * Sin (angle));
    Local space_y:Float = -(obj_x * Sin (angle)) + (obj_y * Cos (angle));

    ' calculate the screen coordinates that go with these space coordinates
    ' by dividing everything by space_x (the distance)
    screen_x = bmp.width/2 + Int (((params.scale_x / space_x) * space_y));
    screen_y = Int(((params.space_z * params.scale_y) / space_x)) - params.horizon;

    ' the size of the Object has To be scaled according To the distance
    height = Int(obj.height * (params.obj_scale_y / space_x));
    width = Int(obj.width *  (params.obj_scale_x / space_x));

    ' draw the Object
	Local img:timage = LoadImage(obj)
    DrawImageRect(img, screen_x - width / 2, screen_y - height, width, height);
End Function

Function  mode_7 (bmp:TPixmap, tile:TPixmap, angle:Float, cx:Float, cy:Float, params:MODE_7_PARAMS)

    ' current screen position
    Local screen_x:Int, screen_y:Int;

    ' the distance And horizontal scale of the line we are drawing
    Local distance:Float, horizontal_scale:Float

    ' masks To make sure we don't read pixels outside the tile
    Local mask_x:Int = (tile.width - 1);
    Local mask_y:Int = (tile.height - 1);

    ' Step For points in space between two pixels on a horizontal line
    Local  line_dx:Float, line_dy:Float;

    ' current space position
    Local space_x:Float, space_y:Float;

    For screen_y = 0 Until bmp.height
    
        ' first calculate the distance of the line we are drawing
        distance = ((params.space_z * params.scale_y) / Float(screen_y + params.horizon));
        ' Then calculate the horizontal scale, Or the distance between
        ' space points on this horizontal line
        horizontal_scale = (distance / params.scale_x);

        ' calculate the dx And dy of points in space when we Step
        ' through all points on this line
        line_dx = (-Sin(angle) * horizontal_scale);
        line_dy = (Cos(angle) * horizontal_scale);

        ' calculate the starting position
        space_x = cx + (distance * Cos(angle)) - bmp.width/2 * line_dx;
        space_y = cy + (distance * Sin(angle)) - bmp.width/2 * line_dy;

        ' go through all points in this screen line
        For screen_x = 0 Until bmp.width
        
            ' get a pixel from the tile And put it on the screen
            WritePixel(bmp, screen_x, screen_y,..
                ReadPixel (tile,..
                    Int(space_x) &amp; mask_x,..
                    Int(space_y) &amp; mask_y ));
            ' advance To the Next position in space
            space_x :+ line_dx;
            space_y :+ line_dy;
        Next
    Next
End Function

Function  test_mode_7 ()

    Local params:MODE_7_PARAMS
    Local tile:TPixmap , sprite:TPixmap, buffer:TPixmap
    'pal:PALETTE 
    Local quit:Int = False;
    Local angle:Float = 0.0
    Local x:Float = 0, y:Float = 0;
    Local  dx:Float = 0, dy:Float = 0;
    Local speed:Float = 0;
    Local i:Int, j:Int, r2:Int;
    params = New MODE_7_PARAMS
    params.space_z = 50;
    params.scale_x = 200.0
    params.scale_y = 200.0
    params.obj_scale_x = 50.0
    params.obj_scale_y = 50.0;
    params.horizon = 20;

    ' To afunction  flicker the program makes use of a Double-buffering system
    buffer = CreatePixmap (GraphicsWidth(), GraphicsHeight(),PF_RGBA8888);
    ' Create a 64x64 tile bitmap And draw something on it.
    tile = CreatePixmap (64, 64,PF_RGBA8888);
    For i = 0 Until 32
    
        For j = i Until 32
        
            WritePixel (tile, i, j, $ff000000 |(i*200));
            WritePixel (tile, i, 63-j, $ff000000|(i*200));
            WritePixel (tile, 63-i, j, $ff000000|(i*200));
            WritePixel (tile, 63-i, 63-j,$ff000000|(i*200));
            WritePixel (tile, j, i, $ff000000|(i*200));
            WritePixel (tile, j, 63-i,$ff000000|(i*200));
            WritePixel (tile, 63-j, i, $ff000000|(i*200));
            WritePixel (tile, 63-j, 63-i, $ff000000|(i*200));
        Next
    Next
 
    ' Create another bitmap And draw something To it.
    ' This bitmap contains the Object.
    sprite = CreatePixmap(64, 64,PF_RGB888);
    'clear (sprite);
    For i = 0 Until 64
        For j = 0 Until 64
            r2 = (32 - i) * (32 - i) + (32 - j) * (32 - j);
            If (r2 &lt; 30 * 30)
                r2 = (24 - i) * (24 - i) + (24 - j) * (24 - j);
                WritePixel (sprite, i, j, 127 - Int(Sqr((r2))));
            EndIf
        Next
    Next
Rem
    ' Create a palette
    ' colors For the tiles
    For i = 0 Until 64
        pal[i].r = i;
        pal[i].g = i;
        pal[i].b = 0;
    Next
    ' colors For the Object
    For i = 0 Until 32
        pal[i+64].r = 0;
        pal[i+64].g = 0;
        pal[i+64].b = 2 * i;
        pal[i+96].r = 2 * i;
        pal[i+96].g = 2 * i;
        pal[i+96].b = 63;
    Next
    set_palette (pal);
EndRem
    While (Not quit)
    	   Cls()
        ' act on keyboard Input
        If (KeyDown(KEY_ESCAPE)) quit = True;
        If (KeyDown(KEY_UP) And speed &lt; 5) speed :+ 0.1
        If (KeyDown(KEY_DOWN) And speed &gt; -5)  speed :- 0.1
        If (KeyDown(KEY_LEFT))angle = Int(angle - 3) &amp; $FFFFFF;
        If (KeyDown(KEY_RIGHT)) angle = Int(angle + 3) &amp; $FFFFFF;
        If (KeyDown(KEY_Z)) params.space_z :+ 5
        If (KeyDown(KEY_X)) params.space_z :- 5
        If (KeyDown(KEY_Q)) params.scale_x = (params.scale_x * 1.5);
        If (KeyDown(KEY_W)) params.scale_x = (params.scale_x / 1.5);
        If (KeyDown(KEY_E)) params.scale_y = (params.scale_y * 1.5);
        If (KeyDown(KEY_R)) params.scale_y = (params.scale_y / 1.5);
        If (KeyDown(KEY_H)) params.horizon :+ 1
        If (KeyDown(KEY_J)) params.horizon :-1
	  
        dx =  (speed * Cos (angle));
        dy =  (speed * Sin (angle));

        x :+ dx;
        y :+ dy;

        mode_7 (buffer, tile, angle, x, y, params);
	   DrawPixmap (buffer, 0, 0)
        draw_object (buffer, sprite, angle, x, y, params);
	   
	   DrawText "ESC    - quits", 10,10
	   DrawText "Arrows - move",10,25
	   DrawText "z,x height ",10,40
	   DrawText "q,w scale x",10,55
	   DrawText "e,r scale y",10,70
	   DrawText "h,j horizon",10,85          

	   Flip()
    Wend
End Function



Graphics 640,480

test_mode_7 ();
</textarea><br>find the ball :) <br><br></td></tr></table><br>
<a name="919469"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MGE</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> Damn impressive! Now, let's see that ball move around a track. :) <br><br></td></tr></table><br>
<a name="919569"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> updated to include a tile map and multiple tile use:<br><img src="http://img113.imageshack.us/img113/7607/mode7vh8.png"><br>warning it is really slow need a bit of optimization.<br>you can get the source from my signature link.<br><br>[edit]<br>you can get the tutorial for it in the Pixelate Magazine for Allegro.<br>download the complete magazine including source code:<br><a href="http://pixwiki.bafsoft.com/mags/5.zip" target="_blank">http://pixwiki.bafsoft.com/mags/5.zip</a> <br>it is in c and easy to understand. <br><br></td></tr></table><br>
<a name="919718"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Drakim</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thank you everybody. With all this information and examples, I'm pretty confident that I can do it. <br><br></td></tr></table><br>
<a name="920151"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Drakim</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi guys, I have a question about scaling:<br><br><div class="quote"> <br>sqr( (Height * Height) + (2Ddistance * 2Ddistance) ) = 3D distance<br>(distance/DistanceAtWhichStuffIs1to1scale) = Scale Percent<br> <br></div><br><br>let's try with this example. You are 300 in distance from an object, and 100 in distance above it. Stuff scales at 200.<br><br>sqr((100*100)+(300*300)) = 316<br>316/200= 1.58 (Scale Percent)<br><br>But now, let's try it again. You are 600 in distance from an object, and 100 in distance above it. <br><br>sqr((100*100)+(300*300)) = 608<br>608/200= 3.04 (Scale Percent)<br><br>So, something is obviously wrong. The further you get away from the object, the larger it's scale percent becomes. That's not right.<br><br>What am I doing wrong? <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
