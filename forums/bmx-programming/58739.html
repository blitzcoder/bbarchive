<!DOCTYPE html><html lang="en" ><head ><title >Aurora And BlitzNet Online docs.</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Aurora And BlitzNet Online docs.</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Aurora And BlitzNet Online docs.</a><br><br>
<a name="653539"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AntonyWells</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here's online docs for both aurora and BlitzNet, covering every class/constant and some general stuff.<br><br>The docs are generated by the Aurora doc system I uploaded recently. It generates docs from specially formatted text files in about 1 second for each doc.<br><br><br>Aurora 3D Engine Docs:<br><br><a href="http://dreamspace.banishedstudios.com/AuroraDocs/index.html" target="_blank">http://dreamspace.banishedstudios.com/AuroraDocs/index.html</a><br><br>BlitzNet Optica Docs:<br><br><a href="http://dreamspace.banishedstudios.com/docs/index.html" target="_blank">http://dreamspace.banishedstudios.com/docs/index.html</a> <br><br></td></tr></table><br>
<a name="653553"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AntonyWells</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Auroras docs have been updated to include more information and method/function examples. <br><br></td></tr></table><br>
<a name="653576"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Beaker</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Why the crazy indented layout? <br><br></td></tr></table><br>
<a name="653580"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AntonyWells</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> No love for the mo fos here? I like 'em.<br><br>And more to the point it's just about the only menu system i could come up with in html. I'm a total newb. <br><br></td></tr></table><br>
<a name="653585"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Damien Sturdy</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> It doesn't indent properly does it? :D <br><br></td></tr></table><br>
<a name="653660"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AntonyWells</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> oh that's cos i havn't used the preserve formatting tag yet. i'll improve the look some more tomorrow. the great thing about an auto-doc generator is you can make a few changes and beautify the whole system in one compile <br><br></td></tr></table><br>
<a name="653662"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> I would suggest using a frame for the core structure and only show the classes part right. <br>You might check OGRE API page or any DoxyGen /Javadoc created page on how presenting OO code should be ... <br><br></td></tr></table><br>
<a name="653669"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AntonyWells</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well the big difference between this and doxygen is doygen took years to develope. this took two afternoons and a thoushand lines of code<br><br>Here's the full &lt;Open_Source&gt; code to the doc generator/viewer<br><br><pre class=code>
'
'Doc Gen 2006
'
'(C)Antony Wells 2006
Strict
Type TBody
	Field con:TList
	Method New()
		con = CreateList()
	End Method
	Method AddString( str:String )
		con.addlast( str )		
	End Method
	Method Close()
	End Method
	
	Field name:String
	Field Node:TGadget
End Type

Type TBase
	Field con:Tlist
	Method New()
		con = CreateList()
		bodies = CreateList()
	End Method
	Method AddString( str:String )
		con.addlast( str )
	End Method
	Method AddBody:TBody( name:String )
		Local nb:TBody = New TBody
		nb.name = name
		bodies.addlast( nb )
		Return nb
		
	End Method
	Method close()
	End Method
	Field Node:TGadget
	Field Bodies:TList
	Field name:String
End Type


Type TFunction Extends TBase

End Type

Type TMethod Extends TBase

End Type



Type TType 
	Method New()
		Methods = New Tlist
		Functions = New TList
		bodies = CreateList()
	End Method
	Method AddFunction:TFunction( name:String )
		Local nf:TFunction = New TFunction 
		functions.addlast( nf )
		nf.name = name
		Return nf
	End Method
	Method AddMethod:TMethod( name:String )
		Local nm:TMethod = New TMethod
		methods.addlast( nm )
		nm.name = name
		Return nm
	End Method
	Method AddBody:TBody( name:String )
		Local nb:TBody = New TBody
		nb.name = name
		bodies.addlast( nb )
		Return nb
		
	End Method
	Method close()
	End Method
	Field Node:TGadget
	Field name:String	
	Field Bodies:TList
	Field Methods:TList
	Field Functions:TList
End Type


Type TDoc
	
	Method New()
		
		Types = CreateList()
		Bodies = CreateList()
		
	End Method
	
	Method AddType:TType( name:String )
		Local nt:TType = New ttype
		nt.name = name
		Types.addlast( nt )
		Return nt
	End Method
	
	Method AddBody:TBody( name:String )
		Local nb:TBody = New TBody
		nb.name = name
		bodies.addlast( nb )
		Return nb
	End Method
	
	Function Load:TDoc( file:String )
	
		Local out:TDoc = New Tdoc
		out.LoadFile( file )
		Return out
			
	End Function
	
	Method Reset()
	End Method
	Method TokS:String( index )
		Return String( ActiveToke.valueatindex( index ) ).tolower()
	End Method
	
	Method TokN:String( index )
		Return String( ActiveToke.valueatindex( index ) )
	End Method
	
	Method TokAll:String( from )
		
		Local txt:String
		For Local j=from Until CountList( activetoke )
			txt:+String( activetoke.valueatindex( j ) )
		Next
		Return txt
			
	End Method
	
	Field ActiveToke:TList
	Method LoadFile( file:String )
	
		Reset()
		Local fi:TStream = ReadFile( file )
		If fi = Null
			RuntimeError "Unable to open doc file."
		End If
		Local T:Tokenizer = New Tokenizer
		Local OpenT:TType,OpenCall:TBase,OpenBody:TBody
		While Not Eof( fi )
			
			Local l:String = ReadLine( fi )
			'Print l
			Local tokes:Tlist = t.parse( l )
			
			If CountList( tokes ) = 0 Continue
			ActiveToke = Tokes
			Print l
			Select TokS( 0 )
			
				Case "["
					Select Toks(1)
						Case "type"
							Print "New Type:"+TokN( 3 )
							If OpenBody &lt;&gt;Null
								OpenBody.Close()	
								OpenBody = Null
							EndIf
							
							OpenT = AddType( tokn(3) )
						Case "endtype"
							Print "End Type"
							If OpenT&lt;&gt;Null	
								OpenT.Close()
							End If
							If OpenBody&lt;&gt;Null
								OpenBody.close()
								OpenBody = Null
							End If
							If OpenCall&lt;&gt;Null
								OpenCall.Close()
								OpenCall = Null
							End If
							OpenT = Null
						Case "function"
							If OpenT = Null
								RuntimeError "Doc Maker supports Class libraries only."
								End
							End If
							If OpenBody&lt;&gt;Null
								OpenBody.Close()
								OpenBody = Null
							End If
							If OpenCall&lt;&gt;Null
								OpenCall.Close()
							End If
							OpenCall = OpenT.AddFunction( tokn(3) )
							OpenBody = OpenCall.AddBody( "Function "+tokall(3) )	
							Print "New function:"+tokn(3)
							
						Case "method"
							If OpenT = Null
								RuntimeError "Doc Maker supports Class libraries only."
								End
							End If
							If OpenBody&lt;&gt;Null
								OpenBody.Close()
								OpenBody = Null
							End If
							If OpenCall&lt;&gt;Null
								OpenCall.Close()
							End If
							OpenCall = OpenT.AddMethod( tokn(3) )
							OpenBody = OpenCall.AddBody( "Method "+tokall(3) )	
							Print "New Method :"+tokn(3)
						Case "body"
						
							If OpenT = Null
								If OpenBody &lt;&gt;Null
									OpenBody.Close()
									OpenBody = Null
								End If
								OpenBody = AddBody( TokN(3) )
								Print "Added Misc Body:"+tokn(3)
							Else
							
								If OpenCall = Null
									OpenBody = OpenT.AddBody( Tokn(3) )
									Print "Added Type Body:"+tokn(3) 
								Else
									Print "Added Call Body:"+tokn(3)
									OpenBody = OpenCall.AddBody( tokn(3) )
								EndIf
							EndIf
							
					End Select
					
				Case "]"	
					Print "Error:"+L
					RuntimeError "Syntax error:"+l
				Default
					Print "Line:"+Trim(l)
					If OpenBody&lt;&gt;Null
						OpenBody.AddString( l )
					Else
						RuntimeError "Syntax error:"+l
					End If
			End Select
			
		Wend 
		
	End Method

	Field Types:tlist
	Field Bodies:TList 

End Type

Type TDoc2HTml
	
	Global ad:Tdoc
	Global fold:String
	
	Function Do( in:Tdoc,folder:String )
	
		ad = in
		If FileType(folder)=0
			CreateDir( folder )
		EndIf
		fold = folder
		GenerateIndex()
		GenerateBodies()
	
	End Function
	
	Function GenerateBodies()
		
		For Local tb:Tbody = EachIn ad.bodies
			'	thml.itemhead()
				'thml.text( tb.name )
			'	thml.LinkHead( tb.name+".html" )
			'	thml.text( tb.name )
			'	thml.linkfoot()
			'	thml.itemfoot()
			thml.write( safename(fold+tb.name+".html") )
			thml.header( "Aurora Docs:"+tb.name )
			thml.bodyhead()
			thml.headhead(3,"center")
			thml.text("Aurora Online Api Reference")
			thml.headfoot(3)
			thml.headhead(5,"center")
			thml.text(tb.name)
			thml.headfoot(5)
			thml.linkHead("index.html")
			thml.text("Back to index.")
			thml.linkfoot()
			WriteBody ( tb,"General Guide" )
			thml.close()
		Next
		For Local t:TType = EachIn ad.types
			For Local tb:TBody = EachIn t.bodies
				thml.write( safename(fold+t.name+tb.name+".html") )
				thml.header( "Aurora Docs:"+t.name+":"+tb.name )
				thml.bodyhead()
				thml.headhead(3,"center")
				thml.text("Aurora Online Api Reference")
				thml.headfoot(3)
				thml.headhead(5,"center")
				thml.text(t.name+":"+tb.name)
				thml.headfoot(5)
				thml.linkHead("index.html")
				thml.text("Back to index.")
				thml.linkfoot()
				WriteBody ( tb,"Type Guide" )
				thml.close()
				
			Next
			
			For Local m:Tmethod = EachIn t.methods
				For Local tb:TBody = EachIn m.bodies
					thml.write( safename(fold+t.name+m.name+tb.name+".html"))
					thml.header( "Aurora Docs:"+tb.name )
					thml.bodyhead()
					thml.headhead(3,"center")
					thml.text("Aurora Online Api Reference")
					thml.headfoot(3)
					thml.headhead(5,"center")
					thml.text(t.name+":"+m.name+":"+tb.name)
					thml.headfoot(5)
					thml.linkHead("index.html")
					thml.text("Back to index.")
					thml.linkfoot()
					WriteBody ( tb,"Method" )
					thml.close()
				Next
			Next
			
			For Local f:Tfunction = EachIn t.functions
				For Local tb:Tbody = EachIn f.bodies
					thml.write( safename(fold+t.name+f.name+tb.name+".html"))
					thml.header( "Aurora Docs:"+tb.name )
					thml.bodyhead()
					thml.headhead(3,"center")
					thml.text("Aurora Online Api Reference")
					thml.headfoot(3)
					thml.headhead(5,"center")
					thml.text(t.name+":"+f.name+":"+tb.name)
					thml.headfoot(5)
					thml.linkHead("index.html")
					thml.text("Back to index.")
					thml.linkfoot()
					WriteBody ( tb,"Function" )
					thml.close()
				Next
			Next
			
		Next
		

		
		
	End Function
	
	Function WriteBody( in:Tbody,btype:String )
		
		thml.TableHead( 4 )
			thml.RowHead()
				thml.datahead()
					thml.italichead()
					thml.text(btype)
					thml.italicfoot()
				thml.datafoot()
				thml.datahead()
					thml.text(in.name)
				thml.datafoot()
			thml.rowfoot()
			thml.rowhead()
				thml.datahead()
					thml.italichead()
					thml.text("Description")
					thml.italicfoot()					
				thml.datafoot()
				thml.datahead()
					For Local s:String = EachIn in.con 
						thml.text( s )
						thml.break()
					Next	
				thml.datafoot()
			thml.rowfoot()
		thml.tablefoot()
		
	End Function
	
	Function GenerateIndex()
		
		thml.write(	fold+"index.html" )
		thml.header("Aurora Doc System Index")
		thml.bodyhead()
		thml.headhead(3,"center")
		thml.text("Aurora Online API Reference")
		thml.headfoot(3)
		WriteIndex()
		thml.bodyfoot()
		thml.footer()
		thml.close()
		
	End Function
	
	Function WriteIndex()
	
		thml.listhead()
			'---Write Types
			
			For Local t:TType = EachIn ad.types
				thml.itemHead()
				thml.text(t.name)
				thml.listhead()
				thml.itemhead()
				thml.text("General")
				thml.listhead()
				For Local tb:TBody = EachIn t.bodies
					thml.itemhead()
					thml.LinkHead( safename(t.name+tb.name+".html") )
					thml.text( tb.name )
					thml.linkfoot()
					thml.itemfoot()
				Next
				thml.listfoot()
				thml.itemfoot()
				thml.itemHead()
				thml.text("Methods")
				thml.listhead()
				For Local m:tmethod = EachIn t.methods
					thml.itemHead()
					thml.text( m.name )
					thml.listhead()
					For Local tb:TBody = EachIn m.bodies
						thml.itemhead()
						thml.linkhead( safename(t.name+m.name+tb.name+".html") )
						thml.text( tb.name )
						thml.linkfoot()
						thml.itemfoot()
					Next
					thml.listfoot()
					thml.itemfoot()
				Next
				thml.listfoot()
				thml.itemfoot()
			
				thml.itemHEad()
				thml.text("Functions")
				thml.listhead()
				For Local f:Tfunction = EachIn t.functions
					thml.itemHead()
					thml.text( f.name )
					thml.listhead()
					For Local tb:Tbody = EachIn f.bodies
						thml.itemhead()
						thml.linkhead( safename(t.name+f.name+tb.name+".html") )
						thml.text( tb.name )
						thml.linkfoot()
						thml.itemfoot()
					Next
					thml.listfoot()
					thml.itemfoot()
				Next
				thml.listfoot()
				thml.itemfoot()
				thml.itemfoot()
				
			Next
			
			
			'---Write General Bodies
			thml.itemHead()
			thml.text("General")
			thml.listhead()
			For Local tb:Tbody = EachIn ad.bodies
				thml.itemhead()
				'thml.text( tb.name )
				thml.LinkHead( safename(tb.name+".html") )
				thml.text( tb.name )
				thml.linkfoot()
				thml.itemfoot()
			Next
			thml.listfoot()
			thml.itemFoot()
		
		thml.listfoot()
	
	End Function
		
	
	

End Type

Local fo:TStream = ReadFile("Quote.txt")
If fo = Null
	Print "No fo mo fo"
	End
End If
Global qMark:String = Chr(ReadByte(fo))
CloseFile fo


Function SafeName:String(in:String)
	Local b:String
	For Local j=1 To Len(in)
		Local c:String = Mid( in,j,1 )
		If c=":"
			c=""
		EndIf
		If c="("
			c=""
		EndIf
		If c=")"
			c=""
		EndIf
		If c=","
			c=""
		End If
		If c=qmark
			c=""
		EndIf
		b:+c
	Next
	Return b
	
	
End Function


Type THml

	Function Write( file:String )
	
		as = WriteFile( file )
		If as = Null 
			Print "File:"+File+" could not be created"
			End
		End If
		
	
	End Function
	
	Function close()
	
		CloseFile as
	
	End Function
	
		
	Global as:TStream
	
	Function SetActiveStream( in:TStream )
		as = in
	End Function
	
	Function TableHead(border = 1)
		WriteLine as,"&lt;table border='"+String(Border)+"'&gt;"
	End Function
	
	Function TableFoot()
		WriteLine as,"&lt;/table&gt;"
	End Function
	
	Function RowHead()
		WriteLine as,"&lt;tr&gt;"
	End Function 
	
	Function RowFoot()
		WriteLine as,"&lt;/tr&gt;"
	End Function 
	
	Function DataHead()
		WriteLine as,"&lt;td&gt;"
	End Function
	
	Function DataFoot()
		WriteLine as,"&lt;/td&gt;"
	End Function
		
	
	Function Header(title:String)
		
		WriteLine as,"&lt;html&gt;"
		WriteLine as,"&lt;head&gt;"
		WriteLine as,"&lt;title&gt;"+title+"&lt;/title&gt;"
		WriteLine as,"&lt;/head&gt;"	
	
	End Function
	
	Function BodyHead()
		WriteLine as,"&lt;body&gt;"
	End Function
	
	Function HeadHead(size:Int,align:String="")
		If align = ""
			WriteLine as,"&lt;h"+String(Size)+"&gt;"
		Else
			WriteLine as,"&lt;h"+String(size)+" align='"+align+"'&gt;"
		EndIf
		
	End Function
	
	Function Break()
		WriteLine as,"&lt;br&gt;"
	End Function
	
	Function StrongHead()
		WriteLine as,"&lt;strong&gt;"
	End Function
	
	Function StrongFoot()
		WriteLine as,"&lt;/strong&gt;"
	End Function
	
	Function BigHead()
		WriteLine as,"&lt;big&gt;"
	End Function
	
	Function BigFoot()
		WriteLine as,"&lt;/big&gt;"
	End Function
	
	Function EmpHead()	
		WriteLine as,"&lt;em&gt;"
	End Function
	
	Function EmpFoot()
		WriteLine as,"&lt;/em&gt;"
	End Function
	
	Function ItalicHead()
		WriteLine as,"&lt;i&gt;"
	End Function
	
	Function ItalicFoot()
		WriteLine as,"&lt;/i&gt;"
	End Function
	
	Function SmallHead()
		WriteLine as,"&lt;small&gt;"
	End Function
	
	Function SmallFoot()
		WriteLine as,"&lt;/small&gt;"
	End Function
	
	Function SubHead()
		WriteLine as,"&lt;sub&gt;"
	End Function
	
	Function SubFoot()
		WriteLine as,"&lt;/sub&gt;"
	End Function
	
	Function SupHead()
		WriteLine as,"&lt;sup&gt;"
	End Function
	
	Function SupFoot()
		WriteLine as,"&lt;/sup&gt;"
	End Function
	
	Function PreHead()
		WriteLine as,"&lt;pre&gt;"
	End Function
	
	Function PreFoot()
		WriteLine as,"&lt;/pre&gt;"
	End Function
	
	Function varHead()
		WriteLine as,"&lt;var&gt;"
	End Function
	
	Function VarFoot()
		WriteLine as,"&lt;/var&gt;"
	End Function
	
	Function acronHead(ac:String)
		WriteLine as,"&lt;acronym title='"+ac+"'&gt;"
	End Function
	
	Function AcronFoot()
		WriteLine as,"&lt;/acronym&gt;"
	End Function
	
	Function QuoteHead()
		WriteLine as,"&lt;blockquote&gt;"
	End Function
	
	Function QuoteFoot()
		WriteLine as,"&lt;/blockquote&gt;"
	End Function
	
	Function LinkHeadTar(html:String,tar:String)
		WriteLine as,"&lt;a href='"+html+"' target='"+tar+"'&gt;"
	End Function
	
	Function LinkHead(html:String)
		WriteLine as,"&lt;a href='"+html+"'&gt;"
	End Function
	
	Function SectionHead(name:String)
		WriteLine as,"&lt;a name='"+name+"'&gt;"	
	End Function
	
	Function FrameSetRow( size:Int[],src:String[],nam:String[])
		
		Local cols = size.length
		Local cs:String
		For Local j=0 Until cols
			If j&gt;0 cs:+","
			cs:+String( size[j] )+"%"
		Next
		
		WriteLine as,"&lt;frameset rows='"+cs+"'&gt;"
		
		For Local j=0 Until cols
			Local txt:String
			txt = "&lt;frame src='"+src[j]+"'"
			If nam[j]&lt;&gt;""
				txt:+" name='"+nam[j]+"'"
			EndIf
			txt:+"&gt;"
			WriteLine as,txt
		Next
		WriteLine as,"&lt;/frameset&gt;"
			
	End Function


	Function ListHead()
		WriteLine as,"&lt;ul&gt;"
	End Function
	
	Function ListFoot()
		WriteLine as,"&lt;/ul&gt;"
	End Function
	
	Function ItemHead()
		WriteLine as,"&lt;li&gt;"
	End Function
	
	Function ItemFoot()
		WriteLine as,"&lt;/li&gt;"
	End Function
	
	
	
	Function FrameSetCol( size:Int[],src:String[],nam:String[])
		
		Local cols = size.length
		Local cs:String
		For Local j=0 Until cols
			If j&gt;0 cs:+","
			cs:+String( size[j] )+"%"
		Next
		
		WriteLine as,"&lt;frameset cols='"+cs+"'&gt;"
		
		For Local j=0 Until cols
			Local txt:String
			txt = "&lt;frame src='"+src[j]+"'"
			If nam[j]&lt;&gt;""
				txt:+" name='"+nam[j]+"'"
			EndIf
			txt:+"&gt;"
			WriteLine as,txt
		Next
		WriteLine as,"&lt;/frameset&gt;"
		
	
	End Function
	
	Function LinkFoot()
		WriteLine as,"&lt;/a&gt;"
	End Function
	
	Function Image(border=0,src:String,width,height,align:String="")
		If align = ""
			WriteLine as,"img border='"+String(border)+"' src='"+src+"' width='"+String(width)+"' height='"+String(height)+"'&gt;"
		Else
			WriteLine as,"img border='"+String(border)+"' src='"+src+"' align='"+align+"' width='"+String(width)+"' height='"+String(height)+"'&gt;"
		EndIf
	End Function
	
		
	
	Function HRule()
		WriteLine as,"&lt;hr&gt;"
	End Function
	
	Function HeadFoot(size:Int)
		WriteLine as,"&lt;/h"+String(size)+"&gt;"
	End Function
	
	Function ParaHead()
		WriteLine as,"&lt;p&gt;"
	End Function 
	
	Function ParaFoot()
		WriteLine as,"&lt;/p&gt;"
	End Function
	
	
	Function Text( txt:String )
		WriteLine as,txt
	End Function
	
	Function BoldText(txt:String)
		WriteLine as,"&lt;b&gt;"+txt+"&lt;/b&gt;"
	End Function
	
	Function BodyFoot()
		WriteLine as,"&lt;/body&gt;"
	End Function
	
	Function Footer()
		WriteLine as,"&lt;/html&gt;"
	End Function
	
	
	

End Type

Type TDocViewer
	Function Create:TDocViewer( view:TDoc )
		viewWin = CreateWindow("Aurora Doc Viewer",20,20,620,500,Null,Window_TitleBar )
		doc = view
		LinkTree = CreateTreeView(2,2,150,460,viewwin)
		'ViewCan = CreateCanvas( 160,2,425,460,viewwin,GRAPHICS_BACKBUFFER)
		viewCan = CreateTextArea(160,2,435,460,viewwin,TEXTAREA_WORDWRAP|TEXTAREA_READONLY )
		
		BuildTree()
	End Function
	
	Function Log( txt:String )
	
		Local mbuf:Byte Ptr = MemAlloc( Len(txt)+1 )
		Local mstr:tramstream = CreateRamStream( mbuf,Len(txt)+1,True,True )
		WriteLine mstr,txt
		Local ntxt:String = ""
		For Local j=0 Until Len(txt)+1
			ntxt:+Chr( mbuf[j] )
		Next
		
		AddTextAreaText viewcan,ntxt
		'Print txt
		MemFree mbuf
		CloseStream mstr
		
	End Function
	
	Function FindBody:Tbody(in:tgadget)
		
		For Local TB:TBody = EachIn doc.bodies
			If tb.node = in Return tb
		Next
		For Local TT:TType = EachIn doc.types
			For Local TB:TBody = EachIn tt.bodies
				If tb.node = in Return tb
			Next
			For Local m:TMethod = EachIn tt.methods
				For Local tb:tbody = EachIn m.bodies
					If tb.node = in Return tb 
				Next
			Next
			For Local f:TFunction = EachIn tt.functions
				For Local tb:TBody = EachIn f.bodies
					If tb.node = in Return tb
				Next
			Next
			
		Next
	'	Print "Node was not found. The shit has hit the fan."
		
		
	End Function
	
	Function BuildTree()
		
		Local tv:tgadget = TreeViewRoot( LinkTree )
		types=AddTreeViewNode("Types",tv )
		general= AddTreeViewNode("General",tv )
		For Local tb:TBody = EachIn doc.bodies
			tb.node =AddTreeViewNode(tb.name,general)
		Next
		For Local tt:TType = EachIn doc.types
			tt.node = AddTreeViewNode(tt.name,types)
			Local Gen:Tgadget= AddTreeViewNode("General",tt.node)
			For Local tb:TBody = EachIn tt.bodies
				tb.node = AddTreeViewNode(tb.name,gen)
			Next
			Local Meths:TGadget = AddTreeViewNode("Methods",tt.node)
			
			For Local m:TMethod = EachIn tt.methods
				m.node = AddTreeViewNode(m.name,meths)
				For Local tb:Tbody =EachIn m.bodies
					tb.node = AddTreeViewNode( tb.name,m.node )
				Next
			Next
			Local Funcs:TGadget = AddTreeViewNode("Functions",tt.node)
			For Local f:Tfunction = EachIn tt.functions
				f.node = AddTreeViewNode(f.name,funcs)
				For Local tb:Tbody = EachIn f.bodies
					tb.node = AddTreeViewNode( tb.name,f.node )
				Next
			Next
			
		Next
		
		
		
	End Function
	
	Function ChangeBody( in:TBody )
		viewBody = in
		ViewY = 0
		Local height:Int = BodyHeight( in )
		SetTextAreaText viewcan,""
		For Local S:String = EachIn in.con
			Log( s )
		Next
		
	End Function
		
	Function BodyHeight(in:Tbody)
		Local gw# = GraphicsWidth()
		Local cpl# = gw/15
		
		Print "Gw:"+gw
		
		Print "Cpl:"+cpl
	End Function
		
	Function Update()
		WaitEvent()
		Select EventID()
			Case Event_TImerTick
				
			Case Event_GadgetSelect
				Local node:TGadget = TGadget( EventExtra() )
				Local bd:TBody = FindBody( node )
				If bd&lt;&gt;Null
					Print "Body:"+bd.name		
					'viewbody = bd
					ChangeBody( bd)
				EndIf
			Case Event_WindowClose
				If EventSource() = viewWin
					End
				End If
		End Select
	End Function
	Global Types:TGadget
	Global General:TGadget
	Global doc:TDoc
	Global ViewWin:TGadget 
	Global linkTree:Tgadget
	Global ViewCan:TGadget
	Global Viewbody:TBody
	Global ViewSlide:TGadget
	Global ViewY#
End Type

Const Deli:String =":;()&lt;&gt;.,][{}-=+/*!@#$%^&amp; 	"

Type Tokenizer
	Method New()
		tokes = CreateList()
	End Method
	
	Method Parse:TList(txt:String)
		ClearList( tokes )
		Local sl:Int = Len( txt )
		Local Fc = 0
		Local Ec = 1
		'DebugStop
		
		For Local j=1 To sl
			Local c:String = Mid( txt,j,1 )
			If Instr( deli,c ) 'Is delimiter
				Ec = j
				Local Ed = ec - fc
				If ed&gt;0
					Local toke:String = Mid( txt,fc+1,ec-fc-1 )
					If toke&lt;&gt;"" And toke&lt;&gt;" " And toke&lt;&gt;"	"
				'	Print "Toke:"+Toke
					tokes.addlast( toke )
					EndIf
					
				EndIf
				fc=j
				If c&lt;&gt;"" And c&lt;&gt;" " And c&lt;&gt;"	"	
				'	Print "Toke:"+c
					tokes.addlast( c )
				EndIf
				
			Else
				If j = sl
					ec = j
					Local ed = ec-fc
					If ed&gt;0
						Local toke:String = Mid( txt,fc+1,ec-fc )
						If toke&lt;&gt;"" Or toke&lt;&gt;" " Or toke&lt;&gt;"	"
							'Print "Toke:"+toke
							tokes.addlast( toke )
						End If
					EndIf
				EndIf
				
			EndIf
			
		Next
		Return tokes
		
	End Method
	
	Field Tokes:Tlist
End Type


'DebugStop
'CreateTimer(35)


Local td:TDoc = TDoc.Load("AuroraDoc.txt")
TDoc2Html.Do( td,"AuroraDocs/" )
End
'TDocViewer.Create( td )
'Repeat
'	TdocViewer.Update()
'Forever
'New Tokenizer.Parse("A speed of 1 is static. A speed of 0.5 is smooth. 0.1 is very smooth but slower.")



</pre><br><br>And here's the aurora doc text file it parses<br><br><pre class=code>
[Type] TScript


	[Function] Create:TScript( file:String )

		-Creates a Tscript object from a file.	


[EndType]



[Type] TSceneCallBack Abstract

	[Body] Tip()
	TsceneCallback is an abstracted class you should extend when using Aurora's
	build in osm scene loader. It's not compatible with the original osm scene 	loader which is also supported.
		

	[Method] OnEntity( Ent:TEntity )

		-Called on the creation of a new entity.


	[Method] OnLight( Light:TLight )

		-Created on the Creation of a new light.

[EndType]


[Type] TSceneLoader

	
	[Function] Create:TSceneLoader()
	
		-Create a new scene loader.


	[Method] RegisterCallback( in:TSceneCallback )


		-Register a new callback.

	[Body] Example()
		
		Type DemoCallback extends TSceneCallback
			
			method OnEntity( ent:TEntity )
				print "Created Entity!"
			end method
		end type
		
		local SceneLoader:TSceneLoader = TSceneLoader.Create() 'Create the scene loader
		SceneLoader.RegisterCallback( new demoCallback ) 'Register a new call back				
		

	[Function] LoadBest:TScene(file:String)


		-Use the original C++ based osm scene loader. This has 
		-the best compatibility as it uses the code wrote by the
		official ofusion team. 


	[Method] LoadSafe:TScene(file:String)

		-Load using the custom bmax wrote xml osm scene parser.
		-This has the advantage of working with tscene and having event call 			-backs
		as it's wrote entirely in bmax and uses MaxXML to parse the scene file.	

[EndType]


[Type] TInertia
	[Body] Tip()	
	Inertia objects describe the rotational and linear force effect on a Tbody.
	These affect how a entity interacts with fellow objects.
	
	
	[Function] CreateCylinder:TInertia( mass:Float,w:Float,h:Float )
		
		-Create a cylinder shaped inertia object.
	[Body] Example()

		Local body.TBody = TBody.Create()
        	body.setInertia( TInertia.CreateCylinder( 5,20,20 ) )		

	[Function] CreateCube:TInertia( mass:Float,w:Float,h:Float,d:Float)


		-Create a Cube shaped inertia object.
	
	[Body] Example()

		Local body.TBody = TBody.Create()
        	body.setInertia( TInertia.CreateCube( 5,20,20,20 ) )	



[EndType]


[Type] TSurface


	[Function] Create:TSurface()

		-Create a Physics Surface. A physic surface is basically a container
		for a material group. You can create one represent all ship objects of a
		certain class, and then use them with a Tsurfacepair to describe
		the interactions between two unique unique surfaces.


[EndType]





[Type] TSurfacePair

	[Body] Tip()
	Surface pairs are the way you get collision feedback. Only valid surface
	pairs generate feedback info when they come in contact with each other.
	You may group off entities using the same surface.

	[Function] Create:TSurfacePair( surf1:TSurface,surf2:TSurface )


		-Create a new surface pair.

	[Body] Example()	
	
		Local MetalSurf:TSurface = TSurface.Create()
		Local WoodSurf:TSurface = TSurface.Create()
		Local MetalWoodPair:TSurfacePair = TSurfacePair.Create( MetalSurf,WoodSurf )


	[Method] EnableFeedback()


		-Enable collision feedback for the pair.
		Using TCollisionfeedback static members you can get detailed information
		on every collision between previously established surface pairs.
		Entities bodies that have no tsurface pair group will still interact with
		each other, they just won't generate any collision feedback. This is by design.

[EndType]



[Type] Tcollision

	[Body] Tip()
	Collisions are the returned objects from newton collision feedback.


	[Method] ContactX:Float()

		-X Contact point of collision in world space.


	[Method] ContactY:Float()

		-Y Contact point in world space.

	[Method] ContactZ:Float()


		-Z Contact Point in world space.


	[Method] NormalX:Float()


		-X contact normal.


	[Method] NormalY:Float()


		-Y Contact normal.


	[Method] NormalZ:Float()


		-Z Contact normal.


	[Method] Speed:Float()

		-Speed of the contact.

	[Method] Body1:TBody()


		-The first body involved in the collision.


	[Method] Body2:TBody()


		-The Second body involved in the collision.

[EndType] 



[Type] TCollisionFeedback


	[Function] GetList:TList()

		-Returns a TLIST containing all the collisions in the last physics	
		-cycle.
	
	[Body] Example()
		
		local Cols:TList = TcollisionFeedback.GetList()
		for Local Col:TCollision = eachin Cols
			print "X:"+col.ContactX()
			print "Y:"+col.ContactY()
			print "Z:"+Col.ContactZ()
		next
		TCollisionFeedback.reset()



	[Function] Reset()

		-Clear the current collisions list, it is important you call this function
		at least once a frame or the buffer will fill up fast.
	

[EndType]


[Type] TBody


	[Function] Create:TBody( ColMesh:TCollider,name:String = "Default" )


		-Create a newton physics body. Collider is the body's shape
		-Name is the name of the body.
		Physics bodies are tied to a pivot/entity of your choice and automatically
		update it's position/rotation to match the body.


	[Method] ActivateForceAndTorque()


		-Activate force and torque callbacks. Allows you influence
		-the body's force and torque directly.


	[Method] SetSurface( in:TSurface )


		-Set the material surface of the entity.
		

	[Method] SetCenterOfMass( x#,y#,z# )


		-Set the centre of the body's mass.


	[Method] AddPush( x#,y#,z# )


		-Add push or force.




	[Method] SetPush( x#,y#,z# )
	
		-Set push or force.	


	End [Method]


	[Method] TorqueSet( x#,y#,z# )

		-Set Torque.
	

	[Method] TorqueAdd( x#,y#,z# )


		-Add Torque.


	[Method] SetVeloc( x#,y#,z# )


		-Set velocity.


	[Method] SetLinearDamping( damping# )


		-Set linear damping.


	[Method] SetAngularDamping( x#,y#,z# )


		-Set angular damping.

	[Method] GetLinearDamping#()


		-Get linear damping.


	[Method] GetAngularDampingX#()


		-Get angular damping x.


	[Method] GetAngularDampingY#()


		-Get angular damping y.

	[Method] getAngularDampingZ#()


		-Get angular damping z.


	[Method] EnableGravity()


		-Enable a global gravity force on this body.


	[Method] SetInertia( in:TInertia )


		-Set Inertia object for the entity.


	[Method] AttachToPivot( piv:TPivot )


		-Attach the body to a visual pivot or Tentity.
		Once attached a visual mesh will automatically be updated
		to track the body's orientation and position. Call this 
		[Function] just once.

	[Body] Example()
		
		local Player:TEntity = TEntity.CreateMesh("Robot.Mesh")
		Local Body:TBody = TBody.Create( TCollider.CreateConvex( Player ) )
                Body.AttachToPivot( Player )		


	[Method] RotatePosition(pitch:Float,yaw:Float,roll:Float,x:Float,y:Float,z:Float )


		-Set the body's rotation and position.


	[Method] Rotate( pitch:Float,yaw:Float,roll:Float )


		-Set the body's orientation.

	[Method] Position(x:Float,y:Float,z:Float)


		-Position the body.


	[Method] Push( fromx:Float,fromy:Float,fromz:Float,vx:Float,vy:Float,vz:Float)


		-Add a global impuse at point fromx,fromy,fromz, with the velocity
		vx,vy,vz
	

	[Body] Example()

		Body.Push( Body.X(),Body.Y(),Body.Z(),0,5,0 ) 'Make the entity float!


	[Method] Attached:TPivot()

		-Returns the attached pivot/entity if any.

	[Method] X#()


		-Returns the x position.


	[Method] Y#()

		-Returns the y position		
	[Method] Z#()

		-Returns the Z Position.


[EndType]


[Type] TCollider
	
	[Body] Tip()
	Colliders are basically the geo/mesh of the collision body used to represent 	a body. There are many [Type]s of collision bodies, each with their own a	advantages.


	[Function] CreateCube:TCollider(width:Float,height:Float,depth:Float)


		-Create a cube shaped collision body.


	[Function] CreateCylinder:TCollider( width#,height# )


		-Create a cylinder shaped collision body.


	[Function] CreateConvex:TCollider( From:TPivot )


		-Create a convex(Simplified approximation) hull based on the given
		entity. Can move dynamically.


	[Function] CreateStatic:TCollider( From:TPivot,optimize = False)

		-Create a static collider. This are for non moving static level geo and 		such

[EndType]


[Type] TPostFx

	[Body] Tip()
	Post-Fx can be chained together by adding two or more postfx filters
	to the screen. They are rendered in order of being added.
	
	[Body] Example()
	
		TPostFx.Add("Bloom")
		TPostFx.Enable("BLoom")

		Violva, bloomy graphics!

	[Function] Add(name:String)

		-Add a post fx filter. Based on it's name in the relevant compositor 			script file. Aurora includes a bunch of pre wrote scripts for you.
		They are. &amp;#147;Bloom&amp;#148;, &amp;#147;DOF&amp;#148;(Depth of field),&amp;#148;Glass&amp;#148;,&amp;#148;B&amp;W&amp;#148;(Black and 			white),&amp;#148;Embossed&amp;#148; and &amp;#147;OldTv&amp;#148;
	



	[Function] Enable( name:String )
	

		-Enable the recently added compositor postfx filter.


	[Function] Disable( name:String )

		-Disable the recently added compositor post fx file.


[EndType]

[Body] ShadowConstants()
Const:[Shadow [Type]s]
Shadows_TextureMod =1,-[Fasted but least attractive form of shadows]
Shadows_StencilMod=2,-[Second fatest and pretty nice looking]
Shadows_StencilAdd=3 -[Best looking, But slowest.]

[Type] TDisplay


	[Function] Create:TDisplay()

		-Create a Display object.

	[Method] OpenScreen()

		-Show the config screen.


	[Method] ShadowMode( mode )

		-Set the current shadow technique. Defaults to Off.
	
[EndType]


[Body] GuiConstants
Const Event_MouseEnter =1
Const Event_MouseLeave =2
Const Event_ButtonClicked = 3

[Type] TGui


	[Function] Init( camera:TCamera )

		-Initialize the gui for the given camera object.

	[Function] FreeEvents()


		-Free the current event queue.


	[Function] UpdateEvents()


		-Grab the current event queue.


	[Function] CursorX:Float()

		-Cursor x in pixels.

	[Function] CursorY:Float()


		-Cursor y in pixels.


	[Function] EventNext:TGuiEvent()


		Get the next event. Returns null when no events are left.


[EndType]

[Type] TButton Extends TBase


	[Function] Create:TButton( x#,y#,width#,height#,text:String,parent:TBase )
	
		-Create a button object


[EndType]


[Type] TWindow Extends tbase


	[Function] Create:TWindow(x:Float,y:Float,width:Float,height:Float,name:String,parent:TBase )


		-Create a window object.

[EndType]


[Type] TRayCast


	[Function] Cast:Int( x#,y#,z#,dx#,dy#,dz# )

		-Cast a ray from x,y,z at the length of dx,dy,dz.
		Returns true on a hit, false otherwise.
	
	[Function] X#()
	
		-X location of the hit. 


	[Function] Y#()


		-Y location of the hit.


	[Function] Z#()

		-Z Location of the hit.

	[Function] CastBody:TBody()

		-The body hit.


[EndType]


[Type] TCamera


	[Function] Create:TCamera()


		-Create a new camera object.


	[Method] Pick:Int(x:Float,y:Float)


		-Cast a linepick at the given pixel coordinates.
		Returns true on hit, false otherwise.

	[Method] PickX#()

		-The x location of the pick. 


	[Method] PickY#()


		-The y location of the pick.


	[Method] PickZ#()


		-The Z location of the pick.


	[Method] PickBody:TBody()


		-The body hit in the pick.


	[Method] Move(x:Float,y:Float,z:Float)


		-Move the camera relative to it's current orientation.




	[Method] TFormVector( nx:Float,ny:Float,nz:Float )

		Transform a vector around the current orientation.


	[Method] TFormPoint( nx:Float,ny:Float,nz:Float )


		Transform a point around the current location and orientation.


	[Method] TFormedX#()


		Get the X component of the Tform.


	[Method] TFormedY#()


		Get the Y component.


	[Method] TFormedZ#()


		Get the Z Component.


	[Method] setquat(quat:Byte Ptr)


		Set the quat directly.


	[Method] GetQuat:Byte Ptr()


		Get the current orientation quat.


	[Method] GetPitch()


		Get the current pitch.


	[Method] GetYaw()


		Get the current yaw.


	[Method] GetRoll()


		Get the current roll.


	[Method] Rotate( pitch:Float,yaw:Float,roll:Float )

		Rotate the camera.


	[Method] Direction(x#,y#,z#)


		Set the direction the camera is looking.


	[Method] X:Float()


		Get the x position.


	[Method] Y:Float()


		Get the y position.


	[Method] Z:Float()


		Get the Z position.


	[Method] Position(x:Float,y:Float,z:Float)


		Set the position of the camera.


	[Method] LookAt( x:Float,y:Float,z:Float )


		Point the camera at a given point in 3d space.


	[Method] Pitch( Inc:Float )


		Increment the pitch by the given amount.


	[Method] Yaw( Inc:Float )


		Increment the yaw.


	[Method] Roll( inc:Float )


		Increment the roll.


	[Method] SetFov( fov:Float )


		Set the field of view.

	[Method] GetFov:Float()


		get the field of view.


[EndType] 


[Type] TLight 


	[Function] CreateOmni:TLight()


		Create an omni light.


	[Method] Position(x:Float,y:Float,z:Float)


		Position the light.


	[Method] Diffuse( r:Float,g:Float,b:Float )


		Set the light's diffuse color.


	[Method] Specular( r:Float,g:Float,b:Float )


		Set the specular of the light.


	[Function] SetAmbient( r:Float,g:Float,b:Float )


		Set the overall ambient light.

[EndType]


[Type] TAnimation


	[Function] Update()


		Update all active animations.


[EndType]


[Type] TEntity Extends TPivot


	[Function] CreateMesh:TEntity( MeshFile:String,Parent:TPivot = Null  )


		Create a new entity, based on the given mesh file. Parent is an	
		optional TPIVOT or TENTITY to anchor the entity to.

	[Method] CastShadows(enable:Int = True )


		Set whether the entity casts shadows or not.



	[Method] SetMaterial( Name:String )

		Set the current entity's material. Materials should be located
		in a specified resource location.
	

	[Method] AdvanceAnim()


		Advance the current animation.


	[Method] PlayAnim( name:String,speed#=1,Loop = False )


		Play the given animation. At the specified speed.


[EndType]


[Type] TEmitter


	[Method] Enable()

		Enable the particle emitter.


	[Method] Disable()


		Disable the particle Emitter.


[EndType] 






[Type] TParticleSystem


	[Function] Create:TParticleSystem( system:String )

		Create a Particle system based on the given script name.
	


	[Method] AttachToPivot( pivot:TPivot )


		Attach the particle system to a pivot/entity.


	[Method] EmitterCount:Int()


		Count the number of emitters in the particle system.


	[Method] EmitterGet:TEmitter(index:Int)


		Return the emitter number &lt;index&gt;


[EndType]


[Type] TParticleController


	[Function] Create:TParticleController(x#,y#,z#,name:String,emitfor,livefor)

		Create a particle controller. Particle controllers allow you
		to emit a particle system at a given location for a given period
		of time. Emitfor is how many milliseconds to emit the particle system.
		Livefor is how long to maintain the particle system before 				      automatically deleting it.
	


	[Function] updateall()

		Update all particle controllers.


	[Method] update()

		Update particle controller.
	
[EndType]








[Type] TMeshData

	
	[Body] Tip()
	TmeshData objects contain vertice and tri mesh data.
	They allow you to construct your own mesh containers for whatever reason you 	have.	We use them to pass mesh data to our ode plugin for example.

	[Function] Create:TMeshData( Pivot:TPivot,name:String )

		Create A mesh data object for the mesh called &lt;name&gt;
		the mesh data is transform to match the orientation, location
		and scale of the given pivot/entity.
	

	[Method] Vertices()


		Return the number of vertices.


	[Method] Triangles()


		Return the number of triangles.


	[Method] GetVertex( index )


		Load the given vertex.


	[Method] GetTriVertex( tri,vertex )


		Load the Triangle vertex. Vertex should be 0,1,2


	[Method] GetTriIndex:Int( tri,vertex)
	
		Return the Triangle Vertex Index. Vertex should be 0,1,2.
	
	[Method] X#()

		Return the x component of the loaded vertex.


	[Method] Y#()

		Return y component of the loaded vertex.


	[Method] Z#()


		Return the z component of the loaded vertex.


	[Method] Pivot:TPivot()

		Returns the pivot used to position and orientate the mesh data.


[EndType]

[Type] Tpivot
	
	[Body] Tip()
	Pivots are identical in usable to pivots(CreatePivot()) in b3d. They are non 	visual scene graph nodes that can be used to construct complex pivot/entity  	relationships.

	[Function] Create:TPivot(Parent:TPivot=Null)


		Create a pivot, with an optional parent.


	[Method] CreateMeshData:TMeshData( mesh:String )


		Create mesh data for the given mesh file using this pivot.


	[Method] CreateChild:TPivot()
		
		Add a child pivot and return it.


	[Method] SetQuat(quat:Byte Ptr)


		Set the quat orientation directly.


	[Method] SetQuatDirect( quat:OQuaternion )


		Set the quat directly using a Oquaternion object.)


	[Method] SetQuatCoords( w#,x#,y#,z# )


		Set the quat directly using coords.


	[Method] GetQuat:Byte Ptr()

		Get the current quat.
	

	[Method] Move(x:Float,y:Float,z:Float)

		Move the pivot relative to it's current orientation.
	


	[Method] X:Float()

		Return the X position.
	

	[Method] Y:Float()


		Return the Y position.


	[Method] Z:Float()


		Return the Z position.


	[Method] Position(x:Float,y:Float,z:Float)


		Position the pivot.


	[Method] GetPitch:Float()


		Get the pitch of the entity.


	[Method] GetYaw:Float()


		Get the yaw of the entity.


	[Method] GetRoll:Float()


		Get the roll of the entity.


	[Method] TFormPoint(x:Float,y:Float,z:Float)


		Transform a point around the pivot.


	[Method] TFormVector(x:Float,y:Float,z:Float)


		Transform a vector around the vector.


	[Method] TFormedX:Float()


		Get the x component of the tform.

	[Method] TFormedY:Float()


		Get the y component of the tform.

	[Method] TFormedZ:Float()


		Get the z component of the tform.

	[Method] LookAt( x:Float,y:Float,z:Float,GlobalSpace = False )


		Point the pivot at the given location.


	[Method] Pitch( Inc:Float )


		Increment the pitch of the pivot.


	[Method] Yaw( Inc:Float )


		Increment the Yaw of the pivot.

	[Method] Roll( Inc:Float )


		Icrement the Roll of the pivot.


	[Method] Rotate( nPitch:Float,nYaw:Float,nRoll:Float )


		Rotate the pivot.


	[Method] Turn( nPitch:Float,nYaw:Float,nRoll:Float )


		Turn the Pivot.


	[Method] Scale(x:Float,y:Float,z:Float)


		Set the pivot's scale.

[EndType]


[Type] Tinput
	[Body] Tip()
	Tinput is used to gather mouse and keyboard input.

	[Function] Create:TInput()

		Create an input device.

	[Method] KeyDown(Key:Int)
		
		Check to determine if the given key is down. Format is Key_&lt;Keyname&gt;
		Example: If MyInput.KeyDown(Key_W) then MoveForward()
	
	[Method] MouseXSpeed()


		Check the amount of pixels the mouse has moved in the last frame.


	[Method] MouseYSpeed()


		Check the amount of pixels the mouse has moved in the last frame.

	[Method] MouseDown( index:Int )


		Check to determine if the given mouse button is down.

[EndType]


[Type] TChasePivot

	[Body] Tip()
	Chase pivots are 3rd person cameras that allow you track an entity/pivot
	at a given offset, and a given speed.

	[Function] Create:TChasePivot(Cam:TCamera,Follow:TPivot,Xoff#,yOff#,zOff#,Speed#=1)
	
		Create a chaser pivot for camera Tcamera, to follow &lt;follow&gt; pivot/entity. At an offset of xoff,yoff,zoff, at a speed of &lt;speed&gt;
		A speed of 1 is static. A speed of 0.5 is smooth. 0.1 is very smooth but slower. 


	[Method] Update()

		Update the Chase pivot.
	

[EndType]


[Type] TEntityPrefab


	[Function] MakePlane:TEntity(width:Float,length:Float,parent:TPivot = Null)

		Create a plane mesh.

[EndType]

[Body] Installation()

	Step 1:Copy Axe.Mod To your module folder.
	Step 2:Copy Aurora.bmx and fellow files to your project folder.
	Step 3:Copy Aurora &amp; Ogre Dlls into System32 or your project folder.
	Step 4:Run Barebones.bmx to ensure you've installed correctly.
	
	If you run into any problems, please post on the forum and I will
	try to help


</pre><br><br>Go on Dreamora. show us how oo code should be presented... :) <br><br></td></tr></table><br>
<a name="653848"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >popcade</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Is this doc reflects to BlitzNet 1.0 or 1.2 ?<br><br>I don't see 1.2 yet, how about include this doc system in next distribution, looks handy for making manuals? <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
