<!DOCTYPE html><html lang="en" ><head ><title >Language request</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Language request</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Language request</a><br><br>
<a name="697871"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brendane</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Mark Sibly:<br>I can get around this in other ways, but (how can I phrase this?) how about making the Type, 'typed' ... ie. invent a new base datatype (essentially an int) called Class (say) and expose the typename as a Class type. Then extend Object to include a Class() function which returns the object's Class.<br><br>to make this clearer I can now do this :-<br>Type MyType<br>EndType<br><br>Local t:MyType = new MyType<br>Local s:MyType = new MyType<br><br>If t.Class() = MyType <br>   ' I'm a MyType , great!<br>EndIf<br><br>If s.Class() = t.Class()<br>   ' Me too!<br>EndIf<br><br><br>Oh, and we should also be able to cast a Class to Byte Ptr ;)  Since I can then also dig around in the class (should I want to). Obviously the names are just semantic<br><br>What do you say? It's a nice way of runtime type checking. <br><br></td></tr></table><br>
<a name="697876"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >deps</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> You could do:<br><br>if MyType(t)<br>  ' Wee...<br>endif <br><br></td></tr></table><br>
<a name="697882"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brendane</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> That isn't sufficient deps. That cast can be performed on anything extending from MyType (which isn't the real test being performed). The real test is to find out EXACTLY what type the object is.. not what it derives from. <br><br></td></tr></table><br>
<a name="697884"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brendane</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> In semantic terms it's probably a better idea to use the existing 'Type' keyword (since a type descriptor is already of type 'Type' - confused yet?).<br><br>ie. in this case<br>Type mytype<br>EndType<br><br>mytype is a Type<br><br>then extend the Type keyword in the language parser for an object so :-<br><br>Local s:mytype = New mytype<br>If Type(s) = mytype<br>  ' That's a nice new language feature - thanks Mark!<br>EndIf <br><br></td></tr></table><br>
<a name="697886"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> The only thing we need is a method on BBObject class which returns the type it is as BM internally knows its type (otherwise you couldn't cast).<br><br>There is already a function which does that but as it missuses Byte Ptr hacks to get it, I wouldn't use them if you plan to stay up to date, so I agree with this request at least partially. <br><br>It would be great to have a method that returns us the class of a given type instance. <br><br></td></tr></table><br>
<a name="697887"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brendane</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> There are three reasons why I want this :-<br><br>1) It's missing from the language<br>2) To avoid using class hacks to make my code future proof.<br>3) To avoid instancing an object in order to test another's class.<br><br>BM *does* know (for example) mytype is a Type - however there is no way to cast this to anything - nor can you even check two types are equivalent - ie, you can't do :-<br><br>If mytype = yourtype  etc...<br><br>The compiler complains that 'Type' and 'Type' are unrelated. <br><br>So we need everything I've asked for. <br><br></td></tr></table><br>
<a name="697888"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brendane</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> - and I do believe that a cast to a Type is a better option than a function which returns the type.<br><br>What I mean is :-<br><br>Type( myTypeInstance )<br><br>seems better to me than :-<br><br>myTypeInstance.Type()<br><br>(and as long as I can cast a Type to a Byte Ptr, I'll be happy : Dreamora feel free to express shock that I might wish to hack around the class) <br><br></td></tr></table><br>
<a name="697890"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jake L.</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> I don't want to join any language theory debates, but this request sounds useful to me. Would be a nice to have feature.<br><br>Edit: Brendane, did you see <a href="/codearcs.php?code=1786#comments" target="_blank">this</a> ?<br>My problem with this is that I'm unsure if this will work with future BMax-versions. So building functionality upon this is a bit jeopardy, I think. <br><br></td></tr></table><br>
<a name="697895"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> I first thought, the target of your request is, to come away from the hundred casting behavior BM currently enforces.<br><br>But after reading your example, it looks more like you want the === operator from PHP.<br>But what I don't see is the reason why you should be able to do something like this between 2 types (ie 2 classes). type is a theoretic construct that does not exist at runtime. At runtime, objects exist so what you need is a check on instance base or on instance against class base but definitely not between classes as you already know that they are equal or not as they only exist in source code. so it is already defined if they are equal so its nonsense to test it.<br><br><br>But there is a good reason to have a .class() command: currently you have to cast object through all potential types. While this is nice, it is extremely slow and not modular as casting can only be done at codetime.<br><br>With a .class() method you could easily select it or check it against a dynamic array of typenames (either int or string, depending on the return of .class() ), which defacto means: dynamic class checking.<br><br>This is currently not possible with the "out of the Box BM"<br><br>I'm aware as well that you can easily work around that and I even do it. I've my own type TObject which is my base class I inherit from which has a field class  which I use for such technics as they are needed in many cases.<br>But I think this shows the restriction: It can only be done on your own types. BMs own types won't work ... <br><br></td></tr></table><br>
<a name="697901"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >H&amp;K</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> I agree with Brendane, except for one thing. <br><br>Why would Marks Solution be better than doing it your self.<br><br>I dont get it. I can add this funtionality to any class that I want to? Why should I be forced to carry this overhead on all classes simply because <b>you</b> are too lazy to impliment it your self?<br><br>Its a nice thing, but I only need it on classes that are going to be cast. And as I know what they are, I should implement it myself<br><br><div class="quote"> I can get around this in other ways <br></div><br>Yep better more suted ones<br><br>(I know the overhead is low, but it is still an overhead) <br><br></td></tr></table><br>
<a name="697926"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brendane</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> @H&amp;K:<br>How can you have a better way than something built into the compiler? <br><br>Also -what overhead are you talking about *exactly* ? There should be zero overhead involved in what I'm suggesting - except in the compiler.<br><br>"Yep better more suted ones" -<br>Please suggest a more suited method - I'm all ears. <br><br></td></tr></table><br>
<a name="697930"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >H&amp;K</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> How can you have a better way than something built into the compiler? <br></div><br><pre class=code>If MyType.GFType = ThisObject.GFType</pre>Its a comparison of two Int? What major problem is there?<br><br>(The overhead as I said was very small (Well ok an Int per type, but its still an overhead) <br><br></td></tr></table><br>
<a name="697932"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brendane</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Dreamora: It isn't my intention to compare 2 'classes'. My example was merely to prove that the compiler does not currently fully recognise that 'Type' is a type.. ie, I can't perform comparisons. Of course I shall be comparing an instance's type and an actual type. <br><br></td></tr></table><br>
<a name="697934"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brendane</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> @H&amp;K: There are two problems in your suggestion that you tried to argue against<br><br>a) there is an overhead involved - in my suggestion there isn't.<br><br>b) it requires that I have created the type myself.<br><br>What is the real point of opposing something useful like this? <br><br></td></tr></table><br>
<a name="697935"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >H&amp;K</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> What is the real point of opposing something useful like this?  <br></div>I am playing devils advocate.<br><a href="http://www.blitzbasic.com/Community/posts.php?topic=60015#669441" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=60015#669441</a><br><br><div class="quote"> it requires that I have created the type myself. <br></div><br>No it requires that you have at the least extended the type yourself <br><br></td></tr></table><br>
<a name="697938"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brendane</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> "No it requires that you have at the least extended the type yourself"<br><br>So, I must extend every type myself?<br>Then the type will no longer *be* it's original type - or have you missed the point? <br><br></td></tr></table><br>
<a name="697940"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >H&amp;K</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> So, I must extend every type myself? <br></div><br><br>Yes. Well every type you might need to cast to and from<br><br>No I havent missed the point. Im telling you that if you want this, then it has to be in your types, because I dont want this One int per type overhead arbitaray added to all the base types, simply because you dont know how to extend properly.<br><br>(Remember I am playing devils advocate.) <br><br></td></tr></table><br>
<a name="697946"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brendane</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> @H&amp;K: I am a professional c++ lead programmer. I know how to extend properly.<br><br>If you're going to play devils advocate at least read the posts you're opposing. I've already told you, there is NO overhead required. Every object already has a class member - it is this value which is the Type. *Literally*. <br><br>There is nothing but a change in the compiler that is required for what I'm after - the result will be that anyone can compare object types without pointless overhead or hacking the underlying object structure. No old code is broken in the process. <br><br>It's all good, trust me. <br><br></td></tr></table><br>
<a name="697947"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >H&amp;K</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think Im doing quite well as devils advocate, no one thinks Im right, And you have been able to reitterate your point. <br><br></td></tr></table><br>
<a name="697948"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brendane</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hehe ;)<br><br>I suspect Mark won't want to go tinkering unneccesarily with the compiler though. How about it Mark? It's my birthday soon. <br><br></td></tr></table><br>
<a name="697949"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brendane</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Jake.L :<br>"Edit: Brendane, did you see this ?"<br>Yes, thanks.  I've also hacked around extensively with the class. In fact it's how I do it at the moment. You're right though, it's not a great idea to base important code on presumed structures which aren't fixed. However, I can be pretty much certain that the class member of the bbObject will never move or be changed, there is too much module code based on it for that to be practical. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
