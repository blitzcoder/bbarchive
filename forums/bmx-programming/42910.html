<!DOCTYPE html><html lang="en" ><head ><title >Opinions on object oriented programming</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Opinions on object oriented programming</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Opinions on object oriented programming</a><br><br>
<a name="480086"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> What's your opinion about object oriented programming?<br><br>Here's an interesting article I just read offering one viewpoint...<br><br><a href="http://www.devx.com/DevX/Article/26776" target="_blank">http://www.devx.com/DevX/Article/26776</a> <br><br></td></tr></table><br>
<a name="480092"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >John Pickford</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Good article.  I'm finding the OOP stuff in BMax fascinating - a real learning experience.  But I must admit, i'm the 'don't quite get it yet' category. <br><br></td></tr></table><br>
<a name="480097"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Loonie</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> from personal experience, once you really understand OOP there's nothing like it.<br><br>now, the problem is *REALLY* understanding it....i mean, not just grasping the concepts, but once you get to the point that you actually *think* objects, then OOP really shines.<br><br>Now, i do understand those who are sill confused...but don't feel bad, everybody has a hard time with OOP at the beginning.<br><br>In reality i think it's a double edged sword....you can make the bests code and the worst with OOP (nothing like spaguetti OOP code, ARGH!)<br><br>=)<br><br>just one piece of advice: don't give up on OOP that easy.....you won't regret it. <br><br></td></tr></table><br>
<a name="480099"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >John Pickford</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's what he says in the article.  People go on about *really* understanding it etc.  I find those sort of statements a bit hard to take as you aren't explaining anything. <br><br></td></tr></table><br>
<a name="480101"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jeremy Alessi</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> I love it.  I typically hate unorganized code with extraneous calls to different datastructures.  OOP brings it all together in a nicely organized and elegant fasion. <br><br></td></tr></table><br>
<a name="480103"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AaronK</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> I would guess that he doesn't realise that when he says some companies are still trying to get it after 10 years, that they missed one fatal thing....They were hackers/old school procedural programmers who knew nothing about OOP and probably didn't get trained. <br><br>Like any programming. You can get a compiler and start hacking away. After a few years you'll find you've re-invented all manner of things that have been around for years....OR you go get some proper training and come out 10 years ahead of the rest. <br><br>It's not a problem with OO, it's a problem with people just going ahead and using it without really knowing how to use it well. Without getting some  really good training on how to make good OO programs. I was from the hacker mentallity. Self taught, learned what I needed. And guess what. I've been doing C++ for about 7 years now and I don't consider myself a great OO designer. I just got the job done how I knew and I was not (Am still not) interested in being an OO design guru - that doesn't mean learning isn't a good thing of you want to be great at what you do. I'm just happy to not be great at it (Programming theory is too boring)<br><br>He also states that you can do stuff in procedural programming that you don't need to in OOP. I AGREE, but guess what? I almost bet my house that any large program, done totally procedurally will actually be an OO program in the end just without using the tools of the language to help <br><br>You'll be passing in objects to work on to your Update() function rather than object.Update(). You'll be checking a type and calling a different Move() function (Hmm, virtual functions anyone?)<br><br><br>Aaron <br><br></td></tr></table><br>
<a name="480114"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Steve Elliott</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> I only have a basic understanding of OOP, but I'm finding it very logical thinking of things as 'objects' and slotting in several objects to produce a program.<br><br>Programming seems so much easier and programs should be less bug free as OOP forces you to think how things are created, updated and drawn before you add each object.<br><br>I do think that OOP can be adhered to too strictly though.  Using an OOP feature even though it makes the code more complicated is not a good idea I feel. <br><br></td></tr></table><br>
<a name="480125"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bot Builder</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> OOP is great because in a number of ways it is more natural for english speakers, anyone who does math, and in some ways to any human:<br><br>1. Method and field calling matches english and math Subject/Verb/Object:<br><pre class=code>
Subject Verb Object(s)
Bank  PokeInt Index, Value                                   &lt;OOP
Mark    Add   Overriding, Private Members, and Properties &lt;English
2        +       2</pre><br><br><div class="quote"> It's not a problem with OO, it's a problem with people just going ahead and using it without really knowing how to use it well. Without getting some really good training on how to make good OO programs. I was from the hacker mentallity. Self taught, learned what I needed. And guess what. I've been doing C++ for about 7 years now and I don't consider myself a great OO designer. I just got the job done how I knew and I was not (Am still not) interested in being an OO design guru - that doesn't mean learning isn't a good thing of you want to be great at what you do. I'm just happy to not be great at it (Programming theory is too boring) <br></div>True, there are all those desing patterns, etc, and rampant misuse of OO.one oribkem is programmers rooted in a procedurall style will ask why they should use OOP.  There is no concrete reason as far as functionality/speed goes that makes oop better.  OOP can be implemented as a preprocessor on nearly any procedural language.  C++ is a preprocessor for C.<br><br>IMHO, OOP is best applied to creation of libraries, and mark should have left out the procedural methods and done most of the mods with just OO (yes, i know the procedural commands are ofte just wrappers for methods/fields).  I know alot of the procedural people would hate this though, so mark has no choice.  OO does apply well to SOME elements of a game/app.  for instance, players, enemies, etc.  However, you should use it restrictivly.  For level data for instance, a type for each tile is crazy in most cases. just use an array.  Also, dont make Types for things you only use once per loop.<br><br>Persanally, atm bmax's oop support isnt that great.  No overloads, no private elements, no properties, no templates.  (order of my opinion of need) <br><br></td></tr></table><br>
<a name="480150"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Loonie</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> @John Pickford: i know, i used to have the same problem when i started with OOP. in college, when we stsarted OOP i felt like charly brown in class, it was all just "WAH WAH WAH OOP WAH WAH Classes WAH WAH Objects" and then one day it clicked. it's kinda hard to explain.<br><br>I don't know if you ever studied logic from a CS point of view. I remember many people in class just staring at the board completely numb and then one day they would brighten up and understand the whole thing at once.<br><br>OOP is more or less like that......it's just very confusing and too much information, and then one day it hits you like a thousand bricks, you go "OH! I *FINALLY* GET IT!"<br><br>just work a little with it, don't worry if you don't *really* get it, because eventually it will be all clear to you.<br><br>that is, if it's not clear already. but it will <br><br>:) <br><br></td></tr></table><br>
<a name="480301"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jhague</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> OOP is good, in moderation.  I've found that many programmers, especially those that have only used languages without formal module systems, tend to see OOP as the only way to modularize their code, keeping data hidden and encapsulated.  Many times pro-OOP arguments tend to be solely about modularization, which is of course something you can do without OOP just fine (it's just verb-noun instead of noun-verb)<br><br>The greatest downside to OOP I've seen is that some people get way too into it, succumbing to a kind of mania.  They feel the need to make <i>everything</i> be an object, even at the expense of simplicity.  The result is "ravoli programming," where everything involves long inheritance chains, and it is difficult to see exactly what the code does because it's scattered across many files.  Even Stroustrup (creator of C++) cautions against using inheritance and more than lightweight classes outside of fundamental libraries.<br><br>OOP shines when you think of it as sending arbitrary messages to things without having to worry about what those things are.  In a game, you can call the "rotate" method of an object without worrying about whether it's a bullet, a tree, or a rocket.  Similarly you can call the "give me your current position" method.  Very nice.  At the same time, you need to be careful here.  "Rotate" may make sense for some objects but not for others.  You don't want to make dissimilar things look functionally the same if they are too different. <br><br></td></tr></table><br>
<a name="480511"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FlameDuck</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> For level data for instance, a type for each tile is crazy in most cases. <br></div>Surely that depends on the complexity of the tile? If it's just an image, sure - if it has an associated sound with it's surface, and physics properties for an object crossing it, then surely using an object would be a most excellent solution?<br><br><div class="quote"> They feel the need to make everything be an object, even at the expense of simplicity. <br></div>These would be the people who do not understand OOP.<br><br><div class="quote"> and it is difficult to see exactly what the code does because it's scattered across many files. <br></div>Again, someone without the faintest idea of the fundamental OO design principles of low coupling, high coherency.<br><br><div class="quote"> "Rotate" may make sense for some objects but not for others. <br></div>Yes. More specifically they would make sense for any object that implements whatever interface your rotate method is defined in. And the compiler will give you an error (as opposed to happilly compiling and then subsequently randomly crashing). <br><br></td></tr></table><br>
<a name="480559"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think object oriented programming has its merits and thinking in terms of object is all very well. But for me, defining things as an `object` is too rigid a definition for aspects of the world or of problems and there needs to be a looser system *which I'm developing* :-) <br><br></td></tr></table><br>
<a name="480804"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RexRhino</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Object Oriented Programing only has problems when you over-abstract. <br><br>But the Black Boxing of OOP is nessicary if you are working on a big project. <br><br></td></tr></table><br>
<a name="480811"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bot Builder</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> lol. can't quite imagine an elegant looser system, but whatever. <br><br></td></tr></table><br>
<a name="480833"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Um. Well my system is based on metaphysics, I think it's a lot more accurate way to represent reality. :-) <br><br></td></tr></table><br>
<a name="480845"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bot Builder</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> lol. <br><br></td></tr></table><br>
<a name="481543"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >jhague</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> These would be the people who do not understand OOP.<br>...<br>Again, someone without the faintest idea of the fundamental OO design principles of low coupling, high coherency. <br></div><br>It is worth arguing that OO is difficult to do correctly, and that difficulty is one of OO's greatest weaknesses.  It's <b>so simple</b> to get a basic understanding of OO, and yet in practice it takes a number of projects to work through the typical "OO over-engineering" phase.  I'd say the majority of OO programmers never get out of that phase, and that makes it difficult to work with them on a large project.<br><br>That said, the most common use of OO in Blitz Max is undoubtedly going to be to represent high-level game entities--aliens, cars, whatever--which is a simple and clean use. <br><br></td></tr></table><br>
<a name="481551"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> I like that BlitzMax gives you plenty of option to NOT use OO as well, makes for a nice balance. <br><br></td></tr></table><br>
<a name="481586"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Steve Elliott</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> That said, the most common use of OO in Blitz Max is undoubtedly going to be to represent high-level game entities--aliens, cars, whatever--which is a simple and clean use.<br> <br></div><br><br>Totally agree. <br><br></td></tr></table><br>
<a name="481637"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've been reading up about many kinds of object oriented implementations, not just BlitzMax's implementation or C++, also looking at Self and Smalltalk and the concepts in general. This: <a href="http://www.objectfaq.com/oofaq2/" target="_blank">http://www.objectfaq.com/oofaq2/</a>  is a good site for explaining things although some terminology is a little unnecessarily heady. *click on the `Basics` button*<br><br>There seems to be a number of often subtle differences between how each language implements object orientation and what features are provided. I liked the sound of `1-dimensional` object-orientation where any object can be a parent to any other object, and you have delegates to choose different parents, rather than having `classes`. So the inheritance is more dynamic. This is closer to what I think of as a highly flexible paradigm. I was also reading up about multiple inheritance and multiple polymorphism. Strange solutions to preconception-induced problems.<br><br>I do have some issues with how all this works and its limits. I don't like the imposition of a hierarchical structure as being the only way for objects to become associated through inheritance. All objects should be completely freely associating with any other. Also those relationships shouldn't be described in terms of superiority or inferiority - all are equal. There may be contracts or associations but none of this super/parent/child stuff.<br><br>I also feel that while it's all very well defining parts of problems or parts of the world in terms of `objects`, where an object is basically any aspect of a problem that is tangible enough to be described, this limits communication to only occuring across boundaries rather than the presence of `direct` understanding. Such communication is interpretation, not `knowing`. Objects should be able to metamorphose fully or in part with other objects to effectively share data and functionality and to temporarily extend any object's repertoir. I think it's wrong to think of things in terms of objects and more powerful to think of them in terms of `mediums` - mediums are always open and are never fixed. Mediums allow objects to transcend themselves and their limitations.<br><br>Also I don't think I believe in encapsulation where you hide stuff behind a stubborn controlling interface. In this model you have to more or less `ask` an object to do something. This is all very polite and socially acceptable but to socialize means `social-lies`. Two people in love do not usually have to ask each other at every turn whether something is okay. There is an openness and trust. I think encapsulation is a closed-minded model. There is no intimacy in having to access objects through interfaces. Interfaces get in the way. That's like having to write a note to your partner asking if it's okay to kiss them.<br><br>Objects should be able to resonate with one another to an absolute degree, optionally of course, so that they effectively become `one` and then one object can operate the other or operate `through` the other or together. Also one object can then be like a merged pool of objects, able to operate on all it is aligned with directly and immediately without any need for message passing. To me, extra message passing indicates poor design.<br><br>I also think there is still too much of the roots of procedural programming still left in object-oriented programming. It's one step up but not all the way up. It's kind of like procedural programming chopped up into smaller pieces and extra infrastructure to manage the pieces.<br><br>I think the best paradigm would be where each part is a reflection of the whole - where the whole is an instance of the part - ie `made in the image of` - holographic. In this system any single object can be the whole system or part of a system. Also any single object needs to be sophisticated enough to interact with all others and not just in predetermined ways. In fact, the ideal system needs to support subjectivity.<br><br>So those are a few of the areas that I have issues with and am seeking to address with a new kind of programming paradigm. <br><br></td></tr></table><br>
<a name="481640"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bradford6</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> been smokin the wacky weed? <br><br></td></tr></table><br>
<a name="481641"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> *smile* no. Your supply is safe. <br><br></td></tr></table><br>
<a name="481644"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >John Pickford</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> Resonate to an absolute degree?,  Metamorphose?, 'Social Lies'?  What a lot of claptrap.<br><br>I'd like to encapsulate that lot in a round filing cabinet. <br><br></td></tr></table><br>
<a name="481677"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Robert</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> Objects making love to one another?  Objects at one with the universe?  Intimate cross-class relationships? <br><br>I think you've lost the plot somewhere. <br><br></td></tr></table><br>
<a name="481720"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> Since your viewpoint of object-orientation is clearly superior maybe you'd like to enlighten us instead of treading on us? <br><br></td></tr></table><br>
<a name="481759"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just to clarify,<br><br>When I said that objects should be able to `resonate to an absolute degree` I am simply saying that I would like two objects to essentially be thought of as the same object, ie with no relative differences, while maintaining some very small degree of detachment allowing the union to be divided later if desired. Think of it as two or more pointers pointing to the same variable, or an instance of a type with more than one handle. But at the same time, each handle has its own local `self` which may become involved in the union to varying degrees.<br><br>Maybe a better word for metamorphose is `shapeshift`, ie one object changes its properties and so on to match those of another, like a mirror.<br><br>The social lies part is valid. Everybody puts on a social persona that covers their inner self. There are tremendous dishonesties involved in most social expression since the persona is involved. I am merely making use of metaphors and analogies by using this to relate to software issues. <br><br></td></tr></table><br>
<a name="481768"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dynaman</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> &gt; The social lies part is valid. Everybody puts on a social persona that covers their inner self.<br><br>Ah, but which is the lie, the social persona or the inner self?  (sorry, couldn't resist) <br><br></td></tr></table><br>
<a name="481771"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Perturbatio</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote">  &gt; The social lies part is valid. Everybody puts on a social persona that covers their inner self.<br><br>Ah, but which is the lie, the social persona or the inner self? (sorry, couldn't resist) <br></div><br><br>But could it not also be argued that the persona displayed in a social situation is an expression of a single facet derived from a multi-faceted personality and thusly that the persona perceived by others is a portion of the whole truth rather than a manufactured lie? ;) <br><br></td></tr></table><br>
<a name="481800"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> Umm, sure. But that's taking it way off-topic - it's just a loose analogy. <br><br></td></tr></table><br>
<a name="481877"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >John Pickford</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> I don't see where 'belief systems' come into it.  We're talking about programming languages and you post a load of air-fairy gibberish. What sort of response do you expect?<br><br>'no relative differences'  what does that mean?<br><br>'while maintaining some very small degree of detachment allowing the union to be divided later if desired'<br><br>Eh?<br><br>'Maybe a better word for metamorphose is `shapeshift`, ie one object changes its properties and so on to match those of another, like a mirror'<br><br>What does that mean?  Why does the object change? How?  What does a mirror have to do with it?<br><br>If you *REALLY* have a sensible point why not post in plain English cos I really can't tell what you are on about.  And I suspect you don't know yourself. <br><br></td></tr></table><br>
<a name="481878"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Robert</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> How does this analogy relate to software exactly?  Can you explain what this might mean, for example, to a programmer working on a 3D platformer or a FPS. <br><br></td></tr></table><br>
<a name="481880"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dynaman</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> I gotta admit, it is like Dilbert speak.  Today's calendar entry has M.T. Suit say "I enhance core competencies by leveraging platforms". <br><br></td></tr></table><br>
<a name="481949"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FlameDuck</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote">  Since your viewpoint of object-orientation is clearly superior maybe you'd like to enlighten us instead of treading on us?  <br></div><a href="http://www.mindview.net/Books/TIJ/" target="_blank">Here</a>. Also see if you can't find an article on Simula instead of SmallTalk. Simula is clearly the more user-oriented (as opposed to programmer oriented) language.<br><br><div class="quote"> When I said that objects should be able to `resonate to an absolute degree` I am simply saying that I would like two objects to essentially be thought of as the same object, ie with no relative differences, while maintaining some very small degree of detachment allowing the union to be divided later if desired. <br></div>Ironically this is where object inheritance comes in.<br><br>It seems to me you just don't understand the point of object orientation. Yet. Read "Thinking in Java", after the first couple of chapters, you'll understand. <br><br></td></tr></table><br>
<a name="481969"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> Belief systems come into it as follows... When you create some software you *probably* try to do the `best job` you can, put your heart and soul into it, make it be the best quality or highest vision that you can muster. So I asked myself, what would be the highest vision or philosophy that I could come up with that could be the inspiration for software that I create? The answer for you might be `other games you like` or `cool ideas` or maybe you draw particular inspiration from chaos theory or see a lot of sense in open systems or object orientation - whatever.<br><br>For me, my personal sense of spirituality and my grasp of metaphysics (albeit incomplete) is the highest most refined aspect of my world and something that I felt could be applied to software engineering. I will usually base everyday actions on those beliefs and understandings, so I figured why not base software creation on such things also. Since a highly refined philosophical outlook probably makes the most sense, why not apply such philosophies to software?<br><br>Wouldn't you seek to express yourself from your highest vision and clearest awareness? And if you are, for example, religious, wouldn't you try to bring God or Jesus or some such beliefs into your work? Just because I happen to favor metaphysics means that I like to try and use those concepts in my work. So when you are attacking my work you are attacking my beliefs. For me it is not just about talking about programming in isolation, it is talking about ethics and sense of reality and the source of my inspiration that I respect.<br><br>Maybe if you personally don't take things that far and focus instead perhaps on pure computer science or pulling together favorite game genre's to create something new, or whatever your method is, that's fine too. I just happen to use other kinds of resources and guidelines in my work. So when I bring something close to my heart into my work, such as spiritual concepts or metaphysics or my sense of God or whatever, yes it does mix `business with pleasure` and puts my beleifs right out there on the programming plate. So please have some respect for that instead of trying to score points with aggressive impatience. Just because my ways are different and you might not prefer them doesn't mean you should persecute them or me.<br><br>I apologize if my way of writing seems esoteric or alludes to but doesn't convey concepts with enough clarity for you, or doesn't speak your language or match your way of thinking. I am used to thinking and writing this way because of the familiarity I have with certain things, and it's also the way I think laterally or create new perspectives. I am trying to convert these ideas into your `plain english`.<br><br>It doesn't come down to what response I expect, Robert, but such a response is ALL I can apparently expect from you. I'm sorry but you've offended me.<br><br>"No relative differences": The human bodily senses can only sense changes. Something needs to move for the eye to detect it - look at the exact same spot for a while and you become temporarily `blind`. You need a `relative` change, something which is in contrast to how things currently are, in order to sense it. There must be a difference and that difference must be in relation to the current state. So what's wrong with referring to such a thing as "relative difference"? The absence of relative difference would essentially mean that separation disappears and things seem to all blend together indistinguishably. Two objects with no relative difference simply means they appear to be one object.<br><br>"While maintaining some very small degree of detachment allowing the union to be divided later if desired": I'm using the word detachment to refer to having some kind of a handle on an object that doesn't get involved in the merging or unification of the content of two objects. The handle is detached and allows you to keep control of the fact that the objects are unique, even though they may be acting identically. You couldn't have absolute unity otherwise you'd completely lose track of there being two objects and their original separate state would be irrecoverable. In order for one object not to lose itself in another when they unite, there must be at least a small degree of detatchment from each other.<br><br>"what does a mirror have to do with it": Copying the content of one object to the content of another could be described as mirroring could it not? Or perhaps causing the content of one object to temporarily mirror that of another, to later revert to its original state?<br><br>"And I suspect you don't know yourself": Did that make you feel better cus that doesn't add anything to the conversation.<br><br>Robert, it is a different way of thinking about what objects are and how they relate to each other. Thinking of object boundaries as tangible differences between parts of the world, is to me a little short of how the world models itself. If I say okay, I have this object, let's call it a tree and lets move it around independently and place it on the landscape, that's all very well. But because that tree is now confined to the definition of what a tree is, you can't think of that tree as anything else. You can maybe compose it of branches or leaves or whatever, but this is still thinking of trees.<br><br>If for example you ask a Buddhist they might ask you, what is a tree? They might tell you actually the qualities of what makes it a tree are fleeting. It is not the bark because the bark changes. It is not the branches because they move and grow and eventually die. It is no that it is separate of the ground because it came from the ground and eventually returns to it. There is nothing inherantly permanently real about any object. But object-oriented programming treats objects as though they have a permanent fixed reality. That really stems from the fact that computers have an extreme sense of state - on or off, black and white, exists or doesn't. To me that is shortsighted and filters out some otherwise interesting possibilities of what you might otherwise do with that `object`. I also see it as the legacy of every software design principle having been in some way a dirivative of a `binary reality`, since that is the computer's native condition. You'd be surprised just how huge an influence 2^n is on all aspects of software creation.<br><br>It is more accurate, metaphysically, to say that the tree is a field of energy held in a given configuration and that it never really achieves a permanent fixed state - it is approximately a tree. It just moves `through` stages of tree life in constant transformation. So I am figuring it would be more expressive to model a world not based on `objects` that have to exactly match given specifications, but based on mediums, whereby a medium can contain a given form but that form is never fixed in a permanent condition. There is always openness and accessibility and mediums are transcendent of what they might contain. I am thinking this is going to be a better way to model the world. It would give more flexibility, efficiency and is an even more natural and accurate representation of reality - for me anyway.<br><br>I'm sure there are benefits to it that I haven't realized yet because I am still refining it and designing an implementation of it. I would hope that in a given game project, for example, it will make things much easier to model, to organize, and to interrelate. It should make sharing between objects much more intuitive and direct. It allows a system to be completely decentralized with the option of centralization at the same time. It frees objects from being in a hierarchy and allows any kind of dynamic structure between them. It ultimately gives the user more freedom and should be easier to create with.<br><br>Does that help? <br><br></td></tr></table><br>
<a name="481981"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >John Pickford</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nope. <br><br></td></tr></table><br>
<a name="482001"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> Never mind then. <br><br></td></tr></table><br>
<a name="482086"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Robert</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> @AngelDaniel<br><br>Perhaps if you could provide some implementation details (code samples and practical game examples) that might clarify things.<br><br>Your above post is too vague to make much sense.  <br><br><div class="quote"> The handle is detached and allows you to keep control of the fact that the objects are unique, even though they may be acting identically. <br></div><br><br>But you can do that quite happily in OO code anyway.  Just create two intances of a class, and another object to represent any shared data.  Each instance has a member variable which points to the shared data object.  Use a bitmask to specify which properties of each object are shared, and which are specific to that instance, and store any specific information in another member variable in that object.<br><br>In BlitzMAX, since every type extends Object, you can cast any type to any other type. <br><br></td></tr></table><br>
<a name="482183"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >podperson</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> If you don't like OOP, don't put any methods in your classes ;) <br><br></td></tr></table><br>
<a name="482188"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> Um, yes, you can implement some of the same functionality using a language like BlitzMax, but it is more longwinded and in my opinion less elegant to do that.<br><br>I don't have any code to show you but there will be some in future. <br><br></td></tr></table><br>
<a name="482206"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >SJB</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#40">[#40]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> In BlitzMAX, since every type extends Object, you can cast any type to any other type. <br></div><br>Err, No. That is quite wrong. If I have two types:<br><pre class=code>Type bob
	Field x : Int
End Type

Type Tim
	Field y : String
End Type</pre>A variable of one of these types should not be able to be cast to the other type - the types are not the same. How would a user of a 'tim' know what to do with the string inside a 'bob'? <br>They might inherit from a common class, but that does not mean they are the same. What it means is that it can be passed to something that expect to get an argument of type Object, but it does not mean that this thing automatically knows what to do with a 'tim' if it expects a 'bob'. <br><br></td></tr></table><br>
<a name="482212"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FlameDuck</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#41">[#41]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Since a highly refined philosophical outlook probably makes the most sense, why not apply such philosophies to software?  <br></div>Because most people (aka programmers) don't subscribe to a single philsophical view. Not so with objects. Most people when they see a bee, they'll recocknize it as a bee (or insect).<br><br><div class="quote"> And if you are, for example, religious, wouldn't you try to bring God or Jesus or some such beliefs into your work? <br></div>Actually I believe the most common answer to this question is "No" since most religions subscribe to the idea that god is the only perfect being, and mankind is imperfect. Thus trying to bring god into a human process would be considered blasphemous.<br><br><div class="quote"> For me it is not just about talking about programming in isolation, it is talking about ethics and sense of reality and the source of my inspiration that I respect.  <br></div>Ethics and sense of reality isn't really much of an issue with regards to computer programming.<br><br><div class="quote"> The handle is detached and allows you to keep control of the fact that the objects are unique, even though they may be acting identically. <br></div>This is already the case in OO methodlogies. All objects by definition have Identity, State and Behavior.<br><br><div class="quote"> But because that tree is now confined to the definition of what a tree is, you can't think of that tree as anything else. You can maybe compose it of branches or leaves or whatever, but this is still thinking of trees.  <br></div>And how is that "short of how the world models itself"?<br><br><div class="quote">  But object-oriented programming treats objects as though they have a permanent fixed reality. <br></div>No it doesn't.<br><br><div class="quote"> That really stems from the fact that computers have an extreme sense of state - on or off, black and white, exists or doesn't. <br></div>Except object oriented methodology takes place in domain space - not computer space. Sure, a computer is a finite state machine, but even metaphysically speaking, everything has a finite ammount of states. It's just a matter of determining which are relevant to your object model.<br><br><div class="quote"> I am thinking this is going to be a better way to model the world. It would give more flexibility, efficiency and is an even more natural and accurate representation of reality - for me anyway.  <br></div>What you're thinking about is the Composite Method Pattern. <br><br></td></tr></table><br>
<a name="482342"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Robert</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#42">[#42]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Err, No. That is quite wrong. If I have two types:  <br></div><br><br>I didn't say that it was a good idea, I just said that as far as I know, the compiler will let you do it.<br><br>EDIT:  If you go round the houses that is - ie. cast the type to an object, and then back to a different type. <br><br></td></tr></table><br>
<a name="482403"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#43">[#43]</a></td></tr></table></td></tr><tr ><td class="posttext"> Mikkel:<br><br>"Ethics and sense of reality isn't really much of an issue with regards to computer programming."<br><br>-- For me it is, so it's a matter of personal preference.<br><br>("The handle is detached and allows you to keep control of the fact that the objects are unique, even though they may be acting identically.")<br><br>"This is already the case in OO methodlogies. All objects by definition have Identity, State and Behavior. "<br><br>-- Then that requires at least two objects or a class and an object. My system requires only one `object`.<br><br>"And how is that "short of how the world models itself"? "<br><br>-- A tree is not just a tree. That's a human interpretation of it. There is more to it. Whether that `more` is important is the issue here. It's important to me. Maybe it doesn't matter for others.<br><br>("But object-oriented programming treats objects as though they have a permanent fixed reality.")<br><br>"No it doesn't."<br><br>-- To a degree it does.<br><br>"What you're thinking about is the Composite Method Pattern."<br><br>-- No, because I don't know what that is. Care to explain? I am guessing it is not an accurate comparison. <br><br></td></tr></table><br>
<a name="482452"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Techlord</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#44">[#44]</a></td></tr></table></td></tr><tr ><td class="posttext"> I started programming with BASIC. My programming skills evolved into OOP as my programs became larger.<br><br>First I started to use a Labeling Rule to group constructs together by label. This made it easier to organize and recognize the purpose of construct in the code.<br><br>Second, I began to separate the groups into individual files. "Bot Stuff" goes into the "Bot" File, "RayGun Stuff" goes into the "RayGun" File.<br><br>Then I found Types. Types solved a lot of problems and used the Labeling Rule by default. Types only handled variables and arrays, I still employed the labeling rule  for functions.<br><br>Before I realized it, I was coding BASIC in a Object-based manner. Once I was made aware this, I picked up a book on C++ and OOP. <br><br>At first, Abstraction,   Encapsulation, Inheritence, and Polymorphism were a tad too tough to grasp. But, as I continued program using my home-made Object-Based techniques, the concepts began to take shape for me.<br><br>I've have worked around OOP for so long, that I have adopted the use of  many other programming techniques: <a href="http://c2.com/cgi/wiki?ObjectBasedProgramming" target="_blank">Object-based</a>,<a href="http://www.utexas.edu/its/windows/database/datamodeling/rm/rm4.html" target="_blank">Relational Key-based</a>, and <a href="http://en.wikipedia.org/wiki/Prototype" target="_blank">Prototype-based</a>.  In some cases these other techniques are more efficient then OOP.  <br><br>Object-based programming becomes a logical means organizing code into objects.  Relational Key based Programming becomes a logical means of  linking the objects together by ID Keys. Protoytype-based programming becomes a logical means of creating new objects from a template.<br><br>I still use my Labeling Rules to keep code readible. <br><br></td></tr></table><br>
<a name="482623"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FlameDuck</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#45">[#45]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> -- For me it is, so it's a matter of personal preference. <br></div>Very well then. Perhaps you could give an example of an unethical programming problem. A problem we, as programmers, should not attempt to solve, because doing so is unethical?<br><br><div class="quote"> -- Then that requires at least two objects or a class and an object. My system requires only one `object`.  <br></div>Please elaborate.<br><br><div class="quote"> -- A tree is not just a tree. That's a human interpretation of it. There is more to it. Whether that `more` is important is the issue here. It's important to me. Maybe it doesn't matter for others. <br></div>Ofcourse a tree is a tree. Human interprentation has nothing to do with it, as human interprentation is dependant of the human that does the interprentation. If that more is more important to you, you simply include it in your object model. Whether you chose to bloat your objects with redundant or superfluous states or behaviors is entirely up to you. I would reckomend against it, but each to his own I guess.<br><br><div class="quote"> -- To a degree it does.  <br></div>Elaborate please.<br><br><div class="quote"> -- No, because I don't know what that is. Care to explain? I am guessing it is not an accurate comparison.  <br></div>Sure. The composite pattern is one of the original "Gang of Four" structural patterns and is described in great detail in the book "Design Patterns: Elements of Reusable Object-Oriented Software" by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (aka. the Gang of four, or just GoF for short). It allows you to create structures of infinite (limited by computer hardware, naturally) complexity, and address them as one. It is your "one object" if you will. It's made up of three distinct type of objects:   A component - which can be either a Leaf or a Composite, a Leaf which is the actual object in question, and a Composite which works as a container for components.<br><br>By far the most common use for the composite pattern is when designing graphical user interfaces.<br><br>Again I can only strongly suggest looking at SIMULA, not SmallTalk for ideas on how Object Oriented disciplines can help you design your software. Additionally I would suggest reading up on agile methodologies that employ Object Oriented principles religiously, like Extreme Programming for example. <br><br></td></tr></table><br>
<a name="482792"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#46">[#46]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks Mikkel for the feedback. <br><br></td></tr></table><br>
<a name="482903"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >John Pickford</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#47">[#47]</a></td></tr></table></td></tr><tr ><td class="posttext"> What about my feedback?  Talk about ungrateful. <br><br></td></tr></table><br>
<a name="482924"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#48">[#48]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks John ;-) <br><br></td></tr></table><br>
<a name="482985"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >flying willy</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#49">[#49]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've gone back to Blitz3D. It pains me to say but I really don't get OO in Blitzmax and nor do I like the way types work. It's a lot for me to fiddle with and remember.<br><br>I know, not an excuse, but there's something quite unsatisfying about Blitzmax right now and although I'm trying my best, the OO stuff just doesn't seem to make anything BETTER than what I can do now anyway.<br><br>In fact I'm finding myself having to do more typing in order to achieve the same results.<br><br>With Blitz3D, you have insert before, after, and really easy types management. Blitzmax requires you to mantain seperate lists and doesn't have commands to easily access types.<br><br>I'm sure many will argue, but BM just doesn't click like Blitz3D did. <br><br></td></tr></table><br>
<a name="483278"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FlameDuck</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#50">[#50]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote">  Blitzmax requires you to mantain seperate lists <br></div>It does not require you to maintain seperate lists, it merely doesn't force you to use a list if some other datastructure is more suitable. Incidently classic Blitz auto-lists can be implemented using 5 lines of code.<br><br><div class="quote"> and doesn't have commands to easily access types. <br></div>What do you mean? How has type access changed? <br><br></td></tr></table><br>
<a name="483281"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Michael Reitzenstein</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#51">[#51]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> What do you mean? How has type access changed?  <br></div><br><div class="quote"> With Blitz3D, you have insert before, after, and really easy types management. <br></div> <br><br></td></tr></table><br>
<a name="484094"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FlameDuck</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#52">[#52]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> With Blitz3D, you have insert before, after, and really easy types management.  <br></div>First of all, this has nothing to do with type access, and second of all, I don't see how Blitz3D is any easyier than BlitzMAX. <br><br></td></tr></table><br>
<a name="484191"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dynaman</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#53">[#53]</a></td></tr></table></td></tr><tr ><td class="posttext"> &gt; First of all, this has nothing to do with type access<br><br>Well it is how you can insert items into a type list in B3D wherever you want - so it isn't exactly not related :)<br><br><br>&gt; With Blitz3D, you have insert before, after, and really easy types management.<br><br>In Blitzmax you can get the same effect easier by setting the comparison properties of a type list - then blitzmax would keep it sorted for you automatically.  (If I am right in assuming that keeping things in a certain order is what you were after) <br><br></td></tr></table><br>
<a name="484435"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Techlord</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#54">[#54]</a></td></tr></table></td></tr><tr ><td class="posttext"> I totally understand where the flying willy is coming from. I think using the <i>Type</i> Keyword in the manner BMAX does is somewhat confusing, if you're familar with previous BlitzBasic Languages. IMHO, the <i>Class</i> Keyword would have been totally appropiate.<br><br>BMAX has some significant syntax changes which make it more similar to C++. It is almost a completely different animal then its predecessors. The introduction to Classes could 'fit' here very well.<br><br>To be honest, all the tutorials on OOP don't explain it in easy-to-understand terms. There is only a small vague definition of what object is and the books/tutorials jump into explaining inheritence, ecapsulation, yada, yada. No one goes in depth on how to identify an physical or virtual object in the first place.<br><br>I've adopted many different programming methods, disciplines, and paradigms all which use a Procedural Language like Basic. <br><br>After writting a compiler and virtual machine for my <a href="/posts.php?topic=39622" target="_blank">BlitzScript3D Engine</a> I realized you simply cannot beat Assembly. Not much OOP involved with it either. <br><br></td></tr></table><br>
<a name="484485"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#55">[#55]</a></td></tr></table></td></tr><tr ><td class="posttext"> OO programming is the best way to create games. All the logical structures used in the development of an algorithm are objects. When ussing languages such as Blitz3D, wich is not OO, you have to 'create' objects (such as a rocket, a bullet, etc), but this objects don't have any existence in the code. they are just a mixture of variables, arrays, etc. OO programing is the best way to organize things, and it helps applications to grow and grow in a good way. <br><br></td></tr></table><br>
<a name="484590"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Techlord</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#56">[#56]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> you have to 'create' objects (such as a rocket, a bullet, etc), but this objects don't have any existence in the code. they are just a mixture of variables, arrays, etc. <br></div>Ziggy you confuse me with this statement. If you create a type structure and write it in the code, does the object or record not exist in the code? <br><br>C++ Classes evolved from C's Type Structs. For all intense purposes, aren't all objects are just a mixture of variables, arrays, methods etc under one identifier at least from a compiler perspective. <br><br></td></tr></table><br>
<a name="484602"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Michael Reitzenstein</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#57">[#57]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> First of all, this has nothing to do with type access, and second of all, I don't see how Blitz3D is any easyier than BlitzMAX.  <br></div><br>It has to do with how objects in a link list are accessed. If you don't see how being able to go:<br><br><pre class=code>a.Alien = First Alien
g = After a</pre><br><br>Isn't easier than the way we have to do it in Max, then you need your head checked. <br><br></td></tr></table><br>
<a name="484616"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Techlord</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#58">[#58]</a></td></tr></table></td></tr><tr ><td class="posttext"> Michael<br><br>Would you be so kind as to provide an example of how you do it in BMax. There are many ways to access data from types in Blitz3D. You have Object/Handle Functions; You can use an Array of Types; and you  have your Sequential Access commands like Before, After, etc. <br><br></td></tr></table><br>
<a name="484700"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FlameDuck</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#59">[#59]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> IMHO, the Class Keyword would have been totally appropiate. <br></div>Traditionally Class and Type are interchangeable. One is from Simula, the other from SmallTalk. Which one you use tends to generally depend on how you got introduced to the object oriented paradigm (or whether you're European or American).<br><br><div class="quote"> C++ Classes evolved from C's Type Structs. <br></div>No they didn't. C++ classes evolved from classes in object oriented languages like Simula (1968) and SmallTalk (1971). Structs evolved from the need to group some variables together (something which was not possible in it's predecessor B).<br><br><div class="quote"> Isn't easier than the way we have to do it in Max, then you need your head checked.  <br></div>I'm sorry. I was not aware there was a way MAX forced you to do it, although I must admit it's been a while since I tried to itterate through a list manually, as I tend to just use EachIn, which is a big step up from For..Each, IMHO.<br><br>Thanks for the personal insult, very becomming of you to belittle my person because I have a different oppinion than yours. <br><br></td></tr></table><br>
<a name="484765"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#60">[#60]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm struggling to follow this but, I think, I'm in the same boat as Frank. How could you manage, for example, the same function as Object/Handle in BlitzMax. <br>I'm sure there was another thread which discussed this at even more length but I can't remember the outcome. <br><br></td></tr></table><br>
<a name="484801"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dynaman</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#61">[#61]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm a little lost as to why it is hard or confusing, of course I've been doing OOP for awhile now.  For the object handle I myself don't find it any harder to create a bunch of images and refer to them in blitzmax then it is to handle images in blitz.  For lists it does take an extra step to get them created but after that it is just as easy - different but just as easy. <br><br></td></tr></table><br>
<a name="484823"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FlameDuck</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#62">[#62]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> How could you manage, for example, the same function as Object/Handle in BlitzMax.  <br></div>It depends on what you're using Object/Handle for. In 99% of all cases you would acheive this more elegantly using polymorphism, and function/method overloading.<br><br>For instance a typical example would have you defining what Java refers to as an Interface, but which isn't actually formalized in BlitzMAX. However you can fake it well enough making a class that's entirely Abstract (having no functionality at all).<br><br>What's the point of making a Type with no functionality? It's hard to imagine, think of it as a skeleton of the functionality you can have. The point is that you now have a type that your other types can extend from. No matter what functionality they have, you can access this functionality in a uniform manner.<br><br>So if you have for example 4 types, car, bus, train and airplane -- all which have different states and behaviours, that are implemented differently you can pass them all to the same function, by using the Interface as a reference to which functionality they have. No need for Object/Handle! Additionally you don't need a field that identifies which type of object it is, as the compiler knows this, and will automatically execute the correct code for a given object, without the need to construct complex nested if ... else or Select ... case structures.<br><br>Additionally you can later add a fifth type, motorcycle, and all you have to do, is write the new implementation, and all of your old code will still work perfectly! There's no need to work out special cases for different objects, because the compiler can tell the difference, so you don't have to! <br><br></td></tr></table><br>
<a name="484846"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Techlord</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#63">[#63]</a></td></tr></table></td></tr><tr ><td class="posttext"> I personally dont use Object/Handle commands. But, from what I've seen in others code, they use them as means to randomly access types vs accessing them sequentially with a For...Each loop. But as I stated eariler, I dont have a problem with OOP. I just feel that many books/tutorials hop into concepts of encapsulation, inheritence, yada, yada before really explaining how to identify and create an 'object' in the first place. <br><br></td></tr></table><br>
<a name="485041"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Michael Reitzenstein</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#64">[#64]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I'm sorry. I was not aware there was a way MAX forced you to do it, although I must admit it's been a while since I tried to itterate through a list manually, as I tend to just use EachIn, which is a big step up from For..Each, IMHO. <br></div><br>EachIn has nothing to do with it. We are talking manual iteration through a linked list, that is, being able to grab the previous or next item.<br><br>There isn't any way Max forces you to do it of course, but there are no simple, out of the box methods you can use. When we're talking simplicity, simplicity only after you've implemented a new feature in the linked list stuff just doesn't cut it.<br><br><div class="quote"> Thanks for the personal insult, very becomming of you to belittle my person because I have a different oppinion than yours.  <br></div><br>I really don't know what to say to that, but I don't see how you can go and take the moral high ground after consistantly treating people like idiots and forever arguing your points (even when you're wrong) to death. <br><br></td></tr></table><br>
<a name="485048"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >N</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#65">[#65]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I totally understand where the flying willy is coming from. <br></div><br><br>Do you have any idea what you're typing? 0_o<br><br>This one's goin' in the vault. <br><br></td></tr></table><br>
<a name="485055"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#66">[#66]</a></td></tr></table></td></tr><tr ><td class="posttext"> lol <br><br></td></tr></table><br>
<a name="485264"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Scienthsine</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#67">[#67]</a></td></tr></table></td></tr><tr ><td class="posttext"> I hate OO advocates. In the end, everything is proccedural(sp?) anyway. The only reason I use Blitz instead of C++ is because it reduces the amount of typing and such that I have to do. The only reason I would use c++ instead of ASM is for this same reason. Alot of the time I find myself typing tons more OO code to do what I could do in ASM in a few lines! wtf?<br><br>I hate the amount of overhead introduced by the famous "GetValue", "SetValue" mehtods. I hate hiding code alot of the time... If they want to break it, let them.<br><br>I use OOP when I need a dynamic amount of instances of something. This is the place where I like OOP. I don't make everything into a class. Anyway, whatever. I like where Blitz is now. BMax is great. And, for the record, I have used more OOP in BMax than Proc so far...<br><br>Ohh and Inheritence is very usefull. <br><br></td></tr></table><br>
<a name="485368"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FlameDuck</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#68">[#68]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> In the end, everything is proccedural(sp?) anyway. <br></div>What do you mean by "everything"? Program execution is not everything. By extending the same arguement you could say that you hate human readable languages (like Basic and C) because "everything" is executed in opcodes anyway, so we should all go back to using punch cards and magnetic tape.<br><br>The object oriented paradigm is meant to make programming more accessable to non-scientist types. The theorem goes that an ordinary person, particularly a computer user, will be more accustomed to understanding things in terms of objects (because that's how we percieve the real world) than arbitrary computer code.<br><br>Additionally object orientation in a programming language works as an abstraction from procedural languages, in much the same way BASIC for example is an abstraction from Machine Language Assembly. It allows you to, as you put it, "type less". (Although the traditional phrase is solve problems of a higher complexity in a shorter relative ammount of time.) <br><br></td></tr></table><br>
<a name="485401"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bot Builder</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#69">[#69]</a></td></tr></table></td></tr><tr ><td class="posttext"> I agree, it is a more natural system, however, that actually makes it harder for procedural programmers, at least until they start using it regularly.  Same with say, switching to a functional language, except much more dramatic since functional languages are bizarre to a procedural/oop programmer, however not as hard for a non-programmer type. <br><br></td></tr></table><br>
<a name="486440"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Clyde</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#70">[#70]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think it's good, allthough all the extends this one, and this extends that one - confuse me. Also what is the difference between a Method and a Function, as they appear to do exactly the same purpose? <br><br></td></tr></table><br>
<a name="486499"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Techlord</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#71">[#71]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I hate OO advocates <br></div> Such strong words. I don't hate them, but, I don't understand the fanaticism. Afterall, its only Programming Paradigm, not a religion. <br><br>As my Procedural programs increased in size and complexity I found myself adopting Object-Based programming techniques to better organized them. But, I also adopted other techniques, paradigms, methodologies or what ever you want to call them, to make my life as a programmer <i>easier</i>.<br><br>The concepts of OOP are really not that complicated if one breaks down those fancy words: Abstraction, Polymorphism, Encapsulation, Inheritance, Interfaces, blah, blah. But, those words in themselves suggest complexity.<br><br>Some would have to admit the C++ syntax is not the most user-friendly, heck, C isnt for that matter. I think BlitzMax attempts to give OOP a friendly face. IMHO its easier to transition into OOP from a procedural programming if you start with Object-Based techniques. <br><br></td></tr></table><br>
<a name="486508"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FlameDuck</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#72">[#72]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> But, those words in themselves suggest complexity. <br></div>How do you figure that?<br><br>How can words suggest complexity? <br><br></td></tr></table><br>
<a name="486509"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#73">[#73]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've little experience of OOP so I'm struggling slightly. <br>However, my major gripe with OOP in BlitzMax is it's turning me into a programmer when I only want to be a games creator.<br>It probably stems from my hopes for BMX.<br>I would have been happy with B2D+(realtime) alpha, rotation, scaling, lighting as it was the only stuff missing for me. I was just getting the hang of the alpha stuff limitations and considering B3D+nsprite pro when BlitzMax beta was announced.<br>I can't say I'm overly impressed at the moment. In fact, I was happier with 1.02 than 1.03.<br>The IDE hasn't advanced much (time for a 3rd party) and the debugger is poor. The suggestion the doc isn't to be updated (except through the Wiki) is a big disappointment.<br>I think what I'm saying is I can't get the impetus to worry about OOP when, at the moment, I'm not sure how useful the final product will be for me.<br>As for OOP itself, it's one of the last bastions of complexity which keep the plebs out of programming. <br><br></td></tr></table><br>
<a name="486607"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FlameDuck</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#74">[#74]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> However, my major gripe with OOP in BlitzMax is it's turning me into a programmer when I only want to be a games creator. <br></div>How do you reckon that? BlitzMAX is a higher abstracted language than Blitz/3D/Plus. Thus using it requires you to be less of a programmer (that is less capable of understanding how a computer works) than you would have with earlier versions of Blitz.<br><br><div class="quote"> As for OOP itself, it's one of the last bastions of complexity which keep the plebs out of programming.  <br></div>Could you send me an e-mail please? I'd like to ask you something in private. <br><br></td></tr></table><br>
<a name="486680"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#75">[#75]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hmmm. I thought I had responded on this but let's try again.<br><div class="quote"> <br>How do you reckon that? BlitzMAX is a higher abstracted language than Blitz/3D/Plus. Thus using it requires you to be less of a programmer (that is less capable of understanding how a computer works) than you would have with earlier versions of Blitz. <br> <br></div><br>I'm sure you're right.<br>However, Blitzmax is making me become a programmer rather than a Games Creator. I'm confident with the Blitz command set and modular/procedural programming so I was hoping BlitzMax would be a maximised version of Blitzbasic rather than a different approach. To learn OOP procedure and, possibly, OpenGL while fighting with the doc and waiting for 3rd party 'add-ons' isn't really what I had in mind when I bought (the beta of) BlitzMax. Due to other commitments I don't really have the computer time to put that much effort into it whereas BlitzBasic was a 'go' from day1.<br>I've emailed you as well. <br><br></td></tr></table><br>
<a name="488187"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >SSS</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#76">[#76]</a></td></tr></table></td></tr><tr ><td class="posttext"> I am personally one of the people who really like oop and like the ways in which it makes the programming process more logical. I would also like to point out one thing about the Object/Handle commands in bb3D and how you can imitate them in blitzMax. <br><br>in BB3D you used to do this,<br><pre class=code>
a = CreateFoo()
DoSomethingToFoo(a)

function CreateFoo()
    f.foo = new foo
    f\a = 0
    return Handle(f)
end function

function DoSomethingToFoo(handle)
    f.foo = Object.foo(handle)
    f\a = f\a +1
end function
</pre><br><br>in blitz max you can do the following (i think because everything is derived from a base object class but i'm not sure)<br><pre class=code>
Type foo
	Field a:Int
End Type

a:Int = MakeFoo()
DoSomethingToFoo(a)


Function MakeFoo:foo()
	f:foo = New foo
	f.a = 0
	Return f
End Function

Function DoSomethingToFoo(f:foo)
	f.a :+ 1
End Function 
</pre><br>now i could be wrong but how does that not give you the same functionality as bb3d's object handle commands.. you're casting the f:foo into a reference integer which is exactly what object handle does <br><br></td></tr></table><br>
<a name="488247"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grover</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#77">[#77]</a></td></tr></table></td></tr><tr ><td class="posttext"> Opinions on object oriented programming - LOL!<br><br>I almost fell over when I read that title<br><br>OOP is a very cult like world. Its alot like the fanaticism seen with the consoles, or cars, or favourite OS's.<br><br>Languages are tools, use them as you would a tool, and dont worry about what other people think - its there to do a job, just do the job :-) <br><br></td></tr></table><br>
<a name="488371"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#78">[#78]</a></td></tr></table></td></tr><tr ><td class="posttext"> Apparently some of us are subjective ;-) <br><br></td></tr></table><br>
<a name="488565"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grover</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#79">[#79]</a></td></tr></table></td></tr><tr ><td class="posttext"> Pedantic would be more appropriate. :-) <br><a href="http://dictionary.reference.com/search?q=pedantic" target="_blank">http://dictionary.reference.com/search?q=pedantic</a> - its pretty appropriate I think (imho of course).<br><br>You think in 20 years time it will matter what langauge you use to make an application on a 100 Tera flop machine :-) I guarantee using C++/OOP will be like people refer to asm now.. takes too long. Its a tool.. not a way of life. <br><br></td></tr></table><br>
<a name="488888"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Alberto</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#80">[#80]</a></td></tr></table></td></tr><tr ><td class="posttext"> Most people , also here in blitz3d forum, think that openGL architecture is much more straightforward than direct x.<br>Why ? <br>OpenGL is a simple library of functions and and variables , while direct x is oop<br>An other example<br>I have tested several game engines.<br>The learning curves for the oop ones is quite steep while I got familiar with non oop engines in a couple of hours. But if you ask , do you like oop?<br>most of people answers, yes<br>In conclusion in my opinion oop is a sort of "fashion"<br>Obviously I do not mean that it is of no use, I am not so competent, for big projects probably it is a must, but  for an hobbyest or shareware programmer it is of little use, except  at a very basic level.<br>I like classes but they are a simple extensions of c structers.<br>Beyond that it only a mess. <br><br></td></tr></table><br>
<a name="489117"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FlameDuck</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#81">[#81]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> You think in 20 years time it will matter what langauge you use to make an application on a 100 Tera flop machine <br></div>Even today, it doesn't matter. That's why PL/1 programmers can ask (and get!) whatever salary they want.<br><br><div class="quote"> OpenGL is a simple library of functions and and variables , while direct x is oop <br></div>Actually it's the other way around. (Except "Managed DirectX" which is now also OO).<br><br><div class="quote"> Obviously I do not mean that it is of no use, I am not so competent, for big projects probably it is a must, but for an hobbyest or shareware programmer it is of little use, except at a very basic level. <br></div>That's a very 'elitist' (for lack of a better word) thing to say. Many OO methodologies, such as XP (extreme programming) and UP (unified process), include quality assurance and quality control techniques (such as unit testing), making it easier to create programs to a high standard. If that's not your intention, I can see how OO and it's associated methodologies might not be your cup of tea.<br><br>Additionally the OO paradigm allows for easier maintenance, making it easier to add new functionality, expand on old functionality or port to newer platforms (as you can keep platform independant code modularized).<br><br><div class="quote"> I like classes but they are a simple extensions of c structers. <br></div>Again it's the other way around. Structs in C are a cheap imitation of classes in SIMULA and SmallTalk, since B and BCPL did not have any advanced datatype support at all. <br><br></td></tr></table><br>
<a name="489176"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#82">[#82]</a></td></tr></table></td></tr><tr ><td class="posttext"> Jeez this is getting to be a long thread ;-) <br><br></td></tr></table><br>
<a name="490267"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grover</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#83">[#83]</a></td></tr></table></td></tr><tr ><td class="posttext"> Id really like to know how OGL suddenly became oo? Since SGI made it 20 odd years ago, its been about as C as you can get. And DX (esp from 5 onwards) has a well defined OO background - especially being derived from COM (OO!). <br><br>Also, OO doesnt define unit testing (otherwise we would have had troubles at uni when I went. :-)). Unit testing is simply a methodology (like black box, white box testing and so on). This is regardless of the language - you can unit test Forth, but I doubt too many would call Forth oo, same goes with ASM, or pretty much any langauge.<br><br>Alberto is fair in judging classes in C++ as extensions from C structs - the simple understanding is that C is a subset of C++, which is the case (otherwise C++ compiler wouldnt be able to compile C). Other lanugages implemented different notations and design ideas - C++ was an extension of an already heavily used language (having its roots back in the early days of programming).<br><br>.. Its not long.. its just started .. :-) <br><br></td></tr></table><br>
<a name="490424"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Techlord</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#84">[#84]</a></td></tr></table></td></tr><tr ><td class="posttext"> Not sure why OOP is a paradigm when its modeled after the realworld. Heck, most man-made creations are modeled after the real-world. Anyhows, any thoughts on OOPM? Object-Oriented Project Managment? <br><br></td></tr></table><br>
<a name="490443"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FlameDuck</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#85">[#85]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Id really like to know how OGL suddenly became oo? <br></div>You're right. It didn't. My bad.<br><br><div class="quote"> Since SGI made it 20 odd years ago, its been about as C as you can get. <br></div>SGI did not make it 20 years ago (they made it in 1992).<br><br><div class="quote"> And DX (esp from 5 onwards) has a well defined OO background - especially being derived from COM (OO!).  <br></div>What do you mean by "well defined OO background" and "derived from COM"? Please elaborate. I was under the impression that COM was a technology, and it did not nessecarilly require object orientation (you can for instance program COM+ applications in C).<br><br><div class="quote"> Also, OO doesnt define unit testing <br></div>AFAIK Unit test is an activity in Extreme Programming, an OO methodology. By all means tho' point me in the direction of a unit test framework that doesn't work with classes. I'm not sure what they taught you at Uni.<br><br><div class="quote"> you can unit test Forth, but I doubt too many would call Forth oo, same goes with ASM, or pretty much any langauge. <br></div>Perhaps you care to provide an example of this?<br><br><div class="quote"> Alberto is fair in judging classes in C++ as extensions from C structs <br></div>No he isn't, because they aren't. Classes where invented 5 years before C was even written. Simula from 1967 uses classes, as does SmallTalk from 1971. Early versions of C where written in 1972 (and at the time was probably only available to Dennis Ritchie and Ken Thompson).<br><br><div class="quote"> C++ was an extension of an already heavily used language (having its roots back in the early days of programming). <br></div>Except according to Bjarne Stroustup (the "inventor" of C with Classes, later C++) C++ was designed as a mix between the usability and flexibility of Simula67, and the raw speed and power of C - because Simula67 was, not fast enough for what Mr. Stroustrup wanted to use it for. So no, classes where not "the natural evolution of structs". They where invented half a decade earlier, and by the time Stroustrup had finished on preliminary verions of C++ (1980), object oriented programming languages had exsisted for more than 20 years. The only reason C became more popular was because a compiler for it was distributed with Unix (System I-V) and BSD.<br><br><div class="quote"> Not sure why OOP is a paradigm when its modeled after the realworld. <br></div>Huh? What <a href="http://dictionary.reference.com/search?q=paradigm" target="_blank">definition of paradigm</a> are you going by?<br><br><div class="quote"> Object-Oriented Project Managment? <br></div>Dunno, never tried it. Got linkage? <br><br></td></tr></table><br>
<a name="491132"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >podperson</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#86">[#86]</a></td></tr></table></td></tr><tr ><td class="posttext"> Unit testing is an idea that predates Extreme Programming, but has been adopted by it. The idea is simply to write code or a script that can be used with a given code component that exercises it and verifies that it works according to spec. This is perfectly possible to do in any programming language and has nothing to do with (pro or con) OO programming.<br><br><a href="http://en.wikipedia.org/wiki/Unit_test" target="_blank">http://en.wikipedia.org/wiki/Unit_test</a><br><br>Object-Oriented languages, in general, range from "Procedural Languages with Classes and Inheritance" through to "Everything, absolutely everything, is an object, including the runtime-environment and the debugger" languages such as Smalltalk.<br><br>At the left side of the scale (and C++ is a bloated example of this) you essentially get identical (run-time) performance to procedural languages (since you're still using a procedural language) with the option of using inheritance and polymorphism to simplify your code.<br><br>At the right end of the scale you tend to see dramatic benefits on the programmer productivity side and dramatic declines on the raw performance side. (Smalltalk is damn slow.)<br><br>So to address the original topic: <b>Opinions on object oriented programming</b> -- I think that the OO approach taken with BlitzMax is a no-lose situation. You're not giving anything up (don't like objects? don't use them).<br><br>We can debate the merits of moving further to the right on the scale (since most of what we do with BlitzMax is being done by libraries of compiled code or graphics hardware, the raw performance of the language itself is possibly not that important), but the OO implementation in Max is costing us nothing. <br><br></td></tr></table><br>
<a name="728758"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Digital Anime</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#87">[#87]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm still trying to get the hang of OOP, but so far so good. I must say that the tutorials helped me a lot in creating something to start with.<br><br>At first when looking at the code on some small OOP applications it seemed clear to me, but after trying to start from scratch to see if I can use objects in a new project I was confused about how the variables worked and it took me a long time before the application would start without giving me some kind of error message...<br><br>But after a while I finally got the hang of it and I must say that it saves a lot of time creating a game with lots of the same type of units when used correctly. Just enter the rules on what that unit needs to do when created... :-)<br><br>The only thing I am still trying to find out is how I can speed up the game I'm creating. I know it has something to do with checking all possible collisions... But I will first read some more tutorials on that first before asking any stupid questions. :-P <br><br></td></tr></table><br>
<a name="728778"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#88">[#88]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm really not sure that oop is the ideal way of doing things. In some ways procedural was lacking but in some ways oop is lacking too. It's really a change in mindset (or paradigm) in thinking about things and structuring their relationships. It is pretty nice to modularize things and keep related things in the same place, but to do it strictly breaks down a number of more efficient ways of doing things. I don't want all my `objects` to be so separate that they barely talk to each other and have to do all kinds of formalities just to relay information back and forth. I am trying to design a game engine and make it sort of oop-ish to have objects and flexibility with them, so that it looks like each item is a separate entity, but separation is not a good foundation. The reality of the world is founded on separation ideas so maybe a separation-based paradigm is a good reflection of `life situations`, but at the same time I do not think this necessarily means that this solves problems in the most elegant or efficient way. The universe is just a big dream and who would want to use that for their inspiration when you have a clean and beautiful alternative? I prefer to look upon these paradigms and decide where i want to use oop and where i want to use procedural and where i want to put boundaries and when i want to follow rules and when i don't. That is more encompassing and inclusive and efficient to me. <br><br></td></tr></table><br>
<a name="728967"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >SculptureOfSoul</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#89">[#89]</a></td></tr></table></td></tr><tr ><td class="posttext"> At some point in the (hopefully near) future I intend to learn Lisp. From my brief introduction to functional programming, it seems like the most powerful programming paradigm available - especially in a language like Lisp where the line between code and data is so thin.<br><br>I'd suggest looking into Lisp Daniel, or even Lua. I'm trying my hand at learning Lua (to use as a scripting language for my MUD server) and finding it to be extremely powerful. In fact, it's hard to imagine how to utilize some of it's features when you come from a statically typed background like I do. Despite the fact that Lua itself doesn't offer a wealth of libraries, the language design should inspire you or at the least, give you some ideas for your own language implementation. <br><br></td></tr></table><br>
<a name="728995"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dubious Drewski</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#90">[#90]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is kind of a silly thread.<br><br>With that said, a healthy amount of OOP <i>is</i> a better way<br>to program than straight procedural.  Anyone who says <br>otherwise does not fully understand OOP. <br><br></td></tr></table><br>
<a name="728997"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#91">[#91]</a></td></tr></table></td></tr><tr ><td class="posttext"> functional programming is really powerfull but for programmers of "regular" languages its hell to learn and get used to it and many many hairs will have to suffer until you are able to program anywhere even near as easy and fast as with procedural or OO ... (I had my fun with prolog and haskell ...) <br><br></td></tr></table><br>
<a name="729009"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >SoggyP</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#92">[#92]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hello.<br><br>Ultimately, non-procedural and non-oop languages are going to be faster.  They're just not as maintainable/future proof or as easy to code, and will generally have a larger footprint.  Of course, as more development time is spent on refining the compilers, and offering better optimisations, for a particular paradigm then the differences in speed should reduce.<br><br>Abstraction of coding techniques is not, in the first instance, about making executables run faster it's about providing a more understandable paradigm within which to develop.<br><br>Different strokes for different folks, I guess.  Also, a lot of the time it's going to be dependant upon what you're trying to acheive.  List manipulation is preferable using something like LISP because it's an abstraction compatible with the problem domain.<br><br>Goodbye. <br><br></td></tr></table><br>
<a name="729015"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FlameDuck</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#93">[#93]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> With that said, a healthy amount of OOP is a better way to program than straight procedural. <br></div>It is absurd to suggest that one programming paradigm is "better" than another. Better at what? <br><br></td></tr></table><br>
<a name="729024"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AntonyWells</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#94">[#94]</a></td></tr></table></td></tr><tr ><td class="posttext"> It's clear what OOP is. it's cyngus worst nightmare.<br><br>Flameduck, it's clearly better...anyone who thinks otherwise is living in the past and probably thinks kirk is a better captain than picard. I laugh at them, and I laugh at you. Hah! <br><br></td></tr></table><br>
<a name="729046"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#95">[#95]</a></td></tr></table></td></tr><tr ><td class="posttext"> OOP makes sense the way I have seen it used in BlitzMax.  However, I think a lot of C/C++ programmers go overboard with it.  Considering that it takes a team of C/C++ programmers to do what one BlitzMax programmer can do, I think there's something to that. <br><br></td></tr></table><br>
<a name="729091"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#96">[#96]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think it is a little bit stupid to make a war, asking if it is better to program OO or proceduraly. If the way you build your logical structures in your mind is OO, then you should program OO. If your logical constructions are, like in a lot of cases, sequental algorithms, you should program using procedures. the best choice is always the choice that fits your needs best. There's also a third way of programing, what I would call mixed OO programming, lots of programers use it. they build a huge procedure that deals with little classes, and they get very interesting results.<br><br>For my personal way of coding, I preffer OO programing, it helps me a lot on maintenance and bugfixing, and development is faster; but you know, that's my personal choice. <br><br></td></tr></table><br>
<a name="729246"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dubious Drewski</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#97">[#97]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> It is absurd to suggest that one programming paradigm is "better" than another. Better at what? <br></div>  Better at organizing code, easier function manipulation...etc  I <br>programmed for <i>years</i> proceduraly before I finally <br><i>got</i> OOP.  Do you guys know of some crazy procedural <br>techniques that I never knew about?  Because from my point <br>of view, it's messy, illogical and innefficient by comparison.<br><br>You are right though, Ziggy and Flameduck, it doesn't matter<br>what you want to program with.  BUT this thread was created<br>for the sole purpose of discussing this.  So, here and now,<br>it's fine to debate it.<br><br><div class="quote"> If the way you build your logical structures in your mind is OO, then you should program OO.  If your logical constructions are, like in a lot of cases, sequental algorithms... <br></div> You sound like you're saying OOP code has no procedural <br>elements to it at all!  What do you mean by that quote?  <br>What kind of crazy OOP have you seen that has <i>no</i> <br>procedural elements to it? <br><br></td></tr></table><br>
<a name="729306"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >rdodson41</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#98">[#98]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well we have languages like C and Java where you don't get a choice of how you program, but luckily for us, in BlitzMax, you have the choice to program however you want. Some tasks are better suited for one type than the other, but BlitzMax was made to allow each individual programmer to decide for themselves the way they want to program. That's why BlitzMax is such a great language. <br><br></td></tr></table><br>
<a name="729355"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#99">[#99]</a></td></tr></table></td></tr><tr ><td class="posttext"> I agree with Leadwerks, that C++ is definitely "over the top" especially as too much freedom is granted to the user. Not because freedom is bad, but because freedom means more hacks as well and less clear and enforced common structure.<br><br>For that reason, my top OO language is Eiffel (its definitely the best. The only language I know which has export and access settings for any method *ie you can fully specify which class is able to access this query, method or function. All and none are possible as well* if you need it. And full redefine, undefine, rename machnism with fully featured inheritance which means you can inherit from any type of class *abstract or implementation, just not final*. something no other language even offers).<br>After Eiffel, I rate C# and Java the best. Mainly C# before Java, because Java isn't that suited for games due to its structure.<br>But beside that its surely a nice language as well.<br><br>C++ might have been nice years ago, but it somehow missed the point where stability and safeness became the most important part of a software, not pure hack and optimation possibilities ... but after all, thats the Linux paradigma, so it isn't its own fault. It just never had a reason to evolve.<br><br>MS and Apple have their own safe OO C derivates so unless you are a Linux user, forget about pure C++ if you are just starting. Use Managed C++, perhaps better C# or on Apple objective C <br><br></td></tr></table><br>
<a name="729388"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FlameDuck</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#100">[#100]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> it's clearly better...anyone who thinks otherwise is living in the past and probably thinks kirk is a better captain than picard. <br></div>That's a postulate, not an arguement.<br><br><div class="quote"> Because from my point of view, it's messy, illogical and innefficient by comparison. <br></div>So it's really just better from your point of view. Which was my point to start with. Saying paradigm x is better than paradigm y is absurd, because it's subjective. You're argumentation should be more objective, along the lines of "using the OO paradigm lets you develop software on a higher abstraction level, which means you can solve more complex problems in a shorter time". <br><br></td></tr></table><br>
<a name="729460"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dynaman</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#101">[#101]</a></td></tr></table></td></tr><tr ><td class="posttext"> &gt; Saying paradigm x is better than paradigm y is absurd<br><br>With the exception of Spaghetti code vs just about anything else of course.<br><br>On the serious side I use a mix of procedural and OO styles.  Some things lend themselves to a procedural approach and some to OO. <br><br></td></tr></table><br>
<a name="729521"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#102">[#102]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think oop is pretty nice for organizing thoughts and related things and keeping things tidy and modular, which is all to do with spacial organization really, but I think it falls short sometimes in terms of organizing time. It almost seems like saying "ok, organize everything based on spacial relations, and never mind how long it takes to process". Or maybe I don't `get it` yet. It's definitely easier to structure a larger app with some types version the old procedural method which is too `locked in`. Oop at least lets you put the boundaries where you want them. <br><br></td></tr></table><br>
<a name="729657"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Blueapples</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#103">[#103]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> a third way of programing, what I would call mixed OO programming, lots of programers use it. they build a huge procedure that deals with little classes, and they get very interesting results. <br></div><br><br>In the software world we usually call "interesting results" <i>incorrect</i>, <i>unpredictable</i>, or <i>buggy</i>.<br><br>I've heard it said that if you have a procedure longer than about 10 lines you need to rethink it: it's probably better if you refactor it out to several procedures that are easier to modify independent of the whole.<br><br>Okay, so take that a tiny bit further and attach the global data to each piece of code that deals with it. What have you got now? That's right. An object.<br><br>So that "huge procedure" that is undoubtedly unmanageable by anyone other than the guy who wrote it, has become smaller more manageable objects. Anyone can come in and work on one of those objects / pieces of code and adjust it. As long as the interface to the object remains the same, it will not affect the rest of the system. <br><br></td></tr></table><br>
<a name="729699"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#104">[#104]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oops! (pun intended) I have a procedure that's at least a few thousand lines long. :-D <br><br></td></tr></table><br>
<a name="729880"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Arowx</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#105">[#105]</a></td></tr></table></td></tr><tr ><td class="posttext"> I tend to think off OOP as a way to simulate or model something, as long as I keep it simple and don't get too drawn into using loads of design-patterns where they aren't needed then OOP allows me to build up quickly a model of a system or game!<br><br>When you start adding lots of layers of indirection and generalise things down to their common denominators it can get either too complex or more elegant.  For me it usually ends up too complex! <br><br></td></tr></table><br>
<a name="729964"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >bradford6</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#106">[#106]</a></td></tr></table></td></tr><tr ><td class="posttext"> The way I like to think about OOP is to break it down into 3 categories.<br><br>1. Encapsulation- This is my favorite. Type Declarations bundle up an abstract concept neatly and keep it tidy fromthe rest of my code. Done Right, it's reusable and clean.<br><br>2. Composition- I like to build my types out of other types<br><br>3. Polymorphism- I try to program to a supertype whenever it makes sense. <br><br></td></tr></table><br>
<a name="853049"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tin</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#107">[#107]</a></td></tr></table></td></tr><tr ><td class="posttext"> OOP in BlitzMax is very much simpler and easy to understand than traditional languages even tough it's same.<br><br>I am one day old BlitzMax licensed user :) <br><br>nice to meet you all.<br>Tin <br><br></td></tr></table><br>
<a name="853086"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#108">[#108]</a></td></tr></table></td></tr><tr ><td class="posttext"> You're welcome! <br><br></td></tr></table><br>
<a name="853174"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#109">[#109]</a></td></tr></table></td></tr><tr ><td class="posttext"> OOP is the only way for many things, BUT when people start talking about supertypes and serializing/deserializing objects, you know they are full of sh*t.<br><br>My most complex hierarchy is like this:<br>TEntity<br>TLight Extends TEntity<br>TPointLight Extends TLight<br>TSpotLight Extends TLight<br>TDirectionalLight Extends TLight<br><br>Any programmer who gets more complicated than that is just masturbating on company time. <br><br></td></tr></table><br>
<a name="853181"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gabriel</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#110">[#110]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> OOP is the only way for many things, BUT when people start talking about supertypes and serializing/deserializing objects, you know they are full of sh*t. <br></div><br>Anyone who writes their objects out to disk and loads them back in again is full of it? Or only if they use one word where six would do? <br><br></td></tr></table><br>
<a name="853184"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#111">[#111]</a></td></tr></table></td></tr><tr ><td class="posttext"> The simplest way to grasp OO btw is to start with it on realworld abstraction.<br><br>Lets take a simple DVD player with a power button, a forward, backward, stop, pause and play and a tray button, as well as a tray and a display.<br>If you think about that in realworld, its an object.<br>Within software it is as well.<br>And anything I mentioned above would be an object as well, that is stored within the DVD player. So you would have 7 additional fields of class "Button" within your DVD Player class and one field of class "DigitalDisplay" and one of class "DVDTray".<br><br>As they are all distinct objects, you can easily program the different behaviors within the different classes. The interaction would be handled normally through the listener / subscriber pattern on the DVDPlayer class.<br><br>I hope this makes sense but if you start to dissect realworld objects like that instead of thinking within your game code etc, you will get the basics and feel for it so much faster, given you have the needed talent for abstract thinking (otherwise drop the idea of OO, its hard to impossible for you to get it, abstraction is the most important thing you must have for it)<br><br><br><br>for those interested, have a look if you can find the script "touch of class" from betrand meyer for the computer science course "Einfhrung in die Programmierung" at www.ethz.ch<br>He has some very simple but out of my sight very ice breaking examples to see how the OO abstraction works basically etc <br><br></td></tr></table><br>
<a name="853189"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#112">[#112]</a></td></tr></table></td></tr><tr ><td class="posttext"> No, I know a lot of people who automatically serialize stuff, so they don't actually have a defined file format...it just changes every time they change the code.<br><br>I remember a story about the Torque engine, where a butterfly model was flying around and landed on a gun, and then picked it up and started hauling it around.  This was not by design, it was due to higher-up behaviors in the object hierarchy.  That is a good example of OOP gone mad. <br><br></td></tr></table><br>
<a name="853192"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#113">[#113]</a></td></tr></table></td></tr><tr ><td class="posttext"> The issue I have with both procedural and object-oriented is that really they are two sides of the same coin. Making stuff object oriented tends to separate everything out into exclusive objects which while possibly mapping well to most of the physical world (avoiding the world `real` here), it does not necessarily represent unification well, and neither does procedural. I don't exactly know what a better way would be but I can see that separating everything into objects doesn't always solve all problems. <br><br></td></tr></table><br>
<a name="853196"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gabriel</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#114">[#114]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> No, I know a lot of people who automatically serialize stuff, so they don't actually have a defined file format...it just changes every time they change the code. <br></div><br>I do that. What's wrong with it? It means I can go back and change things at a really low level without having to change any code in my load and save functions. I'd hate to have to go and manually change the format every time I realized I needed to have some new data. <br><br></td></tr></table><br>
<a name="853203"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#115">[#115]</a></td></tr></table></td></tr><tr ><td class="posttext"> ImaginaryHuman: Well, with reflection you can actually get around some of this "enforced seperation" by dynamically merging data etc.<br>It surely is a complex thing and very error prone from the professional point of view (where the separation is desired as it is the only way to have at least the slightest chance to guarantee correct behavior) <br><br></td></tr></table><br>
<a name="853214"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#116">[#116]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Any programmer who gets more complicated than that is just... <br></div><br>Well, that's just bollocks, really, and typical of something spoken by those who don't know any better.<br><br>I guess Abstraction is some other perverse thing that should be avoided? Right.<br><br>Obviously, in a lot of cases you will only want one or two levels of generalisation. But sometimes you need more...<br><br>Object<br>EventHandler<br>Window<br>Control<br>ControlWithItems<br>ComboBox<br><br>Why? Because each class looks after its own specific functionality, which is inherited by its children.<br>And this is the mind-blowing thing to grasp.... it does away with code-duplication. I know, isn't it amazing? Rather than have the same code copied all over the place doing essentially the same thing in different types, you can actually localise those bits of code and share them.<br><br>Next we'll be hearing that database normalization is for crazy people.... <br><br></td></tr></table><br>
<a name="853216"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#117">[#117]</a></td></tr></table></td></tr><tr ><td class="posttext"> I don't see how this classes relate to a dependency chain.<br><br>EventHandler is no Gadget, its a "delegate".<br>And the controlWithItems would be useless as well, a control should, if it is a contrainer, have a child list.<br><br>I agree that 2 levels is to little, but actually there are definitely users that totally overdue it as well as too much extension does not help, often decoration is much more powerfull and flexible. BM has some very interesting internal classes that show how to use this mechanism usefully like the streamwrapper class which is extended by others.<br><br>And an article like that can only come from someone with no pure indepth OO knowledge like a C++ programmer.<br>I know quite some of them due to study and for some reason they always fall back to procedural the moment they face a problem that needs some real indepth OO knowledge ( -&gt; patterns ) to solve intead of hacking.<br>the "Contradiction Leads to Confusion" is the largest joke I've heard since a long time. Even 1 semester students in computational science know WHY it must be like that if you want error free code. And some of them don't even know how to write a hello world where you can input your name!<br>But for those that don't know it: The idea is that you rely on fixed functionality which is clear specified on its functionality and interface. You can rely on this and that it does what it is meant to. But you must not know (-&gt; use ) its inner working, there is no reason to, as you wanted to use the functionality, not its implementation.<br>Reason is that the implementation can change and by only using the functionality you ensure that other code is unaffected by it in the meaning of "you don't need to alter other code as well"<br><br>the moment you behave like that "great writer", you are doomed on the long sight as it will be impossible to work like that on a larger scale software codebase.<br><br>without OO, todays largescale software systems would be impossible, no mather how cleanly you would program.<br>Clean and stable multithreading would be even less possible, as the most powerfull mechanisms (monitor and the like) rely on objects, not on variable locks which are to easy to break.<br><br>the best one was that:<br><div class="quote"> A frequent argument for OOP is it helps with code reusability, but one can reuse code without OOPoften by simply copying and pasting. <br></div><br><br>Welcome to the world of a real noob <br><br></td></tr></table><br>
<a name="853227"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >N</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#118">[#118]</a></td></tr></table></td></tr><tr ><td class="posttext"> Can we punish that tin fellow for resurrecting this dead thread? <br><br></td></tr></table><br>
<a name="853846"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Blueapples</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#119">[#119]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>I remember a story about the Torque engine, where a butterfly model was flying around and landed on a gun, and then picked it up and started hauling it around. This was not by design, it was due to higher-up behaviors in the object hierarchy. That is a good example of OOP gone mad.<br> <br></div><br><br>That's just funny. I wouldn't say it's gone mad though, simply a case where the butterfly shouldn't be able to weild a weapon. It should be lower on the chain.<br><br><pre class=code>
Creature
   - WeaponWielder
      - Player
      - Enemy
   - Animal
      - Butterfly
</pre><br><br>Anyway I vote for a stay of the punishment since this was a funny little anecdote. <br><br></td></tr></table><br>
<a name="853889"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Who was John Galt?</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#120">[#120]</a></td></tr></table></td></tr><tr ><td class="posttext"> It's really handy but some people get obsessed, overuse (or misuse) it and make a nightmare for themselves. I have read books on OO that sound almost like religious texts. For myself I just fell into using it with BlitMax and thought yeah this isn't bad. <br><br></td></tr></table><br>
<a name="853913"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#121">[#121]</a></td></tr></table></td></tr><tr ><td class="posttext"> The thing that I don't like about OOP is that you have to hard code types of things. Tutorials are like, have a ship type that extends into a fighter type, and crusier type etc. Or I talk about a game and people are like have goblins inheret from blah blahh. Well what if I don't want to have "fighters" and "goblins" in my code. <br><br></td></tr></table><br>
<a name="853914"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#122">[#122]</a></td></tr></table></td></tr><tr ><td class="posttext"> ... then you don't create them. Not sure what your point is. <br><br></td></tr></table><br>
<a name="853970"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#123">[#123]</a></td></tr></table></td></tr><tr ><td class="posttext"> The reason people get so worked up about OOP is the same reason people get so worked up about Linux:<br><br>It's time-consuming, tedious, and inefficient.<br><br><br>That means job security. <br><br></td></tr></table><br>
<a name="853980"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >plash</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#124">[#124]</a></td></tr></table></td></tr><tr ><td class="posttext"> Linux? liez. <br><br></td></tr></table><br>
<a name="854059"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#125">[#125]</a></td></tr></table></td></tr><tr ><td class="posttext"> I just wanted to rant. <br><br></td></tr></table><br>
<a name="854480"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >OremLK</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#126">[#126]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm curious as to how procedural programmers typically do things.  Do you not use types/structs/classes and objects at all?  What do you do, make a bunch of different arrays to store different values for your entities and such?<br><br>For me, OOP is only valuable so long as it improves my efficiency, and as such I don't typically use its more advanced features in most situations.  But the basic idea of having objects of a defined type is invaluable to me.  Couldn't live without it. <br><br></td></tr></table><br>
<a name="854495"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#127">[#127]</a></td></tr></table></td></tr><tr ><td class="posttext"> You can't do without OOP, but it's just that a lot pf programmers make it way too abstract and complicated. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
