<!DOCTYPE html><html lang="en" ><head ><title >Progessive Ray Tracer with Photon Mapping</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Progessive Ray Tracer with Photon Mapping</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Progessive Ray Tracer with Photon Mapping</a><br><br>
<a name="1064375"></a>

<a name="1064376"></a>

<a name="1064385"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamRedwoods</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've ported over a ray tracer that uses photon mapping. It is interactive and progressive, so you are able to drag around the spheres and light.<br><br>Originally written with Processing by Grant Schindler in 2007.<br><a href="http://www.cc.gatech.edu/~phlosoft/photon/" target="_blank">http://www.cc.gatech.edu/~phlosoft/photon/</a><br><br>I feel this version is slower than the Processing version, so there may be some ways to speed it up, but I'll leave that to someone else.<br><br>Enjoy!<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

''Ray Tracing &amp; Photon Mapping
''Grant Schindler, 2007
''
'' to Blitzmax by Adam Piette, 2010
SuperStrict

'' ----- Scene Description -----
Global szImg:Int = 512                  ''Image Size
Global nrTypes:Int = 2                  ''2 Object Types (Sphere = 0, Plane = 1)
Global nrObjects:Int[] = [2,5]          ''2 Spheres, 5 Planes
Global gAmbient:Float = 0.1             ''Ambient Lighting
Global gOrigin:Float[] = [0.0,0.0,0.0]  ''World Origin For Convenient Re-Use Below (Constant)
Global Light:Float[] = [0.0,1.2,3.75]   ''Point Light-Source Position
Global spheres:Float[][] = [[1.0,0.0,4.0,0.5],[-0.6,-1.0,4.5,0.5]]         ''Sphere Center &amp; Radius
Global planes:Float[][]  = [[0.0, 1.5],[1.0, -1.5],[0.0, -1.5],[1.0, 1.5],[2.0,5.0]] ''Plane Axis &amp; Distance-To-Origin

'' ----- Photon Mapping -----
Global nrPhotons:Int = 1000             ''Number of Photons Emitted
Global nrBounces:Int = 3                ''Number of Times Each Photon Bounces
Global lightPhotons:Int = True      ''Enable Photon Lighting?
Global sqRadius:Float = 0.7             ''Photon Integration Area (Squared For Efficiency)
Global exposure:Float = 50.0            ''Number of Photons Integrated at Brightest Pixel
Global numPhotons:Int[][] = [[0,0],[0,0,0,0,0]]              ''Photon Count For Each Scene Object
Global photons:Float[,,,,] = New Float[3,6,5001,4,3]

'' ----- Raytracing Globals -----
Global gIntersect:Int = False       ''For Latest Raytracing Call... Was Anything Intersected by the Ray?
Global gType:Int                       ''... Type of the Intersected Object (Sphere Or Plane)
Global gIndex:Int                       ''... Index of the Intersected Object (Which Sphere/Plane Was It?)
Global gSqDist:Float
Global gDist:Float = -1.0      ''... Distance from Ray Origin To Intersection
Global gPoint:Float[] = [0.0, 0.0, 0.0] ''... Point At Which the Ray Intersected the Object


''---------------------------------------------------------------------------------------
''Ray-Geometry Intersections  -----------------------------------------------------------
''---------------------------------------------------------------------------------------

Function raySphere(idx:Int, r:Float[], o:Float[]) ''Ray-Sphere Intersection: r=Ray Direction, o=Ray Origin
  Local s:Float[] = sub3(spheres[idx],o)  ''s=Sphere Center Translated into Coordinate Frame of Ray Origin
  Local radius:Float = spheres[idx][3]    ''radius=Sphere Radius
  
  ''Intersection of Sphere And Line     =       Quadratic Function of Distance
  Local A:Float = dot3(r,r)                       '' Remember This From High School? :
  Local B:Float = -2.0 * dot3(s,r)                ''    A x^2 +     B x +               C  = 0
  Local C:Float = dot3(s,s) - (radius*radius)          '' (r'r)x^2 - (2s'r)x + (s's - radius^2) = 0
  Local D:Float = B*B - 4.0*A*C                     '' Precompute Discriminant
  
  If (D &gt; 0.0)                              ''Solution Exists only If sqrt(D) is Real (Not Imaginary)
    Local sign:Float
    If (C &lt; -0.00001) Then sign= 1.0 Else sign= -1.0    ''Ray Originates Inside Sphere If C &lt; 0
    Local lDist:Float = (-B + sign*Sqr(D))/(2.0*A) ''Solve Quadratic Equation For Distance To Intersection
    checkDistance(lDist,0,idx)             ''Is This Closest Intersection So Far?
  EndIf
EndFunction

Function rayPlane(idx:Int, r:Float[], o:Float[]) ''Ray-Plane Intersection
  Local axis:Int = planes[idx][0]            ''Determine Orientation of Axis-Aligned Plane
  If (r[axis] &lt;&gt; 0.0)                        ''Parallel Ray -&gt; No Intersection
    Local lDist:Float = (planes[idx][1] - o[axis]) / r[axis] ''Solve Linear Equation (rx = p-o)
    checkDistance(lDist,1,idx)
  EndIf
EndFunction

Function rayObject(typ:Int, idx:Int, r:Float[], o:Float[])
  If (typ = 0)
	raySphere(idx,r,o)
  Else
	rayPlane(idx,r,o)
  EndIf
EndFunction

Function checkDistance(lDist:Float, p:Int, i:Int)
  If (lDist &lt; gDist And lDist &gt; 0.0) ''Closest Intersection So Far in Forward Direction of Ray?
	gType = p
	gIndex = i
	gDist = lDist
	gIntersect = True ''Save Intersection in Global State
  EndIf
EndFunction

''---------------------------------------------------------------------------------------
'' Lighting -----------------------------------------------------------------------------
''---------------------------------------------------------------------------------------

Function lightDiffuse:Float (N:Float[], P:Float[])  ''Diffuse Lighting at Point P with Surface Normal N
  Local L:Float[] = normalize3( sub3(Light,P) ) ''Light Vector (Point To Light)
  Return dot3(N,L)                        ''Dot Product = Cos (Light-To-Surface-Normal Angle)
EndFunction

Function  sphereNormal:Float[] (idx:Int, P:Float[])
  Return normalize3(sub3(P,spheres[idx])) ''Surface Normal (Center To Point)
EndFunction

Function  planeNormal:Float[] (idx:Int, P:Float[], O:Float[])
  Local axis:Int = Int(planes[idx][0])
  Local N:Float[] = [0.0,0.0,0.0]
  N[axis] = O[axis] - planes[idx][1]      ''Vector From Surface To Light
  Return normalize3(N)
EndFunction

Function  surfaceNormal:Float[] (Typ:Int, index:Int, P:Float[], Inside:Float[])
  If (Typ = 0)
	Return sphereNormal(index,P)
  Else
	Return planeNormal(index,P,Inside)
  EndIf
EndFunction

Function  lightObject:Float(Typ:Int, idx:Int, P:Float[], lightAmbient:Float)
  Local i:Float = lightDiffuse( surfaceNormal(Typ, idx, P, Light) , P )
  Return Min(1.0, Max(i, lightAmbient))   ''Add in Ambient Light by Constraining Min Value
EndFunction

''---------------------------------------------------------------------------------------
'' Raytracing ---------------------------------------------------------------------------
''---------------------------------------------------------------------------------------

Function raytrace(ray:Float[] , origin:Float[] )
  gIntersect = False ''No Intersections Along This Ray Yet
  gDist = 999999.9   ''Maximum Distance To Any Object
  
  For Local t:Int = 0 Until nrTypes Step 1
    For Local i:Int = 0 Until nrObjects[t] Step 1
      rayObject(t,i,ray,origin)
    Next
  Next
EndFunction

Function computePixelColor:Float[] (x:Float, y:Float)
  Local rgb:Float[] = [0.0,0.0,0.0]
  Local ray:Float[] = [  x/szImg - 0.5 , ..       ''Convert Pixels To Image Plane Coordinates
                 -(y/szImg - 0.5), 1.0] ''Focal Length = 1.0
  raytrace(ray, gOrigin)                ''Raytrace!!! - Intersected Objects are Stored in Global State

  If (gIntersect)                       ''Intersection                    
    gPoint = mul3c(ray,gDist)           ''3D Point of Intersection
        
    If (gType = 0 And gIndex = 1)      ''Mirror Surface on This Specific Object
      ray = reflect(ray,gOrigin)        ''Reflect Ray Off the Surface
      raytrace(ray, gPoint)             ''Follow the Reflected Ray
      If (gIntersect) gPoint = add3( mul3c(ray,gDist), gPoint) ''3D Point of Intersection
    EndIf
        
    If (lightPhotons)                   ''Lighting via Photon Mapping
      rgb = gatherPhotons(gPoint,gType,gIndex)
    Else                                ''Lighting via Standard Illumination Model (Diffuse + Ambient)
      Local tType:Int = gType
	 Local tIndex:Int = gIndex ''Remember Intersected Object
      Local i:Float = gAmbient                ''If in Shadow, Use Ambient Color of Original Object
      raytrace( sub3(gPoint,Light) , Light)  ''Raytrace from Light To Object
      If (tType = gType And tIndex = gIndex) ''Ray from Light-&gt;Object Hits Object First?
        i = lightObject(gType, gIndex, gPoint, gAmbient) ''Not In Shadow - Compute Lighting
	 EndIf
      rgb[0]=i
	 rgb[1]=i
	 rgb[2]=i
      rgb = GetColorRGB(rgb,tType,tIndex)
    EndIf
  EndIf
  Return rgb
EndFunction

Function reflect:Float[](ray:Float[], fromPoint:Float[])                ''Reflect Ray
  Local N:Float[] = surfaceNormal(gType, gIndex, gPoint, fromPoint)  ''Surface Normal
  Return normalize3(sub3(ray, mul3c(N,(2.0 * dot3(ray,N)))))     ''Approximation To Reflection
EndFunction

''---------------------------------------------------------------------------------------
''Photon Mapping ------------------------------------------------------------------------
''---------------------------------------------------------------------------------------

Function gatherPhotons:Float[] (p:Float[], Typ:Int, id:Int)
  Local energy:Float[] = [0.0,0.0,0.0]  
  Local N:Float[] = surfaceNormal(Typ, id, p, gOrigin)                   ''Surface Normal at Current Point
  For Local i:Int = 0 Until numPhotons[Typ][id] Step 1                    ''Photons Which Hit Current Object
    Local pt:Float[] = [photons[Typ,id,i,0,0],photons[Typ,id,i,0,1],photons[Typ,id,i,0,2]]
	
    If (gatedSqDist3(p,pt,sqRadius))           ''Is Photon Close To Point?
	Local ptd:Float[] = [photons[Typ,id,i,1,0],photons[Typ,id,i,1,1],photons[Typ,id,i,1,2]]
	Local pte:Float[] = [photons[Typ,id,i,2,0],photons[Typ,id,i,2,1],photons[Typ,id,i,2,2]]
      Local weight:Float = Max(0.0, -dot3(N, ptd ))   ''Single Photon Diffuse Lighting
      weight :* (1.0 - Sqr(gSqDist)) / exposure                    ''Weight by Photon-Point Distance
      energy = add3(energy, mul3c(pte, weight)) ''Add Photon's Energy to Total
    EndIf
  Next
  Return energy
EndFunction

Function emitPhotons()
  SeedRnd(0)                               ''Ensure Same Photons Each Time
  For Local t:Int = 0 Until nrTypes Step 1            ''Initialize Photon Count To Zero For Each Object
    For Local i:Int = 0 Until nrObjects[t] Step 1
      numPhotons[t][i] = 0
    Next
  Next 

  Local test:Int = nrPhotons
  If (view3D) test = nrPhotons * 3.0  ''Draw 3x Photons For Usability
  For Local i:Int = 0 To test Step 1 
    Local bounces:Int = 1
    Local rgb:Float[] = [1.0,1.0,1.0]               ''Initial Photon Color is White
    Local ray:Float[] = normalize3( rand3(1.0) )    ''Randomize Direction of Photon Emission
    Local prevPoint:Float[] = Light                 ''Emit From Point Light Source
    
    ''Spread Out Light Source, But Don't Allow Photons Outside Room/Inside Sphere
    While (prevPoint[1] &gt;= Light[1])
		prevPoint = add3(Light, mul3c(normalize3(rand3(1.0)), 0.75))
    Wend
    If (Abs(prevPoint[0]) &gt; 1.5 Or Abs(prevPoint[1]) &gt; 1.2 Or ..
        gatedSqDist3(prevPoint,spheres[0],spheres[0][3]*spheres[0][3])) bounces = nrBounces+1
    
    raytrace(ray, prevPoint)                          ''Trace the Photon's Path
    
    While (gIntersect And bounces &lt;= nrBounces)        ''Intersection With New Object
        gPoint = add3( mul3c(ray,gDist), prevPoint)   ''3D Point of Intersection
        rgb = mul3c (GetColorRGB(rgb,gType,gIndex), 1.0/Sqr(bounces))
        storePhoton(gType, gIndex, gPoint, ray, rgb)  ''Store Photon Info 
        drawPhoton(rgb, gPoint)                       ''Draw Photon
        shadowPhoton(ray)                             ''Shadow Photon
        ray = reflect(ray,prevPoint)                  ''Bounce the Photon
        raytrace(ray, gPoint)                         ''Trace It To Next Location
        prevPoint = gPoint
        bounces:+1
    Wend
  Next
EndFunction

Function storePhoton(Typ:Int, id:Int, location:Float[], direction:Float[], energy:Float[] )
	'MemCopy(copy,array,SizeOf(array))
  photons[Typ,id,numPhotons[Typ][id],0,0] = location[0]  ''Location
  photons[Typ,id,numPhotons[Typ][id],0,1] = location[1]  ''Location
  photons[Typ,id,numPhotons[Typ][id],0,2] = location[2]  ''Location
  photons[Typ,id,numPhotons[Typ][id],1,0] = direction[0] ''Direction
  photons[Typ,id,numPhotons[Typ][id],1,1] = direction[1] ''Direction
  photons[Typ,id,numPhotons[Typ][id],1,2] = direction[2] ''Direction
  photons[Typ,id,numPhotons[Typ][id],2,0] = energy[0]    ''Attenuated Energy (Color)
  photons[Typ,id,numPhotons[Typ][id],2,1] = energy[1]    ''Attenuated Energy (Color)
  photons[Typ,id,numPhotons[Typ][id],2,2] = energy[2]    ''Attenuated Energy (Color)
  numPhotons[Typ][id] :+1
EndFunction

Function shadowPhoton(ray:Float[] )                               ''Shadow Photons
  Local shadow:Float[]  = [-0.25,-0.25,-0.25]
  Local tPoint:Float[]  = gPoint 
  Local tType:Int = gType, tIndex:Int = gIndex                         ''Save State
  Local bumpedPoint:Float[] = add3(gPoint,mul3c(ray,0.00001))      ''Start Just Beyond Last Intersection
  raytrace(ray, bumpedPoint)                                 ''Trace To Next Intersection (In Shadow)
  Local shadowPoint:Float[] = add3( mul3c(ray,gDist), bumpedPoint) ''3D Point
  storePhoton(gType, gIndex, shadowPoint, ray, shadow)
  gPoint = tPoint gType = tType gIndex = tIndex            ''Restore State
EndFunction

Function filterColor:Float[] (rgbIn:Float[], r:Float, g:Float, b:Float) ''e.g. White Light Hits Red Wall
  Local rgbOut:Float[] = [r,g,b]
  For Local c:Int=0 To 2 
	rgbOut[c] = Min(rgbOut[c],rgbIn[c]) ''Absorb Some Wavelengths (R,G,B)
  Next
  Return rgbOut
EndFunction

Function GetColorRGB:Float[] (rgbIn:Float[], Typ:Int, index:Int) ''Specifies Material Color of Each Object
  If (Typ = 1 And index = 0) 
	Return filterColor(rgbIn, 0.0, 1.0, 0.0)
  ElseIf (Typ = 1 And index = 2)
	Return filterColor(rgbIn, 1.0, 0.0, 0.0)
  Else
	Return filterColor(rgbIn, 1.0, 1.0, 1.0)
  EndIf
EndFunction

''---------------------------------------------------------------------------------------
''Vector Operations ---------------------------------------------------------------------
''---------------------------------------------------------------------------------------

Function normalize3:Float[] (v:Float[] )        ''Normalize 3-Vector
  Local L:Float = Sqr(dot3(v,v))
  Return mul3c(v, 1.0/L)
EndFunction

Function sub3:Float[] (a:Float[] , b:Float[] )   ''Subtract 3-Vectors
  Local result:Float[] = [a[0] - b[0], a[1] - b[1], a[2] - b[2]]
  Return result
EndFunction

Function add3:Float[] (a:Float[] , b:Float[] )   ''Add 3-Vectors
  Local result:Float[] = [a[0] + b[0], a[1] + b[1], a[2] + b[2]]
  Return result
EndFunction

Function mul3c:Float[] ( a:Float[] , c:Float)    ''Multiply 3-Vector with Scalar
  Local result:Float[] = [c*a[0], c*a[1], c*a[2]]
  Return result
EndFunction

Function dot3:Float ( a:Float[] , b:Float[] )     ''Dot Product 3-Vectors
  Return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]
EndFunction

Function rand3:Float[] (s:Float )               ''Random 3-Vector
  Local s2:Float = s*2
  Local r:Float[] = [RndFloat()*s2-s,RndFloat()*s2-s,RndFloat()*s2-s]
  Return r
EndFunction

Function gatedSqDist3:Int(a:Float[] , b:Float[], sqradius:Float) ''Gated Squared Distance
  Local c:Float = a[0] - b[0]          ''Efficient When Determining If Thousands of Points
  Local d:Float = c*c                  ''Are Within a Radius of a Point (And Most Are Not!)
  If (d &gt; sqradius) Return False ''Gate 1 - If this dimension alone is larger than
  c = a[1] - b[1]                ''         the search radius, no need To Continue
  d :+ c*c
  If (d &gt; sqradius) Return False ''Gate 2
  c = a[2] - b[2]
  d :+ c*c
  If (d &gt; sqradius) Return False ''Gate 3
  gSqDist = d      
  Return True  ''Store Squared Distance Itself in Global State
EndFunction

Function odd:Int(x:Int)
	'If (x Mod 2) Return 1 ''else return 0
	Return x &amp; 1
EndFunction



''---------------------------------------------------------------------------------------
'' User Interaction And Display ---------------------------------------------------------
''---------------------------------------------------------------------------------------
Global empty:Int = True
Global view3D:Int = False ''Stop Drawing, Switch Views
'PFont font PImage img1, img2, img3  ''Fonts, Images
Global pRow:Int, pCol:Int, pIteration:Int, pMax:Int     ''Pixel Rendering Order


''___________________________

Function draw() 
	Global xx:Int, yy:Int 
  If (view3D)
    If (empty)
	 SetColor $00, $00, $00
	 Cls ''Black Out Drawing Area
	 drawInterface()
      emitPhotons()
	 empty = False ''Emit &amp; Draw Photons
    EndIf
  Else
    If (empty)
		render()
		xx :+1
		'Print xx
		If(xx &gt; 10)
			xx=0
			yy:+1
			Print pMax+" "+pRow
		EndIf
    Else
	''done
	 'frameRate(10) ''Only Draw If Image Not Fully Rendered
    EndIf
  EndIf
EndFunction

Function drawInterface()
  '' three button choices: ray tracing, photons only, full
EndFunction

Function render() ''Render Several Lines of Pixels at Once Before Drawing
  Local x:Int,y:Int,iterations:Int = 0
  Local rgb:Float[] = [0.0,0.0,0.0]

  
  Local imax:Int = Max(pMax, 256)
  If(mouseDragging) Then imax = 1024
  While (iterations &lt; imax)
  
    ''Render Pixels Out of Order With Increasing Resolution: 2x2, 4x4, 16x16... 512x512
    If (pCol &gt;= pMax)
	 pRow:+1
	 pCol = 0 
      If (pRow &gt;= pMax)
		pIteration:+1
		pRow = 0
		pMax = Int(2^pIteration)
	 EndIf
    EndIf
    Local pNeedDrawing:Int = 0
    If (pIteration = 1 Or odd(pRow) Or ((Not odd(pRow)) And odd(pCol))) Then pNeedDrawing = 1
    x = pCol * (szImg/pMax)
    y = pRow * (szImg/pMax)
    pCol:+1
    
    If (pNeedDrawing)
      iterations :+1
      rgb = mul3c( computePixelColor(x,y), 255.0)               ''All the Magic Happens in Here!
      SetColor (rgb[0],rgb[1],rgb[2])  						''Stroke &amp; Fill
      DrawRect (x,y,(szImg/pMax),(szImg/pMax))                  ''Draw the Possibly Enlarged Pixel
    EndIf
	
  Wend

  If (pRow = szImg-1) Then empty = False
EndFunction

Function resetRender() ''Reset Rendering Variables
  pRow=0
  pCol=0
  pIteration=1
  pMax=2
  empty=True
  If (lightPhotons And Not view3D) emitPhotons()
EndFunction

Function drawPhoton(rgb:Float[], p:Float[] )           ''Photon Visualization
  If (view3D And p[2] &gt; 0.0)                       ''Only Draw If In Front of Camera
    Local x:Int = (szImg/2) + Int(szImg *  p[0]/p[2]) ''Project 3D Points into Scene
    Local y:Int = (szImg/2) + Int(szImg * -p[1]/p[2]) ''Don't Draw Outside Image
    If (y &lt;= szImg) 
	 SetColor (255.0*rgb[0],255.0*rgb[1],255.0*rgb[2])
	 Plot(x,y)
    EndIf
  EndIf
EndFunction

''---------------------------------------------------------------------------------------
''Mouse And Keyboard Interaction --------------------------------------------------------
''---------------------------------------------------------------------------------------
Global prevMouseX:Int = -9999, prevMouseY:Int = -9999, sphereIndex:Int = -1
Global s:Float = 130.0 ''Arbitary Constant Through Experimentation
Global mouseDragging:Int = False


'' setup()
Graphics szImg, szImg+48,0,60,0 '' no back buffer

view3D = False ''true = view photon mapping, false = view normal
lightPhotons = 1 ''true = use photons, false= raytrace

emitPhotons()
resetRender() 
drawInterface()

Local t:Int=0

While (Not AppTerminate())
	t:+1
	If(KeyDown(KEY_SPACE))
		Print "reset" 
		resetRender()
	EndIf
	If(MouseDown(1))
		If (Not mouseDragging)
			GrabObject()
		Else If (MouseXSpeed() Or  MouseYSpeed())
			DragObject()
		EndIf
	Else
		prevMouseX = -9999
		prevMouseY = -9999
		mouseDragging = False
	EndIf
	draw()
	Flip
Wend
Print "end"
End


Function GrabObject()
	sphereIndex = 2 ''Click Spheres
	Local mx:Float = (MouseX() - szImg/2.0)/s
	Local my:Float = -(MouseY() - szImg/2.0)/s
  	Local mouse3:Float[] = [mx, my, (0.5*(spheres[0][2] + spheres[1][2])) ]
  	If (gatedSqDist3(mouse3,spheres[0],spheres[0][3]))
		sphereIndex = 0
  	Else If (gatedSqDist3(mouse3,spheres[1],spheres[1][3]))
		sphereIndex = 1
	EndIf
	Print "sphere:"+sphereIndex
	mouseDragging = True
EndFunction

Function DragObject()
	If (prevMouseX &gt; -9999 And sphereIndex &gt; -1)
		If (sphereIndex &lt; nrObjects[0]) ''Drag Sphere
			spheres[sphereIndex][0] :+ (MouseX() - prevMouseX)/s
			spheres[sphereIndex][1] :- (MouseY() - prevMouseY)/s
		Else ''Drag Light
			Light[0] :+ (MouseX() - prevMouseX)/s
			Light[0] = Max(Min(Light[0],1.4),-1.4)
			Light[1] :- (MouseY() - prevMouseY)/s
			Light[1] = Max(Min(Light[1],1.2),-0.4)
		EndIf
		resetRender()
	EndIf
	prevMouseX = MouseX()
	prevMouseY = MouseY()
	mouseDragging = True
EndFunction

Rem
void switchToMode(char i, Int x){ '' Switch Between Raytracing, Photon Mapping Views
  If      (i=='1' || x&lt;230) {view3D = false lightPhotons = false resetRender() drawInterface()}
  Else If (i=='2' || x&lt;283) {view3D = false lightPhotons = true  resetRender() drawInterface()}
  Else If (i=='3' || x&lt;513) {view3D = true resetRender() drawInterface()}
}
EndRem

</textarea><br><br><font class="tiny">Last edited 2010</font><br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1064382"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >KronosUK</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> slight correction to one of the functions<br><br>in Function Filtercolor<br><br>  For Local c:Int=0 To 2 NOT   For Local c:Int=0 To 3<br><br><br><br>Pretty amazing demo. <br><br></td></tr></table><br>
<a name="1064386"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamRedwoods</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Fixed, thanks for catching that! <br><br></td></tr></table><br>
<a name="1064397"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Richard Betson</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Pretty slick. :) <br><br></td></tr></table><br>
<a name="1064416"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ima747</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Very very cool, doesn't really like outputting on my system (lots of flicker and black spaces unless I'm moving something) but still really impressive <br><br></td></tr></table><br>
<a name="1064453"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >smilertoo</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> impressive, now can you multithread it? <br><br></td></tr></table><br>
<a name="1064663"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamRedwoods</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>Very very cool, doesn't really like outputting on my system (lots of flicker and black spaces unless I'm moving something) but still really impressive <br> <br></div><br><br>Yes, sorry about that. It's using a simple FLIP, assuming there is no backbuffer, and the backbuffer remains intact (bad, bad, bad). Converting the display code to use a pixmap would fix that. <br><br></td></tr></table><br>
<a name="1064888"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamRedwoods</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Now it's multi-threaded, but it's terrible!!!<br><br>I've also switched it to pixmaps instead of just flipping the redraw.<br><br>I think threading isn't always the way to go, especially with passing so much data around. It just isn't smooth, but I could be doing something wrong. ( but that's for someone else to explore )<br><br>Multi-threading:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

''Ray Tracing &amp; Photon Mapping
''Grant Schindler, 2007
''
'' to Blitzmax by Adam Piette, 2010
SuperStrict

'' ----- Scene Description -----
Global szImg:Int = 512                  ''Image Size
Global nrTypes:Int = 2                  ''2 Object Types (Sphere = 0, Plane = 1)
Global nrObjects:Int[] = [2,5]          ''2 Spheres, 5 Planes
Global gAmbient:Float = 0.1             ''Ambient Lighting
Global gOrigin:Float[] = [0.0,0.0,0.0]  ''World Origin For Convenient Re-Use Below (Constant)
Global Light:Float[] = [0.0,1.2,3.75]   ''Point Light-Source Position
Global spheres:Float[][] = [[1.0,0.0,4.0,0.5],[-0.6,-1.0,4.5,0.5]]         ''Sphere Center &amp; Radius
Global planes:Float[][]  = [[0.0, 1.5],[1.0, -1.5],[0.0, -1.5],[1.0, 1.5],[2.0,5.0]] ''Plane Axis &amp; Distance-To-Origin

'' ----- Photon Mapping -----
Global nrPhotons:Int = 1000             ''Number of Photons Emitted
Global nrBounces:Int = 3                ''Number of Times Each Photon Bounces
Global lightPhotons:Int = True      ''Enable Photon Lighting?
Global sqRadius:Float = 0.8             ''Photon Integration Area (Squared For Efficiency)
Global exposure:Float = 50.0            ''Number of Photons Integrated at Brightest Pixel
Global numPhotons:Int[][] = [[0,0],[0,0,0,0,0]]              ''Photon Count For Each Scene Object
Global photons:Float[,,,,] = New Float[3,6,5001,4,3]

'' ----- Raytracing Globals -----
'Global gIntersect:Int = False       ''For Latest Raytracing Call... Was Anything Intersected by the Ray?
'Global gType:Int                       ''... Type of the Intersected Object (Sphere Or Plane)
'Global gIndex:Int                       ''... Index of the Intersected Object (Which Sphere/Plane Was It?)
'Global gSqDist:Float
'Global gDist:Float = -1.0      ''... Distance from Ray Origin To Intersection
'Global gPoint:Float[] = [0.0, 0.0, 0.0] ''... Point At Which the Ray Intersected the Object

'Global gSqDist:Float

Global mutex:TMutex=CreateMutex()

Type BounceType
	Field intersect:Int =0
	Field iType:Int =0
	Field index:Int =0
	Field dist:Float = -1.0
	Field point:Float[] = [0.0, 0.0, 0.0]
EndType

Type Threaddata
	Field x:Float
	Field y:Float
	Field a:Int '' the return rgb value
	Field pxl:Int ''size of pixel to be drawn
EndType

''---------------------------------------------------------------------------------------
''Ray-Geometry Intersections  -----------------------------------------------------------
''---------------------------------------------------------------------------------------

Function raySphere:Float(idx:Int, r:Float[], o:Float[]) ''Ray-Sphere Intersection: r=Ray Direction, o=Ray Origin
  Local s:Float[] = sub3(spheres[idx],o)  ''s=Sphere Center Translated into Coordinate Frame of Ray Origin
  Local radius:Float = spheres[idx][3]    ''radius=Sphere Radius
  Local bounce:bounceType

  ''Intersection of Sphere And Line     =       Quadratic Function of Distance
  Local A:Float = dot3(r,r)                       '' Remember This From High School? :
  Local B:Float = -2.0 * dot3(s,r)                ''    A x^2 +     B x +               C  = 0
  Local C:Float = dot3(s,s) - (radius*radius)          '' (r'r)x^2 - (2s'r)x + (s's - radius^2) = 0
  Local D:Float = B*B - 4.0*A*C                     '' Precompute Discriminant
  
  If (D &gt; 0.0)                              ''Solution Exists only If sqrt(D) is Real (Not Imaginary)
    Local sign:Float
    If (C &lt; -0.00001) Then sign= 1.0 Else sign= -1.0    ''Ray Originates Inside Sphere If C &lt; 0
    Local lDist:Float = (-B + sign*Sqr(D))/(2.0*A) ''Solve Quadratic Equation For Distance To Intersection
    Return lDist             

  EndIf
	Return 0.0
EndFunction

Function rayPlane:Float(idx:Int, r:Float[], o:Float[]) ''Ray-Plane Intersection
  Local axis:Int = planes[idx][0]            ''Determine Orientation of Axis-Aligned Plane
  If (r[axis] &lt;&gt; 0.0)                        ''Parallel Ray -&gt; No Intersection
    Local lDist:Float = (planes[idx][1] - o[axis]) / r[axis] ''Solve Linear Equation (rx = p-o)
	Return lDist
  EndIf
	Return 0.0
EndFunction



Function checkDistance:Float(lDist:Float, gDist:Float)
	Local newDist:Float = gDist
	If (lDist &lt; gDist And lDist &gt; 0.0) ''Closest Intersection So Far in Forward Direction of Ray?
		'gType = p
		'gIndex = i
		'gDist = lDist
		'gIntersect = True ''Save Intersection in Global State
		newDist = lDist
	EndIf
	Return newDist
EndFunction

''---------------------------------------------------------------------------------------
'' Lighting -----------------------------------------------------------------------------
''---------------------------------------------------------------------------------------

Function lightDiffuse:Float (N:Float[], P:Float[])  ''Diffuse Lighting at Point P with Surface Normal N
  Local L:Float[] = normalize3( sub3(Light,P) ) ''Light Vector (Point To Light)
  Return dot3(N,L)                        ''Dot Product = Cos (Light-To-Surface-Normal Angle)
EndFunction

Function  sphereNormal:Float[] (idx:Int, P:Float[])
  Return normalize3(sub3(P,spheres[idx])) ''Surface Normal (Center To Point)
EndFunction

Function  planeNormal:Float[] (idx:Int, P:Float[], O:Float[])
  Local axis:Int = Int(planes[idx][0])
  Local N:Float[] = [0.0,0.0,0.0]
  N[axis] = O[axis] - planes[idx][1]      ''Vector From Surface To Light
  Return normalize3(N)
EndFunction

Function  surfaceNormal:Float[] (Typ:Int, index:Int, P:Float[], Inside:Float[])
  If (Typ = 0)
	Return sphereNormal(index,P)
  Else
	Return planeNormal(index,P,Inside)
  EndIf
EndFunction

Function  lightObject:Float(Typ:Int, idx:Int, P:Float[], lightAmbient:Float)
  Local i:Float = lightDiffuse( surfaceNormal(Typ, idx, P, Light) , P )
  Return Min(1.0, Max(i, lightAmbient))   ''Add in Ambient Light by Constraining Min Value
EndFunction

''---------------------------------------------------------------------------------------
'' Raytracing ---------------------------------------------------------------------------
''---------------------------------------------------------------------------------------

Function raytrace:BounceType(ray:Float[] , origin:Float[], oldpoint:Float[] )
	Local bounce:BounceType = New BounceType

	bounce.point = oldpoint
	bounce.intersect = 0 ''No Intersections Along This Ray Yet
	Local dist:Float=0.0	
	bounce.dist = 999999.9   ''Maximum Distance To Any Object
	
  For Local t:Int = 0 Until nrTypes Step 1
    For Local idx:Int = 0 Until nrObjects[t] Step 1
		''throw ray
		If (t = 0)
			dist =raySphere(idx,ray,origin)
		Else
			dist =rayPlane(idx,ray,origin)
		EndIf
		'' save successful ray info
		'If(dist)
			If (dist &lt; bounce.dist And dist &gt; 0.0) ''Closest Intersection So Far in Forward Direction of Ray?
				''Save Intersection in Global State
				bounce.dist = dist
				bounce.index = idx
				bounce.iType = t
				bounce.intersect = True
			EndIf
		'EndIf
    Next
  Next
  Return bounce '' keep the previous bounce information
EndFunction

'Function computePixelColor:Int (x:Float, y:Float)
Function computePixelColor:Object (obj:Object)
	Local td:Threaddata = New Threaddata
	'' may have to mutex these three lines since obj may be a shared reference?
	Local x:Float = ThreadData(obj).x
	Local y:Float = ThreadData(obj).y
	td.x = x
	td.y = y
	td.pxl = threaddata(obj).pxl
	td.a =0
	
	Local bounce:BounceType = New BounceType
	Local intrgb:Int =0
	Local rgb:Float[] = [0.0,0.0,0.0]
	Local ray:Float[] = [  x/szImg - 0.5 , ..       ''Convert Pixels To Image Plane Coordinates
	               -(y/szImg - 0.5), 1.0] ''Focal Length = 1.0

  bounce = raytrace(ray, gOrigin, bounce.point)                ''Raytrace!!! - Intersected Objects are Stored in Global State

  If (bounce.intersect)                       ''Intersection                    
    bounce.point = mul3c(ray, bounce.dist)           ''3D Point of Intersection
    
    If (bounce.itype = 0 And bounce.index = 1)      ''Mirror Surface on This Specific Object
      ray = reflect(ray,gOrigin, bounce.itype, bounce.index, bounce.point)        ''Reflect Ray Off the Surface
      bounce = raytrace(ray, bounce.point, bounce.point)             ''Follow the Reflected Ray
      If (bounce.intersect) bounce.point = add3( mul3c(ray,bounce.dist), bounce.point) ''3D Point of Intersection
    EndIf
      
    If (lightPhotons)                   ''Lighting via Photon Mapping
      rgb = gatherPhotons(bounce.point,bounce.iType,bounce.index)
    Else                                ''Lighting via Standard Illumination Model (Diffuse + Ambient)
      Local tType:Int = bounce.iType
	 Local tIndex:Int = bounce.index ''Remember Intersected Object
      Local i:Float = gAmbient                ''If in Shadow, Use Ambient Color of Original Object
      bounce = raytrace( sub3(bounce.point, Light) , Light, bounce.point)  ''Raytrace from Light To Object
      If (tType = bounce.iType And tIndex = bounce.index) ''Ray from Light-&gt;Object Hits Object First?
        i = lightObject(bounce.iType, bounce.index, bounce.point, gAmbient) ''Not In Shadow - Compute Lighting
	 EndIf
      rgb[0]=i
	 rgb[1]=i
	 rgb[2]=i
	'rgb = mul3c(GetColorRGB(rgb,tType,tIndex), 255.0)
	rgb = GetColorRGB(rgb,tType,tIndex)
	
    EndIf
  EndIf
	'' return int rgb
	Local red:Int = Int(rgb[2]*255.0)
	If (red &lt; 0) red=0
	If red &gt; 255 Then red =255
	Local grn:Int = Int(rgb[1]*255.0)
	If grn &lt;0 Then grn =0
	If grn &gt; 255 Then grn =255
	Local blu:Int = Int(rgb[0]*255.0) 
	If blu &lt;0 Then blu =0
	If blu &gt; 255 Then blu =255
	intrgb =  ((red Shl 16) | (grn Shl 8) | blu)

	td.a=intrgb

	'Return intrgb
	Return td
EndFunction

Function reflect:Float[](ray:Float[], fromPoint:Float[], t:Int, i:Int, gPoint:Float[])                ''Reflect Ray
  Local N:Float[] = surfaceNormal(t, i, gPoint, fromPoint)  ''Surface Normal
  Return normalize3(sub3(ray, mul3c(N,(2.0 * dot3(ray,N)))))     ''Approximation To Reflection
EndFunction

''---------------------------------------------------------------------------------------
''Photon Mapping ------------------------------------------------------------------------
''---------------------------------------------------------------------------------------

Function gatherPhotons:Float[] (p:Float[], Typ:Int, id:Int)
  Local energy:Float[] = [0.0,0.0,0.0] 
  Local N:Float[] = surfaceNormal(Typ, id, p, gOrigin)                   ''Surface Normal at Current Point
  For Local i:Int = 0 Until numPhotons[Typ][id] Step 1                    ''Photons Which Hit Current Object
	Local pt:Float[] = [photons[Typ,id,i,0,0],photons[Typ,id,i,0,1],photons[Typ,id,i,0,2]]
	Local gSqu:Float = gatedSqDist3(p,pt,sqRadius)
	If (gSqu)           ''Is Photon Close To Point?
		Local ptd:Float[] = [photons[Typ,id,i,1,0],photons[Typ,id,i,1,1],photons[Typ,id,i,1,2]]
		Local pte:Float[] = [photons[Typ,id,i,2,0],photons[Typ,id,i,2,1],photons[Typ,id,i,2,2]]
		Local weight:Float = Max(0.0, -dot3(N, ptd ))   ''Single Photon Diffuse Lighting
		weight :* (1.0 - Sqr(gSqu)) / exposure                    ''Weight by Photon-Point Distance
		energy = add3(energy, mul3c(pte, weight)) ''Add Photon's Energy to Total
	EndIf
  Next
  Return energy
EndFunction

Function emitPhotons()
  Local bounce:BounceType = New BounceType
  SeedRnd(0)                               ''Ensure Same Photons Each Time
  For Local t:Int = 0 Until nrTypes Step 1            ''Initialize Photon Count To Zero For Each Object
    For Local i:Int = 0 Until nrObjects[t] Step 1
      numPhotons[t][i] = 0
    Next
  Next 

  Local test:Int = nrPhotons
  If (view3D) test = nrPhotons * 3.0  ''Draw 3x Photons For Usability
  For Local i:Int = 0 To test Step 1 
    Local bounces:Int = 1
    Local rgb:Float[] = [1.0,1.0,1.0]               ''Initial Photon Color is White
    Local ray:Float[] = normalize3( rand3(1.0) )    ''Randomize Direction of Photon Emission
    Local prevPoint:Float[] = Light                 ''Emit From Point Light Source
    
    ''Spread Out Light Source, But Don't Allow Photons Outside Room/Inside Sphere
    While (prevPoint[1] &gt;= Light[1])
		prevPoint = add3(Light, mul3c(normalize3(rand3(1.0)), 0.75))
    Wend
    If (Abs(prevPoint[0]) &gt; 1.5 Or Abs(prevPoint[1]) &gt; 1.2 Or ..
        gatedSqDist3(prevPoint,spheres[0],spheres[0][3]*spheres[0][3])) bounces = nrBounces+1
    
    bounce =raytrace(ray, prevPoint, bounce.point)                          ''Trace the Photon's Path
    
    While (bounce.intersect And bounces &lt;= nrBounces)        ''Intersection With New Object
        bounce.point = add3( mul3c(ray,bounce.dist), prevPoint)   ''3D Point of Intersection
        rgb = mul3c (GetColorRGB(rgb,bounce.itype,bounce.index), 1.0/Sqr(bounces))
        storePhoton(bounce.itype, bounce.index, bounce.point, ray, rgb)  ''Store Photon Info 
        drawPhoton(rgb, bounce.point)                       ''Draw Photon
        shadowPhoton(ray, bounce)                             ''Shadow Photon
        ray = reflect(ray,prevPoint, bounce.itype, bounce.index, bounce.point)                  ''Bounce the Photon
        bounce = raytrace(ray, bounce.point, bounce.point)                         ''Trace It To Next Location
        prevPoint = bounce.point
        bounces:+1
    Wend
  Next
EndFunction

Function storePhoton(Typ:Int, id:Int, location:Float[], direction:Float[], energy:Float[] )
	'MemCopy(copy,array,SizeOf(array))
  photons[Typ,id,numPhotons[Typ][id],0,0] = location[0]  ''Location
  photons[Typ,id,numPhotons[Typ][id],0,1] = location[1]  ''Location
  photons[Typ,id,numPhotons[Typ][id],0,2] = location[2]  ''Location
  photons[Typ,id,numPhotons[Typ][id],1,0] = direction[0] ''Direction
  photons[Typ,id,numPhotons[Typ][id],1,1] = direction[1] ''Direction
  photons[Typ,id,numPhotons[Typ][id],1,2] = direction[2] ''Direction
  photons[Typ,id,numPhotons[Typ][id],2,0] = energy[0]    ''Attenuated Energy (Color)
  photons[Typ,id,numPhotons[Typ][id],2,1] = energy[1]    ''Attenuated Energy (Color)
  photons[Typ,id,numPhotons[Typ][id],2,2] = energy[2]    ''Attenuated Energy (Color)
  numPhotons[Typ][id] :+1
EndFunction

Function shadowPhoton(ray:Float[], bounce:BounceType )                               ''Shadow Photons
  Local shadow:Float[]  = [-0.25,-0.25,-0.25]
  'Local tPoint:Float[]  = gPoint 
  'Local tType:Int = t, tIndex:Int = i                         ''Save State

  Local bumpedPoint:Float[] = add3(bounce.point,mul3c(ray,0.00001))      ''Start Just Beyond Last Intersection
  Local sBounce:BounceType = raytrace(ray, bumpedPoint, bounce.point)                                 ''Trace To Next Intersection (In Shadow)
  Local shadowPoint:Float[] = add3( mul3c(ray,sBounce.dist), bumpedPoint) ''3D Point
  storePhoton(sBounce.iType, sBounce.index, shadowPoint, ray, shadow)
  'gPoint = tPoint gType = tType gIndex = tIndex            ''Restore State
EndFunction

Function filterColor:Float[] (rgbIn:Float[], r:Float, g:Float, b:Float) ''e.g. White Light Hits Red Wall
  Local rgbOut:Float[] = [r,g,b]
  For Local c:Int=0 To 2 
	rgbOut[c] = Min(rgbOut[c],rgbIn[c]) ''Absorb Some Wavelengths (R,G,B)
  Next
  Return rgbOut
EndFunction

Function GetColorRGB:Float[] (rgbIn:Float[], Typ:Int, index:Int) ''Specifies Material Color of Each Object
  If (Typ = 1 And index = 0) 
	Return filterColor(rgbIn, 0.0, 1.0, 0.0)
  ElseIf (Typ = 1 And index = 2)
	Return filterColor(rgbIn, 1.0, 0.0, 0.0)
  Else
	Return filterColor(rgbIn, 1.0, 1.0, 1.0)
  EndIf
EndFunction

''---------------------------------------------------------------------------------------
''Vector Operations ---------------------------------------------------------------------
''---------------------------------------------------------------------------------------

Function normalize3:Float[] (v:Float[] )        ''Normalize 3-Vector
  Local L:Float = Sqr(dot3(v,v))
  Return mul3c(v, 1.0/L)
EndFunction

Function sub3:Float[] (a:Float[] , b:Float[] )   ''Subtract 3-Vectors
  Local result:Float[] = [a[0] - b[0], a[1] - b[1], a[2] - b[2]]
  Return result
EndFunction

Function add3:Float[] (a:Float[] , b:Float[] )   ''Add 3-Vectors
  Local result:Float[] = [a[0] + b[0], a[1] + b[1], a[2] + b[2]]
  Return result
EndFunction

Function mul3c:Float[] ( a:Float[] , c:Float)    ''Multiply 3-Vector with Scalar
  Local result:Float[] = [c*a[0], c*a[1], c*a[2]]
  Return result
EndFunction

Function dot3:Float ( a:Float[] , b:Float[] )     ''Dot Product 3-Vectors
  Return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]
EndFunction

Function rand3:Float[] (s:Float )               ''Random 3-Vector
  Local s2:Float = s*2
  Local r:Float[] = [RndFloat()*s2-s,RndFloat()*s2-s,RndFloat()*s2-s]
  Return r
EndFunction

Function gatedSqDist3:Float(a:Float[] , b:Float[], sqradius:Float) ''Gated Squared Distance
  Local c:Float = a[0] - b[0]          ''Efficient When Determining If Thousands of Points
  Local d:Float = c*c                  ''Are Within a Radius of a Point (And Most Are Not!)
  If (d &gt; sqradius) Return 0 ''Gate 1 - If this dimension alone is larger than
  c = a[1] - b[1]                ''         the search radius, no need To Continue
  d :+ c*c
  If (d &gt; sqradius) Return 0 ''Gate 2
  c = a[2] - b[2]
  d :+ c*c
  If (d &gt; sqradius) Return 0 ''Gate 3
  'gSqDist = d      
  Return d  ''Store Squared Distance Itself in Global State
EndFunction

Function odd:Int(x:Int)
	'If (x Mod 2) Return 1 ''else return 0
	Return x &amp; 1
EndFunction



''---------------------------------------------------------------------------------------
'' User Interaction And Display ---------------------------------------------------------
''---------------------------------------------------------------------------------------
Global empty:Int = True
Global view3D:Int = False ''Stop Drawing, Switch Views
'PFont font PImage img1, img2, img3  ''Fonts, Images



''___________________________

Function draw() 
	Global xx:Int, yy:Int 
  If (view3D)
    If (empty)
	 SetColor $00, $00, $00
	 Cls ''Black Out Drawing Area
      emitPhotons()
	 empty = False ''Emit &amp; Draw Photons
    EndIf
  Else
    If (empty)
		render()
		xx :+1
		'Print xx
		If(xx &gt; 10)
			xx=0
			yy:+1
			Print pMax+" "+pRow
		EndIf
    Else
	''done
	 'frameRate(10) ''Only Draw If Image Not Fully Rendered
    EndIf
  EndIf
EndFunction


Global pRow:Int, pCol:Int, pIteration:Int, pMax:Int     ''Pixel Rendering Order

Function render() ''Render Several Lines of Pixels at Once Before Drawing
  Local x:Int,y:Int,iterations:Int = 0
  Local tindex:Int =0, pxl:Int
	
  Local td:threaddata[] = New threaddata[61]
  Local tdata:threaddata = New threaddata
  Local thread:TThread[] = New TThread[61]
  Local maxthreads:Int = 16

  Local pmaxsize:Int
  
  Local imax:Int = Max(pMax, 256)
  If(mouseDragging)
		imax = 1024
		maxthreads = 0 ''keep it quick while moving
  EndIf

  While (iterations &lt;= imax)
  
    ''Render Pixels Out of Order With Increasing Resolution: 2x2, 4x4, 16x16... 512x512
    If (pCol &gt;= pMax)
	 pRow:+1
	 pCol = 0 
      If (pRow &gt;= pMax)
		pIteration:+1
		pRow = 0
		pMax = Int(2^pIteration)
	 EndIf
    EndIf
    Local pNeedDrawing:Int = 0
    If (pIteration = 1 Or odd(pRow) Or ((Not odd(pRow)) And odd(pCol))) Then pNeedDrawing = 1
    pmaxsize = szImg/pMax
    x = pCol * pmaxsize 
    y = pRow * pmaxsize 
    pCol:+1
    
    If (pNeedDrawing)
		pNeedDrawing = 0
		iterations :+1
		Local tdd:threaddata = New threaddata
		tdd.x = x
		tdd.y = y
		tdd.a = 0
		tdd.pxl = pmaxsize 
	'Print tdata.x
		thread[tindex]=CreateThread( computePixelColor,tdd ) ''All the Magic Happens in Here!
		tindex :+1
    EndIf
	
	If(tindex &gt;maxthreads Or iterations &gt; imax) ''draw pixels
		
		For Local ti:Int=0 To maxthreads
			If(thread[ti])
				tdata = threaddata(WaitThread(thread[ti]) )			
				Local tx:Int = tdata.x
				Local ty:Int = tdata.y
				Local rgb:Int = tdata.a
				Local px:Int = tdata.pxl
				thread[ti]=Null
		'Print tx
				 
				Local cc:Int Ptr = Int Ptr(img.PixelPtr(tx,ty))
				Local m:Int =0, imgrowsize:Int = img.width
				For Local nn:Int = 0 To px-1
					For Local n:Int = 0 To px-1
						cc[n+m] = rgb
						'WritePixel(img, x, y, rgb)
					Next
					m=m+imgrowsize
				Next
			EndIf
		Next
		tindex=0
	EndIf
	
  Wend

  If (pRow = szImg-1) Then empty = False
EndFunction

Function resetRender() ''Reset Rendering Variables
  pRow=0
  pCol=0
  pIteration=1
  pMax=2
  empty=True
  If (lightPhotons And Not view3D) emitPhotons()
EndFunction

Function drawPhoton(rgb:Float[], p:Float[] )           ''Photon Visualization
  If (view3D And p[2] &gt; 0.0)                       ''Only Draw If In Front of Camera
    Local x:Int = (szImg/2) + Int(szImg *  p[0]/p[2]) ''Project 3D Points into Scene
    Local y:Int = (szImg/2) + Int(szImg * -p[1]/p[2]) ''Don't Draw Outside Image
    If (y &lt;= szImg) 
	 SetColor (255.0*rgb[0],255.0*rgb[1],255.0*rgb[2])
	 Plot(x,y)
    EndIf
  EndIf
EndFunction

''---------------------------------------------------------------------------------------
''Mouse And Keyboard Interaction --------------------------------------------------------
''---------------------------------------------------------------------------------------
Global prevMouseX:Int = -9999, prevMouseY:Int = -9999, sphereIndex:Int = -1
Global s:Float = 130.0 ''Arbitary Constant Through Experimentation
Global mouseDragging:Int = False


'' setup()
Graphics szImg, szImg+48,0,60,0 '' no back buffer
Global img:TPixmap = CreatePixmap(szImg, szImg+48, PF_RGBA8888)

view3D = 0 ''true = view photons only, false = view normal
lightPhotons = 1 ''true = use photons, false= raytrace

emitPhotons()
resetRender() 

Local t:Int=0

While (Not AppTerminate())
	t:+1
	If(KeyDown(KEY_SPACE))
		Print "reset" 
		resetRender()
	EndIf
	If(MouseDown(1))
		If (Not mouseDragging)
			GrabObject()
		Else If (MouseXSpeed() Or  MouseYSpeed())
			DragObject()
		EndIf
	Else
		prevMouseX = -9999
		prevMouseY = -9999
		mouseDragging = False
	EndIf
	draw()
	DrawPixmap img,0,0
	Flip
Wend
Print "end"
End


Function GrabObject()
	sphereIndex = 2 ''Click Spheres
	Local mx:Float = (MouseX() - szImg/2.0)/s
	Local my:Float = -(MouseY() - szImg/2.0)/s
  	Local mouse3:Float[] = [mx, my, (0.5*(spheres[0][2] + spheres[1][2])) ]
  	If (gatedSqDist3(mouse3,spheres[0],spheres[0][3]))
		sphereIndex = 0
  	Else If (gatedSqDist3(mouse3,spheres[1],spheres[1][3]))
		sphereIndex = 1
	EndIf
	Print "sphere:"+sphereIndex
	mouseDragging = True
EndFunction

Function DragObject()
	If (prevMouseX &gt; -9999 And sphereIndex &gt; -1)
		If (sphereIndex &lt; nrObjects[0]) ''Drag Sphere
			spheres[sphereIndex][0] :+ (MouseX() - prevMouseX)/s
			spheres[sphereIndex][1] :- (MouseY() - prevMouseY)/s
		Else ''Drag Light
			Light[0] :+ (MouseX() - prevMouseX)/s
			Light[0] = Max(Min(Light[0],1.4),-1.4)
			Light[1] :- (MouseY() - prevMouseY)/s
			Light[1] = Max(Min(Light[1],1.2),-0.4)
		EndIf
		resetRender()
	EndIf
	prevMouseX = MouseX()
	prevMouseY = MouseY()
	mouseDragging = True
EndFunction

Rem
void switchToMode(char i, Int x){ '' Switch Between Raytracing, Photon Mapping Views
  If      (i=='1' || x&lt;230) {view3D = false lightPhotons = false resetRender() drawInterface()}
  Else If (i=='2' || x&lt;283) {view3D = false lightPhotons = true  resetRender() drawInterface()}
  Else If (i=='3' || x&lt;513) {view3D = true resetRender() drawInterface()}
}
EndRem

</textarea> <br><br></td></tr></table><br>
<a name="1064895"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just got around to trying this -- impressive stuff! <br><br></td></tr></table><br>
<a name="1064936"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm getting a "Identifier TMutex not found". <br><br></td></tr></table><br>
<a name="1064938"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Perturbatio</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I'm getting a "Identifier TMutex not found".  <br></div><br>Me too, despite having the latest BMax installed and the threads module is definitely there. <br><br></td></tr></table><br>
<a name="1064940"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Turn on Threaded Build! <br><br></td></tr></table><br>
<a name="1064944"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Perturbatio</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> oops :) <br><br></td></tr></table><br>
<a name="1064950"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> oops [2] <br><br></td></tr></table><br>
<a name="1073099"></a>

<a name="1073100"></a>

<a name="1073101"></a>

<a name="1073102"></a>

<a name="1073103"></a>

<a name="1073104"></a>

<a name="1073105"></a>

<a name="1073106"></a>

<a name="1073107"></a>

<a name="1073109"></a>

<a name="1073111"></a>

<a name="1073112"></a>

<a name="1073114"></a>

<a name="1073115"></a>

<a name="1073116"></a>

<a name="1073117"></a>

<a name="1073118"></a>

<a name="1073119"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Does this profile info help for the single thread version ?<br><br><pre class=code>
Name			Average ms	Total ms	Calls		Lines	
raySphere		0.01		403		513912		15	
rayPlane		0.01		287		1284780		5	
rayObject		0.01		949		1798692		5	
checkDistance		0.01		70		1311247		6	
lightDiffuse		0.00		0		0		2	
sphereNormal		0.00		0		16414		1	
planeNormal		0.01		54		204506		4	
surfaceNormal		0.01		12		220920		5	
lightObject		0.00		0		0		2	
raytrace		0.01		1227		256956		8	
computePixelColor	0.62		116331		187648		31	
reflect			0.01		38		33272		2	
gatherPhotons		0.62		115161		187648		14	
emitPhotons		60.45		544		9		36	
storePhoton		0.01		13		54054		11	
shadowPhoton		0.01		198		27027		8	
filterColor		0.01		11		27027		5	
GetColorRGB		0.01		1		27027		7	
normalize3		0.01		67		280895		2	
sub3			0.01		108		563598		2	
add3			0.01		4058		19819653	2	
mul3c			0.01		4133		20536143	2	
dot3			0.01		493		21570536	1	
rand3			0.01		17		26703		3	
gatedSqDist3		0.01		18349		193699404	11	
odd			0.01		13		502016		2	
draw			181.25		116726		644		24	
drawInterface		0.00		0		1		1	
render			181.25		116723		644		34	
resetRender		60.25		482		8		6	
drawPhoton		0.00		0		27027		8	
GrabObject		0.20		1		5		11	
DragObject		35.09		421		12		15	

Function		Total time ms	% of program run time
.draw			116726		99.24
.render			116723		99.24
.computePixelColor	116331		98.91
.gatherPhotons		115161		97.91
.gatedSqDist3		18349		15.60
.mul3c			4133		3.51
.add3			4058		3.45
.raytrace		1227		1.04
.rayObject		949		0.80
.emitPhotons		544		0.46
.dot3			493		0.41
.resetRender		482		0.40
.DragObject		421		0.35
.raySphere		403		0.34
.rayPlane		287		0.24
.shadowPhoton		198		0.16
.sub3			108		0.09
.checkDistance		70		0.05
.normalize3		67		0.05
.planeNormal		54		0.04
</pre><br><br>I ran the code for 117612 ms (almost 2 mins) on a Vaio VGN-FW31M (Vista Home).<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1073129"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Doc Holliday</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> @col: sorry, but I'm new to bmx. How did you do the profiling? Is there any software out to do that? It's very interesting for me ...<br><br>Thanks in advance<br><br>Doc Holliday <br><br></td></tr></table><br>
<a name="1074661"></a>

<a name="1074662"></a>

<a name="1074663"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Doc Holliday<br><br>Hi, I did the profiling using software that I'd written. It loads in a BMax file and creates another file with profiler timing functions and data. Each function runs full speed, although the final exe runs slower because its only the bits in-between function calling that slow it down - obviously it doesnt matter about this slowdown as its only used for profiling.<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1074769"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Doc Holliday</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> @col:<br><br>Hello and thanks for the answer!<br><br>The profiling software you have written isn't available at random? ;-)<br>I'm interested in this piece of software, so is there a chance to get it?<br><br>Thx<br><br>Doc Holliday <br><br></td></tr></table><br>
<a name="1075178"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Without meaning to 'off-topic' this thread Ive posted a reply in your thread about profiling in the BMax Beginner Forum<br><br>Dave <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
