<!DOCTYPE html><html lang="en" ><head ><title >Polygon merging or substracting</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Polygon merging or substracting</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Polygon merging or substracting</a><br><br>
<a name="1070414"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Space_guy</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> example link:<br><a href="http://www.cs.man.ac.uk/~toby/alan/software/" target="_blank">http://www.cs.man.ac.uk/~toby/alan/software/</a><br><br>Is there any module or tips on how to merge two polygon shapes together.<br><br>Thankfull for any tips! <br><br></td></tr></table><br>
<a name="1070478"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >beanage</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is awefully complicated, and there wont be a trivial way to do this (unless you feel more like a genius than me :).. couldnt you port some parts of the GPC? <br><br></td></tr></table><br>
<a name="1070487"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Space_guy</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes it is hard. Ive been thinking about this many times the last few years but i always gave up on it. Im not experienced in porting code either. :(<br><br>But perhaps someone has something? <br><br></td></tr></table><br>
<a name="1070502"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Oddball</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here's something to get you started<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict

Graphics 800,600

Global poly1:Float[]=[ 200.0,200.0, 500.0,250.0, 500.0,350.0, 200.0,300.0 ]
Global poly2:Float[]=[ 300.0,300.0, 700.0,250.0, 700.0,350.0, 300.0,400.0 ]

Global merged:Float[]

SetColor 0,255,0
DrawText "Polygon 1",0,0
DrawPoly poly1,False
Flip

WaitKey()

SetColor 0,255,0
DrawText "Polygon 1",0,0
DrawPoly poly1,False
SetColor 0,0,255
DrawText "Polygon 2",0,15
DrawPoly poly2,False
Flip

WaitKey()

merged=AddPoly(poly1,poly2)

SetColor 0,255,0
DrawText "Polygon 1",0,0
DrawPoly poly1,False
SetColor 0,0,255
DrawText "Polygon 2",0,15
DrawPoly poly2,False
SetColor 255,0,0
DrawText "Merged Polygon",0,30
DrawPoly merged,False
Flip

WaitKey()

Function AddPoly:Float[]( p1:Float[], p2:Float[] )
	Local m:Float[p1.length+p2.length]
	
	Local start:Int=0
	While PointInPoly(p1[start],p1[start+1],p2) And start&lt;p1.length
		start:+2
	Wend
	If start&gt;=p1.length Then Return p2
	
	Local countm:Int=0
	Local count1:Int=start
	Local count2:Int=0
	Local flag:Int=0
	Repeat
		If flag=0
			m[countm]=p1[count1]
			m[countm+1]=p1[count1+1]
			
			For Local count:Int=0 To p2.length Step 2
				Local tmpx:Float
				Local tmpy:Float
				If LinesCross(tmpx,tmpy,p1[count1],p1[count1+1],p1[(count1+2) Mod p1.length],p1[(count1+3) Mod p1.length], p2[(count2+count) Mod p2.length],p2[(count2+count+1) Mod p2.length],p2[(count2+count+2) Mod p2.length],p2[(count2+count+3) Mod p2.length] )
					countm:+2
					m[countm]=tmpx
					m[countm+1]=tmpy
					count2=(count2+count+2) Mod p2.length
					flag=1
					Exit
				EndIf
			Next
			count1:+2
			If count1&gt;=p1.length Then count1=0
		Else
			m[countm]=p2[count2]
			m[countm+1]=p2[count2+1]
			
			For Local count:Int=0 To p2.length Step 2
				Local tmpx:Float
				Local tmpy:Float
				If LinesCross(tmpx,tmpy,p2[count2],p2[count2+1],p2[(count2+2) Mod p2.length],p2[(count2+3) Mod p2.length], p1[(count1+count) Mod p1.length],p1[(count1+count+1) Mod p1.length],p1[(count1+count+2) Mod p1.length],p1[(count1+count+3) Mod p1.length] )
					countm:+2
					m[countm]=tmpx
					m[countm+1]=tmpy
					count1=(count1+count+2) Mod p1.length
					flag=0
					Exit
				EndIf
			Next
			count2:+2
			If count2&gt;=p2.length Then count2=0
		EndIf
		countm:+2
	Until count1=start
	
	Return m[..countm]
End Function

'Adapted from Fredborg's code
Function LinesCross:Int( rx:Float Var, ry:Float Var, x0:Float, y0:Float , x1:Float, y1:Float,..
						x2:Float ,y2:Float, x3:Float, y3:Float )
	  
	Local n:Float=(y0-y2)*(x3-x2)-(x0-x2)*(y3-y2)
	Local d:Float=(x1-x0)*(y3-y2)-(y1-y0)*(x3-x2)
	
	If Abs(d) &lt; 0.0001 
		' Lines are parallel!
		Return False
	Else
		' Lines might cross!
		Local Sn:Float=(y0-y2)*(x1-x0)-(x0-x2)*(y1-y0)

		Local AB:Float=n/d
		If AB&gt;0.0 And AB&lt;1.0
			Local CD:Float=Sn/d
			If CD&gt;0.0 And CD&lt;1.0
				' Intersection Point
				rx=x0+AB*(x1-x0)
		       	ry=y0+AB*(y1-y0)
				Return True
			End If
		End If
	
		' Lines didn't cross, because the intersection was beyond the end points of the lines
	EndIf

	' Lines do Not cross!
	Return False

End Function

Function PointInPoly:Int( point_x:Float, point_y:Float, xy:Float[] )
	
	If xy.length&lt;6 Or (xy.length&amp;1) Return False
	
	Local x1:Float=xy[xy.Length-2]
	Local y1:Float=xy[xy.Length-1]
	Local cur_quad:Int=GetQuad(point_x,point_y,x1,y1)
	Local next_quad:Int
	Local total:Int
	
	For Local i:Int=0 Until Len xy Step 2
		Local x2:Float=xy[i]
		Local y2:Float=xy[i+1]
		next_quad=GetQuad(point_x,point_y,x2,y2)
		Local diff:Int=next_quad-cur_quad
		
		Select diff
		Case 2,-2
			If ( x2 - ( ((y2 - point_y) * (x1 - x2)) / (y1 - y2) ) )&lt;point_x
				diff=-diff
			EndIf
		Case 3
			diff=-1
		Case -3
			diff=1
		End Select
		
		total:+diff
		cur_quad=next_quad
		x1=x2
		y1=y2
	Next
	
	If Abs(total)=4 Then Return True Else Return False
End Function

Function GetQuad:Int(axis_x:Float,axis_y:Float,vert_x:Float,vert_y:Float)
	If vert_x&lt;axis_x
		If vert_y&lt;axis_y
			Return 1
		Else
			Return 4
		EndIf
	Else
		If vert_y&lt;axis_y
			Return 2
		Else
			Return 3
		EndIf	
	EndIf

End Function

Function DrawPoly( xy:Float[], fill:Int=True, x:Float=0, y:Float=0 )
	Local origin_x:Float
	Local origin_y:Float
	GetOrigin origin_x,origin_y
	Local handle_x:Float
	Local handle_y:Float
	GetHandle handle_x,handle_y
	
	If fill
		_max2dDriver.DrawPoly xy,..
		-handle_x,-handle_y,..
		x+origin_x,y+origin_y
	Else
		Local x1:Float=xy[xy.Length-2]
		Local y1:Float=xy[xy.Length-1]
		For Local i:Int=0 Until Len xy Step 2
			Local x2:Float=xy[i]
			Local y2:Float=xy[i+1]
			_max2dDriver.DrawLine..
			-handle_x+x1,-handle_y+y1,..
			-handle_x+x2,-handle_y+y2,..
			x+origin_x-0.5,y+origin_y-0.5
			x1=x2
			y1=y2
		Next
	EndIf
End Function</textarea><br>It's not perfect but it's a start. <br><br></td></tr></table><br>
<a name="1070511"></a>

<a name="1070512"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Oddball</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> How about this one?<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict

Graphics 800,600

Global poly1:Float[]=[ 100.0,250.0, 700.0,250.0, 700.0,350.0, 100.0,350.0 ]'[ 200.0,200.0, 500.0,250.0, 500.0,350.0, 200.0,300.0 ]
Global poly2:Float[]=[ 300.0,100.0, 500.0,100.0, 500.0,500.0, 300.0,500.0 ]'[ 300.0,300.0, 700.0,250.0, 700.0,350.0, 300.0,400.0 ]

Global merged:Float[]

SetColor 0,255,0
DrawText "Polygon 1",0,0
DrawPoly poly1,False
Flip

WaitKey()

SetColor 0,255,0
DrawText "Polygon 1",0,0
DrawPoly poly1,False
SetColor 0,0,255
DrawText "Polygon 2",0,15
DrawPoly poly2,False
Flip

WaitKey()

merged=AddPoly(poly1,poly2)

SetColor 0,255,0
DrawText "Polygon 1",0,0
DrawPoly poly1,False
SetColor 0,0,255
DrawText "Polygon 2",0,15
DrawPoly poly2,False
SetColor 255,0,0
DrawText "Merged Polygon",0,30
DrawPoly merged,False
Flip

WaitKey()

Function AddPoly:Float[]( p1:Float[], p2:Float[] )
	Local m:Float[1024]
	
	Local start:Int=0
	While PointInPoly(p1[start],p1[start+1],p2) And start&lt;p1.length
		start:+2
	Wend
	If start&gt;=p1.length Then Return p2
	
	m[0]=p1[start];m[1]=p1[start+1]
	Local countm:Int=2
	Local count1:Int=start+2
	Local count2:Int=0
	Local flag:Int=0
	Repeat
		If flag=0
			
			Local mx:Float=p1[count1]
			Local my:Float=p1[count1+1]
			Local i:Int
			For Local count:Int=0 To p2.length Step 2
				Local tmpx:Float
				Local tmpy:Float
				If LinesCross(tmpx,tmpy,m[countm-2],m[countm-1],mx,my, p2[(count2+count) Mod p2.length],p2[(count2+count+1) Mod p2.length],p2[(count2+count+2) Mod p2.length],p2[(count2+count+3) Mod p2.length] )
					If (tmpx-m[countm-2])*(tmpx-m[countm-2])+(tmpy-m[countm-1])*(tmpy-m[countm-1])&lt;(mx-m[countm-2])*(mx-m[countm-2])+(my-m[countm-1])*(my-m[countm-1])
						mx=tmpx
						my=tmpy
						i=count
						flag=1
					EndIf
				EndIf
			Next
			m[countm]=mx
			m[countm+1]=my
			countm:+2
			If flag=0
				count1:+2
				If count1&gt;=p1.length Then count1=0
			Else
				count2=(count2+i+2) Mod p2.length
			EndIf
		Else
			
			Local mx:Float=p2[count2]
			Local my:Float=p2[count2+1]
			Local i:Int
			For Local count:Int=0 To p2.length Step 2
				Local tmpx:Float
				Local tmpy:Float
				If LinesCross(tmpx,tmpy,m[countm-2],m[countm-1],mx,my, p1[(count1+count) Mod p1.length],p1[(count1+count+1) Mod p1.length],p1[(count1+count+2) Mod p1.length],p1[(count1+count+3) Mod p1.length] )
					If (tmpx-m[countm-2])*(tmpx-m[countm-2])+(tmpy-m[countm-1])*(tmpy-m[countm-1])&lt;(mx-m[countm-2])*(mx-m[countm-2])+(my-m[countm-1])*(my-m[countm-1])
						mx=tmpx
						my=tmpy
						i=count
						flag=0
					EndIf
				EndIf
			Next
			m[countm]=mx
			m[countm+1]=my
			countm:+2
			If flag=1
				count2:+2
				If count2&gt;=p2.length Then count2=0
			Else
				count1=(count1+i+2) Mod p1.length
			EndIf
		EndIf
		
	Until count1=start
	
	Return m[..countm]
End Function

'Adapted from Fredborg's code
Function LinesCross:Int( rx:Float Var, ry:Float Var, x0:Float, y0:Float , x1:Float, y1:Float,..
						x2:Float ,y2:Float, x3:Float, y3:Float )
	  
	Local n:Float=(y0-y2)*(x3-x2)-(x0-x2)*(y3-y2)
	Local d:Float=(x1-x0)*(y3-y2)-(y1-y0)*(x3-x2)
	
	If Abs(d) &lt; 0.0001 
		' Lines are parallel!
		Return False
	Else
		' Lines might cross!
		Local Sn:Float=(y0-y2)*(x1-x0)-(x0-x2)*(y1-y0)

		Local AB:Float=n/d
		If AB&gt;0.0 And AB&lt;1.0
			Local CD:Float=Sn/d
			If CD&gt;0.0 And CD&lt;1.0
				' Intersection Point
				rx=x0+AB*(x1-x0)
		       	ry=y0+AB*(y1-y0)
				Return True
			End If
		End If
	
		' Lines didn't cross, because the intersection was beyond the end points of the lines
	EndIf

	' Lines do Not cross!
	Return False

End Function

Function PointInPoly:Int( point_x:Float, point_y:Float, xy:Float[] )
	
	If xy.length&lt;6 Or (xy.length&amp;1) Return False
	
	Local x1:Float=xy[xy.Length-2]
	Local y1:Float=xy[xy.Length-1]
	Local cur_quad:Int=GetQuad(point_x,point_y,x1,y1)
	Local next_quad:Int
	Local total:Int
	
	For Local i:Int=0 Until Len xy Step 2
		Local x2:Float=xy[i]
		Local y2:Float=xy[i+1]
		next_quad=GetQuad(point_x,point_y,x2,y2)
		Local diff:Int=next_quad-cur_quad
		
		Select diff
		Case 2,-2
			If ( x2 - ( ((y2 - point_y) * (x1 - x2)) / (y1 - y2) ) )&lt;point_x
				diff=-diff
			EndIf
		Case 3
			diff=-1
		Case -3
			diff=1
		End Select
		
		total:+diff
		cur_quad=next_quad
		x1=x2
		y1=y2
	Next
	
	If Abs(total)=4 Then Return True Else Return False
End Function

Function GetQuad:Int(axis_x:Float,axis_y:Float,vert_x:Float,vert_y:Float)
	If vert_x&lt;axis_x
		If vert_y&lt;axis_y
			Return 1
		Else
			Return 4
		EndIf
	Else
		If vert_y&lt;axis_y
			Return 2
		Else
			Return 3
		EndIf	
	EndIf

End Function

Function DrawPoly( xy:Float[], fill:Int=True, x:Float=0, y:Float=0 )
	Local origin_x:Float
	Local origin_y:Float
	GetOrigin origin_x,origin_y
	Local handle_x:Float
	Local handle_y:Float
	GetHandle handle_x,handle_y
	
	If fill
		_max2dDriver.DrawPoly xy,..
		-handle_x,-handle_y,..
		x+origin_x,y+origin_y
	Else
		Local x1:Float=xy[xy.Length-2]
		Local y1:Float=xy[xy.Length-1]
		For Local i:Int=0 Until Len xy Step 2
			Local x2:Float=xy[i]
			Local y2:Float=xy[i+1]
			_max2dDriver.DrawLine..
			-handle_x+x1,-handle_y+y1,..
			-handle_x+x2,-handle_y+y2,..
			x+origin_x-0.5,y+origin_y-0.5
			x1=x2
			y1=y2
		Next
	EndIf
End Function</textarea><br>It's a little better. It can handle multiple line crosses along a single line.<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1070521"></a>

<a name="1070522"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Oddball</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, now it has a limited form of polygon subtraction<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict

Graphics 800,600

Global poly1:Float[]=[ 200.0,200.0, 500.0,250.0, 500.0,350.0, 200.0,300.0 ]
Global poly2:Float[]=[ 300.0,300.0, 700.0,250.0, 700.0,350.0, 300.0,400.0 ]

Global merged:Float[]

Cls
SetColor 0,255,0
DrawText "Polygon 1",0,0
DrawPoly poly1,False
Flip

WaitKey()

Cls
SetColor 0,255,0
DrawText "Polygon 1",0,0
DrawPoly poly1,False
SetColor 0,0,255
DrawText "Polygon 2",0,15
DrawPoly poly2,False
Flip

WaitKey()

merged=BoolPoly(poly1,poly2)

Cls
SetColor 0,255,0
DrawText "Polygon 1",0,0
DrawPoly poly1,False
SetColor 0,0,255
DrawText "Polygon 2",0,15
DrawPoly poly2,False
SetColor 255,0,0
DrawText "P1+P2 Polygon",0,30
DrawPoly merged,False
Flip

WaitKey()

merged=BoolPoly(poly1,poly2,True)

Cls
SetColor 0,255,0
DrawText "Polygon 1",0,0
DrawPoly poly1,False
SetColor 0,0,255
DrawText "Polygon 2",0,15
DrawPoly poly2,False
SetColor 255,0,0
DrawText "P1-P2 Polygon",0,30
DrawPoly merged,False
Flip

WaitKey()

Function BoolPoly:Float[]( p1:Float[], p2:Float[], sub:Int=False )
	If sub
		Local tmp:Float[p2.length]
		For Local count:Int=0 Until p2.length Step 2
			tmp[count]=p2[p2.length-count-2]
			tmp[count+1]=p2[p2.length-count-1]
		Next
		p2=tmp
	EndIf
	Local m:Float[1024]
	
	Local start:Int=0
	While PointInPoly(p1[start],p1[start+1],p2) And start&lt;p1.length
		start:+2
	Wend
	If start&gt;=p1.length Then Return p2
	
	m[0]=p1[start];m[1]=p1[start+1]
	Local countm:Int=2
	Local count1:Int=start+2
	Local count2:Int=0
	Local flag:Int=0
	Repeat
		If flag=0
			
			Local mx:Float=p1[count1]
			Local my:Float=p1[count1+1]
			Local i:Int
			For Local count:Int=0 To p2.length Step 2
				Local tmpx:Float
				Local tmpy:Float
				If LinesCross(tmpx,tmpy,m[countm-2],m[countm-1],mx,my, p2[(count2+count) Mod p2.length],p2[(count2+count+1) Mod p2.length],p2[(count2+count+2) Mod p2.length],p2[(count2+count+3) Mod p2.length] )
					If (tmpx-m[countm-2])*(tmpx-m[countm-2])+(tmpy-m[countm-1])*(tmpy-m[countm-1])&lt;(mx-m[countm-2])*(mx-m[countm-2])+(my-m[countm-1])*(my-m[countm-1])
						mx=tmpx
						my=tmpy
						i=count
						flag=1
					EndIf
				EndIf
			Next
			m[countm]=mx
			m[countm+1]=my
			countm:+2
			If flag=0
				count1:+2
				If count1&gt;=p1.length Then count1=0
			Else
				count2=(count2+i+2) Mod p2.length
			EndIf
		Else
			
			Local mx:Float=p2[count2]
			Local my:Float=p2[count2+1]
			Local i:Int
			For Local count:Int=0 To p2.length Step 2
				Local tmpx:Float
				Local tmpy:Float
				If LinesCross(tmpx,tmpy,m[countm-2],m[countm-1],mx,my, p1[(count1+count) Mod p1.length],p1[(count1+count+1) Mod p1.length],p1[(count1+count+2) Mod p1.length],p1[(count1+count+3) Mod p1.length] )
					If (tmpx-m[countm-2])*(tmpx-m[countm-2])+(tmpy-m[countm-1])*(tmpy-m[countm-1])&lt;(mx-m[countm-2])*(mx-m[countm-2])+(my-m[countm-1])*(my-m[countm-1])
						mx=tmpx
						my=tmpy
						i=count
						flag=0
					EndIf
				EndIf
			Next
			m[countm]=mx
			m[countm+1]=my
			countm:+2
			If flag=1
				count2:+2
				If count2&gt;=p2.length Then count2=0
			Else
				count1=(count1+i+2) Mod p1.length
			EndIf
		EndIf
		
	Until count1=start
	
	Return m[..countm]
End Function

'Adapted from Fredborg's code
Function LinesCross:Int( rx:Float Var, ry:Float Var, x0:Float, y0:Float , x1:Float, y1:Float,..
						x2:Float ,y2:Float, x3:Float, y3:Float )
	  
	Local n:Float=(y0-y2)*(x3-x2)-(x0-x2)*(y3-y2)
	Local d:Float=(x1-x0)*(y3-y2)-(y1-y0)*(x3-x2)
	
	If Abs(d) &lt; 0.0001 
		' Lines are parallel!
		Return False
	Else
		' Lines might cross!
		Local Sn:Float=(y0-y2)*(x1-x0)-(x0-x2)*(y1-y0)

		Local AB:Float=n/d
		If AB&gt;0.0 And AB&lt;1.0
			Local CD:Float=Sn/d
			If CD&gt;0.0 And CD&lt;1.0
				' Intersection Point
				rx=x0+AB*(x1-x0)
		       	ry=y0+AB*(y1-y0)
				Return True
			End If
		End If
	
		' Lines didn't cross, because the intersection was beyond the end points of the lines
	EndIf

	' Lines do Not cross!
	Return False

End Function

Function PointInPoly:Int( point_x:Float, point_y:Float, xy:Float[] )
	
	If xy.length&lt;6 Or (xy.length&amp;1) Return False
	
	Local x1:Float=xy[xy.Length-2]
	Local y1:Float=xy[xy.Length-1]
	Local cur_quad:Int=GetQuad(point_x,point_y,x1,y1)
	Local next_quad:Int
	Local total:Int
	
	For Local i:Int=0 Until Len xy Step 2
		Local x2:Float=xy[i]
		Local y2:Float=xy[i+1]
		next_quad=GetQuad(point_x,point_y,x2,y2)
		Local diff:Int=next_quad-cur_quad
		
		Select diff
		Case 2,-2
			If ( x2 - ( ((y2 - point_y) * (x1 - x2)) / (y1 - y2) ) )&lt;point_x
				diff=-diff
			EndIf
		Case 3
			diff=-1
		Case -3
			diff=1
		End Select
		
		total:+diff
		cur_quad=next_quad
		x1=x2
		y1=y2
	Next
	
	If Abs(total)=4 Then Return True Else Return False
End Function

Function GetQuad:Int(axis_x:Float,axis_y:Float,vert_x:Float,vert_y:Float)
	If vert_x&lt;axis_x
		If vert_y&lt;axis_y
			Return 1
		Else
			Return 4
		EndIf
	Else
		If vert_y&lt;axis_y
			Return 2
		Else
			Return 3
		EndIf	
	EndIf

End Function

Function DrawPoly( xy:Float[], fill:Int=True, x:Float=0, y:Float=0 )
	Local origin_x:Float
	Local origin_y:Float
	GetOrigin origin_x,origin_y
	Local handle_x:Float
	Local handle_y:Float
	GetHandle handle_x,handle_y
	
	If fill
		_max2dDriver.DrawPoly xy,..
		-handle_x,-handle_y,..
		x+origin_x,y+origin_y
	Else
		Local x1:Float=xy[xy.Length-2]
		Local y1:Float=xy[xy.Length-1]
		For Local i:Int=0 Until Len xy Step 2
			Local x2:Float=xy[i]
			Local y2:Float=xy[i+1]
			_max2dDriver.DrawLine..
			-handle_x+x1,-handle_y+y1,..
			-handle_x+x2,-handle_y+y2,..
			x+origin_x-0.5,y+origin_y-0.5
			x1=x2
			y1=y2
		Next
	EndIf
End Function</textarea><br>Still far from perfect, but not bad for 20 minutes coding. I'm sure you can take it from here and customise it to your needs.<br><br>Have fun!<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1070523"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Oddball</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> I should add that the points in the polygons should run clockwise for this to work correctly. <br><br></td></tr></table><br>
<a name="1070526"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warpy</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> To detect if the points in a triangle are clockwise:<br><pre class=code>
Function makeClockwise(tri#[])
   Local cp# = (tri[2]-tri[0])*(tri[5]-tri[1]) - (tri[4]-tri[0])*(tri[3]-tri[1])
   If cp &gt; 0
     Local x# = tri[2], y# = tri[3]
     tri[2] = tri[4]
     tri[4] = x
     tri[3] = tri[5]
     tri[5] = y
   EndIf
End Function
</pre><br><br>I'm sure I had a page bookmarked which explained the algorithm for polygon operations, but I can't find it. <a href="http://revar.livejournal.com/81627.html" target="_blank">This livejournal post</a> seems to give a brief summary of the process. <br><br></td></tr></table><br>
<a name="1070527"></a>

<a name="1070538"></a>

<a name="1070642"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Oddball</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Do you have a version of that for polygons of any number of points? It would help make the function more robust. Anyway there is a serious bug in my last example so here it is all fixed up<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict

Graphics 800,600

Global poly1:Float[]=[ 200.0,200.0, 500.0,250.0, 400.0,300.0, 500.0,350.0, 200.0,300.0 ]
Global poly2:Float[]=[ 300.0,300.0, 700.0,250.0, 700.0,350.0, 300.0,400.0, 100.0,250.0 ]

Global merged:Float[]

Cls
SetColor 0,255,0
DrawText "Polygon 1",0,0
DrawPoly poly1,False
Flip

WaitKey()

Cls
SetColor 0,255,0
DrawText "Polygon 1",0,0
DrawPoly poly1,False
SetColor 0,0,255
DrawText "Polygon 2",0,15
DrawPoly poly2,False
Flip

WaitKey()

merged=BoolPoly(poly1,poly2)

Cls
SetColor 0,255,0
DrawText "Polygon 1",0,0
DrawPoly poly1,False
SetColor 0,0,255
DrawText "Polygon 2",0,15
DrawPoly poly2,False
SetColor 255,0,0
DrawText "P1+P2 Polygon",0,30
DrawPoly merged,False
Flip

WaitKey()

merged=BoolPoly(poly1,poly2,True)

Cls
SetColor 0,255,0
DrawText "Polygon 1",0,0
DrawPoly poly1,False
SetColor 0,0,255
DrawText "Polygon 2",0,15
DrawPoly poly2,False
SetColor 255,0,0
DrawText "P1-P2 Polygon",0,30
DrawPoly merged,False
Flip

WaitKey()

Function BoolPoly:Float[]( p1:Float[], p2:Float[], sub:Int=False )
	If sub
		Local tmp:Float[p2.length]
		For Local count:Int=0 Until p2.length Step 2
			tmp[count]=p2[p2.length-count-2]
			tmp[count+1]=p2[p2.length-count-1]
		Next
		p2=tmp
	EndIf
	Local m:Float[1024]
	
	Local start:Int=0
	While PointInPoly(p1[start],p1[start+1],p2) And start&lt;p1.length
		start:+2
	Wend
	If start&gt;=p1.length Then Return p2
	
	m[0]=p1[start];m[1]=p1[start+1]
	Local countm:Int=2
	Local count1:Int=start+2
	If count1&gt;=p1.length Then count1=0
	Local count2:Int=0
	Local flag:Int=0
	Repeat
		If flag=0
			
			Local mx:Float=p1[count1]
			Local my:Float=p1[count1+1]
			Local i:Int
			Local md:Float=(mx-m[countm-2])*(mx-m[countm-2])+(my-m[countm-1])*(my-m[countm-1])
			For Local count:Int=0 Until p2.length Step 2
				Local tmpx:Float
				Local tmpy:Float
				If LinesCross(tmpx,tmpy,m[countm-2],m[countm-1],mx,my, p2[(count2+count) Mod p2.length],p2[(count2+count+1) Mod p2.length],p2[(count2+count+2) Mod p2.length],p2[(count2+count+3) Mod p2.length] )
					Local d:Float=(tmpx-m[countm-2])*(tmpx-m[countm-2])+(tmpy-m[countm-1])*(tmpy-m[countm-1])
					If d&gt;.001 And d&lt;md
						mx=tmpx
						my=tmpy
						i=count
						md=d
						flag=1
					EndIf
				EndIf
			Next
			m[countm]=mx
			m[countm+1]=my
			countm:+2
			If flag=0
				count1:+2
				If count1&gt;=p1.length Then count1=0
			Else
				count2=(count2+i+2) Mod p2.length
			EndIf
		Else
			
			Local mx:Float=p2[count2]
			Local my:Float=p2[count2+1]
			Local i:Int
			Local md:Float=(mx-m[countm-2])*(mx-m[countm-2])+(my-m[countm-1])*(my-m[countm-1])
			For Local count:Int=0 Until p1.length Step 2
				Local tmpx:Float
				Local tmpy:Float
				If LinesCross(tmpx,tmpy,m[countm-2],m[countm-1],mx,my, p1[(count1+count) Mod p1.length],p1[(count1+count+1) Mod p1.length],p1[(count1+count+2) Mod p1.length],p1[(count1+count+3) Mod p1.length] )
					Local d:Float=(tmpx-m[countm-2])*(tmpx-m[countm-2])+(tmpy-m[countm-1])*(tmpy-m[countm-1])
					If d&gt;.001 And d&lt;md
						mx=tmpx
						my=tmpy
						i=count
						md=d
						flag=0
					EndIf
				EndIf
			Next
			m[countm]=mx
			m[countm+1]=my
			countm:+2
			If flag=1
				count2:+2
				If count2&gt;=p2.length Then count2=0
			Else
				count1=(count1+i+2) Mod p1.length
			EndIf
		EndIf
		
	Until count1=start
	
	Return m[..countm]
End Function

'Adapted from Fredborg's code
Function LinesCross:Int( rx:Float Var, ry:Float Var, x0:Float, y0:Float , x1:Float, y1:Float,..
						x2:Float ,y2:Float, x3:Float, y3:Float )
	  
	Local n:Float=(y0-y2)*(x3-x2)-(x0-x2)*(y3-y2)
	Local d:Float=(x1-x0)*(y3-y2)-(y1-y0)*(x3-x2)
	
	If Abs(d) &lt; 0.0001 
		' Lines are parallel!
		Return False
	Else
		' Lines might cross!
		Local Sn:Float=(y0-y2)*(x1-x0)-(x0-x2)*(y1-y0)

		Local AB:Float=n/d
		If AB&gt;0.0 And AB&lt;1.0
			Local CD:Float=Sn/d
			If CD&gt;0.0 And CD&lt;1.0
				' Intersection Point
				rx=x0+AB*(x1-x0)
		       	ry=y0+AB*(y1-y0)
				Return True
			End If
		End If
	
		' Lines didn't cross, because the intersection was beyond the end points of the lines
	EndIf

	' Lines do Not cross!
	Return False

End Function

Function PointInPoly:Int( point_x:Float, point_y:Float, xy:Float[] )
	
	If xy.length&lt;6 Or (xy.length&amp;1) Return False
	
	Local x1:Float=xy[xy.Length-2]
	Local y1:Float=xy[xy.Length-1]
	Local cur_quad:Int=GetQuad(point_x,point_y,x1,y1)
	Local next_quad:Int
	Local total:Int
	
	For Local i:Int=0 Until Len xy Step 2
		Local x2:Float=xy[i]
		Local y2:Float=xy[i+1]
		next_quad=GetQuad(point_x,point_y,x2,y2)
		Local diff:Int=next_quad-cur_quad
		
		Select diff
		Case 2,-2
			If ( x2 - ( ((y2 - point_y) * (x1 - x2)) / (y1 - y2) ) )&lt;point_x
				diff=-diff
			EndIf
		Case 3
			diff=-1
		Case -3
			diff=1
		End Select
		
		total:+diff
		cur_quad=next_quad
		x1=x2
		y1=y2
	Next
	
	If Abs(total)=4 Then Return True Else Return False
End Function

Function GetQuad:Int(axis_x:Float,axis_y:Float,vert_x:Float,vert_y:Float)
	If vert_x&lt;axis_x
		If vert_y&lt;axis_y
			Return 1
		Else
			Return 4
		EndIf
	Else
		If vert_y&lt;axis_y
			Return 2
		Else
			Return 3
		EndIf	
	EndIf

End Function

Function DrawPoly( xy:Float[], fill:Int=True, x:Float=0, y:Float=0 )
	Local origin_x:Float
	Local origin_y:Float
	GetOrigin origin_x,origin_y
	Local handle_x:Float
	Local handle_y:Float
	GetHandle handle_x,handle_y
	
	If fill
		_max2dDriver.DrawPoly xy,..
		-handle_x,-handle_y,..
		x+origin_x,y+origin_y
	Else
		Local x1:Float=xy[xy.Length-2]
		Local y1:Float=xy[xy.Length-1]
		For Local i:Int=0 Until Len xy Step 2
			Local x2:Float=xy[i]
			Local y2:Float=xy[i+1]
			_max2dDriver.DrawLine..
			-handle_x+x1,-handle_y+y1,..
			-handle_x+x2,-handle_y+y2,..
			x+origin_x-0.5,y+origin_y-0.5
			x1=x2
			y1=y2
		Next
	EndIf
End Function</textarea><br>That's the last one I promise. I shouldn't really be messing with this stuff anyway, but it piqued my interest and I couldn't help myself.<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1070536"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Space_guy</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> :) This is awsome! Thanks alot!<br>I hope to have a play with this tonight <br><br></td></tr></table><br>
<a name="1070542"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> You could do it in realtime using the stencil buffer in opengl. <br><br></td></tr></table><br>
<a name="1070544"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warpy</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oddball: just look at the first three points. Assuming the polygon doesn't self-intersect, if the first three points are clockwise the whole polygon has to be. If the polygon does self-intersect, being clockwise or anticlockwise has no meaning. <br><br></td></tr></table><br>
<a name="1070573"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Oddball</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> D'oh! Good call Warpy. Makes perfect sense, if only I'd taken a moment to think about it. <br><br></td></tr></table><br>
<a name="1070576"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warpy</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> I was wrong: if you choose a concave bit it won't work. <br><br></td></tr></table><br>
<a name="1070579"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Oddball</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's nothing a quick tweak won't fix.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict

Graphics 800,600

Global poly1:Float[]=[ 100.0,50.0, 300.0,400.0, 700.0,350.0, 700.0,250.0, 300.0,100.0, 300.0,300.0 ]
Global poly2:Float[]=[ 200.0,300.0, 500.0,350.0, 400.0,300.0, 500.0,250.0, 200.0,200.0 ]

Global merged:Float[]

Cls
SetColor 0,255,0
DrawText "Polygon 1",0,0
DrawPoly poly1,False
Flip

WaitKey()

Cls
SetColor 0,255,0
DrawText "Polygon 1",0,0
DrawPoly poly1,False
SetColor 0,0,255
DrawText "Polygon 2",0,15
DrawPoly poly2,False
Flip

WaitKey()

merged=BoolPoly(poly1,poly2)

Cls
SetColor 0,255,0
DrawText "Polygon 1",0,0
DrawPoly poly1,False
SetColor 0,0,255
DrawText "Polygon 2",0,15
DrawPoly poly2,False
SetColor 255,0,0
DrawText "P1+P2 Polygon",0,30
DrawPoly merged,False
Flip

WaitKey()

merged=BoolPoly(poly1,poly2,True)

Cls
SetColor 0,255,0
DrawText "Polygon 1",0,0
DrawPoly poly1,False
SetColor 0,0,255
DrawText "Polygon 2",0,15
DrawPoly poly2,False
SetColor 255,0,0
DrawText "P1-P2 Polygon",0,30
DrawPoly merged,False
Flip

WaitKey()

Function BoolPoly:Float[]( p1:Float[], p2:Float[], sub:Int=False )
	If Not IsClockwise(p1) Then p1=ReversePoly(p1)
	If (sub And IsClockwise(p2)) Or (Not sub And Not IsClockwise(p2)) Then p2=ReversePoly(p2)
	Local m:Float[1024]
	
	Local start:Int=0
	While PointInPoly(p1[start],p1[start+1],p2) And start&lt;p1.length
		start:+2
	Wend
	If start&gt;=p1.length Then Return p2
	
	m[0]=p1[start];m[1]=p1[start+1]
	Local countm:Int=2
	Local count1:Int=start+2
	If count1&gt;=p1.length Then count1=0
	Local count2:Int=0
	Local flag:Int=0
	Repeat
		If flag=0
			
			Local mx:Float=p1[count1]
			Local my:Float=p1[count1+1]
			Local i:Int
			Local md:Float=(mx-m[countm-2])*(mx-m[countm-2])+(my-m[countm-1])*(my-m[countm-1])
			For Local count:Int=0 Until p2.length Step 2
				Local tmpx:Float
				Local tmpy:Float
				If LinesCross(tmpx,tmpy,m[countm-2],m[countm-1],mx,my, p2[(count2+count) Mod p2.length],p2[(count2+count+1) Mod p2.length],p2[(count2+count+2) Mod p2.length],p2[(count2+count+3) Mod p2.length] )
					Local d:Float=(tmpx-m[countm-2])*(tmpx-m[countm-2])+(tmpy-m[countm-1])*(tmpy-m[countm-1])
					If d&gt;.001 And d&lt;md
						mx=tmpx
						my=tmpy
						i=count
						md=d
						flag=1
					EndIf
				EndIf
			Next
			m[countm]=mx
			m[countm+1]=my
			countm:+2
			If flag=0
				count1:+2
				If count1&gt;=p1.length Then count1=0
			Else
				count2=(count2+i+2) Mod p2.length
			EndIf
		Else
			
			Local mx:Float=p2[count2]
			Local my:Float=p2[count2+1]
			Local i:Int
			Local md:Float=(mx-m[countm-2])*(mx-m[countm-2])+(my-m[countm-1])*(my-m[countm-1])
			For Local count:Int=0 Until p1.length Step 2
				Local tmpx:Float
				Local tmpy:Float
				If LinesCross(tmpx,tmpy,m[countm-2],m[countm-1],mx,my, p1[(count1+count) Mod p1.length],p1[(count1+count+1) Mod p1.length],p1[(count1+count+2) Mod p1.length],p1[(count1+count+3) Mod p1.length] )
					Local d:Float=(tmpx-m[countm-2])*(tmpx-m[countm-2])+(tmpy-m[countm-1])*(tmpy-m[countm-1])
					If d&gt;.001 And d&lt;md
						mx=tmpx
						my=tmpy
						i=count
						md=d
						flag=0
					EndIf
				EndIf
			Next
			m[countm]=mx
			m[countm+1]=my
			countm:+2
			If flag=1
				count2:+2
				If count2&gt;=p2.length Then count2=0
			Else
				count1=(count1+i+2) Mod p1.length
			EndIf
		EndIf
		
	Until count1=start
	
	Return m[..countm]
End Function

Function ReversePoly:Float[]( poly:Float[] )
	Local tmp:Float[poly.length]
	For Local count:Int=0 Until poly.length Step 2
		tmp[count]=poly[poly.length-count-2]
		tmp[count+1]=poly[poly.length-count-1]
	Next
	Return tmp
End Function

'Adapted from Wary's code
Function IsClockwise:Int( poly:Float[] )
	Local vex:Int=PointInPoly( (poly[0]+poly[2]+poly[4])*.333, (poly[1]+poly[3]+poly[5])*.333, poly )
	Local cp:Float = (poly[2]-poly[0])*(poly[5]-poly[1]) - (poly[4]-poly[0])*(poly[3]-poly[1])
	If (cp&gt;0 And vex) Or (cp&lt;=0 And Not vex)
		Return True
	EndIf
End Function

'Adapted from Fredborg's code
Function LinesCross:Int( rx:Float Var, ry:Float Var, x0:Float, y0:Float , x1:Float, y1:Float,..
						x2:Float ,y2:Float, x3:Float, y3:Float )
	  
	Local n:Float=(y0-y2)*(x3-x2)-(x0-x2)*(y3-y2)
	Local d:Float=(x1-x0)*(y3-y2)-(y1-y0)*(x3-x2)
	
	If Abs(d) &lt; 0.0001 
		' Lines are parallel!
		Return False
	Else
		' Lines might cross!
		Local Sn:Float=(y0-y2)*(x1-x0)-(x0-x2)*(y1-y0)

		Local AB:Float=n/d
		If AB&gt;0.0 And AB&lt;1.0
			Local CD:Float=Sn/d
			If CD&gt;0.0 And CD&lt;1.0
				' Intersection Point
				rx=x0+AB*(x1-x0)
		       	ry=y0+AB*(y1-y0)
				Return True
			End If
		End If
	
		' Lines didn't cross, because the intersection was beyond the end points of the lines
	EndIf

	' Lines do Not cross!
	Return False

End Function

Function PointInPoly:Int( point_x:Float, point_y:Float, xy:Float[] )
	
	If xy.length&lt;6 Or (xy.length&amp;1) Return False
	
	Local x1:Float=xy[xy.Length-2]
	Local y1:Float=xy[xy.Length-1]
	Local cur_quad:Int=GetQuad(point_x,point_y,x1,y1)
	Local next_quad:Int
	Local total:Int
	
	For Local i:Int=0 Until Len xy Step 2
		Local x2:Float=xy[i]
		Local y2:Float=xy[i+1]
		next_quad=GetQuad(point_x,point_y,x2,y2)
		Local diff:Int=next_quad-cur_quad
		
		Select diff
		Case 2,-2
			If ( x2 - ( ((y2 - point_y) * (x1 - x2)) / (y1 - y2) ) )&lt;point_x
				diff=-diff
			EndIf
		Case 3
			diff=-1
		Case -3
			diff=1
		End Select
		
		total:+diff
		cur_quad=next_quad
		x1=x2
		y1=y2
	Next
	
	If Abs(total)=4 Then Return True Else Return False
End Function

Function GetQuad:Int(axis_x:Float,axis_y:Float,vert_x:Float,vert_y:Float)
	If vert_x&lt;axis_x
		If vert_y&lt;axis_y
			Return 1
		Else
			Return 4
		EndIf
	Else
		If vert_y&lt;axis_y
			Return 2
		Else
			Return 3
		EndIf	
	EndIf

End Function

Function DrawPoly( xy:Float[], fill:Int=True, x:Float=0, y:Float=0 )
	Local origin_x:Float
	Local origin_y:Float
	GetOrigin origin_x,origin_y
	Local handle_x:Float
	Local handle_y:Float
	GetHandle handle_x,handle_y
	
	If fill
		_max2dDriver.DrawPoly xy,..
		-handle_x,-handle_y,..
		x+origin_x,y+origin_y
	Else
		Local x1:Float=xy[xy.Length-2]
		Local y1:Float=xy[xy.Length-1]
		For Local i:Int=0 Until Len xy Step 2
			Local x2:Float=xy[i]
			Local y2:Float=xy[i+1]
			_max2dDriver.DrawLine..
			-handle_x+x1,-handle_y+y1,..
			-handle_x+x2,-handle_y+y2,..
			x+origin_x-0.5,y+origin_y-0.5
			x1=x2
			y1=y2
		Next
	EndIf
End Function</textarea><br>Now works with polygons running in either direction. Far from perfect, but still pretty good I'd say. <br><br></td></tr></table><br>
<a name="1070598"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Space_guy</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> I did not have the time i hoped for last night but in the time i had i must say it works very good! Thanks alot for sharing this Oddball! <br><br></td></tr></table><br>
<a name="1072854"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Space_guy</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> As Im back into this polygon code i discovered a bug.<br>Whenever i try add or substract from the final line in the p1 polygon it just ignores it.<br><br>Any thougths? <br><br>Also im thinking if a polygon gets split in 2 parts by the second poly it would be very cool to be able to get both polygons :) Any ideas where I could start? <br><br>And thanks again for this code. Its almost perfect for my needs :) <br><br></td></tr></table><br>
<a name="1072863"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warpy</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> The algorithm <a href="http://revar.livejournal.com/81627.html" target="_blank">on the livejournal blog</a> I posted before is the only proper algorithm to do this. I wish I could find the much more detailed page I can remember seeing, but I can't find it. <br><br></td></tr></table><br>
<a name="1073091"></a>

<a name="1073095"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Difference</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> This might be what he came up with : <a href="https://github.com/revarbat/TkCAD/blob/master/tksrc/lib/geometry.tcl" target="_blank">https://github.com/revarbat/TkCAD/blob/master/tksrc/lib/geometry.tcl</a> ?<br><br>It does seem to be his github: <a href="https://github.com/revarbat" target="_blank">https://github.com/revarbat</a><br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1073174"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Space_guy</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> If you use these polys you will see what the bug I mentioned.<br>I tried to find the bug my self but nothing i change seems to fix this.<br><br><br>Global poly1:Float[]=[ 200.0,200.0, 200.0,450.0, 400.0,450.0, 400.0,200.0 ]<br>Global poly2:Float[]=[ 250.0,100.0, 300.0,250.0, 500.0,100.0 ]<br><br>And that livejournal is very interesting. I just wish i could this code though as it works good enough for me. Exept that bug ofcourse :) <br><br></td></tr></table><br>
<a name="1073231"></a>

<a name="1073232"></a>

<a name="1073233"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Oddball</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm just making this stuff up as I'm going along so I doubt it's the best way of doing it. It's just the problem piqued my interest and I couldn't rest until I'd given it a go.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict

Graphics 800,600

Global poly1:Float[]=[ 200.0,200.0, 200.0,450.0, 400.0,450.0, 400.0,200.0 ]
Global poly2:Float[]=[ 250.0,100.0, 300.0,250.0, 500.0,100.0 ]

Global merged:Float[]

Cls
SetColor 0,255,0
DrawText "Polygon 1",0,0
DrawPoly poly1,False
Flip

WaitKey()

Cls
SetColor 0,255,0
DrawText "Polygon 1",0,0
DrawPoly poly1,False
SetColor 0,0,255
DrawText "Polygon 2",0,15
DrawPoly poly2,False
Flip

WaitKey()

merged=BoolPoly(poly1,poly2)

Cls
SetColor 0,255,0
DrawText "Polygon 1",0,0
DrawPoly poly1,False
SetColor 0,0,255
DrawText "Polygon 2",0,15
DrawPoly poly2,False
SetColor 255,0,0
DrawText "P1+P2 Polygon",0,30
DrawPoly merged,False
Flip

WaitKey()

merged=BoolPoly(poly1,poly2,True)

Cls
SetColor 0,255,0
DrawText "Polygon 1",0,0
DrawPoly poly1,False
SetColor 0,0,255
DrawText "Polygon 2",0,15
DrawPoly poly2,False
SetColor 255,0,0
DrawText "P1-P2 Polygon",0,30
DrawPoly merged,False
Flip

WaitKey()

Function BoolPoly:Float[]( p1:Float[], p2:Float[], sub:Int=False )
	If Not IsClockwise(p1) Then p1=ReversePoly(p1)
	If (sub And IsClockwise(p2)) Or (Not sub And Not IsClockwise(p2)) Then p2=ReversePoly(p2)
	Local m:Float[1024]
	
	Local start:Int=0
	While PointInPoly(p1[start],p1[start+1],p2) And start&lt;p1.length
		start:+2
	Wend
	If start&gt;=p1.length Then Return p2
	
	m[0]=p1[start];m[1]=p1[start+1]
	Local countm:Int=2
	Local count1:Int=start+2
	If count1&gt;=p1.length Then count1=0
	Local count2:Int=0
	Local flag:Int=0
	Repeat
		If flag=0
			
			Local mx:Float=p1[count1]
			Local my:Float=p1[count1+1]
			Local i:Int
			Local md:Float=(mx-m[countm-2])*(mx-m[countm-2])+(my-m[countm-1])*(my-m[countm-1])
			For Local count:Int=0 Until p2.length Step 2
				Local tmpx:Float
				Local tmpy:Float
				If LinesCross(tmpx,tmpy,m[countm-2],m[countm-1],mx,my, p2[(count2+count) Mod p2.length],p2[(count2+count+1) Mod p2.length],p2[(count2+count+2) Mod p2.length],p2[(count2+count+3) Mod p2.length] )
					Local d:Float=(tmpx-m[countm-2])*(tmpx-m[countm-2])+(tmpy-m[countm-1])*(tmpy-m[countm-1])
					If d&gt;.001 And d&lt;md
						mx=tmpx
						my=tmpy
						i=count
						md=d
						flag=1
					EndIf
				EndIf
			Next
			m[countm]=mx
			m[countm+1]=my
			countm:+2
			If flag=0
				count1:+2
				If count1&gt;=p1.length Then count1=0
			Else
				count2=(count2+i+2) Mod p2.length
			EndIf
		Else
			
			Local mx:Float=p2[count2]
			Local my:Float=p2[count2+1]
			Local i:Int
			Local md:Float=(mx-m[countm-2])*(mx-m[countm-2])+(my-m[countm-1])*(my-m[countm-1])
			For Local count:Int=0 Until p1.length Step 2
				Local tmpx:Float
				Local tmpy:Float
				If LinesCross(tmpx,tmpy,m[countm-2],m[countm-1],mx,my, p1[(count1+count) Mod p1.length],p1[(count1+count+1) Mod p1.length],p1[(count1+count+2) Mod p1.length],p1[(count1+count+3) Mod p1.length] )
					Local d:Float=(tmpx-m[countm-2])*(tmpx-m[countm-2])+(tmpy-m[countm-1])*(tmpy-m[countm-1])
					If d&gt;.001 And d&lt;md
						mx=tmpx
						my=tmpy
						i=count
						md=d
						flag=0
					EndIf
				EndIf
			Next
			m[countm]=mx
			m[countm+1]=my
			countm:+2
			If flag=1
				count2:+2
				If count2&gt;=p2.length Then count2=0
			Else
				count1=(count1+i+2) Mod p1.length
			EndIf
		EndIf
		
	Until count1=start+2
	
	Return m[..countm]
End Function

Function ReversePoly:Float[]( poly:Float[] )
	Local tmp:Float[poly.length]
	For Local count:Int=0 Until poly.length Step 2
		tmp[count]=poly[poly.length-count-2]
		tmp[count+1]=poly[poly.length-count-1]
	Next
	Return tmp
End Function

'Adapted from Wary's code
Function IsClockwise:Int( poly:Float[] )
	Local vex:Int=PointInPoly( (poly[0]+poly[2]+poly[4])*.333, (poly[1]+poly[3]+poly[5])*.333, poly )
	Local cp:Float = (poly[2]-poly[0])*(poly[5]-poly[1]) - (poly[4]-poly[0])*(poly[3]-poly[1])
	If (cp&gt;0 And vex) Or (cp&lt;=0 And Not vex)
		Return True
	EndIf
End Function

'Adapted from Fredborg's code
Function LinesCross:Int( rx:Float Var, ry:Float Var, x0:Float, y0:Float , x1:Float, y1:Float,..
						x2:Float ,y2:Float, x3:Float, y3:Float )
	  
	Local n:Float=(y0-y2)*(x3-x2)-(x0-x2)*(y3-y2)
	Local d:Float=(x1-x0)*(y3-y2)-(y1-y0)*(x3-x2)
	
	If Abs(d) &lt; 0.0001 
		' Lines are parallel!
		Return False
	Else
		' Lines might cross!
		Local Sn:Float=(y0-y2)*(x1-x0)-(x0-x2)*(y1-y0)

		Local AB:Float=n/d
		If AB&gt;0.0 And AB&lt;1.0
			Local CD:Float=Sn/d
			If CD&gt;0.0 And CD&lt;1.0
				' Intersection Point
				rx=x0+AB*(x1-x0)
		       	ry=y0+AB*(y1-y0)
				Return True
			End If
		End If
	
		' Lines didn't cross, because the intersection was beyond the end points of the lines
	EndIf

	' Lines do Not cross!
	Return False

End Function

Function PointInPoly:Int( point_x:Float, point_y:Float, xy:Float[] )
	
	If xy.length&lt;6 Or (xy.length&amp;1) Return False
	
	Local x1:Float=xy[xy.Length-2]
	Local y1:Float=xy[xy.Length-1]
	Local cur_quad:Int=GetQuad(point_x,point_y,x1,y1)
	Local next_quad:Int
	Local total:Int
	
	For Local i:Int=0 Until Len xy Step 2
		Local x2:Float=xy[i]
		Local y2:Float=xy[i+1]
		next_quad=GetQuad(point_x,point_y,x2,y2)
		Local diff:Int=next_quad-cur_quad
		
		Select diff
		Case 2,-2
			If ( x2 - ( ((y2 - point_y) * (x1 - x2)) / (y1 - y2) ) )&lt;point_x
				diff=-diff
			EndIf
		Case 3
			diff=-1
		Case -3
			diff=1
		End Select
		
		total:+diff
		cur_quad=next_quad
		x1=x2
		y1=y2
	Next
	
	If Abs(total)=4 Then Return True Else Return False
End Function

Function GetQuad:Int(axis_x:Float,axis_y:Float,vert_x:Float,vert_y:Float)
	If vert_x&lt;axis_x
		If vert_y&lt;axis_y
			Return 1
		Else
			Return 4
		EndIf
	Else
		If vert_y&lt;axis_y
			Return 2
		Else
			Return 3
		EndIf	
	EndIf

End Function

Function DrawPoly( xy:Float[], fill:Int=True, x:Float=0, y:Float=0 )
	Local origin_x:Float
	Local origin_y:Float
	GetOrigin origin_x,origin_y
	Local handle_x:Float
	Local handle_y:Float
	GetHandle handle_x,handle_y
	
	If fill
		_max2dDriver.DrawPoly xy,..
		-handle_x,-handle_y,..
		x+origin_x,y+origin_y
	Else
		Local x1:Float=xy[xy.Length-2]
		Local y1:Float=xy[xy.Length-1]
		For Local i:Int=0 Until Len xy Step 2
			Local x2:Float=xy[i]
			Local y2:Float=xy[i+1]
			_max2dDriver.DrawLine..
			-handle_x+x1,-handle_y+y1,..
			-handle_x+x2,-handle_y+y2,..
			x+origin_x-0.5,y+origin_y-0.5
			x1=x2
			y1=y2
		Next
	EndIf
End Function</textarea><br>The last line bug should be fixed now, but I'm sure the function is still far from totally bug free.<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1073270"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Space_guy</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks but when i move the polygon to the right of the box then it wont work again :(<br><br><br>Global poly1:Float[]=[ 200.0,200.0, 200.0,450.0, 400.0,450.0, 400.0,200.0 ]<br>Global poly2:Float[]=[ 450.0,240.0,  250.0,300.0, 450.0,380.0 ] <br><br></td></tr></table><br>
<a name="1073280"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Oddball</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yep, I kinda messed that fix up. Try this one on for size.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict

Graphics 800,600

Global poly1:Float[]=[ 200.0,200.0, 200.0,450.0, 400.0,450.0, 400.0,200.0 ]
Global poly2:Float[]=[ 450.0,240.0, 250.0,300.0, 450.0,380.0 ] 

'Global poly1:Float[]=[ 200.0,200.0, 200.0,450.0, 400.0,450.0, 400.0,200.0 ]
'Global poly2:Float[]=[ 250.0,100.0, 300.0,250.0, 500.0,100.0 ]

Global merged:Float[]

Cls
SetColor 0,255,0
DrawText "Polygon 1",0,0
DrawPoly poly1,False
Flip

WaitKey()

Cls
SetColor 0,255,0
DrawText "Polygon 1",0,0
DrawPoly poly1,False
SetColor 0,0,255
DrawText "Polygon 2",0,15
DrawPoly poly2,False
Flip

WaitKey()

merged=BoolPoly(poly1,poly2)

Cls
SetColor 0,255,0
DrawText "Polygon 1",0,0
DrawPoly poly1,False
SetColor 0,0,255
DrawText "Polygon 2",0,15
DrawPoly poly2,False
SetColor 255,0,0
DrawText "P1+P2 Polygon",0,30
DrawPoly merged,False
Flip

WaitKey()

merged=BoolPoly(poly1,poly2,True)

Cls
SetColor 0,255,0
DrawText "Polygon 1",0,0
DrawPoly poly1,False
SetColor 0,0,255
DrawText "Polygon 2",0,15
DrawPoly poly2,False
SetColor 255,0,0
DrawText "P1-P2 Polygon",0,30
DrawPoly merged,False
Flip

WaitKey()

Function BoolPoly:Float[]( p1:Float[], p2:Float[], sub:Int=False )
	If Not IsClockwise(p1) Then p1=ReversePoly(p1)
	If (sub And IsClockwise(p2)) Or (Not sub And Not IsClockwise(p2)) Then p2=ReversePoly(p2)
	Local m:Float[1024]
	
	Local start:Int=0
	While PointInPoly(p1[start],p1[start+1],p2) And start&lt;p1.length
		start:+2
	Wend
	If start&gt;=p1.length Then Return p2
	
	m[0]=p1[start];m[1]=p1[start+1]
	Local countm:Int=2
	Local count1:Int=start+2
	If count1&gt;=p1.length Then count1=0
	Local count2:Int=0
	Local flag:Int=0
	Repeat
		If flag=0
			
			Local mx:Float=p1[count1]
			Local my:Float=p1[count1+1]
			Local i:Int
			Local md:Float=(mx-m[countm-2])*(mx-m[countm-2])+(my-m[countm-1])*(my-m[countm-1])
			For Local count:Int=0 Until p2.length Step 2
				Local tmpx:Float
				Local tmpy:Float
				If LinesCross(tmpx,tmpy,m[countm-2],m[countm-1],mx,my, p2[(count2+count) Mod p2.length],p2[(count2+count+1) Mod p2.length],p2[(count2+count+2) Mod p2.length],p2[(count2+count+3) Mod p2.length] )
					Local d:Float=(tmpx-m[countm-2])*(tmpx-m[countm-2])+(tmpy-m[countm-1])*(tmpy-m[countm-1])
					If d&gt;.001 And d&lt;md
						mx=tmpx
						my=tmpy
						i=count
						md=d
						flag=1
					EndIf
				EndIf
			Next
			m[countm]=mx
			m[countm+1]=my
			countm:+2
			If flag=0
				count1:+2
				If count1&gt;=p1.length Then count1=0
				If count1=start+2 Then Exit
			Else
				count2=(count2+i+2) Mod p2.length
			EndIf
		Else
			
			Local mx:Float=p2[count2]
			Local my:Float=p2[count2+1]
			Local i:Int
			Local md:Float=(mx-m[countm-2])*(mx-m[countm-2])+(my-m[countm-1])*(my-m[countm-1])
			For Local count:Int=0 Until p1.length Step 2
				Local tmpx:Float
				Local tmpy:Float
				If LinesCross(tmpx,tmpy,m[countm-2],m[countm-1],mx,my, p1[(count1+count) Mod p1.length],p1[(count1+count+1) Mod p1.length],p1[(count1+count+2) Mod p1.length],p1[(count1+count+3) Mod p1.length] )
					Local d:Float=(tmpx-m[countm-2])*(tmpx-m[countm-2])+(tmpy-m[countm-1])*(tmpy-m[countm-1])
					If d&gt;.001 And d&lt;md
						mx=tmpx
						my=tmpy
						i=count
						md=d
						flag=0
					EndIf
				EndIf
			Next
			m[countm]=mx
			m[countm+1]=my
			countm:+2
			If flag=1
				count2:+2
				If count2&gt;=p2.length Then count2=0
			Else
				count1=(count1+i+2) Mod p1.length
			EndIf
		EndIf
	Forever	
	
	Return m[..countm]
End Function

Function ReversePoly:Float[]( poly:Float[] )
	Local tmp:Float[poly.length]
	For Local count:Int=0 Until poly.length Step 2
		tmp[count]=poly[poly.length-count-2]
		tmp[count+1]=poly[poly.length-count-1]
	Next
	Return tmp
End Function

'Adapted from Wary's code
Function IsClockwise:Int( poly:Float[] )
	Local vex:Int=PointInPoly( (poly[0]+poly[2]+poly[4])*.333, (poly[1]+poly[3]+poly[5])*.333, poly )
	Local cp:Float = (poly[2]-poly[0])*(poly[5]-poly[1]) - (poly[4]-poly[0])*(poly[3]-poly[1])
	If (cp&gt;0 And vex) Or (cp&lt;=0 And Not vex)
		Return True
	EndIf
End Function

'Adapted from Fredborg's code
Function LinesCross:Int( rx:Float Var, ry:Float Var, x0:Float, y0:Float , x1:Float, y1:Float,..
						x2:Float ,y2:Float, x3:Float, y3:Float )
	  
	Local n:Float=(y0-y2)*(x3-x2)-(x0-x2)*(y3-y2)
	Local d:Float=(x1-x0)*(y3-y2)-(y1-y0)*(x3-x2)
	
	If Abs(d) &lt; 0.0001 
		' Lines are parallel!
		Return False
	Else
		' Lines might cross!
		Local Sn:Float=(y0-y2)*(x1-x0)-(x0-x2)*(y1-y0)

		Local AB:Float=n/d
		If AB&gt;0.0 And AB&lt;1.0
			Local CD:Float=Sn/d
			If CD&gt;0.0 And CD&lt;1.0
				' Intersection Point
				rx=x0+AB*(x1-x0)
		       	ry=y0+AB*(y1-y0)
				Return True
			End If
		End If
	
		' Lines didn't cross, because the intersection was beyond the end points of the lines
	EndIf

	' Lines do Not cross!
	Return False

End Function

Function PointInPoly:Int( point_x:Float, point_y:Float, xy:Float[] )
	
	If xy.length&lt;6 Or (xy.length&amp;1) Return False
	
	Local x1:Float=xy[xy.Length-2]
	Local y1:Float=xy[xy.Length-1]
	Local cur_quad:Int=GetQuad(point_x,point_y,x1,y1)
	Local next_quad:Int
	Local total:Int
	
	For Local i:Int=0 Until Len xy Step 2
		Local x2:Float=xy[i]
		Local y2:Float=xy[i+1]
		next_quad=GetQuad(point_x,point_y,x2,y2)
		Local diff:Int=next_quad-cur_quad
		
		Select diff
		Case 2,-2
			If ( x2 - ( ((y2 - point_y) * (x1 - x2)) / (y1 - y2) ) )&lt;point_x
				diff=-diff
			EndIf
		Case 3
			diff=-1
		Case -3
			diff=1
		End Select
		
		total:+diff
		cur_quad=next_quad
		x1=x2
		y1=y2
	Next
	
	If Abs(total)=4 Then Return True Else Return False
End Function

Function GetQuad:Int(axis_x:Float,axis_y:Float,vert_x:Float,vert_y:Float)
	If vert_x&lt;axis_x
		If vert_y&lt;axis_y
			Return 1
		Else
			Return 4
		EndIf
	Else
		If vert_y&lt;axis_y
			Return 2
		Else
			Return 3
		EndIf	
	EndIf

End Function

Function DrawPoly( xy:Float[], fill:Int=True, x:Float=0, y:Float=0 )
	Local origin_x:Float
	Local origin_y:Float
	GetOrigin origin_x,origin_y
	Local handle_x:Float
	Local handle_y:Float
	GetHandle handle_x,handle_y
	
	If fill
		_max2dDriver.DrawPoly xy,..
		-handle_x,-handle_y,..
		x+origin_x,y+origin_y
	Else
		Local x1:Float=xy[xy.Length-2]
		Local y1:Float=xy[xy.Length-1]
		For Local i:Int=0 Until Len xy Step 2
			Local x2:Float=xy[i]
			Local y2:Float=xy[i+1]
			_max2dDriver.DrawLine..
			-handle_x+x1,-handle_y+y1,..
			-handle_x+x2,-handle_y+y2,..
			x+origin_x-0.5,y+origin_y-0.5
			x1=x2
			y1=y2
		Next
	EndIf
End Function</textarea><br>Hopefully that should fix the issue without creating ay new ones... I hope. <br><br></td></tr></table><br>
<a name="1073281"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GW</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> Awesome! <br><br></td></tr></table><br>
<a name="1073282"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Space_guy</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> Seems to work perfectly :)<br><br>Thank you very much! <br><br></td></tr></table><br>
<a name="1074915"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Space_guy</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks again for the code! Its really usefull!<br><br>However I noticed one more bug that I tried to fix but was not yet able to.<br>There seems to be a way for it to get stuck in a loop that ends with a crash.<br><br>What happens is atleast that countm counter keeps going up and up but it will never exit. This seems to be rare. But too frequent for me to ignore. <br><br></td></tr></table><br>
<a name="1087754"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GW</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> This seems help illustrate the bug.<br><br><pre class=code>
Global poly1:Float[]=[ 200.0,200.0, 200.0,450.0, 400.0,450.0, 400.0,200.0 ]
Global poly2:Float[]=[ 250.0-110,100.0, 300.0-110,250.0, 500.0-110,100.0 ]
</pre> <br><br></td></tr></table><br>
<a name="1087788"></a>

<a name="1087789"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Oddball</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> Those polys add and subtract flawlessly for me.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict

Graphics 800,600

Global poly1:Float[]=[ 200.0,200.0, 200.0,450.0, 400.0,450.0, 400.0,200.0 ]
Global poly2:Float[]=[ 250.0-110,100.0, 300.0-110,250.0, 500.0-110,100.0 ]

Global merged:Float[]

Cls
SetColor 0,255,0
DrawText "Polygon 1",0,0
DrawPoly poly1,False
Flip

WaitKey()

Cls
SetColor 0,255,0
DrawText "Polygon 1",0,0
DrawPoly poly1,False
SetColor 0,0,255
DrawText "Polygon 2",0,15
DrawPoly poly2,False
Flip

WaitKey()

merged=BoolPoly(poly1,poly2)

Cls
SetColor 0,255,0
DrawText "Polygon 1",0,0
DrawPoly poly1,False
SetColor 0,0,255
DrawText "Polygon 2",0,15
DrawPoly poly2,False
SetColor 255,0,0
DrawText "P1+P2 Polygon",0,30
DrawPoly merged,False
Flip

WaitKey()

merged=BoolPoly(poly1,poly2,True)

Cls
SetColor 0,255,0
DrawText "Polygon 1",0,0
DrawPoly poly1,False
SetColor 0,0,255
DrawText "Polygon 2",0,15
DrawPoly poly2,False
SetColor 255,0,0
DrawText "P1-P2 Polygon",0,30
DrawPoly merged,False
Flip

WaitKey()

Function BoolPoly:Float[]( p1:Float[], p2:Float[], sub:Int=False )
	If Not IsClockwise(p1) Then p1=ReversePoly(p1)
	If (sub And IsClockwise(p2)) Or (Not sub And Not IsClockwise(p2)) Then p2=ReversePoly(p2)
	Local m:Float[1024]
	
	Local start:Int=0
	While PointInPoly(p1[start],p1[start+1],p2) And start&lt;p1.length
		start:+2
	Wend
	If start&gt;=p1.length Then Return p2
	
	m[0]=p1[start];m[1]=p1[start+1]
	Local countm:Int=2
	Local count1:Int=start+2
	If count1&gt;=p1.length Then count1=0
	Local count2:Int=0
	Local flag:Int=0
	Repeat
		If flag=0
			
			Local mx:Float=p1[count1]
			Local my:Float=p1[count1+1]
			Local i:Int
			Local md:Float=(mx-m[countm-2])*(mx-m[countm-2])+(my-m[countm-1])*(my-m[countm-1])
			For Local count:Int=0 Until p2.length Step 2
				Local tmpx:Float
				Local tmpy:Float
				If LinesCross(tmpx,tmpy,m[countm-2],m[countm-1],mx,my, p2[(count2+count) Mod p2.length],p2[(count2+count+1) Mod p2.length],p2[(count2+count+2) Mod p2.length],p2[(count2+count+3) Mod p2.length] )
					Local d:Float=(tmpx-m[countm-2])*(tmpx-m[countm-2])+(tmpy-m[countm-1])*(tmpy-m[countm-1])
					If d&gt;.001 And d&lt;md
						mx=tmpx
						my=tmpy
						i=count
						md=d
						flag=1
					EndIf
				EndIf
			Next
			m[countm]=mx
			m[countm+1]=my
			countm:+2
			If flag=0
				count1:+2
				If count1&gt;=p1.length Then count1=0
				If count1=start+2 Then Exit
			Else
				count2=(count2+i+2) Mod p2.length
			EndIf
		Else
			
			Local mx:Float=p2[count2]
			Local my:Float=p2[count2+1]
			Local i:Int
			Local md:Float=(mx-m[countm-2])*(mx-m[countm-2])+(my-m[countm-1])*(my-m[countm-1])
			For Local count:Int=0 Until p1.length Step 2
				Local tmpx:Float
				Local tmpy:Float
				If LinesCross(tmpx,tmpy,m[countm-2],m[countm-1],mx,my, p1[(count1+count) Mod p1.length],p1[(count1+count+1) Mod p1.length],p1[(count1+count+2) Mod p1.length],p1[(count1+count+3) Mod p1.length] )
					Local d:Float=(tmpx-m[countm-2])*(tmpx-m[countm-2])+(tmpy-m[countm-1])*(tmpy-m[countm-1])
					If d&gt;.001 And d&lt;md
						mx=tmpx
						my=tmpy
						i=count
						md=d
						flag=0
					EndIf
				EndIf
			Next
			m[countm]=mx
			m[countm+1]=my
			countm:+2
			If flag=1
				count2:+2
				If count2&gt;=p2.length Then count2=0
			Else
				count1=(count1+i+2) Mod p1.length
			EndIf
		EndIf
	Forever	
	
	Return m[..countm]
End Function

Function ReversePoly:Float[]( poly:Float[] )
	Local tmp:Float[poly.length]
	For Local count:Int=0 Until poly.length Step 2
		tmp[count]=poly[poly.length-count-2]
		tmp[count+1]=poly[poly.length-count-1]
	Next
	Return tmp
End Function

'Adapted from Wary's code
Function IsClockwise:Int( poly:Float[] )
	Local vex:Int=PointInPoly( (poly[0]+poly[2]+poly[4])*.333, (poly[1]+poly[3]+poly[5])*.333, poly )
	Local cp:Float = (poly[2]-poly[0])*(poly[5]-poly[1]) - (poly[4]-poly[0])*(poly[3]-poly[1])
	If (cp&gt;0 And vex) Or (cp&lt;=0 And Not vex)
		Return True
	EndIf
End Function

'Adapted from Fredborg's code
Function LinesCross:Int( rx:Float Var, ry:Float Var, x0:Float, y0:Float , x1:Float, y1:Float,..
						x2:Float ,y2:Float, x3:Float, y3:Float )
	  
	Local n:Float=(y0-y2)*(x3-x2)-(x0-x2)*(y3-y2)
	Local d:Float=(x1-x0)*(y3-y2)-(y1-y0)*(x3-x2)
	
	If Abs(d) &lt; 0.0001 
		' Lines are parallel!
		Return False
	Else
		' Lines might cross!
		Local Sn:Float=(y0-y2)*(x1-x0)-(x0-x2)*(y1-y0)

		Local AB:Float=n/d
		If AB&gt;0.0 And AB&lt;1.0
			Local CD:Float=Sn/d
			If CD&gt;0.0 And CD&lt;1.0
				' Intersection Point
				rx=x0+AB*(x1-x0)
		       	ry=y0+AB*(y1-y0)
				Return True
			End If
		End If
	
		' Lines didn't cross, because the intersection was beyond the end points of the lines
	EndIf

	' Lines do Not cross!
	Return False

End Function

Function PointInPoly:Int( point_x:Float, point_y:Float, xy:Float[] )
	
	If xy.length&lt;6 Or (xy.length&amp;1) Return False
	
	Local x1:Float=xy[xy.Length-2]
	Local y1:Float=xy[xy.Length-1]
	Local cur_quad:Int=GetQuad(point_x,point_y,x1,y1)
	Local next_quad:Int
	Local total:Int
	
	For Local i:Int=0 Until Len xy Step 2
		Local x2:Float=xy[i]
		Local y2:Float=xy[i+1]
		next_quad=GetQuad(point_x,point_y,x2,y2)
		Local diff:Int=next_quad-cur_quad
		
		Select diff
		Case 2,-2
			If ( x2 - ( ((y2 - point_y) * (x1 - x2)) / (y1 - y2) ) )&lt;point_x
				diff=-diff
			EndIf
		Case 3
			diff=-1
		Case -3
			diff=1
		End Select
		
		total:+diff
		cur_quad=next_quad
		x1=x2
		y1=y2
	Next
	
	If Abs(total)=4 Then Return True Else Return False
End Function

Function GetQuad:Int(axis_x:Float,axis_y:Float,vert_x:Float,vert_y:Float)
	If vert_x&lt;axis_x
		If vert_y&lt;axis_y
			Return 1
		Else
			Return 4
		EndIf
	Else
		If vert_y&lt;axis_y
			Return 2
		Else
			Return 3
		EndIf	
	EndIf

End Function

Function DrawPoly( xy:Float[], fill:Int=True, x:Float=0, y:Float=0 )
	Local origin_x:Float
	Local origin_y:Float
	GetOrigin origin_x,origin_y
	Local handle_x:Float
	Local handle_y:Float
	GetHandle handle_x,handle_y
	
	If fill
		_max2dDriver.DrawPoly xy,..
		-handle_x,-handle_y,..
		x+origin_x,y+origin_y
	Else
		Local x1:Float=xy[xy.Length-2]
		Local y1:Float=xy[xy.Length-1]
		For Local i:Int=0 Until Len xy Step 2
			Local x2:Float=xy[i]
			Local y2:Float=xy[i+1]
			_max2dDriver.DrawLine..
			-handle_x+x1,-handle_y+y1,..
			-handle_x+x2,-handle_y+y2,..
			x+origin_x-0.5,y+origin_y-0.5
			x1=x2
			y1=y2
		Next
	EndIf
End Function</textarea><br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
