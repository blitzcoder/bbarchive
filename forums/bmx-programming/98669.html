<!DOCTYPE html><html lang="en" ><head ><title >Raycasting engine assistance?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Raycasting engine assistance?</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Raycasting engine assistance?</a><br><br>
<a name="1154576"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >codermax</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, so I decided to start on a raycasting engine, as I love the early FPS games of the 90s and wanted to make my own. Once I did that, I'd be able to port the engine to C# using XNA as this particular type of fake 3D rendering is more beneficial than true 3D to me at the moment. Sadly, it's always the complex math that stops me in my tracks.<br><br>The specific cork in my plans for world domination, is the fact that I wanna make the engine RIGHT. In this case I'm following the "tutorial" on this page:<br><a href="http://www.permadi.com/tutorial/raycast/index.html" target="_blank">http://www.permadi.com/tutorial/raycast/index.html</a><br><br>I'm stuck on the wall finding part. I would make a workaround, but...<br>-I wanna make the engine according to the tutorial, to follow along and do all the cool stuff in it. That's what I wanna accomplish, that's the goal. :)<br>-Coding a workaround might stop me from doing that. I might find a way to track walls and might even get to texture maps, but maybe not drawing ceilings etc. That's wasted time I could've used to just follow along and code an engine proper.<br><br>So I go with it and try to follow the "tutorial". However it's not one with a decent codebase, so I can't just copy it/improvise and port to BlitzMax. Which would be the best thing ever. :D<br><br>The problem that keeps me up after I try finding walls is that when I go to draw walls, my math equations don't equal a wall, it's more like... this... ghost thing! And since there's nothing resembling a source, I can't just use it as a reference and keep trying to get it right, I'd waste days doing so.<br><br>There are other sources out there that do raycasting, but they don't follow this tutorial, and worse so they don't have any comments about their code, it's usually just huge walls of text with not even so much as a sign where the main loop starts! To top it off, they're in different languages(asm!?) and if you don't know them, you're better off reading Chinese. XD I'm not one who likes to use stuff and not know what the heck it is. That's why I don't use premade sources if they're not well commented. I wanna understand what I'm coding, so it'd be easier to use/expand and port.<br><br>So, I'd appreciate it if someone who is knowledgable about this and able to at least give a dog a bone, well...give a dog a bone! :D I just need a hand in fully deciphering what's going on, I should be able to take it from there. <br><br></td></tr></table><br>
<a name="1154622"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >matibee</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> That tutorial looks really good.  I don't want to sound harsh but if you really want to learn sit down with a pen, graph paper and a calculator.  Run through some example inputs and calculate the outputs.  When you're happy with the procedure test your code with the same inputs.  Otherwise you won't know if your code or methodology is flawed.  It's a great way to cement your knowledge.<br><br>I've been doing exactly this for a number of weeks for all kinds of 3d math problems.. cone vs triangle intersection, cylinder vs triangle, sphere vs triangle etc etc (including all the relevant edge, surface and vertex tests), things are becoming more and more clear as I go on and I have great confidence in my resultant (and thoroughly tested) code.  Time spent this way is a great investment for the future.<br><br>Anyway, if you want a bone, read through this :) ...<br><a href="http://www.blitzbasic.com/Community/posts.php?topic=89478" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=89478</a> <br><br></td></tr></table><br>
<a name="1154649"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> yep, when things get complex (number wise), it is always better to sit down with some paper and do the math there, then check if the routine gives you what you expected.<br><br>If it isn't what you expect, then either the math is wrong (very likely as converting paper math to computer math always has a bug or two) or the data is wrong (garbage in = garbage out)?<br><br>I could get my head around 3d vertexes, but not how models fitted together, so I ended up writing a 3d editor so I could check everything at the vertex level. It turned out that an x should have been a z and everything suddenly worked... <br><br></td></tr></table><br>
<a name="1154830"></a>

<a name="1154831"></a>

<a name="1155432"></a>

<a name="1155435"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >codermax</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> YAY! I managed to draw the 3D world somewhat correctly now. However, I still need to correct the fish-eye distortion. I have NO IDEA what the author is talking about on figure 17 on the Finding Distance to Walls page, where they describe a couple of equations. The problem is, I have no idea how to apply them in the code! Apparently I need them to fix the fish-eye, as my simple length variable for rays won't cut it.<br><br><b>EDIT:</b><br>Awesome! Texture mapped walls with some strafing and ADS for good measure. However, I just can't seem to wrap my head around drawing textured floors/ceilings! I tried to bring over code from various tutorials, but they don't seem to work in my engine and one piece of code I used was WAY too slow. I can complete every part of the raycasting tutorial on the permadi website, EXCEPT drawing floors and ceilings! If somebody can help me out I'd greatly appreciate it! :D<br><br>Here's my source so far:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

Extern "win32"
    Function GetSystemMetrics:Int(Axis:Int)
	Function GetActiveWindow%()
	Function IsZoomed%(hwnd%)
	Function SetWindowPos%(hWnd%, after%, x%, y%, w%, h%, flags%)
End Extern

Global desktopX:Int=GetSystemMetrics(0)
Global desktopY:Int=GetSystemMetrics(1)

Graphics desktopY-desktopY/10, desktopY-desktopY/4,0
Global hWnd% = GetActiveWindow() ' Save current Window handle

' Init Buttons
enableMinimize( hwnd% )
enableMaximize( hwnd% )
'Set the game's original "native" resolution.
SetVirtualResolution 640,480
'320,240
'220,180

'Set the area the game will be drawn to.
'SetViewport 0,0,320,240

'SetWindowPos(hWnd, 0, desktopX/6, desktopY/8, GraphicsWidth(), GraphicsHeight(), 0)
'INITIALIZE VARIABLES
Global game_run:Int=0
Global wanna_exit:Int=0
Global max_gridX:Int=8
Global max_gridY:Int=6
Global grid_size:Int=64
Global wall_height:Int=11
Global p_fov:Float=60
Global adjust_mouse:Int=0
Global zoom_mode:Int=0
Global ads_zoom:Float=0
Global goal_ads:Float=1

Global p_width:Int=grid_size/5
Global p_view_angle:Float=360
Global p_vertical_angle:Float=0
Global max_vertical_angle:Int=135
Global p_view_height:Float=32
Global goal_p_view_height:Float=p_view_height
Global plr_pos:Float[3]
Global real_plr_pos:Float[3]
'cam zoom index:0=x,=y,2=length
Global cam_zoom:Float[3]

Global plr_speed:Int=1
Global plr_turn_speed:Int=7
Global closest_wall:Float=26
Global p_dist:Int=0
Global button_delay:Int=0
Global fov_edit:Int=0
Global goal_fov:Float=p_fov
Global goal_p_view_angle:Float=p_view_angle

Global zoom_speed:Int=18

Global debug_value:Double[999]
Global OldMouseX:Int=0
Global OldMouseY:Int=0
Global current_peak:Int=0

Global intersectX:Int[99]
Global intersectY:Int[99]

Global textureW:Int=64
Global textureH:Int=64
Global plr_box:Float[5]
Global projection_plane:Float[3]
projection_plane[0]=320 projection_plane[1]=200
'VirtualResolutionWidth()  projection_plane[1]=
'VirtualResolutionHeight()
plr_pos[0]=96 plr_pos[1]=96
real_plr_pos[0]=96 real_plr_pos[1]=96
'ray stats 1st dimension index: 0=x,1=y,2=dist from wall
'3=direction, 4=wall or nothing,5=dir x,6=dir y,7=image rect posX,
'8=image rect posY,9=shadow
Global ray_stats:Double[14,projection_plane[0]]
Global ray_height:Double[14,projection_plane[0]]
'floor ray stats 1st dimension index: 0=x,1=y,2=lengthX,3=lengthY,4=row
Global floor_ray_stats:Float[14,projection_plane[1]+max_vertical_angle]
Global floor_ray_center:Float[14]
Global celing_ray_stats:Float[14,projection_plane[1]+max_vertical_angle]

Global strafe_ray_stats:Float[9,3]

Global level_grid:Int[max_gridX,max_gridY]
Global level_grid_bmp:Int[4,max_gridX,max_gridY]
Global level_grid2:Int[grid_size*max_gridX,grid_size*max_gridY]
For Local b:Int=0 Until max_gridX Step+1
level_grid[b,0]=1 level_grid[b,max_gridY-1]=1
Next
For Local b:Int=0 Until max_gridY Step+1
level_grid[0,b]=1 level_grid[max_gridX-1,b]=1
Next

level_grid[3,3]=1 level_grid[5,3]=1

For Local b:Int=0 Until max_gridX Step+1
For Local d:Int=0 Until max_gridY Step+1

For Local g:Int=0 Until grid_size Step+1
For Local z:Int=0 Until grid_size Step+1
level_grid2[b*grid_size+g,d*grid_size+z]=level_grid[b,d]
Next
Next

Next
Next

For Local b:Int=0 Until max_gridX Step+1
For Local d:Int=0 Until max_gridY Step+1
intersectX[b]=(b*grid_size)
intersectY[d]=(d*grid_size)
Next
Next

OldMouseX=VirtualMouseX()
OldMouseY=VirtualMouseY()
adjust_mouse=1

Global main_pic_dir:String=AppDir$
Global level_tile:TImage
SetMaskColor 255,0,255
level_tile=LoadImage(main_pic_dir+"/tile01.bmp",MASKEDIMAGE|FILTEREDIMAGE)
Global level_floor:TPixmap=LoadPixmap(main_pic_dir+"/tile01.bmp")

Global floortexture:Int[textureW,textureH]
For Local x:Int = 0 Until textureW Step+1
	For Local y:Int = 0 Until textureH Step+1
			floortexture[x,y] = ReadPixel(level_floor,x, y)
		Next
	Next	
	
'MAIN LOOP
While game_run=0

If adjust_mouse=1
adjust_mouse=0
OldMouseX=VirtualMouseX()
OldMouseY=VirtualMouseY()
EndIf

If button_delay&gt;0
button_delay:-1
EndIf

If zoom_mode=1
If ray_stats[2,(projection_plane[0]/2)-1]&gt;closest_wall
goal_ads:+0.5
If goal_ads&gt;50
goal_ads=50
ads_zoom=50
EndIf
EndIf
If ray_stats[2,(projection_plane[0]/2)-1]&lt;closest_wall
goal_ads:-0.5
EndIf
EndIf
For Local zoom:Int=0 Until zoom_speed Step+1
If zoom_mode=0
plr_pos[0]=real_plr_pos[0]
plr_pos[1]=real_plr_pos[1]
ads_zoom=0
goal_ads=0
EndIf
If zoom_mode=1
If ads_zoom&gt;goal_ads
ads_zoom:-0.5
EndIf
If  ads_zoom&lt;goal_ads
ads_zoom:+0.5
EndIf
Local x_dis:Float=lengthdir_x(ads_zoom,p_view_angle)
Local y_dis:Float=lengthdir_y(ads_zoom,p_view_angle)
plr_pos[0]=real_plr_pos[0]+x_dis
plr_pos[1]=real_plr_pos[1]+y_dis
EndIf

If p_view_height&lt;goal_p_view_height
p_view_height:+0.1
If p_view_height&gt;goal_p_view_height
 p_view_height=goal_p_view_height
EndIf
EndIf
If p_view_height&gt;goal_p_view_height
p_view_height:-0.1
If p_view_height&lt;goal_p_view_height
 p_view_height=goal_p_view_height
EndIf
EndIf

Next

If AppTerminate() Or KeyDown(KEY_ESCAPE)
game_run=-1
	EndIf
If wanna_exit=1
Local result:Int=Confirm("Do you really wanna close this program?")
	If result=True
	wanna_exit=0
	game_run=-1
	EndIf
	If result=False
	wanna_exit=0
	EndIf
		wanna_exit=0
  EndIf
    
    If AppSuspended() Then
     EndIf 

	If iszoomed(hWnd) Then
	 SetVirtualResolution projection_plane[0],projection_plane[1]
	SetViewport 0,0,projection_plane[0],projection_plane[1]
	EndIf

    GCCollect() 'Garbage Collect, just to be safe
process_input()
SetClsColor 255,255,255
Cls
Local total_fov:Float=p_view_angle-(p_fov/2)
Local angle_div:Float=p_fov/projection_plane[0] 
Local strafe_angleL:Int=p_view_angle-90
Local strafe_angleR:Int=p_view_angle+90

If strafe_angleL&lt;0
strafe_angleL:+360
EndIf
If strafe_angleR&gt;360
strafe_angleR:-360
EndIf

Local x_strafeL:Int=lengthdir_x(2, strafe_angleL)
Local y_strafeL:Int=lengthdir_y(2, strafe_angleL)
Local x_strafeR:Int=lengthdir_x(2, strafe_angleR)
Local y_strafeR:Int=lengthdir_y(2, strafe_angleR)

Local mapX:Int=plr_pos[0]/grid_size

SetClsColor 0,0,0
Cls
'draw_grid()
cast_rays()
calculate_pov()
SetColor 255,255,255
SetScale 2,2
Local g:Int=0
Rem
For Local b:Int=projection_plane[0]/2-10 Until projection_plane[0]/2+10 Step+1
DrawText "DEBUG:"+debug_value[b],4,56+(15*g)
g:+1
Next
End Rem
DrawText Int(ray_stats[2,(projection_plane[0]/2)-1])+","+closest_wall/1.5,4,40
SetColor 255,255,255
DrawRect projection_plane[0]/2-6,projection_plane[1]/2+1.8,6,1
DrawRect projection_plane[0]/2-3.2,projection_plane[1]/2-1,1,6
SetScale 1,1
Flip

Wend

Function enableMaximize(hWnd:Long)
' Adds the Maximize Button "[]"
	Local tmp:Int = GetWindowLongA( hWnd, GWL_STYLE )
	tmp = tmp | WS_MAXIMIZEBOX
	SetWindowLongA( hWnd, GWL_STYLE, tmp )
	DrawMenuBar( hWnd )
End Function

Function enableMinimize(hWnd:Long)
' Adds the Minimize Button "_"
	Local tmp:Long = GetWindowLongA( hWnd, GWL_STYLE )
	tmp = tmp | WS_MINIMIZEBOX
	SetWindowLongA( hWnd, GWL_STYLE, tmp )
	DrawMenuBar( hWnd )
End Function

Function draw_grid:Int()
plr_box[0]=Int(plr_pos[0]/grid_size)
plr_box[1]=Int(plr_pos[1]/grid_size)

For Local g:Int=0 Until max_gridX Step +1
For Local k:Int=0 Until max_gridY Step +1
SetColor 30,30,30
If level_grid[g,k]=1
SetColor 200,120,0
EndIf
If level_grid[g,k]=2
SetColor 0,190,0
EndIf
DrawRect g*grid_size,k*grid_size,grid_size-1,grid_size-1
Next
Next

Rem
For Local g:Int=0 Until max_gridX*grid_size Step +1
For Local k:Int=0 Until max_gridY*grid_size Step +1
SetColor 255,255,255

If level_grid2[g,k]=1
Plot g,k
EndIf
Next
Next
End Rem

SetColor 0,160,60
'draw player.
DrawRect plr_pos[0],plr_pos[1],p_width,p_width
'draw rays.
SetColor 255,255,255

For Local g:Int=0 Until projection_plane[0] Step +1
DrawLine plr_pos[0],plr_pos[1],ray_stats[0,g],ray_stats[1,g]
SetColor 0,0,255
DrawRect ray_stats[5,g],ray_stats[6,g],2,2
SetColor 255,255,255
Next
SetColor 0,255,0
DrawRect floor_ray_center[0],floor_ray_center[1],3,3

SetColor 0,255,50
For Local g:Int=0 Until projection_plane[1] Step +1
DrawLine floor_ray_stats[0,g],floor_ray_stats[1,g],floor_ray_stats[2,g],floor_ray_stats[3,g]
Next

SetColor 255,255,255
'p_view_angle=get_angle(plr_pos[0],plr_pos[1],VirtualMouseX(),VirtualMouseY())
plr_box[0]=plr_pos[0]/grid_size plr_box[1]=plr_pos[1]/grid_size
Local plr_spotY:Int=plr_pos[1]+p_width
Local r_lenX:Int=(plr_box[0]*grid_size)-plr_pos[0]
Local r_lenY:Int=(plr_box[1]*grid_size)-plr_pos[1]
Local shrink:Int=8

DrawLine(plr_pos[0],plr_pos[1],VirtualMouseX(),VirtualMouseY())
End Function

Function cast_rays:Int()
Rem
    Dimension of the Projection Plane = 320 x 200 units
    Center of the Projection Plane = (160,100)
    Distance to the Projection Plane =
center of proj plane(160)/Tan(field of view(60)/2)=277 units 
    Angle between subsequent rays =
 field of view(60)/Projection Plane X degrees 
End Rem
'1. Based on the viewing angle, subtract 30 degrees (half of the FOV).
Local total_fov:Float=p_view_angle-(p_fov/2)
Local angle_div:Float=p_fov/projection_plane[0] 
'debug_value=total_fov
'If total_fov&lt;0
'total_fov:+30 EndIf
''2. Starting from column 0:
Local ray_len:Int=0
Local wall_found:Int=0
Local steps:Int=10

		Local cameraX:Double
		Local rayPosX:Double
		Local rayPosY:Double
		Local rayDirX:Double
		Local rayDirY:Double
		Local drawMapX:Double
		Local drawMapY:Double
		Local perpWallDist:Double
		
			' which box of the map we're in  
			Local mapX:Int
			Local mapY:Int			
			' length of ray from current position To Next x Or y-side
			Local sideDistX:Double
			Local sideDistY:Double
			Local deltaDistX:Double
			Local deltaDistY:Double			
			
			Local stepX:Int
			Local stepY:Int

			Local hit:Int
			Local side:Int 
			Local wallX:Double 
			
			Rem
	For Local v:Int=(projection_plane[1]/2)-15 Until projection_plane[1] Step+1
			' calculate ray position And direction 
			cameraX=total_fov+(angle_div*v)
			rayPosX = plr_pos[0]
			rayPosY = plr_pos[1]
			rayDirX = lengthdir_x(1,cameraX)
			rayDirY =  lengthdir_y(1,cameraX)
			Next
			End Rem
			current_peak=0
For Local v:Int=0 Until projection_plane[0] Step+1
			' calculate ray position And direction 
			cameraX=total_fov+(angle_div*v)
			rayPosX =plr_pos[0]
			rayPosY =plr_pos[1]
			rayDirX = lengthdir_x(1,cameraX)
			rayDirY =  lengthdir_y(1,cameraX)

			' which box of the map we're in  
			mapX = rayPosX
			mapY = rayPosY
			
			' length of ray from current position To Next x Or y-side

			' length of ray from one x Or y-side To Next x Or y-side
		deltaDistX = Sqr(1 + (rayDirY * rayDirY) / (rayDirX * rayDirX))
		deltaDistY = Sqr(1 + (rayDirX * rayDirX) / (rayDirY * rayDirY))
		
	' what direction To Step in x Or y-direction (either +1 Or -1)

			hit= 0 ' was there a wall hit?
			'Local side:Int ' was a NS Or a EW wall hit?

		' calculate Step And initial sideDist
			If rayDirX &lt; 0 Then
				stepX = -1
				sideDistX = (rayPosX - mapX) * deltaDistX
			Else
				stepX = 1
				sideDistX = (mapX + 1.0 - rayPosX) * deltaDistX
			End If

			If rayDirY &lt; 0 Then
				stepY = -1
				sideDistY = (rayPosY - mapY) * deltaDistY
			Else
				stepY = 1
				sideDistY = (mapY + 1.0 - rayPosY) * deltaDistY
			End If

			' perform DDA
			While hit = 0

				' jump To Next map square, Or in x-direction, Or in y-direction
				If sideDistX &lt; sideDistY Then
					sideDistX :+ deltaDistX
					mapX :+ stepX
					side = 0
				Else
					sideDistY :+ deltaDistY
					mapY :+ stepY
					side = 1
				End If

				' Check If ray has hit a wall
				If level_grid2[mapX,mapY] &gt; 0 Then
					hit = 1
					'ray_stats[7,v]=
					 'game_run=-1
				End If
			Wend

	' calculate value of wallX
		 ' where exactly the wall was hit
			If side = 1 Then
				wallX = rayPosX + ((mapY - rayPosY + (1.0 - stepY) / 2.0) / rayDirY) * rayDirX
			ray_stats[7,v]=wallX Mod grid_size
						ray_stats[8,v]=1
			Else
				wallX = rayPosY + ((mapX - rayPosX + (1.0 - stepX) / 2.0) / rayDirX) * rayDirY
			ray_stats[7,v]=wallX Mod grid_size
						ray_stats[8,v]=0
				End If

			wallX :- Floor((wallX))

			drawMapX = mapX
			drawMapY = mapY

			If side = 1 Then
				If plr_pos[1] &gt; drawMapY Then
					drawMapY :+ 1
				End If
				drawMapX = drawMapX + wallX
			Else
				If plr_pos[0]  &gt; drawMapX Then
					drawMapX :+ 1
				End If
				drawMapY = drawMapY + wallX
			End If
			
'Calculate distance projected on camera direction (oblique distance will give fisheye effect!)
			If side = 0
				perpWallDist = Abs((mapX - rayPosX + (1 - stepX) / 2) / rayDirX)
			Else
				perpWallDist = Abs((mapY - rayPosY + (1 - stepY) / 2) / rayDirY)
      		End If

'ray stats 1st dimension index: 0=x,1=y,2=dist from wall
'3=direction, 4=wall or nothing,5=dir x,6=dir y,7=image rect pos X,8=shadow
ray_stats[0,v]=drawMapX
ray_stats[1,v]=drawMapY
ray_stats[2,v]=perpWallDist*Float(Cos(-(p_fov/2)+(angle_div*v))/(20-(0.30*p_fov)))
ray_stats[4,v]=1

ray_stats[0,v]=ray_stats[0,v]

'FLOOR CASTING
Rem
1b. find the ray with the longest distance.
End Rem
If ray_stats[2,v]&gt;ray_stats[2,current_peak]
current_peak=v
EndIf

'1. Find an intersection with the Floor.
'start in the wall rays' longest position.
'then go backwards until "bottom" of the screen.
'floor_ray_stats=ray_stats[1,v]+grid_size
'2. Determine the world coordinate of the Floor that had been intersected.

'3. Calculate the distance between the player And the Floor intersection.

'4. Project the Floor intersection onto the projection plane.
'texture width/height=64
Rem

1. For each raycasted column store Y position of its bottom rendered pixel. All 
pixels below this in this column will be filled with Floor. This can be of course done
 using one-dimensional table with one cell For each column.
2. For every screen row below horizon calculate leftmost And rightmost column
 position where Floor texture needs To be drawn.
3. For every screen row below horizon calculate texture position at first pixel To be 
drawn.
4. Draw a row using texel offset increments inside loop (determining texture using
 tile map can be done here too).
End Rem

' Floor casting	
'floor ray stats 1st dimension index: 0=x,1=y,2=lengthX,3=lengthY,4=row

Rem
1. For each raycasted column store Y position of its bottom rendered pixel. All 
pixels below this in this column will be filled with Floor. 
End Rem
If rayDirX&lt;0
ray_stats[5,v]=ray_stats[0,v]+lengthdir_x(2,cameraX)
EndIf
If rayDirX&gt;0
ray_stats[5,v]=ray_stats[0,v]-lengthdir_x(2,cameraX)
EndIf
If rayDirY&lt;0
ray_stats[6,v]=ray_stats[1,v]+lengthdir_y(2,cameraX)
EndIf
If rayDirY&gt;0
ray_stats[6,v]=ray_stats[1,v]-lengthdir_y(2,cameraX)
EndIf
End Function

Function calculate_pov:Int()
Rem
    Dimension of the Projection Plane = 320 x 200 units
    Center of the Projection Plane = (160,100) - 320/2,200/2
    Distance to the Projection Plane =
center of proj plane(160)/Tan(field of view(60)/2)=277 units 
    Angle between subsequent rays =
 field of view(60)/Projection Plane X degrees - 60/320
End Rem
Local total_fov:Float=p_view_angle-(p_fov/2)
Local angle_div:Float=p_fov/projection_plane[0] 
Local angle_divY:Float=p_fov/projection_plane[1]

Local drawX:Float=0
Local drawY:Float=0
Local draw_height:Float=0
Local lookY:Int=p_vertical_angle
Local ray_height:Float[projection_plane[0]]
Local d_h:Int
Local v_h:Int

For Local v:Int=0 Until projection_plane[0] Step+1
SetColor 0,0,0
'get projection height of wall slice.
'projection height=wall height/distance*Distance to Projection Plane
'ray_stats[2,v](ray_stats[2,v])/(20-(0.05*p_fov))
'/(20-(0.05*p_fov))
draw_height=(wall_height/(ray_stats[2,v])*((projection_plane[0]/2)/Tan(p_fov/2)))
'display wall slice and the center of projection plane Y, minus half of 
'the wall's computed projection height.
'to change vertical perspective(looking up or down):
'change the "lookY" variable value.
'to look up: set the "lookY" variable as a positive number.
'to look down: set the "lookY" variable as a negative number.
lookY=p_vertical_angle
drawY=(projection_plane[1]/2)+lookY-(draw_height/2)+(p_view_height)
ray_height[v]=drawY+draw_height
'draw wall slice.
	' choose wall color
			Local colR:Int=170
			Local colG:Int=170
			Local colB:Int=170
If ray_stats[4,v]&gt;0
SetColor colR,colG,colB
EndIf

	If ray_stats[8,v] = 0 Then
				colR :/ 2
				colG :/ 2
				colB :/ 2
			End If
SetColor colR,colG,colB
'Local l_scale:Int=
DrawSubImageRect (level_tile,v,drawY,2,draw_height,..
ray_stats[7,v],1,1,ImageHeight(level_tile),0,0,0)
'DrawRect v,drawY,1,draw_height

d_h=drawY+(draw_height/2)
v_h=projection_plane[1]+max_vertical_angle

Rem
DrawSubImageRect (level_tile,v,d_h,1,v_h,..
2,floor_ray_stats[1,v],1,ImageHeight(level_tile),0,0,0)
End Rem
Next
'End Rem
End Function

        Function lengthdir_x:Float(length:Float,direction:Float)
          Local x_com:Float= 0;
            x_com = Float(Sin(direction) * length)
            Return x_com;
       End Function

        Function lengthdir_y:Float(length:Float,direction:Float)
          Local y_com:Float= 0
            y_com = Float(Cos(direction) * length)
            Return y_com;
       End Function

Function get_angle:Float(x0:Int,y0:Int,x2:Int,y2:Int)
Local a1:Int=x2-x0
Local a2:Int=y2-y0

Local answer:Float=ATan2(a1,a2)
Return answer
End Function

Function rects_overlap:Int(x0:Float ,y0:Float, w0:Float, h0:Float,x2:Float,y2:Float,w2:Float,h2:Float)
            If (x0 &gt; (x2 + w2) Or (x0 + w0) &lt; x2)
            Return 0
			EndIf
            If (y0 &gt; (y2 + h2) Or (y0 + h0) &lt; y2)
            Return 0
			EndIf
            Return 1
End Function

Function process_input:Int()

Local x_dis:Float=lengthdir_x(1,p_view_angle)
Local y_dis:Float=lengthdir_y(1,p_view_angle)
Local x_dis2:Float=lengthdir_x(ads_zoom+closest_wall,p_view_angle)
Local y_dis2:Float=lengthdir_y(ads_zoom+closest_wall,p_view_angle)

Local strafe_angleL:Int=p_view_angle+90
Local strafe_angleR:Int=p_view_angle-90
			If strafe_angleL&lt;0
			strafe_angleL:+360
			EndIf
			If strafe_angleR&gt;360
			strafe_angleR:-360
			EndIf
Local x_strafeL:Int=lengthdir_x(2, strafe_angleL)
Local y_strafeL:Int=lengthdir_y(2, strafe_angleL)
Local x_strafeL2:Int=lengthdir_x(ads_zoom+closest_wall, strafe_angleL)
Local y_strafeL2:Int=lengthdir_y(ads_zoom+closest_wall, strafe_angleL)

Local x_strafeR:Int=lengthdir_x(2, strafe_angleR)
Local y_strafeR:Int=lengthdir_y(2, strafe_angleR)
Local x_strafeR2:Int=lengthdir_x(ads_zoom+closest_wall, strafe_angleR)
Local y_strafeR2:Int=lengthdir_y(ads_zoom+closest_wall, strafe_angleR)
'debug_value=x_strafeL debug_value2=y_strafeL

If x_dis&gt;1
x_dis=1 EndIf
If x_dis&lt;-1
x_dis=-1 EndIf

If y_dis&gt;1
y_dis=1 EndIf
If y_dis&lt;-1
y_dis=-1 EndIf

If x_strafeL&gt;1
x_strafeL=1 EndIf
If x_strafeL&lt;-1
x_strafeL=-1 EndIf

If y_strafeL&gt;1
y_strafeL=1 EndIf
If y_strafeL&lt;-1
y_strafeL=-1 EndIf

If KeyDown(KEY_UP)
'move forward if there's distance between you and walls
For Local g:Int=0 Until plr_speed Step+1
If level_grid2[(real_plr_pos[0]+x_dis2+x_dis),(real_plr_pos[1])]=0
real_plr_pos[0]:+(x_dis)
EndIf
If level_grid2[(real_plr_pos[0]),(real_plr_pos[1]+y_dis2+y_dis)]=0
real_plr_pos[1]:+(y_dis)
EndIf
Next
EndIf

If KeyDown(KEY_DOWN)
For Local g:Int=0 Until plr_speed Step+1
If level_grid2[(real_plr_pos[0]-x_dis2-x_dis),(real_plr_pos[1])]=0
real_plr_pos[0]:-(x_dis)
EndIf
If level_grid2[(real_plr_pos[0]),(real_plr_pos[1]-y_dis2-y_dis)]=0
real_plr_pos[1]:-(y_dis)
EndIf
Next
EndIf

If KeyDown(KEY_LEFT)
If level_grid2[(real_plr_pos[0]-x_strafeL-x_strafeL2),(real_plr_pos[1])]=0
real_plr_pos[0]:-(x_strafeL)
EndIf
If level_grid2[(real_plr_pos[0]),(real_plr_pos[1]-y_strafeL-y_strafeL2)]=0
real_plr_pos[1]:-(y_strafeL)
EndIf
EndIf
'//===
If KeyDown(KEY_RIGHT)
If level_grid2[(real_plr_pos[0]-x_strafeR-x_strafeR2),(real_plr_pos[1])]=0
real_plr_pos[0]:-(x_strafeR)
EndIf
If level_grid2[(real_plr_pos[0]),(real_plr_pos[1]-y_strafeR-y_strafeR2)]=0
real_plr_pos[1]:-(y_strafeR)
EndIf
EndIf

Rem
If KeyDown(KEY_LEFT)
p_view_angle:-0.25*plr_turn_speed
If p_view_angle&lt;0
p_view_angle=360
EndIf
EndIf
If KeyDown(KEY_RIGHT)
p_view_angle:+0.25*plr_turn_speed
If p_view_angle&gt;360
p_view_angle=0
EndIf
EndIf
End Rem
If VirtualMouseX()&lt;100
p_view_angle:-0.1*plr_turn_speed
If p_view_angle&lt;0
p_view_angle=360
EndIf
EndIf
If VirtualMouseX()&gt;VirtualResolutionWidth()-100
p_view_angle:+0.1*plr_turn_speed
If p_view_angle&gt;360
p_view_angle=0
EndIf
EndIf
If VirtualMouseY()&lt;100 And p_vertical_angle&lt;max_vertical_angle
p_vertical_angle:+0.5*plr_turn_speed
EndIf
If VirtualMouseY()&gt;VirtualResolutionHeight()-100 And p_vertical_angle&gt;-max_vertical_angle
p_vertical_angle:-0.5*plr_turn_speed
EndIf

If KeyDown(KEY_0)
wall_height=0
EndIf
If KeyDown(KEY_1)
wall_height=1
EndIf
If KeyDown(KEY_2)
wall_height=2
EndIf
If KeyDown(KEY_3)
If button_delay=0
If fov_edit=2
fov_edit=0
EndIf
fov_edit:+1
If fov_edit=1
zoom_mode=1
'goal_p_view_height=36
'max_vertical_angle=100
EndIf
If fov_edit=2
zoom_mode=0
'goal_p_view_height=32
'max_vertical_angle=60
EndIf
EndIf
button_delay=8
EndIf
End Function

Function find_distance:Float(x0:Float,y0:Float,x2:Float,y2:Float)
Local answer:Float=0
answer=Sqr(((x2-x0)^2)+((y2-y0)^2))
Return answer
End Function
</textarea><br><br>*sigh* I was planning on drawing the floor by horizontal row, as I was told that would be faster, since there'd be no per-pixel division.<br><br><font class="tiny">Last edited 2012</font><br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1155433"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >codermax</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Anyone happened to have ported the floors and ceiling render code from <a href="http://lodev.org/cgtutor/raycasting2.html" target="_blank">http://lodev.org/cgtutor/raycasting2.html</a> ? <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
