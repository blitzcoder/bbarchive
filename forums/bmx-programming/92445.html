<!DOCTYPE html><html lang="en" ><head ><title >solitaire anyone?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >solitaire anyone?</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >solitaire anyone?</a><br><br>
<a name="1053409"></a>

<a name="1053410"></a>

<a name="1053417"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> A while a go I duplicated the windows solitaire game so she would have the game on here Mac and she would stop trying to use my Windows pc. She now uses it all the time and has not bother me anymore.  the version I have on her laptop is 99% complete. including redo undo (all the way to the first step) and few extra options.  I decided to share a stripped down version for anyone interested in looking at the code or using some of it's functionality for their own purpose. It does not include redo/undo functionality or the ability to change image faces.   this is the code:<br>main:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Const HEARTS			:Int = 0
Const DIAMONDS		:Int = 1
Const CLUBS			:Int = 2
Const SPADES			:Int = 3
 
Const ACE				:Int = 0
Const TWO				:Int = 1
Const THREE			:Int = 2
Const FOUR			:Int = 3
Const FIVE			:Int = 4
Const SIX				:Int = 5
Const SEVEN			:Int = 6
Const EIGHT			:Int = 7
Const NINE			:Int = 8
Const TEN				:Int = 9
Const JACK			:Int = 10
Const QUEEN			:Int = 11
Const KING			:Int = 12

Const HIDDEN_Y_SPACING	:Int = 10
Const HIDDEN_X_SPACING	:Int = 15


Const CARD_SPEED		:Int = 40
Const TRAIL_DELAY		:Int = 50 ' distance between cards

Const SCALE			:Float = 2.00
Const TOTALCARDS		:Int = 104
Const TotalSlots		:Int = 10
Const SUIT_TOTAL		:Int = 13
Const CARDS_PERsuit	:Int = 19

'card's face
Const FRONT			:Int = 1
Const BACK			:Int = 2

Global fc				:String[] = ["","FRONT","BACK"]
'cards style
Const CLASSIC			:Int = 0
Const COMIC			:Int = 1
Const NATURE			:Int = 2

'card back image
Const BACK1			:Int = 0
Const BACK2			:Int = 1
Const BACK3			:Int = 2
Const BACK4			:Int = 3
Const BACK5			:Int = 4
Const BACK6			:Int = 5
Const BACK7			:Int = 6
Const BACK8			:Int = 7

Const CARD_WIDTH		:Int = 36
Const CARD_HEIGHT		:Int = 48
Incbin "gfx/carddeck.png"

'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
'							SPIDER SOLITAIRE REMAKE
'			Designed  to be played on Windows, Lenux and Mac
'			10/8/2010																
'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
'
'			TCardForm
'			a type for loading graphics
'
'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

Type TCardForm
	Field _image:TImage
	Field _frontStyle:Int
	Field _backStyle:Int
	Field _width:Int
	Field _height:Int
	Field _cardType:String[]
	Field _cardName:String[]
		
	Method New()
		_image:TImage = LoadAnimImage("incbin::gfx/carddeck.png",CARD_WIDTH,CARD_HEIGHT,0,84)
		_FrontStyle = CLASSIC
		_backStyle:Int = BACK3
		_width  = CARD_WIDTH
		_height = CARD_HEIGHT
		_cardtype = ["Clover","Diamond","Heart","Spade","Joker"]
		_cardName = ["Ace","two","Three","Four","Five","Six","Seven","Eight","Nine","Ten",..
				   "Jack","Queen","King","Joker"]
	End Method

	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
	'
	'			setFrontStyle is used the set the front face of the cards
	'			three different Styles: CLASSIC, COMMIC, NATURE
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

	Method setFrontStyle(style:Int)
		_frontStyle = style
	End Method
		
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			getFrontStyle used to get the current cards front style
	'			returns one of the three styles previously mentioned.
	'																	 
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

	
	Method getFrontStyle:Int(style:Int)
		Return _frontStyle
	End Method

	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			setScale sets the cards image scale
	'			set image width and height to as spcefied size 1,1 is actual size 
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

	
	Method SetScale(xs:Float, ys:Float)
		_width  = CARD_WIDTH * xs
		_height = CARD_HEIGHT *ys
	End Method
	
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			setBackStyle is used to set the image for  the back of the cards
	'			type range between 0 and 7 inclusive
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
	

	Method setBackStyle(style:Int)
		_backStyle = style
	End Method
	
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			getBackStyle returns the current style of the cartds
	'			will return style between 0 and 7 inclusive 
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
	
	Method getBackStyle:Int(style:Int)
		Return _backStyle
	End Method
	
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			drawFontFace used to display the front of a specific card 
	'			x,y is the position of the image to be drawn
	'			cardPos is the number of the image to draw  a number between 0 and 12 inclusive 0 being Ace and 12 being King
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
	
	Method drawFrontFace(x:Int,y:Int,cardPos:Int,suit:Int)
		Local i:Int = suit * 19
		If cardPos &gt; TEN
			i :+ _frontStyle * 3 +cardPos
		Else
			i:+ cardPos
		EndIf
		DrawImageRect _image, x, y, _width, _height, i
	End Method
	
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			draws the back image of the card in the current style
	'			see setBackStyle for more info. 
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

	Method drawBackFace(x:Int,y:Int)
		Local i:Int = 76 + _backStyle
		DrawImageRect _image, x, y, _width, _height, i
	End Method
	
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			draws a white outline the current cards scale 
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

	Method drawOutLine(x:Int, y:Int)
		SetColor 255,255,255
		DrawLine x,y,x+_width-1,y
		DrawLine x,y+_height-1,x+_width-1,y+_height-1
		DrawLine x,y,x,y+_height-1
		DrawLine x+_width-1,y,x+_width-1,y+_height-1
	End Method

End Type

'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
'
'			TcardForm instantiated for global use 
'
'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

Global cardForm:TcardForm = New TcardForm

'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
'
'			Tposition is the type communly used to keep track and position all 
'			types in view
'
'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

Type Tposition

	Field x:Int
	Field y:Int	
End Type

'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
'
'			Tcard is used to create a single card  
'
'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

Type Tcard
	Field position:Tposition
	Field suit:Int
	Field number:Int
	Field face:Int
	Field link:TLink

	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			initialization of required variables
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

	Method New()
		position = New TPosition
	End Method

	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			used to create an instance of  tcard
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

	Function Create:Tcard(cardPos:Int, suit:Int, face:Int = BACK)
		Local c:Tcard = New Tcard
		c.number = cardPos
		c.Face = face
		c.suit = suit
		Return c
	End Function
	
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			setFace is used to set the face of the card for display purpose
	'			it can be FRONT todisplay the front of the card
	'			or BACK to display the back of the card
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

	Method SetFace(f:Int)
		face = f
	End Method 	

	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			setPosition is used to actually display the position of the card
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

	Method setPosition(x:Int, y:Int)
		position.x = x
		position.y = y
	End Method

	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			getPosition returns the actual position of the playing cards.
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
	
	Method getPosition(x:Int Var, y:Int Var)
		x = position.x
		y = position.y
	End Method

	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			display the card with preset conditions.
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
	
	Method draw()
		If face = FRONT 
			cardForm.drawFrontFace(position.x,position.y,number,suit)
		Else				
			cardForm.drawBackFace(position.x,position.y)
		EndIf
	End Method	
	
End Type

'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
'
'		TSpacing is used to set the spacing for the front of the back of the card
'
'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

Type TSpacing
	Field frontx:Int
	Field fronty:Int
	Field backx:Int
	Field backy:Int
End Type

'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
'
'			Tsuit is used to create a suit type set of cards
'
'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

Type Tsuit
	Field position:Tposition
	Field Spacing:TSpacing
	Field cards:Tcard[SUIT_TOTAL]
	Field suitType:Int

	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			Initialized required variables
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
	
	Method New()
		position = New Tposition
		Spacing = New Tspacing
	End Method
	
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			Create creates an instance of  a suit type
	'			Suit types are CLUBS, DIAMONDS,SPADES,HEARTS
	' 
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

	Function Create:Tsuit(suitType:Int)
		Local s:Tsuit = New Tsuit
		s.suitType = SuitType
		For Local i:Int = 0 Until SUIT_TOTAL
			s.cards[i] = Tcard.Create(i,suitType,FRONT)				
		Next
		Return s
	End Function

	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			setPosition  of the suit in screen.
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
	
	Method setPosition(x:Int,y:Int)
		position.x = x
		position.y = y
	End Method
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			Returns the position of the suit in the screen
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

	
	Method getPosition(x:Int Var,y:Int Var)
		x = position.x
		y = position.y
	End Method

	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			Set spacing per card face is FRONT, BACK 
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
	
	Method SetSpacing(x:Int,y:Int,face:Int)
		If face = FRONT
			spacing.frontx = x
			spacing.fronty = y
		Else
			spacing.backX = x
			spacing.backy = y
		EndIf
		x = position.x
		y = position.y
		For Local i:Int = KING To ACE Step -1 
			cards[i].setPosition(x,y)
			If cards[i].face = FRONT
				x:+spacing.frontx
				y:+spacing.fronty
			Else
				x:+spacing.backx
				y:+spacing.backy
			EndIf
		Next
	End Method

	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			Get all cards in the suit
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
	
	Method getCards:Tcard[]()
		Local c:Tcard[] = cards
		cards = Null
		Return c
	End Method
	
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			displays all cards in the suit.
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
	

	Method display()
		Local x:Int = position.x
		Local y:Int = position.y

		For Local i:Int = KING To ACE Step -1 
			cards[i].draw()
		Next

	End Method	
End Type

'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
'
'			a collection of 4 suits one each type CLUBS, DIAMONS, HEARTS and SPADES
'
'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

Type Tdeck
	Field Position:Tposition
	Field Spacing:Tposition
	Field suits:Tsuit[4]
	
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			Used to create a deck of cards.
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
	Method Create:Tdeck()
	
		suits[CLUBS]  =Tsuit.Create(CLUBS)
		suits[DIAMONDS] =Tsuit.Create(DIAMONDS)
		suits[HEARTS]   =Tsuit.Create(HEARTS)
		suits[SPADES]   =Tsuit.Create(SPADES)
		position = New TPosition
		Spacing = New TPosition
		Return Self
		
	End Method
	
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			Returns one of  the specified suits CLUBS, DIAMONDS, HEARTS, SPADES
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

	Method getSuit:Tsuit(suit:Int)
		Return suits[suit]
	EndMethod

	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			Returns the complete deck of cards in a single array
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
	
	Method getCards:Tcard[]()
		Local c:Tcard[] = suits[0].getCards()
		c :+ suits[1].getCards()
		c :+ suits[2].getCards()
		c :+ suits[3].getCards()
		Return c
	End Method

	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			Sets the position of the deck of cards for display purpose.
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
	
	Method setPosition(x:Int,y:Int)
		position.x = x
		position.y = y
	End Method
	
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			sets the spacing of each card  applicable to all  for display purpose
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

	Method SetSpacing(x:Int,y:Int)
		spacing.x = x
		spacing.y = y
	End Method

	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			the whole deck of cards in a single long strip(spacing previously set.
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

	Method display()
		Local x:Int = position.x
		Local y:Int = position.y
		For Local i:Int = 0 Until suits.length
			suits[i].setSpacing(50,10,FRONT)
			suits[i].setPosition(x,y)
			suits[i].display()
			x :+ spacing.x
			y :+ spacing.y
		Next
	End Method
End Type

'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
'
'			temporay storage to allow acces to a collection of cards.
'
'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/


Type Tsupply
	Field position:Tposition
	Field Spacing:Tspacing
	Field cards:Tcard[]
	
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			Initialization of required Variables.
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
	
	Method New()
		position = New Tposition
		spacing = New Tspacing
	End Method
	
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'		Add a card or cards to the method.
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

	Method AddCards(cards:Tcard[])
		Self.cards:+ cards
	End Method
	
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			Get the number of cards currently stored with in.
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

	Method TotalCards:Int()
		Return cards.length
	End Method
	
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			Extract a single card from card collection.
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

	Method extractCard:Tcard[]()
		If cards.length = 0 Return Null
		Local card:Tcard[] = cards[cards.length-1..]
		cards = cards[..cards.length-1]
		Return card
	End Method
	
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			shuffle a number of cards
	'			n is the number of times to shuffle the number of cards currently stored.
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

	Method shuffle(n:Int)
		For Local t:Int = 0 Until n
			For Local i:Int = 0 Until cards.length
				Local i2:Int = Rand(cards.length) - 1
				Local temp:Tcard = cards[i]
				cards[i] = cards[i2]
				cards[i2] = temp
			Next
		Next
	End Method
	
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			SetPosition is used to set the location where to display the cards from within this object.
	'
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

	Method setPosition(x:Int,y:Int)
		position.x = x
		position.y = y
	End Method
	
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			used to set direction and spacing distance for each card for displaying with in this object
	'			mainly used fo testing purpose.
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

	Method setSpacing(x:Int,y:Int,face:Int)
		If face = FRONT
			spacing.frontx = x
			spacing.fronty = y
		Else
			spacing.backx = x
			spacing.backy = y
		EndIf
	End Method
	
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			display - used for displaying the current total cards in The Tstorage 
	'			type Object. Mainly used for testing purpose.
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
	
	Method display()
		Local x:Int = position.x
		Local y:Int = position.y
		Local a:Int
		Local d:Int
		
		If cards[0].face = FRONT
			a = spacing.frontx
			d = spacing.fronty
		Else
			a = spacing.backx
			d = spacing.backy
		EndIf
		
		If  a = 0 And d = 0
			Local i:Int = cards.length-1
			cards[i].setPosition(x,y)
			cards[i].draw()
		Else
			For Local i:Int = 0 Until cards.length
				cards[i].setPosition(x,y)
				If cards[i].face = FRONT
					x :+ spacing.frontx
					y :+ spacing.fronty
				Else
					x :+ spacing.backx
					y :+ spacing.backy
				EndIf
				cards[i].setPosition(x,y)
				cards[i].draw()
			Next
		EndIf
	End Method
	 
End Type

'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
'
'		Tdealer used to deal cards to dealer area.
'
'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

Type Tdealer

	Field position:Tposition
	Field spacing:Tspacing
	Field stacks:Tsupply[]
	Field cardsInSet:Int[]
	Field cards:Tcard[]
	
	Method New()
		position = New TPosition
		spacing = New Tspacing
	End Method
	
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			Create creates an instance of  a Tdealer type
	'			Suit types are CLUBS, DIAMONDS,SPADES,HEARTS
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

	Function Create:Tdealer(x:Int,y:Int, decks:Int=1, stacks:Int=1,cardsEach:Int=52)
		Local deck:Tdeck[decks]
		Local d:TDealer = New TDealer
		d.position.x = x
		d.position.y = y
		For Local i:Int = 0 Until decks
			deck[i] = New Tdeck.Create()
		Next
		Local supply:Tsupply
		supply = New Tsupply
		For Local n:Int= 0 Until decks
			supply.addCards(deck[n].getcards())
		Next
		d.stacks = New Tsupply[stacks]
		For Local i:Int = 0 Until d.stacks.length
			d.stacks[i] = New Tsupply
		Next
		d.spacing.backx = -10
		d.spacing.backy = 0
		supply.shuffle(20)
		Local card:Tcard[] = supply.extractCard()
		Local i:Int = 0
		Local c:Int = 1
		While card.length &gt; 0
			card[0].setPosition(x,y)
			card[0].setFace(BACK)			
			d.stacks[i].addcards(card)
			If c = cardsEach
				i:+1
				x :+ d.spacing.backx
				y :+ d.spacing.backy
				c = 0
			EndIf
			c :+ 1
			card = supply.extractCard()
		Wend
		Return d
	End Function
	
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			mouseInSet - this is used to see if the mouse in the area of the dealer 
	'																			
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
	
	Method mouseInSet:Int()
		If stacks.length &gt; 0
			If mouse.x &gt; stacks[0].position.x + cardForm._width Return False
			If mouse.x &lt; stacks[stacks.length-1].Position.x Return False
			If mouse.y &lt; stacks[0].position.y Return False
			If mouse.y &gt; stacks[0].position.y + cardForm._height Return False
			Return True
		EndIf
		Return False
	End Method

	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			setPosition - set the position of the dealer card set for display purpose.
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/		
	
	Method setPosition(x:Int, y:Int)
		position.x = x
		position.y = y
	End Method

	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			setSpacing  - used setting the spacing for the each vissible set of cards
	'			negative numbers will display upwards and/or to the left  positive numbers will display downwards and/or to the ritht
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

	Method setSpacing(x:Int,y:Int)
		spacing.backx = x
		spacing.backy = y
	End Method
	
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			dealCard - exract a single card 
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

	Method dealCard:Tcard[]()
		Local card:tcard[] = stacks[stacks.length-1].extractCard()
		If card = Null
			stacks = stacks[..stacks.length-1]
			If stacks.length = 0 Return Null
			card = dealCard()
		ElseIf stacks[stacks.length-1].TotalCards() = 0 
			stacks = stacks[..stacks.length-1]
		EndIf
		Return card
	End Method

	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			getASet - extracts 10 cards from dealer card stored 
	'			as supply sets.
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

	Method getASet:Tsupply()
		If stacks.length
			Local stack:Tsupply = stacks[stacks.length-1]
			stacks = stacks[..stacks.length-1]
			Return stack
		EndIf
		Return Null
	End Method
	
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'			addASet - adds a set of 10 cards back to the dealer
	'			and must be put in Tsupply first
	'
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
			
	Method addAset(set:Tsupply)
		Local x:Int = position.x + spacing.backx*stacks.length
		Local y:Int = position.y + spacing.backy*stacks.length
		set.setPosition(x,y)
		For Local card:tcard = EachIn set.cards
			card.setposition(x,y)
		Next
		stacks = stacks[..stacks.length+1]
		stacks[stacks.length-1] = set
	End Method

	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'		getNextXY - returns future x and y values of the of the set to be added to
	'		the dealer
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 

	Method getNextXY(x:Int Var,y:Int Var)
		x = position.x + stacks.length * spacing.backx
		y = position.y
	End Method

	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	'
	'		display - displays the back of one card per set available in the dealer
	'		
	'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
	
	Method display()
		Local x:Int = position.x
		Local y:Int = position.y
		For Local supp:Tsupply = EachIn stacks
			supp.setPosition(x,y)
			supp.display()
			x :+ spacing.backx
			y :+ spacing.backy
		Next
	End Method
	
End Type

'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
'
'		TDump - storage area for all of the completed stacks
'
'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 

Type Tdump
	Field position:Tposition
	Field spacing:Tspacing
	Field cards:tcard[]
	
	Method New()
		position= New Tposition
		spacing = New Tspacing
	End Method
	
	Function Create:Tdump(x:Int,y:Int)
		Local s:Tdump = New Tdump
		s.Position.x = x
		s.position.y = y
		s.spacing.frontx = 15
		s.spacing.fronty = 0
		Return s
	End Function
	
	Method getNextXY(x:Int Var, y:Int Var)
		If cards.length = 0
			x = position.x
			y = position.y
		Else
			x = cards[cards.length-1].position.x + spacing.frontx
			y = cards[cards.length-1].position.y + spacing.fronty
		EndIf
	End Method
	
	Method addcard(card:Tcard[])
		Self.cards :+ card
		If cards.length = 0 Return  
		Local x:Int = position.x
		Local y:Int = position.y
		For Local i:Int = 0 Until cards.length
			If (i Mod 13) = 0 And i &gt; 0
				cards[i].setPosition(x,y)
				x :+ spacing.frontx
				y :+ spacing.fronty
			Else
				cards[i].setPosition(x,y)
			EndIf
		Next
	End Method
	
	Method getASet:TSupply()
		If cards.length = 0 Return Null
		Local c:Tcard[] = cards[cards.length-13..]
		cards =  cards[..cards.length-13]
		Local supply:Tsupply = New Tsupply
		supply.AddCards(c)
		Return supply
	End Method
	
	Method display()
		If cards.length = 0 Return  
		For Local i:Int = -1 Until cards.length Step 13
			If i&gt;= 0 Then 
				cards[i].draw()
			EndIf
		Next
	End Method
	
End Type

'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
'
'		Tstack - colums normally used in the play section.
'
'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 

	
Type TStack
	Field position:Tposition
	Field spacing:Tspacing
	Field cards:Tcard[]
	
	Method New()
		position = New Tposition
		spacing = New Tspacing
	End Method
	
	Function Create:TStack(x:Int,y:Int)
			Local s:Tstack = New Tstack
			s.position.x = x
			s.position.y = y
			Return s
	End Function
	
	Method peekFrontCard:Int(value:Int Var,suit:Int Var,index:Int Var)
		If cards.length &gt; 0
			value = cards[cards.length-1].number
			suit = cards[cards.length-1].suit
			index = cards.length-1
			Return True
		EndIf
		Return False	
	End Method
	
	Method peekCard:Int(value:Int Var, suit:Int Var, index:Int)
		If cards.length &gt; 0 And index &lt; cards.length
			value = cards[index].number
			suit = cards[index].suit
			Return True
		EndIf
		Return False
	End Method
	
	Method SetSpacing(x:Int,y:Int,face:Int)
		If face = FRONT
			spacing.frontx = x
			spacing.fronty = y
		Else
			spacing.backx = x
			spacing.backy = y
		EndIf
	End Method
	
	Method getSpacing(x:Int Var,y:Int Var,face:Int)
		If face = FRONT
			x = spacing.frontx
			y = spacing.fronty
		Else
			x = spacing.backx
			y = spacing.backy
		EndIf
	End Method
	
	Method frontCardFaceUp()
		If cards.length 
			cards[cards.length-1].face = FRONT
		EndIf
	End Method
	
	Method frontCardFaceDown()
		If cards.length
			cards[cards.length-1].face = BACK
		EndIf
	End Method
	
	Method extractFrontCard:tcard[]()
		If cards.length = 0 Return Null
		Local card:Tcard[] = cards[cards.length-1..]
		cards = cards[..cards.length-1]
		Return card
	End Method
	
	Method getCardOnPoint:Int(mx:Int,my:Int)
		For Local i:Int = (cards.length-1) To 0 Step -1
			Local card:tcard = cards[i]
			Local x:Int,y:Int
			card.getposition(x,y)
			If mx &lt; x Continue
			If my &lt; y Continue
			If mx &gt; x+cardForm._width Continue 
			If my &gt; y+cardForm._height Continue
			Return i
		Next
		Local x:Int = position.x
		Local y:Int = position.y
		If mx &lt; x Return -1
		If my &lt; y Return -1
		If mx &gt; x+cardForm._width Return -1 
		If my &gt; y+cardForm._height Return -1
		
		Return -2
	End Method
	
	Method getNextXY(x:Int Var,y:Int Var)
		If cards.length = 0
			x = position.x
			y = position.y
		Else
			Local px:Int,py:Int
			cards[cards.length-1].getPosition(x,y)
			If cards[cards.length-1].face = FRONT
				x :+ spacing.frontx
				y :+ spacing.fronty
			Else
				x :+ spacing.backx
				y :+ spacing.backy
			EndIf
		EndIf
	End Method
	
	Method getLastPosition:Int(x:Int Var,y:Int Var)
		If cards.length = 0
			x = position.x
			y = position.y
		Else
			cards[cards.length-1].getPosition(x,y)
		EndIf
	End Method
	
	Method validCardRules:Int(index:Int)
		If index = cards.length-1 And cards[index].face = FRONT Then Return True

		Local suit:Int = cards[index].suit
		Local number:Int = cards[index].number
		For Local i:Int = index+1 Until  cards.length
			If cards[i].face = back Then Return False
			If cards[i].suit &lt;&gt; suit Then  Return False
			If cards[i].number &lt;&gt; (number-1) Then Return False
			suit = cards[i].suit
			number :- 1
		Next
		Return True
	End Method
		
	Method completeSuit:Int()		
		If cards.length &lt; 13 Return False
		Local suit:Int,Number:Int
		For Local index:Int = ACE To KING
			Local card:tcard = cards[(cards.length -1) - index]
			If index = 0 
				If card.number = ACE
					suit = card.suit
					number = ACE
				Else
					Return False
				EndIf
			ElseIf card.suit = suit
				If card.face = BACK Return False
				number = number + 1
				If card.number &lt;&gt; number
					Return False
				EndIf
			Else
				Return False
			EndIf
		Next
		Return True
		
	End Method
	
	Method isEmpty:Int()
		Return cards.length = 0
	End Method		
	
	Method extractFromIndex:Tcard[](index:Int,remainingFrontCardFace:Int Var)
		If  index=-1 Then index = 0
		Local c:Tcard[] = cards[index..]
		cards = cards[..index]
		If cards.length &gt; 0
			remainingFrontCardFace = cards[cards.length-1].face
		Else
			remainingFrontCardFace = 0
		EndIf
		Return c
	End Method
	
	Method addToEnd(card:Tcard[])
		cards :+ card
		Local x:Int = position.x
		Local y:Int = position.y
		For Local c:Tcard = EachIn cards
			c.setposition(x,y)
			If c.face = FRONT
				x :+ spacing.frontx
				y :+ spacing.fronty 
			Else
				x :+ spacing.backx
				y :+ spacing.backy
			EndIf
		Next
	End Method
	
	Method display()
		If cards.length = 0
			cardForm.drawOutline(position.x,position.y)
			Return
		Else
			For Local card:Tcard = EachIn cards
				card.draw()
			Next
		EndIf
	End Method
		
End Type

'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
'
'		TPlayField - play area consist of 10 stacks workable with the mouse
'	

'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 

Type TplayField

	Field stacks:TStack[]
	Field positiony:Int
	Field Spacingx:Int
	Field Width:Int
	Field height:Int
	
	Function Create:TplayField(width:Int, height:Int,y:Int)
		Local p:TplayField = New Tplayfield
		p.width = width
		p.height = height
		p.positiony = y
		Return p
	End Function
	
	Method setSpacing(W:Int, y:Int)
		Spacingx = w
		positiony = y
	End Method
	
	Method createStacks(n:Int)
		stacks = New Tstack[n]
		spacingx = (width - (cardForm._width * n)) /(n+1)
		Local x:Int = spacingx
		Local y:Int = positiony
		For Local i:Int = 0 Until stacks.length
			stacks[i] =Tstack.Create(x,y)
			x :+ spacingx + cardForm._width
		Next
	End Method
	
	Method emptyStacks:Int()
		For Local stack:Tstack = EachIn stacks
			If stack.isEmpty() Return True
		Next
		Return False	
	End Method
	
	Method StackValidCardRules:Int(stackNo:Int,cardPos:Int)
		Return stacks[stackNo].validcardRules(cardpos)
	End Method
	
	Method getCards:Tcard[](stackNo:Int,Cardpos:Int,remainingFrontCardFace:Int Var)
		Return stacks[stackNo].extractFromIndex(cardpos,remainingFrontCardFace)
	End Method
	Method stackExtractFrontCard:Tcard[](stackNo:Int)
		Return stacks[stackNo].extractFrontCard()
	End Method
	
	Method StackCompleteSuit:Int(stackIndex:Int)
		Return stacks[stackIndex].completeSuit()
	End Method
		
	Method StackFaceFrontCard(stackNo:Int)
		stacks[stackNo].frontCardFaceUp()
	End Method
	
	Method stackSetFrontFace(stackNo:Int,face:Int)
		If face = FRONT
			stacks[stackNo].frontCardFaceUp()
		ElseIf face = BACK
			stacks[stackNo].frontCardFaceDown()
		EndIf
	EndMethod
	
	Method getMouseCardIndexes:Int(stackNo:Int Var,cardPos:Int Var)
		Local mx:Int = Mouse.X
		Local my:Int = Mouse.Y
		cardPos = -1
		stackno = -1
		If my &lt; positiony  Return 0
		stackNo = mx/(spacingx + cardForm._width)
		Local r:Int = mx Mod (spacingx+cardForm._width)
		If stackNo &gt;= stacks.length Return 0
		If r &lt;= spacingx Return 0
		cardPos = stacks[stackNo].getCardonPoint(mx,my)
		If cardPos = -1 Return 0
		Return 1
	End Method
		
	Method getStackNextXY(x:Int Var, y:Int Var, stackIndex:Int)
		stacks[StackIndex].getNextXY(x,y)
	End Method
	
	Method getStackLastPosition(x:Int Var, y:Int Var, stackIndex:Int)
		stacks[stackIndex].getLastPosition(x,y)
	End Method
	
	Method stackSetSpacing(x:Int,y:Int,face:Int)
		For Local stack:Tstack = EachIn stacks
			stack.setSpacing(x,y,face)
		Next
	End Method
	
	Method stackGetCardSpacing(x:Int Var,y:Int Var,face:Int, stackIndex:Int)
		stacks[stackIndex].getSpacing(x,y,face)
	End Method 

	Method addcardsToStack(card:tcard[],StackIndex:Int)
		stacks[StackIndex].addToEnd(card)
	End Method
			
	Method mouseInStack:Int(x:Int,y:Int,StackIndex:Int)
		If stackIndex &gt; 9 Return False
		Local w:Int = cardForm._width
		Local h:Int = cardForm._height
		Local tx:Int,ty:Int
		stacks[stackIndex].getLastPosition(tx,ty)
		If x &lt; stacks[stackIndex].position.x Return False
		If x &gt; stacks[stackIndex].position.x+w Return False
		If y &lt; positiony Return False
		If y &gt; ty+h Return False
		Return True
	End Method
	
	Method stackPeekFrontCard:Int(number:Int Var,suit:Int Var,index:Int Var, stackIndex:Int)
		Return stacks[stackIndex].peekFrontCard(number,suit,index)
	End Method
	
	Method Display()
		Local x:Int = spacingx
		Local y:Int = positiony
		For Local stack:Tstack = EachIn stacks
			stack.display()
		Next
	End Method
		
End Type

'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
'
'	TmouseStack - place where the cards are stored when the mouse is moving
'	the cards.
'
'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 

Type TmouseStack
	Field oldStackIndex:Int
	Field oldFace:Int
	Field cardShift:Tposition
	Field spacing:Tspacing
	Field cards:Tcard[]
	Field state:Int
	
	Method New()
		cardShift = New Tposition
		Spacing = New Tspacing
	End Method

	Function Create:TmouseStack()
		Local m:tMouseStack = New TmouseStack
		Return m
	End Function
	
	Method isActive:Int()
		Return cards.length &gt; 0
	End Method
	
	Method addCards(card:Tcard[],oldStack:Int,oldFace:Int)  'oldface =  FRONT,BACK, 
		Self.cards :+ card
		Self.oldStackIndex = oldStack
		Self.oldFace = oldface
		setOffSet(card[0].position.x,card[0].position.y)
	
	End Method

	Method SetCardSpacing(x:Int,y:Int,face:Int)
		If face = FRONT
			spacing.frontx = x
			spacing.fronty = y
		Else
			spacing.backx = x
			spacing.backy = y
		EndIf
	End Method
	
	Method peekFirst:Int(number:Int Var, suit:Int Var)
		If cards.length = 0 Return False
		number = cards[0].number
		suit = cards[0].suit
		Return True
	End Method
		
	Method extractAllCards:Tcard[](card:Tcard[] Var,oldIndex:Int Var,oldFace:Int Var)
		card = Self.cards
		oldIndex = Self.oldStackIndex
		oldFace = Self.oldFace
		cards = Null
		Return cards
	End Method
	
	Method setOffset(x:Int,y:Int)
		cardShift.x = Mouse.X - x
		cardShift.y = Mouse.Y - y
	End Method
	
	Method display()
		Local px:Int = Mouse.X - cardShift.x
		Local py:Int = Mouse.Y - cardshift.y
		Local n:Int = 0
		For Local card:Tcard = EachIn cards
			card.setPosition(px,py)
			If card.face = FRONT
				px :+ spacing.frontx
				py :+ spacing.fronty
			Else
				px :+ spacing.backx
				py :+ spacing.backx
			EndIf
			card.draw()
		Next 

	End Method
	
End Type	

'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
'
'		TAnimatedCard - used to animate/move the card/s from one position to another
'		area uniformly.
'		
'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 

Type TanimatedCard
	Field card:Tcard[]
	Field slotIndex:Int
	Field spacing:Tspacing
	Field source:Tposition
	Field x:Float
	Field y:Float
	Field dx:Float
	Field dy:Float
	Field Speed:Float
	Field distance:Float
	
	Method New()
		spacing = New Tspacing
		source = New Tposition
	End Method
	
	Function Create:TanimatedCard(card:tcard[],destinationx:Float,destinationy:Float,speed:Float,slotIndex:Int)
		Local a:TanimatedCard = New TanimatedCard
		a.card = card
		card[0].GetPosition(a.source.x,a.source.y)
		a.x = a.source.x
		a.y = a.source.y
		Local lx:Float = destinationx - a.x
		Local ly:Float = destinationy - a.y
		Local angle:Float = ATan2(ly,lx)
		a.dx = Cos(angle)
		a.dy = Sin(angle)
		a.distance = Sqr(lx^2+ly^2)
		a.slotIndex = slotIndex
		a.spacing.frontx = 0
		a.spacing.fronty = 15
		a.speed = speed
		Return a
	End Function
	
	Method setSpacing(x:Int,y:Int)
		spacing.frontx = x
		spacing.fronty = y
	End Method

	Method getCardandSlotIndex:Int(card:Tcard[] Var, slotIndex:Int Var)
		card = Self.card
		slotIndex = Self.slotIndex
	End Method
	
	Method update:Int()
		x :+ dx*speed
		y :+ dy*speed
		Local td:Float = Sqr((x-source.x)^2+ (y-source.y)^2)
		If td &gt;= distance Return False
		card[0].setPosition(x,y)
		Return True
	End Method
	
	Method display()
		Local n:Int = 0
		For Local c:Tcard = EachIn card
			c.setPosition(x,y+spacing.fronty*n)
			c.draw()
			n :+ 1
		Next
	End Method

End Type

'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
' 
'		TAnimation - used to move several cards or sets of cards
'
'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 


Type Tanimation
	Field inlist:TList
	Field activeList:TList
	Field outList:TList
	Field startTime:Long
	Field wait:Long
	Field working:Int
	
	Method New()
		inlist = New TList
		outlist = New TList
		activeList = New TList
		startTime = MilliSecs()
		wait = TRAIL_DELAY
		working:Int = True
	End Method
	
	Function Create:Tanimation()
		Local a:Tanimation = New Tanimation
		Return a
	End Function
	
	Method addAnimation(anim:tanimatedCard)
		inList.AddFirst(anim)
		working = True	
	End Method
	
	Method extractAnimation:TanimatedCard()
		Return TanimatedCard(outList.removeLast())
	End Method
	
	Method update:Int()
		If working
			Local time:Long = MilliSecs() - startTime
			
			If time &gt; wait
				If inList.isEmpty() = False
					activeList.addlast((inlist.removelast()))
				EndIf
				startTime = MilliSecs()
			EndIf
			For Local c:TAnimatedCard = EachIn activeList
				If c.update() = False
					activeList.remove(c)
					outList.addFirst(c)
				EndIf
			Next	
		EndIf
		
		If activeList.isEmpty() And inList.isEmpty() working = False
		Return working
	End Method
	
	Method display()
		For Local animate:tanimatedCard = EachIn inList
			animate.display()
		Next 
		If outList.isEmpty() = False
			TanimatedCard(outList.first()).display()
		EndIf
		For Local animate:tanimatedCard = EachIn activeList
			animate.display()
		Next
			
	End Method

End Type

'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 
'
'		TGame the main Solitare game section.
' 
'\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ 

Type Tgame

		Field dealing:Int
		Field dumping:Int
		Field count:Int
		Field enableUndo:Int
		Field disableUndo:Int
		Field RedoingUndoing:Int
		Field undealing:Int
		Field undumping:Int
		Field playfield:tplayfield
		Field dealer:Tdealer
		Field mouseStack:TmouseStack
		Field animation:Tanimation
		Field dump:Tdump
		Field tempSupply:TSupply
		
		Method New()
			dealer:Tdealer = Tdealer.Create(900,600,2,11,10)
			playfield:Tplayfield = TplayField.Create(GraphicsWidth(),600,50)
			mouseStack:Tmousestack = New TmouseStack
			mouseStack.SetCardSpacing(0,20,FRONT)
			mouseStack.SetCardSpacing(0,10,BACK)
			cardForm.SetFrontStyle(COMIC)
			cardForm.SetScale(SCALE,SCALE)
			playfield.createStacks(10)
			playfield.stackSetSpacing(0,20,FRONT)
			playfield.stacksetSpacing(0,10,BACK)
			animation = Tanimation.Create()
			dump = Tdump.Create(200,600)
			disableUndo = True
			enableUndo = False
			dumping = False
			dealing = False
			undealing = False
		End Method
	
		Method dealingCards()
			Local slotIndex:Int,card:tcard[]		
			If animation.update() = True '
				Local animated:TanimatedCard = animation.extractAnimation()
				While animated
					animated.getCardandSlotIndex(card,slotIndex)
					playfield.addCardsToStack(card,SlotIndex)
					animated:TanimatedCard = animation.extractAnimation()
				Wend
			Else
				Local animated:TanimatedCard = animation.extractAnimation()
				While animated
				 	Local slotIndex:Int
					animated.getCardandSlotIndex(card,slotIndex)
					playfield.addCardsToStack(card,SlotIndex)
					animated:TanimatedCard = animation.extractAnimation()						
				Wend
				dealing = False
			EndIf	
		End Method
		
		Method dumpingCards()
				Local slotIndex:Int, card:Tcard[]
				If animation.update() = True
				Else
					Local animated:TanimatedCard = animation.extractAnimation()
					While animated
						Local slotIndex:Int
						animated.getCardAndSlotIndex(card,slotIndex)
						dump.addCard(card)
						animated:tanimatedCard = animation.extractAnimation()
					Wend
					dumping = False				
				EndIf
		End Method
		
		Method dealFaced(face:Int)
			Local x:Int,y:Int
			Local index:Int
			' get a set of cards to send to playfield
			Local supply:tsupply = dealer.getASet() 
			If supply ' if there were cards available process				
				'grab one card at a time from collected set of cards
				Local card:tcard[] = supply.extractCard()
				index = 0
				While card
					card[0].setface(face)
					playfield.getStackNextXY(x,y,index)
					Local animated:TanimatedCard = TanimatedCard.Create(card,x,y,CARD_SPEED,index)
					animation.AddAnimation(animated)
					card:tcard = supply.extractCard()
					dealing = True
					index :+ 1
				Wend
				count :+ 1
			EndIf
		End Method

		Method getCards()
			Local StackNo:Int
			Local cardPos:Int
			Local oldstackFrontCardFace:Int
			Local number2:Int
			If playField.getMouseCardIndexes(StackNo,cardPos)
				If cardPos &gt;= 0 Then
					If playfield.stackValidCardRUles(stackNo,cardPos)
						Local card:tcard[] = playField.getCards(stackNo,cardPos,oldstackFrontCardFace)
						If card
							mouseStack.addCards(card,stackNo,oldStackFrontCardFace)
						EndIf
					EndIf
				EndIf
			ElseIf dealer.mouseInSet()
				distributeCards()
			EndIf
		
		End Method
		
		Method distributeCards()
			Local x:Int, y:Int
			Local column:Int
			Local row:Int
			Local cardPos:Int
			Local suit:Int
			If Not playField.emptyStacks()
				Local supply:tsupply = dealer.getASet()
				If supply
					Local card:tcard[] = supply.extractCard()
					column = 0
					While card
						playField.stackPeekFrontCard(cardPos,suit, row, column)
						card[0].setface(FRONT)
						playfield.getStackNextXY(x,y,column)
						Local animated:TanimatedCard = TanimatedCard.Create(card,x,y,CARD_SPEED,column)
						animation.AddAnimation(animated)
						card:tcard = supply.extractCard()
						dealing = True
						column :+ 1
					Wend
					count :+ 1
				EndIf
			Else
				'notify that there is an empty stack not able to deal the set
			EndIf							
		
		End Method
		
		Method positionCards(stackNo:Int,state:Int)
			Local number:Int
			Local number2:Int
			Local suit:Int
			Local index:Int
			Local oldFace:Int
			Local x:Int,y:Int
			Local oldStackNo:Int
			Local card:Tcard[]
			mouseStack.peekFirst(number,suit) ' get the card number of the back(last) card and the stack number it came from
			Local tn:Int = playField.stackPeekFrontCard(number2,suit, index, stackNo) ' get the card number of the front card(first) in the stack and the card suit. 
			If number+1 = number2 ' if  the card in the stack is one less than  the card  being placed next to it, process.
				mouseStack.extractAllCards(card,oldStackNo,oldFace) ' remove all cards from mouse stack
				playField.addCardsToStack(card,stackNo)
				If stackNo &lt;&gt; OldStackNo
					playfield.StackFaceFrontCard(OldStackNo)
				EndIf
				If playField.StackCompleteSuit(stackNo)
					card = playfield.stackExtractFrontCard(stackNo)
					Repeat 
						dump.getNextXY(x,y)
						Local animated:TanimatedCard = TanimatedCard.Create(card,x,y,CARD_SPEED,stackNo)
						animation.addAnimation(animated)
						If card[0].number = KING Exit
						card = playfield.stackExtractFrontCard(stackNo)
					Forever
					playField.StackFaceFrontCard(OldStackNo)
					dumping = True
				EndIf	
			ElseIf tn = 0
				mouseStack.extractAllCards(card,oldStackNo,oldFace) ' remove all cards from mouse stack
				playField.addCardsToStack(card,stackNo)
				If stackNo &lt;&gt; OldStackNo
					playfield.StackFaceFrontCard(OldStackNo)
				EndIf
			
			Else
				mouseStack.extractAllCards(card,stackNo,oldFace)
				If card
					playfield.getStackNextXY(x,y,StackNo)
					Local animated:TanimatedCard = TanimatedCard.Create(card,x,y,CARD_SPEED,stackNo)
					If card.length  &gt; 1 Then animated.setSpacing(0,20)
					animation.addAnimation(animated)
					dealing = True
				EndIf
			EndIf
		End Method
	
		Method update()
			Local card:tcard[]
			Local index:Int
			Local x:Int,y:Int
			Local stackNo:Int
			Local cardPos:Int
			Local OldStackNo:Int
			Local oldFace:Int
			
			If dealing = True 'auto moving  cards from dealer to playfield stacks &amp; from mouse to playfield stacks
				dealingCards()
			ElseIf dumping = True 'auto moving complete suits from playfield to dump Area.
				dumpingCards()

'-------------------------determines how many sets to pre-deal fase down ---------------				
			ElseIf count &lt; 5'prepare playe field with 4 x 10 cards set face down.
				dealFaced(BACK)
'-------------------------next set pre-deals fase up -----------------------------------
			ElseIf count &lt; 6 'set number 4 10 card face up
				dealFaced(FRONT)
				
			ElseIf Mouse.ButtonActivated()
				getcards()
			ElseIf mouse.ButtonReleased()
				If mouseStack.isActive()
					If playfield.getMouseCardIndexes(StackNo,cardPos)
						positionCards(stackNo,cardPos)
					Else
						mouseStack.extractAllCards(card,stackNo,oldFace)
						playfield.getStackNextXY(x,y,StackNo)
						Local animated:TanimatedCard = TanimatedCard.Create(card,x,y,CARD_SPEED,stackNo)
						animation.addAnimation(animated)
						dealing = True
					EndIf
				EndIf
			EndIf
	End Method
	
	Method display()
		playfield.display()
		dealer.display()
		dump.display()
		If mouseStack.isActive() Then mouseStack.display()
		animation.display()
	End Method
End Type
</textarea><br>"game.bmx"<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
 '
' 
'
SuperStrict
Framework BRL.GLMax2D

Import MaxGui.Drivers
Import BRL.EventQueue

Import BRL.StandardIO
Import BRL.RETRO
Import BRL.PNGLOADER
Import BRL.BLITZ
Import BRL.Timer

Include "Tmouse.bmx"
Include "game.bmx"


Type TApplet 

	Method OnEvent(Event:TEvent) Abstract

	Method Run()
		AddHook EmitEventHook,eventhook,Self
	End Method

	Function eventhook:Object(id:Int,data:Object,context:Object)
		Local event:TEvent = TEvent(data)
		Local app:TApplet = TApplet(context)
		app.OnEvent( event )
		Return data
	End Function

End Type

Type TSolitaireApplet Extends TApplet
	
	Field timer					:TTimer
	Field window					:TGadget
	Field canvas					:TGadget
	Field GameMenu				:TGadget
	Field DealMenu				:TGadget
	Field helpMenu				:TGadget
	Field gameMenuUndoItem			:TGadget
	Field gameMenuNextROwItem		:TGadget
	Field gameAvailablemoveItem		:TGadget
	Field game					:Tgame
	Field MouseInUse				:Int
	Field seed					:Int
	
	Const MENU_NEW				:Int=101
	Const MENU_RESTART				:Int=102
	Const MENU_UNDO				:Int=103
	Const MENU_DEAL				:Int=104
	Const MENU_MOVE				:Int=105
	Const MENU_DIFFICULTY			:Int=106
	Const MENU_STATISTICS			:Int=107
	Const MENU_OPTIONS				:Int=108
	Const MENU_SAVE				:Int=109
	Const MENU_LAST_SAVED			:Int=110
	Const MENU_EXIT				:Int=111
	Const MENU_ABOUT				:Int=112
	
	Method Draw(event:TEvent)
		
		SetGraphics CanvasGraphics(canvas)
		SetClsColor 31,98,10
		Cls
		If game game.display()
		Flip()
		
	End Method
	
	Method OnEvent(event:TEvent)
	
		mouse.Load(event)
		Select event.id
			Case EVENT_WINDOWCLOSE, EVENT_APPTERMINATE
				End
			Case EVENT_MENUACTION
				Select Event.Data
					Case MENU_NEW
						seed = Rand(10000)
						SeedRnd seed
						game = New Tgame
						EnableMenu gameMenuNextROwItem
						EnableMenu dealMenu						
					Case MENU_RESTART
						SeedRnd seed
						game = New Tgame
					Case MENU_DEAL
						game.DistributeCards()
					Case MENU_UNDO
						'game.undo()
					Case MENU_ABOUT
						Notify "Spider Remake~n Designed by Jesse Jan 2009"
					Case MENU_EXIT
						End
				End Select
			Case EVENT_TIMERTICK
				RedrawGadget( canvas )
			Case EVENT_GADGETPAINT
				If (event.source = canvas) Then Draw(event)
		End Select
		If game
			If game.enableUndo = True
				DisableMenu GameMenuUndoItem
				UpdateWindowMenu window
				game.enableUndo = False
			ElseIf game.disableUndo = True
				EnableMenu gameMenuUndoItem
				UpdateWindowMenu window
				game.disableUndo = False
			EndIf	
			game.update()
			'If game.supplyEmpty()
			'	DisableMenu gameMenuNextROwItem
			'	DisableMenu dealMenu
			'	UpdateWindowMenu window
			'EndIf
		EndIf	
				
	End Method
	
	Method Create:TSolitaireApplet(name$)
		
		window = CreateWindow( name, 20, 20, 1024, 768 )
		Local w:Int = ClientWidth(window)
		Local h:Int = ClientHeight(window)
		
		canvas = CreateCanvas( 0, 0, w, h, window )
		SetGadgetLayout( canvas, EDGE_ALIGNED, EDGE_ALIGNED, EDGE_ALIGNED, EDGE_ALIGNED )
		
		GameMenu=CreateMenu("&amp;Game",0,WindowMenu(window))
		CreateMenu"&amp;New Game",MENU_NEW,GameMenu,KEY_F2
		CreateMenu"&amp;Restart This Game",MENU_RESTART,gamemenu
		CreateMenu"",0,GameMenu
	
		GameMenuUndoItem  = CreateMenu("&amp;Undo",MENU_UNDO,GameMenu,KEY_Z,MODIFIER_COMMAND)
		gameMenuNextROwItem = CreateMenu("Deal Next Row",MENU_DEAL,GameMenu,KEY_D)
		gameAvailablemoveItem = CreateMenu("Show An Available Move",MENU_MOVE,GameMenu,KEY_M)
		CreateMenu"",0,GameMenu
		CreateMenu"Dificulty...",MENU_DIFFICULTY,GameMenu,KEY_F3
		CreateMenu"Statistic..",MENU_STATISTICS,GameMenu,KEY_F4
		CreateMenu"Option..",MENU_OPTIONS,GameMenu,KEY_F5
		CreateMenu"",0,GameMenu
		CreateMenu"Save This Game",MENU_SAVE,GameMenu,KEY_S,MODIFIER_COMMAND
		CreateMenu"Open Last Saved Game",MENU_LAST_SAVED,GameMenu,KEY_O,MODIFIER_COMMAND
		CreateMenu"",0,GameMenu
		CreateMenu"Exit",MENU_EXIT,GameMenu

		DealMenu=CreateMenu("Deal",MENU_DEAL,WindowMenu(window))
		HelpMenu=CreateMenu("&amp;Help",0,WindowMenu(window))
		CreateMenu "&amp;About",MENU_ABOUT,HelpMenu
		DisableMenu GameMenuUndoItem
		DisableMenu gameMenuNextROwItem
		DisableMenu gameAvailablemoveItem
		DisableMenu dealMenu
		UpdateWindowMenu window
		timer = CreateTimer( 100 )
		Run()
		
		Return Self
		
	End Method
	
End Type

AutoMidHandle True

Local Spider:TSolitaireApplet = New TSolitaireApplet.Create("Spider Solitaire")

Repeat
	WaitSystem()
Forever
</textarea><br><br>"tmouse.bmx"<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Const	BUTTONDEACTIVATED		:Int =  3
Const BUTTONDOWN				:Int =  2
Const	BUTTONPRESSED			:Int =  1
Const	BUTTONFREE				:Int =  0

Const	REPEATTIME	:Int =250 'in milliseconds
Global	mouse	:tmouse = New Tmouse

Type Tmouse

	Field x						:Int,..
			y						:Int,..
			Pressed				:Int,..
			Released				:Int=7,..
			DoublePressed		:Int,..
			mousewheel			:Int	
	
	Field	oldx					:Int,..
			oldy					:Int,..
			oldpressed			:Int,..
			oldReleased			:Int=7,..
			oldmousewheel		:Int

	Field	turnDifference		:Int,..
			selected				:Int
	
	Field	state					:Int[]=[3,3,3],..
			ClickCount			:Int[3],..
			endtime				:Long[3],..
			oldevent				:TEvent

	' loads all of the mouse processes such as 
	' mouse x, y, z, buttons and click, double, double click.
	' mouse pressed, used and released.
	' needs be called at the beginning of each frame.

	Method Load(event:TEvent) 
		oldx = x
		oldy = y
		Select event.id
			Case EVENT_MOUSEDOWN
				Local q:Int = (1 Shl (event.data-1))
				Local xored:Int = oldreleased ~ q
				released = released &amp; xored 
				Pressed = pressed | q
				
			Case EVENT_MOUSEUP
				Local q:Int = (1 Shl (event.data-1))
				Local xored:Int = pressed ~ q
				pressed = pressed &amp; xored
				Released = released | q
			Case EVENT_MOUSEWHEEL
				oldmousewheel = mousewheel
				mousewheel = Event.Data 'MouseZ() 
			
			Case EVENT_MOUSEMOVE
				x = event.x
				y = event.y
		End Select
		For Local b:Int = 0 To 2
			Local bt:Int = 1 Shl b
			If oldpressed &amp; bt
				If pressed &amp;  bt
					state[b] = BUTTONDOWN
				Else
					state[b] = BUTTONDEACTIVATED
				EndIf
			ElseIf pressed &amp; bt
				state[b] = BUTTONPRESSED
			Else
				state[b] = BUTTONFREE
			EndIf
			
			DoublePressed = False
		
			If state[b] = BUTTONPRESSED
				If ClickCount[b] = 0
			
					ClickCount[b] = 1 'first click
					endtime[b] = MilliSecs() + REPEATTIME
			
				Else 'second click
			
					If MilliSecs() &lt; endtime[b] 
						DoublePressed = True 
					EndIf
					ClickCount[b] = 0
			
				EndIf
			ElseIf MilliSecs() &gt; Endtime[b]

				ClickCount[b] = 0

			EndIf
		Next
		oldpressed = pressed
		oldreleased = released
	End Method
	' checks if mouse cursor is with in a specified area
	' h = start x
	' v = start y
	' width of area
	' height of area
	' returns true if in area false if not	

	Method InArea:Int(h:Int, v:Int, width:Int, height:Int)	

		If x &lt; h Return False
		If x &gt; (h+Width) Return False
		If y &lt; v Return False
		If y &gt; (v + Height) Return False
		Return True

	End Method
	
	' returns mouse x and y position
	' through input variables a and d.

	Method GetXY(a:Int Var, d:Int Var)

		a=Self.x
		d=Self.y

	End Method
	
	'returns true if a mouse "double click" was completed with in current cycle frame. 	

	Method doubleclick:Int(selected:Int = 1)
		selected :- 1
		selected :&amp; 3
		
		Return (DoublePressed Shr selected) &amp; 1

	End Method
	
	' returns true if a specified mouse button is still pressed based on previos frame.
	
	Method ButtonInUse:Int(selected:Int = 1)
	 	selected :- 1
		selected :&amp; 3

		If state[selected] = BUTTONDOWN
			Return True
		EndIf
		Return False

	End Method
	
	' returns true if the pre-specified mouse button was pressed on current frame.
	
	Method ButtonActivated:Int(selected:Int = 1)
		selected :- 1
		selected :&amp; 3
		If state[selected] = BUTTONPRESSED
			Return True
		EndIf
		Return False

	End Method
	
	'returns true if a pre-specified buttone was released in current cycle
	
	Method ButtonReleased:Int(selected:Int = 1)
		selected :- 1
		selected :&amp; 3
		
		If state[selected] = BUTTONDEACTIVATED
			Return True
		EndIf
		
		Return False

	End Method
	
	Method Buttonfreed:Int(selected:Int = 1)
		Selected :- 1
		selected :&amp; 3
		
		If state[selected] = BUTTONFREE
			Return True
		EndIf
		
		Return True
	
	End Method
	
	'return true if the mouse button was moved based on previos frame and current frame.
	
	Method moved:Int()

		If oldx &lt;&gt; x Return True
		If oldy &lt;&gt; y Return True
		Return False

	End Method
	
	' same as above but for x only
	
	Method MovedX:Int()

		If oldx &lt;&gt; x Return True
		Return False

	End Method 
	
	' same as above but for y only
	
	Method movedy:Int()

		If oldy &lt;&gt; y Return True
		Return False

	End Method
	
	' returns mouse speed(difference between current frame x and previous frame x
	
	Method Thrustx:Int()

		Return x - oldx

	End Method
	
	' returns mouse speed(difference between current frame y and previous frame y
	
	Method Thrusty:Int()

		Return y - oldy

	End Method
	
	' returns mouse wheel speed based on current frame and prvious frame position.
	
	Method wheelThrust:Int() 
		
		Return mouseWheel - oldMouseWheel		

	End Method

End Type

</textarea><br><br><img src="http://www.hexobot.com/images/carddeck.png"><br><br><font class="tiny">Last edited 2010</font><br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="1053411"></a>

<a name="1053416"></a>

<a name="1053431"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> it will be easy to modify to not use "mouse.bmx"  but I didn't bother, sorry. I forgot, put the image in a folder and name it "gfx". the game requires MaxGUI to work.<br><br><font class="tiny">Last edited 2010</font> <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
