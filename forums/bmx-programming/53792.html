<!DOCTYPE html><html lang="en" ><head ><title >Tlist Compare, Sort, and Contains, or Why God Why</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Tlist Compare, Sort, and Contains, or Why God Why</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Tlist Compare, Sort, and Contains, or Why God Why</a><br><br>
<a name="600910"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Warpy</td><td align="right"><font class=tiny>(Posted 2005)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, so I'm overriding the Compare method in one of my types so I can sort a list of them easily using Tlist.Sort(). So far so good, easy stuff, works. Now when it comes to using Tlist.Contains() on the same set of objects, everything breaks. Looking at linkedlist.bmx, Contains() checks if Compare() returns 0 for each item in the list, assuming that means they're the same. Obviously, as I've overridden Compare(), it will return 0 for things that aren't exactly the same object. Everything breaks; I'm not happy.<br><br>I can't think of a way round this, other than writing my own version of either Sort or Contains. Is there a sensible reason why Contains uses _value.Compare(value) and not just _value=value?<br><br><br>Edit: I'm an eejit, it was returning null because the thing was actually null :P<br>And I now see Compare() in Contains would always work because it's using Object.Compare(), not whatever I've got. <br><br></td></tr></table><br>
<a name="647299"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sören</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Bump<br><br>"And I now see Compare() in Contains would always work because it's using Object.Compare(), not whatever I've got."<br><br>No it doesn't, because it will use the overridden version of Compare() in MyObject (derived from Object (right?)).<br><br>So, <br><br>"Is there a sensible reason why Contains uses _value.Compare(value) and not just _value=value?" <br><br></td></tr></table><br>
<a name="647421"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Chris C</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> because = is mathmatically equals, where as compare is user defined (by default it subtracts variable pointers) being able to override it (and needing to do _value.compare(value)) makes it very much more flexible and very powerful <br><br></td></tr></table><br>
<a name="647437"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Is there a sensible reason why Contains uses _value.Compare(value) and not just _value=value? <br></div><br><br>Contains does not do what you think it does, or what the help file says it does.<br><br>BlitzMax uses the term "value" to refer to the object a link points to, but it also uses it to refer to the "value" of that object, and the "value" of the OBJECT is whatever the object's compare() method says it is.<br><br>Here, "value" is referring to the OBJECT's value, not the value of the link.  So the help file is wrong.<br><br>In other words, if your compare function is set up to use the sprite's draw order as its "value" then Contains tells you the first sprite it comes across that has a particular order.<br><br>I don't know why they did it this way, and the help file is damn confusing with regards to it, but that's what's happening.  If you're using a for eachin loop, you'll probably be better off setting up your own loop with while wend to loop through the list one member at a time so you can compare them properly. <br><br></td></tr></table><br>
<a name="647458"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >FlameDuck</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> "Is there a sensible reason why Contains uses _value.Compare(value) and not just _value=value?" <br></div>Because two different objects might be identical, without being the same physical object?<br><pre class=code>Type Vector
	Field x:Int , y:Int
EndType

Local vect1:Vector = New Vector
Local vect2:Vector = New Vector

vect1.x = 200
vect2.x = 200

vect1.y = 30
vect2.y = 30

Print vect1 = vect2</pre> <br><br></td></tr></table><br>
<a name="647523"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Michael Reitzenstein</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think we need two functions, ContainsReference and ContainsValue. I can see the merit in a contains value function but I really don't see why its the default-and-only! <br><br></td></tr></table><br>
<a name="647551"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> If you want it to be value identical, you could do the compare that way. Mine for example only returns 0 if the value references are identical. Otherwise it only returns 1 and -1.<br><br>Reason: Remove bases on compare as well, if you return 0 for anything beside reference identities, you will have BAD problems, when you ever ask yourself why stuff is in lists, that you removed before ... <br><br></td></tr></table><br>
<a name="647599"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> WTF?  I'm confused now, and concerned that there might be a serious problem with my code.<br><br>Here's some internal code from BlitzMax:<br><br><pre class=code>
Rem
bbdoc: Remove an object from a linked list
about: #RemoveLink is more efficient than #ListRemove.
end rem
Function RemoveLink( link:TLink )
	link.Remove
End Function
</pre><br><br><b>"Remove an object from a linked list"</b><br><br>There aren't a whole lot of ways that can be interpreted.  So we should assume this is intended to remove the link passed to the function right?<br><br>So what does that method it is calling do?<br><br><pre class=code>
	Rem
	bbdoc: Remove an object from a linked list
	about: Remove scans a list for the specified value and removes its link.
	End Rem
	Method Remove( value:Object )
		Local link:TLink=FindLink( value )
		If Not link Return False
		link.Remove
		Return True
	End Method
</pre><br><br>Once again, "remove an object form a linked list".<br><br>So what does that findlink method do?<br><br><pre class=code>
	Rem
	bbdoc: Returns the first link in the list with the given value, or null if none found.
	End Rem
	Method FindLink:TLink( value:Object )
		Local link:TLink=_head._succ
		While link&lt;&gt;_head
			If link._value.Compare( value )=0 Return link
			link=link._succ
		Wend
	End Method
</pre><br><br>Oh wonderful.  It uses the compare method of the link's value! <br><br><br><pre class=code>
	Rem
	bbdoc: Sort a list in either ascending (default) or decending order.
	about: User types should implement a Compare method in order to be sorted.
	End Rem
	Method Sort( ascending=True )
		Local term:TLink=_head
		Repeat
			Local link:TLink=_head._succ
			Local sorted=True
			Repeat
				Local succ:TLink=link._succ
				If succ=term Exit
				Local cc=link._value.Compare( succ._value )
				If (cc&gt;0 And ascending) Or (cc&lt;0 And Not ascending)
					Local link_pred:TLink=link._pred
					Local succ_succ:TLink=succ._succ
					link_pred._succ=succ
					succ._succ=link
					succ._pred=link_pred
					link._succ=succ_succ
					link._pred=succ
					succ_succ._pred=link
					sorted=False
				Else
					link=succ
				EndIf
			Forever
			If sorted Return
			term=link
		Forever
	End Method
</pre><br><br><b>"User types should implement a Compare method in order to be sorted."</b><br><br>It seems to me that this behavior of the linked list system using the compare method to determine if links should be removed makes the sort function entirely WORTHLESS, because the ONLY way to use the linked list system is to leave the compare method ALONE.  Otherwise it is impossible to remove links after they have been created, EVEN if you SAVE THE LINKS!<br><br>Also, what the hell is the point of saving the link pointer if the thing SEARCHES THE WHOLE LIST TO FIND THE LINK TO BE REMOVED ANYWAY?  "More efficient" indeed.  Comparing the value of one link to all the other linkes is HARDLY more efficient than comparing the value of the value of a link to the value of the value of another link.<br><br>I guess someone's gonna have to write up a test app to make sure this is really the case, but it sure seems like it unless I'm misinterpreting the code above. <br><br></td></tr></table><br>
<a name="647609"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Whats your problem?<br>don't see any problem with the way it is implemented.<br>Compare is used to find an element in a list, no mather if you search for the link pointing to that element or for the value itself.<br><br>The fact is that the way BM does that, is the best possible I could think of!!<br>Because in OO, the definition of "the same" is very dependant of the subject or the system they are used in. For integers, the same is very clear, as they are the same value.<br><br>But what if you have a class "Car". What makes them the same? Their color? The manufacturer? The model? The owner? Or an arbitrary combination of those?<br><br>Without the compare, "the same" would be a quite useless terminology.<br><br>If you want it to return reference equalness, then you can implement that in the compare, as you can any other wished behavior.<br>Its just a mather of planning and your softwares design.<br><br>And that it needs the compare to order and find is logical if you only have the least idea of OO design.<br><br>Sort: Think that does not need an explanation<br>Find: How would you find out when you can stop searching if you don't know if you already passed the point, where the object should be? (as long =1 you haven't reached it, if =-1 then you passed the point and thus return null)<br><br><br>And if youy use TLink.remove() it does NOT search the whole list to remove it. It removes the link and links _succ and _prev to maintain the double linked list structure.<br>If you need to do internal stuff on the List, then using the TLink is the way (or if you want to search a specific object, do some operations on it and the remove it without researching it in the list to readd it at the end, like you do in GUI systems with draging windows etc.)<br><br><br>If you need any other help, feel free to mail me and I will try to help you. But it has no use if you come up with "why the heck" just because you seem to have no full understanding in OO design and still think on procedural somehow (at least it seems so. sorry if I'm wrong)<br>Believe us, if the implementation was crap, we would have done our job in bringing up a better implementation that had replaced the BRL one long times ago! <br><br></td></tr></table><br>
<a name="647613"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here is a test program.  I haven't been able to get it to screw up, and I don't know why:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Type Sprite

	Global SpriteList:TList = CreateList()

	Field _Link:TLink
	Field _Number%
	Field _Order%
	

		Function Create:Sprite(Number%, Order%)
	
			Local NS:Sprite
			
			NS = New Sprite
			NS._Link   = SpriteList.AddLast(NS)
			NS._Number = Number
			NS._Order  = Order
	
			Return NS
	
		End Function


		Method Compare%(OtherObject:Object)

			Local OtherSprite:Sprite = Sprite(OtherObject)
			If OtherSprite = Null Then Return 0
																																																																																																																																																																																																																																																																																																																																														
			Return _Order - OtherSprite._Order
			
		End Method
	
	
		Method Free()
			RemoveLink _Link
			_Link = Null	
		End Method
		
		
End Type



Sprite1:Sprite = Sprite.Create(1, 0)
Sprite2:Sprite = Sprite.Create(2, 0)
Sprite3:Sprite = Sprite.Create(3, 0)
Sprite4:Sprite = Sprite.Create(4, 0)

Sprite3.Free()
Sprite3 = Null

For ThisSprite:Sprite = EachIn Sprite.SpriteList
	Print ThisSprite._Number
Next
</textarea><br><br><br><div class="quote"> <br>But what if you have a class "Car". What makes them the same? Their color? The manufacturer? The model? The owner? Or an arbitrary combination of those?<br><br>Without the compare, "the same" would be a quite useless terminology.<br> <br></div><br><br><br>I don't understand what you are saying.<br><br>Look at my example above.  In it I create four sprites.  Each of the four sprites has the SAME order in my example, but really their order could be anyhting.  <br><br>I want to sort them by ORDER.  So I change the compare method so that the SORT() method will work. <br><br>But if I understand what Mark's code is doing, when I overrode that compare method, the REMOVE method now uses that instead, and if I pass it a link pointer to tell it to delete a specific sprite, it will compare that to the ORDER of the other sprites, and should in theory always return false.<br><br>Of course now I am totally unsure of whether I have that right because I can't get my test program to screw up.<br><br><div class="quote"> <br>And if youy use TLink.remove() it does NOT search the whole list to remove it.<br> <br></div><br><br>Ohhh yes it does.<br><br><pre class=code>
	Method Remove( value:Object )
		Local link:TLink=FindLink( value )
		If Not link Return False
		link.Remove
		Return True
	End Method

	Method FindLink:TLink( value:Object )
		Local link:TLink=_head._succ
		While link&lt;&gt;_head
			If link._value.Compare( value )=0 Return link
			link=link._succ
		Wend
	End Method
</pre><br><br><br><br>See?  The remove method uses findlink, even though we are passing it the pointer to the exact link that needs to be removed.  And Findlink does a while loop to loop through the whole list looking for a link whose value (which is dtermined by the compare method I overrode to use order?) is the same as the specified link.<br><br>So yes, it definitely is looping through the entire list when you use remove. <br><br></td></tr></table><br>
<a name="647619"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Also, I'm not sure Mark's findlink code there is even correct.<br><br>Correct me if I'm wrong but:<br><pre class=code>Local link:TLink=_head._succ</pre><br><br>This sets Link to be the sucessor of the head of the list, correct?<br><br>Wouldn't that mean we're starting our search at the SECOND link in the list?  <br><br>Why start there instead of at the first link in the list?<br><br><pre class=code>While link&lt;&gt;_head
link=link._succ
wend</pre><br><br>Okay, so if we started at the first link, the while loop would exit immediately.  It seems then like Mark intended to loop through the list in reverse order, from the end, back to the head, and to stop when it reaches the head.<br><br>But link=link._succ indicates that he is looping through the list in a FORWARD direction, and starting from the second link as indicated above no less.<br><br>I really haven't got a clue what the hell is going on here.<br><br>If I were to code this function the way I think it's supposed to work, I think it would look like this:<br><br><pre class=code>
Method FindLink:TLink( value:Object )
		Local link:TLink=_head
		While link&lt;&gt;Null
			If link._value.Compare( value )=0 Return link
			link=link._succ
		Wend
	End Method
</pre><br><br>Now it starts at the beginning of the list, and loops through all the elements till it reaches the end which is denoted by Null. <br><br></td></tr></table><br>
<a name="647620"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well I can't seem to get that example to screw up no matter what I do.  I guess I must have some misunderstanding here about how the compare override works.  <br><br>Shouldn't link._value.Compare( value ) be using the Compare value of my sprite?<br><br>Is not "_value" here, the pointer to my sprite type?  So would not _value.compare() execute the sprite's compare method?<br><br>What's going on here? <br><br></td></tr></table><br>
<a name="647622"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brendane</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> The RemoveLink() function does this - which decrements the ref to the object (_value) and updates the prev/next links. It isn't calling the function you thought it was Shawn.<br><br><pre class=code>
	Rem
	bbdoc: Removes the link from the List.
	End Rem
	Method Remove()
		_value=Null
		_succ._pred=_pred
		_pred._succ=_succ
	End Method
</pre> <br><br></td></tr></table><br>
<a name="647624"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Wait a minute...<br><br>There are two remove methods in the tlist source file!<br><br><pre class=code>
Type TLink
	Method Remove()
		_value=Null
		_succ._pred=_pred
		_pred._succ=_succ
	End Method
End Type

Type TList Extends TData
	Rem
	bbdoc: Remove an object from a linked list
	about: Remove scans a list for the specified value and removes its link.
	End Rem
	Method Remove( value:Object )
		Local link:TLink=FindLink( value )
		If Not link Return False
		link.Remove
		Return True
	End Method
End Type
</pre><br><br><br>I see now.  <br><br>ThisSprite.Remove() calls the first one. <br>The RemoveLink() function also calls the first one.<br><br>And Sprite.SpriteList.Remove() would call the second one.  <br><br><br>Well I blame this half on my stupidity.  But I also place half the blame on Mark.  Using the term VALUE to refer to both the object a link points to, and the value of that object has just been confusing the hell out of me from day 1.  <br><br>I guess I shouldn't have flown off the handle so quick, but after that other fiasco with being unable to find previous and next links from within an EachIn loop, I was ready to believe the problems ran deeper than that.<br><br>I think I'll have to start over from scratch looking at this fellows problem now that I have a little better understanding what is going on. <br><br></td></tr></table><br>
<a name="647625"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brendane</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> I agree. It would be more appropriate to call _value, "object" or something similar - since it is in fact, an object.<br><br>May I also take this opportunity to have another dig about the absolute TRASH that is the "documentation" supplied with BlitzMax. Sort it out fellas. <br><br></td></tr></table><br>
<a name="647626"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Okay so looking at contains again:<br><br><pre class=code>
	Rem
	bbdoc: Check if list contains a value
	returns: True if list contains @value, else false
	end rem
	Method Contains( value:Object )
		Local link:TLink=_head._succ
		While link&lt;&gt;_head
			If link._value.Compare( value )=0 Return True
			link=link._succ
		Wend
		Return False
	End Method
</pre><br><br><br>Contains uses the compare method of the object you placed in the linked list.  So contains would tell me if my list contains a sprite with order 5.  But it would not tell me if my list contains my ship sprite.  <br><br>(Unless I didn't have a compare function, or wrote one that compared the object pointers.)<br><br><br>The reason Warpy and I have been getting confused is the stupid "Value" variable name Mark has used all over the place:<br><br>In this case, Value is the object you want to place in the linked list:<br>Method AddFirst:TLink( value:Object )<br><br>In this case, Value is the value of the object you placed in the linked list according to that object's compare method:<br>Method Contains( value:Object )<br><br>That is way too confusing, and should be changed. <br><br></td></tr></table><br>
<a name="647629"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brendane</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> I see your point. Surely the TList.Contains() method should be checking that link._value = value.   Mark?<br><br>As an extra thought Shawn. When you call Sprite.Remove() I presume it is calling link.Remove() (assuming the sprite is referencing its own link in the Sprite list).<br><br>If you do not set the Sprite.link to Null within Sprite.Release() - will the link ever be released? (or will it be released once the sprite is garbage collected?) <br><br></td></tr></table><br>
<a name="647632"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> It's actually Sprite.Free() and it does set Sprite._Link to Null.  <br><br>You are correct, if I did not do that, then the link created in the list would never truly be freed, and the sprite itself would continue to exist as well because the link would point back to it. <br><br></td></tr></table><br>
<a name="647636"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brendane</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks. Just trying confirm with myself how the gc system works.<br><br>Well, in your case had you not set the _Link to Null, the link would persist, but the Sprite would be removed ok (since calling TLink.Remove() will set the _value to Null) <br><br></td></tr></table><br>
<a name="647637"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well if that's the case, yeah.<br><br>Hm... In that case, maybe setting _Link to Null is not neccessary.  If I don't set _Link to null, but I do tell the list to remove the link, then if the list nulls ouf the link back to the sprite, and you set your own link to the sprite to null after calling the free function, then there is no longer a link to the sprite, and the garbage collector should remove the sprite... which would in turn remove the link which hasn't been freed yet. <br><br></td></tr></table><br>
<a name="647657"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brendane</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm sure something just popped in my head whilst reading that ;)<br><br>I'd stick with setting _Link to Null - just to be on the safe side :) <br><br></td></tr></table><br>
<a name="647661"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brendane</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> I understand the TList.Contains() method now.<br>But it's completely mis-documented. Par for the course really.<br><br>The gist of the method is to see whether a list contains an object which is 'comparably equal' to the object being passed into the call. But NOT, as the doc/method name suggests, to check whether a list CONTAINS the ACTUAL object in question.<br><br>In order to test for that condition (a list containing a specific object) you should call TList.FindLink( object ) - which returns Null if the object is not in the list<br><br>I wonder if BRL are actually listening to the complaints about documentation. <br><br></td></tr></table><br>
<a name="647668"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here is how your compare should look like:<br><br><pre class=code>
Method Compare%(OtherObject:Object)
	Local OtherSprite:Sprite = Sprite(OtherObject)
	If self = OtherSprite	return 0
	if _Order &gt;= OtherSprite._Order
		return 1
	endif
	return -1										
End Method</pre><br><br>There were 3 main errors in:<br><br>1. Creating lists of differing types can't use compare (only reference pointer equalnes is counted on them) and are thus useless beside "reference ensuring", no mather what you do. They must at least extend the same basetype which has the compare implemented to be of real use with lists.<br><br>2. 0 must only be returned if the references are identical<br>3. due to 2, return something - something is not adviceable, because it can as well return 0 -&gt; break.<br><br>All 3 things are taken into account in the above method.<br>I assumed that you only want to count objects the same if they point to the same object actually, not if the have the same _Order.<br>The return 1 on &gt;= does not destroy the relative order within a layer (nor would &gt; and &lt;= btw. As long as = can't return 0 TList methods will work)<br><br><br>Most problems and errors connected to TList result out of compare method with return something - something which can return 0 and thus breaks the whole list or more than 1 equality, which points to a design error in the software system itself.<br><br>Hope the compare method helps you :-) <br><br></td></tr></table><br>
<a name="647678"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Chris C</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> errmmm<br><br>shouldnt<br>if _Order = OtherSprite._Order <br><br>return 0??? <br><br></td></tr></table><br>
<a name="647680"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> Dreamora:<br>There you go telling me my compare method is wrong again.  But I already told you before, I based my compare method on one of the examples.<br><br>Look at this page in the Wiki, which is the same as the information in the BlitzMax docs under Objects:<br><a href="http://www.blitzwiki.org/index.php/Objects" target="_blank">http://www.blitzwiki.org/index.php/Objects</a><br><br><div class="quote"> <br>Returns a value less than 0 if an object is less than another object, a value greater than 0 if an object is greater than another object or the value 0 if an object equals another object.<br> <br></div><br><br>As for your point 1, I don't care about that, I don't plan on making lists that contain more than one kind of type.<br><br>As for point 2, 0 must be returned only if the references are identical...  I think you mean the value of the object... in this case the order.  My code does that.<br><br>As for point 3, being in conflict with 2, that's absurd.<br><br><br>If Object 1 has an order of 5, and Object 2 has an order of 5, then Compare should return 0 because they are the same.  5-5 = 0<br><br>If Object 1 has an order of 10 and Object 2 has an order of 5, then Compare should return a value greater than 0.  10-5 = 5 which is greater than 0.<br><br>If Object 1 has an order of 5 and Object 2 has an order of 10, then Compare should return a value less than 0.  5-10 = -5 which is less than 0.<br><br>YOUR example is the one which is broken, because it will never return 0 if the two objects are equal.  It will return 1.  And if it returns 1, then the sorter will always thinks one value is greater than the other.  And that will probably break the sort.  At the very least, it will probably make the sort go from a sort where values do not change position in the list if they don't need to, to one where the values get shuffled when they don't need to be moved at all, and that reduces the efficiency of the sort and can lead to the sprites flipping back and forth which is drawn in front if they have the same orders, rather than it just being whichever was added last which is drawn in front.<br><br>Anyway, maybe I am wrong here, but what you are telling me goes against the docs, and provides no way to determine if two objects have equal value, only if one is less than, or greater than AND equal to.<br><br>Also, I do not see how changing the compare method should break how the list works.  Most of the list functions are accessing the compare method of the link type, not the compare method of the object which the link type points to.<br><br>Btw, I have already tested sorting my sprite list by the order... Look at the example I posted.  It works just fine with compare set up that way.<br><br>Show me an example which breaks with compare set up to use the _order - _order thing. <br><br></td></tr></table><br>
<a name="647698"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> If compare returns 0 for _order = other._order, remove will remove the first with the same order as the searched object, no mather if it is the one you wanted to remove. Same goes for contains.<br><br><br>Sswift: Compare which returns 0 means they are "the same". This means if you look for them through contains / remove, they will be removed, no mather if they are the same as they are "object compare equal" (the only real equalness test on objects). Thats why I restricted 0 to reference qualness. You did not comment in that _Order is a unique value which can't be shared by 2 objects, in which case the return on _order - _order would break with .Remove/.Contains.<br><br>My compare was especially targeted for general usage, where no "reference to TLink" is used.<br><br><br>So in general: My compare works, yours will fail. But in the special circumstances you use yours with the TLink backsave, yours will work as long as you do not use TList.Remove / TList.Contains (perhaps others) as those will fail.<br>You cut of some functionality for speed gains. (I would better add a comment on that, to prevent untrackable bugs later)<br>I only added my method as the talk was on the "general TList usage level" not a specific usage. Sorry if I did not write it like that. <br><br></td></tr></table><br>
<a name="647706"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brendane</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> TList.Remove() is fundamentally flawed anyway. The documentation is wrong (or rather inconsistent with the comments in TLink.Remove() which suggests it is the more effiecient version of TList.Remove() )<br><br>You can't even use TList.FindLink( object ) in order to find the link and remove it using link.Remove() - since TList.FindLink() uses Compare().<br><br>Note, this is only a problem if you override the Compare() function - which you need to do to perform a sort.<br><br>Dreamora: your Compare function is incorrect - Swift has implemented a correct Compare function as per the definition. However - due to the flaws listed above there is a conflict between sorting and finding an object in a list - Mark's fault. <br><br></td></tr></table><br>
<a name="647713"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> How should FindLink find the link for a value without compare?<br><br>What in my version is incorrect? Show me the example that will break it. I use it in several spots and did not get into any trouble.<br>If marks implementation is the wrong one, then I fear that some of the true OO languages available (which are used for critical tasks like airplanes and medic equip), are badly flawed as well, right?<br>Its more that most seem to think of C++ OO as the correct OO which it isn't from the modern point of view. No mather how many things miss in BM, the OO parts it has are at least following the modern OO design rules. <br><br></td></tr></table><br>
<a name="647716"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brendane</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> It breaks on Sorts when two items have the same value but are NOT the same object.<br><br>Let's not debate OO, that is not the issue, nor the problem - I've been programming C++ for over 12 years.<br><br>The point is :-<br>Compare() is used in 2 disparate situations :-<br>1) To act as a value comparator in a Sort. Sswift has implemented it correctly for this.<br>2) To act as a comparator when finding a link in a list.<br><br>It cannot act for both situations without breaking one or the other. It's flawed. <br><br></td></tr></table><br>
<a name="647719"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> I already assumed that this is the reason all believe my version breaks, although it does not.<br>Same value and not same object does not break. Depending on &gt;= or &lt;= it will either place it as first or last object in the listpart where all have this same value. It won't interfer with higher / lower values.<br><br>Its all a question of how you design your code and how much time you put into it. OO is not procedural and naturally needs far more time in planning before writting. But it has its benefits that let you forget this time, you first thought would be wasted.<br><br>Sswifts code is correct for his specific situation (beside the =null check that is not needed) which is trimed for maximum speed on remove of single objects which is a really good usage of the BM possibilities.<br>Mine is targeted to general usage where the list serves other purposes.<br><br>Here the proof that it does not break<br><pre class=code>

Strict

Type Test
	Field value:Int
	Field name:String
	
	Method Compare:Int(other:Object)
		Local obj:Test	= Test(other)
		If obj	= Self		Return 0
		
		If value &gt;= obj.value
			Return 1
		EndIf
		Return -1
	End Method
End Type

Function CreateTest:Test(name:String, value:Int)
	Local result:Test	= New Test
	result.name		= name
	result.value	= value
	Return result
End Function


Global List:TList		= CreateList()

For Local i:Int = 1 To 100
	List.Addlast(CreateTest("In" + i,Rand(0,6)))
Next

List.sort()


For Local t:Test	= EachIn List
	Print Chr(34) + t.name + Chr(34) + " with value: " + t.value + "~n"
Next

End</pre> <br><br></td></tr></table><br>
<a name="647721"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Chris C</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> I remember having this problem and ended up having to have a global sort_mode variable depending on what I was doing, which is a bit of a kludge...<br><br>there should be comparevalue and compareobject methods really I guess? <br><br></td></tr></table><br>
<a name="647723"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> No.<br>Compare is a "object based equality test". If you as the designer of your software are not able to say if 2 objects of the same class are equal or if not, which one is larger, whats the use of any object oriented programming then?<br><br>If your system only takes reference equalness as true equal, then only return 0 then (which indicates equal). If you don't need a that "hard" equalness (there are cases where this might happen although I can't think of any ...), you can return 0 for field equalness or level equalness (on tree structures) or anything your class needs to test for equalness (like same shape, same color, same size -&gt; same geometric object). <br><br></td></tr></table><br>
<a name="647724"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Chris C</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm sorry but your reply doesnt make sence can you re-word it?<br><br>I want to be able to compare values and also have findlink remove etc work... <br><br></td></tr></table><br>
<a name="647726"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brendane</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> Dreamora - what happens if you sort in descending order? <br><br></td></tr></table><br>
<a name="647728"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sören</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> EDIT: Brendane, Dreamora's version works both way. Try his example. :) Thanks for that btw Dreamora. <br><br>I'm guessing the problem is that the TList methods, Compare, Contains, FindLink, etc, doesn't do what the name of the methods, comments in the code and documentation suggest they do (when you override the Compare method in your own type(s)).<br><br>I think most of us expect Contains to check for reference equalness, and only Sort to use Compare(?). <br><br></td></tr></table><br>
<a name="647730"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brendane</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> It works, but you are relying on the Sort function performing it's test in a very specific way. The interface to Compare() is clearly defined - and the usage of that is not appropriate for FindLink() etc.<br><br>What if the sort function implementation was changed and the test was inverted? Your code breaks because you are not conforming to the true definition of Compare() <br><br></td></tr></table><br>
<a name="647733"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> I am conforming:<br><br>1: -&gt; actual object is larger than "other"<br>0: -&gt; object is, depending on the definition, equal to "other"<br>-1: -&gt; actual object is smaller than "other"<br><br>Don't see where this is not following the interface declaration for the method "compare".<br><br>On the FindLink: How should it work out of your sight? How shall it find the tlink whichs value is "OO equal" to the object you use to search the link if it does NOT use compare?<br>As mentioned: the equalness fully depends on the object and is nothing BM should define as it would fully break the OO usability of BM. Eiffel and other modern OO language work the same way.<br>There is no other usefull way than the actual one. <br><br></td></tr></table><br>
<a name="647741"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brendane</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> "depending on the definition" is the key phrase there.<br><br>You are writing your Compare function in order to make FindLink work for your Type. However in your case I cannot call Compare() on 2 (different) instances of your Type in order to test that they are equal.<br><br>In that case I get 1 returned - not 0<br><br>FindLink was surely intended to find the TLink in a list which contains the ACTUAL object - no? It's only really used in TList.Remove() (as far as I can tell) - what sense does it make to use Compare in FindLink? Either that or TList.Remove() should not be using FindLink at all but should be scanning the list for the object to be removed. <br><br></td></tr></table><br>
<a name="647748"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Chris C</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> However in your case I cannot call Compare() on 2 (different) instances of your Type in order to test that they are equal. <br></div><br>exactly the point and an important one! <br><br></td></tr></table><br>
<a name="647775"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brendane</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#40">[#40]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sorry Chris C - are you saying Dreamora's definition of Compare is correct? It's not, I assure you. <br><br></td></tr></table><br>
<a name="647781"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#41">[#41]</a></td></tr></table></td></tr><tr ><td class="posttext"> Compare is not meant to be called to 2 arbitary types.<br>Problem is you can't fix the list to a given "basetype" as BM lacks generics. Thats why I mentioned: Use a basetype from which you extend.<br><br>If you plan to compare any type with each other, your design has a BIG design flaw!<br>In a modern language, the BM way would not even be possible! You would have to use generics to define a fixed type from which everything is extended. Which is the way I suggested as well.<br><br>How would you compare apples with bananas? (as a realworld example) There is no equal between those, not even a usefull possibility to define equalness.<br>You really miss the points behind type safe (modern) OO.<br>This is NOT C++ where you can hack around any stupid and unsecure OO stuff just because C++ does allow it. Thats BM, a language that follows actual OO design rules, not ones that were ok 20 years ago.<br>At least from your postings, I get the real impression that you have not much experience or knowledge in type safe OO design or modern OO in general. If you aren't a Linux user, you hopefully will change this soon and fill the OO knowledge holes ... everywhere beside Linux, C++ will die sooner or later. (OSX: Objective C, Win: C#, All 3: Java)<br><br>Blaming Mark for following modern programming is about the worst antisupport you can give BM!!<br><br>I'm not going to post any further on this topic. Discussing with C++ programmers on modern OO system designs only makes lot of headaches with no real use. I've nothing against C++ as long as they don't want their unsecure, OO breaking pointer-unsafe hick-hacking in "real world" <br><br></td></tr></table><br>
<a name="647822"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brendane</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#42">[#42]</a></td></tr></table></td></tr><tr ><td class="posttext"> Dreamora you have misunderstood. I never said 2 arbitrary Types, I said 2 instances of the same Type.<br><br>Someone please inform me how Dreamora's Compare() correctly informs me when 2 instances of a Type are quantitatively equal.<br><br>ie. <br>item1:Fruit = CreateFruit("apple")<br>item2:Fruit = CreateFruit("apple")<br><br>if item1.Compare( item2 ) = 0<br>   ' fruits are the same!<br>endif<br><br>It's flawed. If you write it to function correctly such that you are comparing the strings, then TList.Remove() on a Fruit does not do what you intend - rather it removes the first item which is comparably equal to the item you intend to remove, BUT not necessarily THE item you intend to remove. <br><br></td></tr></table><br>
<a name="647832"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brendane</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#43">[#43]</a></td></tr></table></td></tr><tr ><td class="posttext"> And for your information BM has more OO holes than a swiss cheese. Constructors anyone? Safe encapsulation? Give me a break. <br><br></td></tr></table><br>
<a name="647834"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#44">[#44]</a></td></tr></table></td></tr><tr ><td class="posttext"> 2 instaces of the same type won't have problems with the compare methode.<br><br>But the definition of "the same" depends on what you see as requirement to call them the same. In most cases this will be reference equality (at least for me so far, have not met something that would make a field based equality usefull), which is why I have the reference check as first part in the compare method and which is the only way my compare can ever return 0 (ie the only case that TList will both accept as beeing equal)<br><br>For your example, this would mean, that 0 would never happen, as the Fruit Compare would do a self = fruit(other) comparision to decide if they are equal which can never be the case for item1 = item2 as those 2 references point to 2 different objects. if that fails, then they can't be equal anymore which means that only 1 and -1 can be returned after that point (the output of those 2 most likely then will depend on fields. in this case depend on the fruits name for example).<br>That only 1 and -1 is returned, using &gt;= and &lt; on the names of the fruits isn't a problem for sorting as well as it won't mix the order between different names. and at which point in a "same name block" a specific instance of an apple ends for example is of no interest for the lists absolute ordering. An apple is an apple :-) <br><br></td></tr></table><br>
<a name="647844"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#45">[#45]</a></td></tr></table></td></tr><tr ><td class="posttext"> "Compare is not meant to be called to 2 arbitary types."<br><br>He didn't say it was.  He said 2 instances of your type.  Ie, two apples.<br><br><div class="quote"> <br>However in your case I cannot call Compare() on 2 (different) instances of your Type in order to test that they are equal.<br> <br></div><br><br>See?<br><br>How can he call your compare and test if the two apples are mathematically equal?  He can't.  With your function you have only mathematically less than, POINTER equal, and mathematically greater than OR equal.<br><br><br><div class="quote"> <br>1: -&gt; actual object is larger than "other"<br>0: -&gt; object is, depending on the definition, equal to "other"<br>-1: -&gt; actual object is smaller than "other"<br> <br></div><br><br>Ah, but your test doesn't follow that definition.  EVEN IF you assume that you can use MATHEMATICALLY greater than or less than for two of the cases, and POINTER EQUAL, your function does not follow the definition because:<br><br><div class="quote"> <br>1: -&gt; actual object is larger than "other"<br> <br></div><br><br><pre class=code>
If value &gt;= obj.value
   Return 1
EndIf
</pre><br><br>You return 1 if actual object is larger than <b>or equal to</b> "other".  And that does not mesh with the definition!<br><br><br>Also, your example is broken!<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict

Type Test
	Field value:Int
	Field name:String
	
	Method Compare:Int(other:Object)
		Local obj:Test	= Test(other)
		If obj	= Self		Return 0
		
		If value &gt;= obj.value
			Return 1
		EndIf
		Return -1
	End Method
End Type

Function CreateTest:Test(name:String, value:Int)
	Local result:Test	= New Test
	result.name		= name
	result.value	= value
	Return result
End Function


Global List:TList		= CreateList()

For Local i:Int = 1 To 100
	List.Addlast(CreateTest("In" + i,0))
Next


For Local t:Test	= EachIn List
	Print Chr(34) + t.name + Chr(34) + " with value: " + t.value + "~n"
Next


List.sort(True)


For Local t:Test	= EachIn List
	Print Chr(34) + t.name + Chr(34) + " with value: " + t.value + "~n"
Next

End

</textarea><br><br><br>Run that.  That is the same as your test, but I have set all the values to 0.  <br><br>When the list starts out, it is sorted from 1 to 100.  When it ends, it is sorted from 100 to 1.  Every single element in the list has moved, even though they all had the same value!<br><br><a href="http://en.wikipedia.org/wiki/Sort_algorithm" target="_blank">http://en.wikipedia.org/wiki/Sort_algorithm</a><br><br>Mark's Sort function is a Bubble Sort.  Bubble Sort is supposed to be INVARIANT.  Ie, if two elements in the list are sorted relative to one another, then they do not swap positions relative to one another.  But as you can see here, your compare function caused all the objects in the list to swap positions.  Your compare method therefore broke Mark's code!<br><br>If on the other hand you use my compare method:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict

Type Test
	Field value:Int
	Field name:String
	
		Method Compare%(OtherObject:Object)

			Local OtherTest:Test = Test(OtherObject)
			If OtherTest = Null Then Return 0
																																																																																																																																																																																																																																																																																																																																														
			Return value - OtherTest.value
			
		End Method
		
End Type

Function CreateTest:Test(name:String, value:Int)
	Local result:Test	= New Test
	result.name		= name
	result.value	= value
	Return result
End Function


Global List:TList		= CreateList()

For Local i:Int = 1 To 100
	List.Addlast(CreateTest("In" + i,0))
Next


For Local t:Test	= EachIn List
	Print Chr(34) + t.name + Chr(34) + " with value: " + t.value + "~n"
Next


List.sort(True)


For Local t:Test	= EachIn List
	Print Chr(34) + t.name + Chr(34) + " with value: " + t.value + "~n"
Next

End
</textarea><br><br>Mark's sort function does not break!<br><br>If I ran your code using my sprite system, then every single update all sprites with the same order would swap positions in the list!  In other words, if the user created all their sprites with the same order, and assumed that the order of creation would cause them to be drawn in the order they desired, they'd be in for a shock when every frame the sprites swapped from drawing back to front to front to back, and vice versa! <br><br></td></tr></table><br>
<a name="647852"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brendane</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#46">[#46]</a></td></tr></table></td></tr><tr ><td class="posttext"> My example is a valid and real world requirement. I very often need to know whether I already have an item (judged by value not reference) in a list. <br><br>How can I then Sort that list unless I write a separate function to compare items and forfeit the built in list scanning functions such as TList.FindLink()? <br><br>Hint, I can't.<br><br>The PROPER OO way to do this is to provide the call to Sort() with a function to call back to do the comparison - NOT to use the Type's overridden comparison operator. <br><br></td></tr></table><br>
<a name="647875"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#47">[#47]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sswift: 1 and -1 are only used for sorting, while 0 is used for equality test (which is of minor importance on sorting. In trees this would normally end in a return unless you allow node value overrides). &gt;= 1 does sort correctly as my example above has shown.<br><br>For the same values, there is no rule on "how they are sorted" as I was not interested in their internal ordering. If you want it to output the elements in the ordering they were put into the list use if value &gt; obj.value return 1 else return -1 instead of &gt;=<br>But as mentioned. Unless you define a ordering rule for all elements with the same value, there is no "true" or "wrong" in the sort as they are taken as relatively equal within the value = 0 group. If you need a further distinction in whats larger and what smaller, you will have to add it or it is not there. For example<br><pre class=code>	Method Compare:Int(other:Object)
		Local obj:Test	= Test(other)
		If obj	= Self		Return 0
		
		If value &gt;= obj.value
			If name &gt; obj.name
				Return 1
			EndIf
		EndIf
		Return -1
	End Method</pre><br><br>And the second block breaks baaaadly. Do a remove for any object of the "added at last" ones and you will see it as it will remove the ones at the front because it return 0 on compare for anything and TList.remove will remove the first object with compare = 0, not the one with the reference you give it due to the implementation.<br>Marks code will only work correctly if the comparision value is unique (no 2 instances can have the same value. You could get such a unique key by using a type global int field which is incremented in method new but never decremented.before incrementing, assing its value to the ID field. that way you have unique IDs that can be used in marks way), I think that is even mentioned somewhere.<br><br><br>Brendane: And why not? Sort only needs to know if an object is larger (for ascending sorting) or smaller (for descending sorting), so the OO compare method is exactly the thing thats needed. 0 is not even needed for sorting as sorting algos sort basing on "while smaller push to front" or "while larger push to back" ideas behind them.<br><br>Quicksort would not even allow a compare 0 result as it only accepts unique sorting keys. Same goes for trees normally if they are meant to work efficiently (AVL, dictionary, segment trees, interval trees and the like).<br><br><br>This does not mean that the actual way is perfect. But it is as perfect as the cut down OO implementation does allow it to be without making its handling the hell on earth.<br>We have no delegates nor have we generics / multi inheritance. Delegates would be needed for the call back idea *-&gt; method pointers* (although I would use the call back for the actual sorting method, not the compare. I use such techniques to have EventHandlers a la C# on my own ingame GUI elements or for animate AI)<br><br>btw: Nothing prevents you from creating a type TSortable that has 2 distinct comparision methods and create an extended TList Type that does not base on Object but on TSortable (you then will have to extend all types from that instead of object, but that shouldn't be a problem). So its not like BM would prevent more "user intuitive" implementations of their datastructures. And that should not even be a problem btw in that case :-) <br><br></td></tr></table><br>
<a name="647889"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#48">[#48]</a></td></tr></table></td></tr><tr ><td class="posttext"> Dreamora:<br>I still don't understand where you are coming from.  <br><br>You say my compare method is bad.  Well create an example for me where MY compare method breaks, so I can see what it is you are saying is wrong about my method.<br><br>I've shown you how your example breaks.  "For the same values, there is no rule on "how they are sorted" as I was not interested in their internal ordering." doesn't cut it.<br><br>A Bubble sort by definition is invariant.  Mark's bubble sort is invariant when using my compare method.  It is not invariant when using your compare method.  Your compare method therefore is not compatible with Mark's bubble sort.  It clearly does not return the values Mark's bubble sort expects it to return.<br><br>And if it doesn't return the values MARK expects it to return, how can you possibly say it is the correct way to implement it?  Wouldn't MARK know best how it is supposed to work?  Wouldn't Marks OWN compare methods implemented in his own types return the correct values?<br><br>Here is how Mark has implemented compare functions in HIS OWN TYPES:<br><br>win32gui.bmx:<br><pre class=code>
Type TIntWrapper
	Field		value

	Method Compare(o:Object)
		Return value-TIntWrapper(o).value
	End Method
</pre><br><br>data.bmx:<br><pre class=code>
Type TDataId

	Field id
	
	Method Compare( with:Object )
		Return id-TDataId(with).id
	End Method
</pre><br><br>cocoamaxgui:<br><pre class=code>
Type TIntWrapper
	Field		value

	Method Compare(o:Object)
		Return value-TIntWrapper(o).value
	End Method
</pre><br><br>And the last one, which is the only one which is different:<br><br>fltkgui.bmx:<br><pre class=code>
Type TFLFont
	Field		name$,ids[4],sizes[]
	Method Compare( o:Object )
		Local f:TFLFont=TFLFont(o)
		Assert f
		Return name.ToLower().Compare( f.name.ToLower() )
	End Method
</pre><br><br>This one is different because it's comparing strings, and converts the strings to lowercase before comparison.  It's still returning -1 0 or 1 if the strings are less than equal or greater than one another.  None of that pointer funny business.<br><br>Those four examples comprise every single compare method Mark implemented in the max code.  Not one is like your own.<br><br>So again, I ask how you can say your method is correct when the author of the language, who should know better than you how it works, uses a different method from yours? <br><br></td></tr></table><br>
<a name="647956"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#49">[#49]</a></td></tr></table></td></tr><tr ><td class="posttext"> Your compare in your "real code" is not bad, it will work as it is optimized for your task :-)<br><br>But marks code will break, if you use Remove / Contains on it, it will return the wrong values if the value you compare is not unique (no 2 instances can have the same value), as those 2 TList methods search for the "correct" instance through compare.<br><br>They won't break unless you use one of those 2 TList methods or if you are lucky and never try to remove objects in the "wrong" order ...<br><br>I can't check the BM sources at the moment, but I assume that the used IDs are unique. Either through their own functionality or through the Object that creates them and assigns the ID. <br><br></td></tr></table><br>
<a name="647967"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#50">[#50]</a></td></tr></table></td></tr><tr ><td class="posttext"> "But marks code will break, if you use Remove / Contains on it"<br><br>You mean List.Remove() not Link.Remove()...<br><br>I would argue that the problem here is that the List.Remove() and List.Contains() functions are designed to find a link with a specific value, NOT a specific link.<br><br>So you're right, those do break if you change Compare() in the way I and Mark have...  <br><br>But that is ONLY because the "value" of a link by default is its memory location.  If you decide to have the "value" of a link be the links "order" or whatever, then it makes perfect sense that List.Remove() and List.Contains() break, because those are designed to search for a link with a specific value and NOT a link with a specific location in memory.<br><br>So YOU'RE one breaking List.Remove() and List.Contains()... Because they are intended to search for a link with the specified value, NOT to search for a specific link!  It is totally NOT breaking them if you specify one link to them, and they delete another, because that is what they're supposed to do.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Type Sprite

	Global SpriteList:TList = CreateList()

	Field _Link:TLink
	Field _Number%
	Field _Order%
	

		Function Create:Sprite(Number%, Order%)
	
			Local NS:Sprite
			
			NS = New Sprite
			NS._Link   = SpriteList.AddLast(NS)
			NS._Number = Number
			NS._Order  = Order
	
			Return NS
	
		End Function


		Method Compare%(OtherObject:Object)

			Local OtherSprite:Sprite = Sprite(OtherObject)
			If OtherSprite = Null Then Return 0
																																																																																																																																																																																																																																																																																																																																														
			Return _Order - OtherSprite._Order
			
		End Method
	
	
		Method Free()
			RemoveLink _Link
			_Link = Null	
		End Method
		
		
End Type



Sprite1:Sprite = Sprite.Create(1, 0)
Sprite2:Sprite = Sprite.Create(2, 2)
Sprite3:Sprite = Sprite.Create(3, 2)
Sprite4:Sprite = Sprite.Create(4, 3)

Sprite.SpriteList.Remove(Sprite3)

For ThisSprite:Sprite = EachIn Sprite.SpriteList
	Print ThisSprite._Number
Next
</textarea><br><br><br>So in this example, I pass it sprite3, which has a value of 2, and it removes sprite 2 because sprite 2 is the first sprite it comes across which has a value of 2.<br><br><div class="quote"> <br>Remove scans a list for the specified value and removes its link.<br> <br></div><br><br>It says value, and if we assume that here, Mark does indeed mean VALUE, and not OBJECT, then the List.Remove() function works exactly the way it should when you have the Compare() function set up the way Mark and I have it set up.<br><br>Consider this:<br><br>If the List.Remove() function were NOT meant to behave in this way, then why is it comparing the value of the link's value?  <br><br><pre class=code>
Method Remove( value:Object )
	Local link:TLink=FindLink( value )
	If Not link Return False
	link.Remove
	Return True
End Method

Method FindLink:TLink( value:Object )
	Local link:TLink=_head._succ
	While link&lt;&gt;_head
		If link._value.Compare( value )=0 Return link
		link=link._succ
	Wend
End Method
</pre><br><br><br>If the List.Remove() method were meant to remove the specified object from the list, and not just any old object with the same value, then why is the findlink function coded  like that?  Shouldn't it be like this instead?<br><br><pre class=code>
If link.Compare(_value )=0 Return link
</pre><br><br>Shouldn't it be trying to find the link in the list which has the _Value (MEMORY address) which matches the specified memory address?<br><br>As it is written now, it's finding the link in the list with the object that has a Value that matches the specified object's value.  And that's totally wrong and absurd if the point is to remove the specified object, and not any old object with the same value! <br><br></td></tr></table><br>
<a name="647974"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brendane</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#51">[#51]</a></td></tr></table></td></tr><tr ><td class="posttext"> You have hit upon the real point. TList.Remove() is implemented incorrectly - or only half the functionality is there.<br><br>Either it was intended to remove a mathematically equal item - or it was intended to remove the exact object. Either way, half the functionality is missing. The "documentation" gives no real clue either since there are conflicting comparisons between TList.Remove() and TLink.Remove(). No surprises there.<br><br>All you're doing is abusing the Compare() method in order to make TList.Remove() work when you have non-unique items. By the very definition of Compare() (and it is clearly defined) it is meant to return 0 when 2 items are quantitavely equal. Are you doing that? No. <br><br></td></tr></table><br>
<a name="648030"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#52">[#52]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sswift: It depends on what you search. Normally you don't create 10 objects which are value equal as this is pure waste of memory (at least I did not so far). But if you have such cases, you would most likely not do a reference check but check all fields your object has for equality. There you are right :-)<br>But thats the strength of the compare ... you define what is allowed and required for your object and what not, not BM.<br><br>And the docs state clear the same value, right. But same depends on how your object is built. In most cases you do not want to have an object removed, just because it shares 1 fields value with a different object.<br>As mentioned, BM does not suffer of that as the IDs used within are unique. There can never be 2 objects with the same ID ... In those cases, marks will work without problems as well.<br><br>But the examples you bring up use a value to compare which is not unique to only 1 instance in which case it will break and remove the wrong object as you proofed yourself. This means it does not work as intended as it does not remove the object you specified but one on the same order level. (for a sprite system, the order although should be unique as there must be one above the other in any case, so there it won't break as well).<br><br>Brendane: It does remove the OO equal item (for numerics that would be mathematically equal item), and there is nothing missing to do so ... Compare = 0 -&gt; equal. Everything &lt;&gt; 0 means unequal. That it is a 3 way result is just a nice addition, that makes sorting far easier as you don't need to implement several methods for it. But as I mentioned: you could use a TSortable as base Object which has a isEqual and a Compare method and use an own list. Or you could implement it and suggest it as an addition to the official thing (if it gets enough fans it could even happen that the original is adjusted and the methods split as you suggest, which surely has its good points as well)<br><br><br>Where the conflict on TLink.remove should be is a mystery to me. It does not compare anything, it just removes itself from the list and maintains the list structure.<br><br>And that different object have same names for familiar functions is what OO is for ... Otherwise we could use procedural where a function name only can exist once.<br><br>But I think we are somehow turning around the whole topic instead of really getting to the point. <br><br></td></tr></table><br>
<a name="648053"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Lomat</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#53">[#53]</a></td></tr></table></td></tr><tr ><td class="posttext"> Without going over what has already been said you can always simply extend the base TList type and reimplement the way links are compared to suit your requirements. Isn't that one of the main advantages of OOp?<br><br>For example you can have a TStrictList type that will check that the object is a specific instance instead of a comparision with the following code...<br><br><pre class=code>
Type TStrictList Extends TList

	Method FindLink:TLink( value:Object )
		Local link:TLink=_head._succ
		While link&lt;&gt;_head
			If link._value = value Return link
			link=link._succ
		Wend
	End Method

	Method Contains:Int( value:Object )
		Local link:TLink=_head._succ
		While link&lt;&gt;_head
			If link._value = value Return True
			link=link._succ
		Wend
		Return False
	End Method

End Type
</pre><br><br>This will then give you a dropin replacement whenever you need it and because your extending the TList type you dont need to change any variable declarations they can simply stay as a TList type but you now use "New TStrictList" when creating a new instance. For example...<br><br><pre class=code>
Local l:TList
l = New TStrictList
</pre> <br><br></td></tr></table><br>
<a name="648062"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brendane</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#54">[#54]</a></td></tr></table></td></tr><tr ><td class="posttext"> Compare() was designed to act as a value comparator to perform in a Sort algorithm. This bears no direct relation to 'equality' (imagine I am sorting on a single non-unique field). The problem is Compare() is being used in TList.Remove() which has nothing to do with sort criteria.<br><br>Lomat you are very right - I could simply derive from the TList class and override those members. I could also ditch the TList and write my own. My point is that the base class is flawed from the beginning and ought to be addressed. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
