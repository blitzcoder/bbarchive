<!DOCTYPE html><html lang="en" ><head ><title >How do do 'Solid wireframe'?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >How do do 'Solid wireframe'?</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >How do do 'Solid wireframe'?</a><br><br>
<a name="999616"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sokurah</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> 'Solid wireframes'?<br><br>I've made several games with 'ordinary' glowing wireframe graphics. Thanks to Indiepath's texturedpoly module that's been an easy task.<br><br>Now, what if I want to do something that's solid? - here, look at this screenshot from Gravity Crash to see what I mean.<br><br><img src="http://cache.g4tv.com/images/ImageDb3/169/049/image169049/169049_S.jpg"><br><br>What I'd like to do is the effect where you have a solid or textured background on one side and nothing on the other.<br>I'm sure polygons would be involved but I have no idea how to do it - I'm simply not that bright. :o)<br><br>Any ideas?...perhaps a bit of code? ;)<br><br><i>Edit: damn, noticed a typing mistake in the title. It should have said '<u>How TO do ...</u>'. Oh well, too late now. :(</i> <br><br></td></tr></table><br>
<a name="999653"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> It looks like an image with a wireframe around it. <br><br></td></tr></table><br>
<a name="999673"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> How about you create your environment as a tilemap and the images used for the tiles have alpha of 0 where you want the `sky`, draw your tilemap and then draw your glowy lines around the edges? <br><br></td></tr></table><br>
<a name="999710"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Corum</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> In that screenshot I could see:<br>1) lots of outlined polygons filled with a mask color to show a lower layer;<br>2) lots of outlined polygons flood-filled with a texture;<br>3) tile mapped background.<br><br>;-) <br><br></td></tr></table><br>
<a name="999746"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sokurah</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> How about you create your environment as a tilemap and the images used for the tiles have alpha of 0 where you want the `sky`, draw your tilemap and then draw your glowy lines around the edges? <br></div><br>I'd considered that as a easy way of doing it but it would feel like cheating...<i>and</i> I'd have to basically run two engines on top of each other and struggle with a sh!tload of tiles too.<br>It wouldn't make sense with a wireframe game that has a gigantic memory footprint either (because of the tiles).<br><br>Doing it with tiles also have a few limitations as I'd be stuck with a static scenery which means that I wouldn't be able to do moving or perhaps even rotating scenery.<br><br>Like I said - not that I have anything planned right now, but I would like to do it 'the best way' if I ever get to it (which IS my plan). :)<br><br>No, I'd feel better with a 'pure' vector solution...<i>if</i> there is a good solution to it. <br><br></td></tr></table><br>
<a name="999777"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >_JIM</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Can't you draw the environment as textured polygons? Mapping the UVs to a texture should be as easy as:<br><br><pre class=code>
U = (X / ScreenWidth) * Tile
V = (Y / ScreenHeight) * Tile
</pre><br><br>With slight adjustments to preserve the aspect ratio of the texture.<br><br>Then the glowy lines should be easy. <br><br></td></tr></table><br>
<a name="999781"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >matibee</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> I had a play, trying to avoid arbitrary triangle tesselation because that looks bloody tricky :/<br><br>I used a square quadtree that tested if nodes were fully inside the geometry, intersecting the geometry (and hence subdivided) or fully outside.  This gives a list of rects down to 1x1 pixel so it's not uber efficient.  Thing is, this list of rects could be turned into one triangle list and drawn in one hit<br><br>A fairly simple optimisation would be to see if the node only hits one line and make a clipped poly for the node, instead of subdividing any further.  This would also solve the issue where one pixel accuracy isn't really enough (it needs a line width of 2 to 3 to cover the edges properly).<br><br>Like I said, It was just a play.  Nodes are given a random color to show them.<br><br><img src="http://www.matibee.co.uk/temp/quadtreefill.jpg"><br><br>You'll need my primitive based collision mod to try this <a href="http://www.blitzmonkeys.com/index.php?topic=188.0" target="_blank">from here</a>.  Which in turn needs another mod :/<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict 

Import matibee.collision 
Import mauft.vector

Type node
	Field p1:TVector
	Field p2:TVector
	Field r:Int, g:Int, b:Int
	Function Create:node ( p1:TVector, p2:TVector )
		Local n:node = New node
		n.p1 = VectorClone( p1 )
		n.p2 = VectorClone( p2 ) 
		n.r = Rand( 1, 255 )
		n.g = Rand( 1, 255 )
		n.b = Rand( 1, 255 )
		Return n
	End Function 	
	Method Draw()
		SetColor( r,g,b )
		DrawRect( p1._x, p1._y, p2._x - p1._x, p2._y - p1._y )
	End Method 	
End Type 

Type quadTreeArea
	Field quadList:TList 
	
	Function build:quadTreeArea( poly:collisionPoly )
		Local n:node = New node
		Local qta:quadTreeArea = New quadTreeArea		
		
		' start with the bounds of the polygon
		Local width:Float = poly.p2._x - poly.p1._x
		Local height:Float = poly.p2._y - poly.p1._y
		n.p1 = VectorClone( poly.p1 )
		n.p2 = VectorCreate( poly.p1._x + Max( width, height ), poly.p1._y + Max( width, height ) )
		
		' recursively build the nodes..
		qta.quadList = New TList 
		qta._buildNode( n, poly )
		DebugLog qta.quadList.count()
		Return qta
	End Function 
	
	Method _buildNode( n:node, poly:collisionPoly )
		' stop recursing if the node is smaller than one pixel
		If ( n.p2._x - n.p1._x &lt; 1.0 ) Or ( n.p2._y - n.p1._y &lt; 1.0 ) Return  
		
		' check if this node is inside, or collides with the polygon..
		Local cr:collisionRect = collisionRect.Create( n.p1, n.p2 )
		
		If ( rectPolyIntersection( cr, poly ) ) ' does this node collide with the poly??
			' does it intersect the poly.. (4 line checks)
			If ( poly.lineIntersect(  cr.p1, VectorCreate( cr.p2._x, cr.p1._y ) ) Or ..
				poly.lineIntersect(  cr.p1, VectorCreate( cr.p1._x, cr.p2._y ) ) Or ..
				poly.lineIntersect(  cr.p2, VectorCreate( cr.p2._x, cr.p1._y ) ) Or ..
				poly.lineIntersect(  cr.p2, VectorCreate( cr.p1._x, cr.p2._y ) ) )
					
				' subdive this node and test again...
				Local midx:Float = (cr.p1._x + cr.p2._x) / 2
				Local midy:Float = (cr.p1._y + cr.p2._y) / 2
								
				Local n1:node = node.Create( cr.p1, VectorCreate( midx, midy ) )
				Local n2:node = node.Create( VectorCreate( midx, cr.p1._y ), VectorCreate( cr.p2._x, midy ) )
				Local n3:node = node.Create( VectorCreate( cr.p1._x, midy ), VectorCreate( midx, cr.p2._y ) )
				Local n4:node = node.Create( VectorCreate( midx, midy ), cr.p2 )
				
				_buildNode( n1, poly )
				_buildNode( n2, poly )
				_buildNode( n3, poly )
				_buildNode( n4, poly )
			Else 
				' it must be fully inside..
				quadList.AddLast( n )
			End If 
		End If 		
	End Method 
	
	Method Draw()
		For Local n:node = EachIn quadList 
			n.draw()
		Next 
	End Method 
		
End Type 
	

Graphics 800, 600


Local poly:collisionPoly = collisionPoly.CreatePoly( VectorCreate(146, 407) )
RestoreData polydata
For Local t:Int = 1 To 27
	Local x:Float, y:Float 
	ReadData x, y
	poly.AddVertex( VectorCreate(x, y) )
Next 

Local qt:quadTreeArea = quadTreeArea.Build( poly )


While ( Not AppTerminate() )
Cls

SetColor (255,255,255 )
qt.Draw()


SetColor (255,0,0)
SetLineWidth( 2 ) 
poly.debugDraw()

Flip 
Wend 


#polydata
DefData 176,382
DefData 146,330
DefData 182,273
DefData 222,232
DefData 155,185
DefData 184,141
DefData 205,142
DefData 203,130
DefData 187,129
DefData 192,116
DefData 205,120
DefData 239,93
DefData 280,71
DefData 315,83
DefData 314,123
DefData 348,143
DefData 346,212
DefData 379,243
DefData 365,326
DefData 386,336
DefData 396,328
DefData 409,329
DefData 409,338
DefData 421,353
DefData 419,367
DefData 409,415
DefData 381,436


</textarea> <br><br></td></tr></table><br>
<a name="999805"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sledge</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Surely you could pick just about any 3D engine and render the outline geometry first, slightly larger than the 'fill' geometry? For example in MiniB3D it would be along the lines (arf!) of:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict
Import sidesign.miniB3D
AppTitle$ = "Solid"

Graphics3D 800,600,32,2,60
Global cam:TCamera = CreateCamera()
CameraProjMode cam,2
CameraZoom cam,.25
PositionEntity cam,0,0,-5

Local myCube:TSolidFing = New TSolidFing
ListAddLast TSolidFing.list,myCube
myCube.geom = CreateCube(); EntityOrder myCube.geom,1;EntityColor myCube.geom,200,200,100
myCube.outline = CreateCube(myCube.geom); EntityOrder myCube.outline,-1; ScaleEntity myCube.outline,.9,.9,.9

Local mySphere:TSolidFing = New TSolidFing
ListAddLast TSolidFing.list,mySphere
mySphere.geom = CreateSphere(8); EntityOrder mySphere.geom,1;EntityColor mySphere.geom,200,200,100
mySphere.outline = CreateSphere(8,mySphere.geom); EntityOrder mySphere.outline,-1; ScaleEntity mySphere.outline,.9,.9,.9

Local xMod:Int = 0

While Not ( KeyHit(KEY_ESCAPE) Or AppTerminate() )

	PositionEntity mySphere.geom,Cos(xMod)*2.2,1,0
	
	For Local currentFing:TSolidFing = EachIn TSolidFing.List
		TurnEntity currentFing.geom,0,0,1
	Next
	
	RenderWorld()
	Flip
	Cls
	
	xMod:+1
Wend


Type TSolidFing
	Global list:TList = CreateList()
	
	Field outline:TEntity
	Field geom:TEntity
End Type</textarea><br><br>The speed of 'proper' 2D in Blitz3D/B3D SDK would mean you could do some neato stencil stuff if you opted for that language/API. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
