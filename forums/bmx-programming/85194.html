<!DOCTYPE html><html lang="en" ><head ><title >Optimization Help (Pixmaps etc)...</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Optimization Help (Pixmaps etc)...</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Optimization Help (Pixmaps etc)...</a><br><br>
<a name="963311"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >mic_pringle</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>I've been developing a Raycasting engine in the style of Wolfenstein3d and Rise of the Triad, and everything was sweet until I introduced textures. Now, any resolution above 320 x 200 and the framerate drops considerably, to the point where it's almost unplayable.<br><br>The way I'm managing the textures is as follows ...<br><br>- Create a texture pixmap by loading an image from disk straight  into a pixmap<br>- Create an empty buffer pixmap, the size and width of the resolution<br>- In the Raycasting loop I detemine which pixel I need from the texture depending on where the ray hit the wall and then use ReadPixel to get it, and then use WritePixel to write it to the buffer pixmap.<br>- Once the Raycasting loop has ended I draw the buffer pixmap to the screen, and then clear it's pixels<br><br>I'm assuming that using pixmaps is my bottleneck as from what I've read on the forums they can be slow. Which is why I'm here, does anyone have any ideas on how I can optimize this process ?<br><br>I've had the following thoughts so far ...<br><br>- Cache the pixmap pixel data into an array before entering the Raycasting loop and then using this instead of ReadPixel when needing to determine pixel color at a particual offset. Would this be faster than using ReadPixel ?<br><br>- Instead of writing to another pixmap, write the pixel directly to the screen. I understand that plot can be used for this, but can be slow because it calls glBegin and glEnd for each call. What I thought was to instead implement my own version, calling glBegin, then looping through an array to get the x and y values, calling setColor and then plot the point using glVertex2f. Finally calling glEnd once the loop has finished. This would then send all the commands to the GFX card in one, rather than individually ? Is my train of thought correct on this ? Would this be a worthwhile exercise ?<br><br>Does anyone else have any thoughts on how best to optimize this process ? I understand I can get a pointer to each pixel in a pixmap instead of using ReadPixel, which is apparently faster, but I'm not sure how to do this ?<br><br>All help appreciated.<br><br>Thanks<br><br>-Mic <br><br></td></tr></table><br>
<a name="963322"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >matibee</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm not sure about the internals of a pixmap but it sounds to me you only want your textures in ram and access them with a raw lookup.<br><br>Also have a destination (render target) in ram and write pixels with a raw lookup.  Copy the entire render target ram to video memory in one operation at the end of generating the frame.<br><br>Work in 256 colors too :), or at most, 16 bit. <br><br></td></tr></table><br>
<a name="963324"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >mic_pringle</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks 'matibee' ... any ideas on this technique can be implemented ?<br><br>Thanks<br><br>-Mic <br><br></td></tr></table><br>
<a name="963326"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >matibee</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sorry Mic, I can't help with the bmax specifics, I'm still finding my feet here.<br><br>I enjoyed reading this article recently, it should give you plenty of pointers while you work out the bmax way to do it.<br><br><a href="http://www.tophatarcade.com/dev/articles/2DSoftwareRenderer.php" target="_blank">http://www.tophatarcade.com/dev/articles/2DSoftwareRenderer.php</a><br><br>Cheers<br>Matt <br><br></td></tr></table><br>
<a name="963338"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >mic_pringle</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks 'matibee' ... have read through the article, put I don't think it applies well to what I'm trying to achieve.<br><br>Thanks anyway.<br><br>-Mic <br><br></td></tr></table><br>
<a name="963341"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Arowx</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> My understanding is that pixmaps are very slow, and yes the best way to access them is using a pointer.<br><br>So you could replace your readPixel and WritePixel with pointer based access.<br><br>Example <a href="/codearcs.php?code=2376" target="_blank">here</a><br><br>Definitly look into writing your own DX or OpenGL routine for this as you could potentially save a lot of time, but have a search first someone has probably already written a faster bitmap plotter.<br><br>You are processing 64000 raycasts at 320 x 200 resolution, possible optimisations could be...<br><br>1. Don't recalculate when nothing moves<br>2. Only recalculate moved items e.g. monsters<br>3. Look into Axis Aligned Bounding Box 'AABB' optimisations used in raytracing.<br>4. Figure out a way for the GPU to do the work for you, so all calculations and pixel lookups occur on the graphics card?<br><br>But I am wondering why not just go the 3d route, even basic hardware could run way above this resolution and provide that blocky wolfenstein 3d look as well? <br><br></td></tr></table><br>
<a name="963359"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >mic_pringle</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi Merx,<br><br>Thanks for your post.<br><br><div class="quote"> You are processing 64000 raycasts at 320 x 200 resolution <br></div><br><br>This is not quite accurate. I think you are thinking about ray tracing, where you cast a ray for each pixel. In ray casting you only cast a ray once for each pixel along the x-axis (or screen width), in this case 320 times. Which is why it was incredibly fast pre-textures, and why I associate the slow down with the use of pixmaps and ReadPixel/WritePixel.<br><br><div class="quote"> Figure out a way for the GPU to do the work for you, so all calculations and pixel lookups occur on the graphics card? <br></div><br><br>I'm extremely interested in this suggestion. Do you have a links where I can get more information ?<br><br><div class="quote"> But I am wondering why not just go the 3d route, even basic hardware could run way above this resolution and provide that blocky wolfenstein 3d look as well? <br></div><br><br>It started out as a bit of fun, but I have since become obsessed with it. <br><br>Plus I hate 3D maths.<br><br>Thanks<br><br>-Mic <br><br></td></tr></table><br>
<a name="963368"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Don't use readpixel or write pixel, learn how to use int pointers to get and set pixels, and keep the base pointers of the pixmaps in local variables and use as many locals as you can, defined outside of the loop to avoid garbage collection.<br><br>Not sure why you are trying to do raycasting when the hardware can do Z-buffered texturing for you much faster, unless you're going for nostalgia? <br><br></td></tr></table><br>
<a name="963371"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> you dont need 3d math to user minib3d <br><br></td></tr></table><br>
<a name="963416"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Arowx</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> @mic_pringle If you only cast 320 tests then work out which textures to display, why not keep their distance or z value and then scale the images accordingly and draw them in z order, why do you need to do all the texture/pixel copying?<br><br>@mic_pringle Well it's kind of back to front as the 3d your average GPU is used for provides nice z-buffered hi-res graphics, where it takes in textures and geometry and generates a pixel buffer.<br><br>So from this you know that it's what a GPU is made to do, but to get it to raycast in the style you need would probably involve writing in a GPU specific language depending on hardware ATI/Nvidia or OpenML...<br><br>Just google for 'GPU Raycasting' it appears to be used quite a lot in medical visualisation.<br><br>Regards<br><br>Merx <br><br></td></tr></table><br>
<a name="963523"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >matibee</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sorry Mic, that article is not as relevant as I remembered it.<br><br>You can see the TPixMap source code (in the folder "mod\brl.mod\pixmap.mod").  In there you'll see functions like read and write pixel have a lot of conditional code to handle many different pixel formats.  If you're working with one format throughout there's no conversion or checking to do and you can do it with raw pointer access quite easy.<br><br>This example has a pixmap for the back buffer, and another for a simple sprite, it accesses both by byte pointer.<br><br>I'm not sure what bounds checking comes with the Ptr types though so be careful (I managed a BSOD yesterday :) )<br><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

Graphics 640,480

' create pixmaps in the STDFORMAT which is 32 bit RGBA
Global sprite:TPixmap = CreatePixmap( 32, 32, PF_STDFORMAT )
Global backBuffer:TPixmap = CreatePixmap( 640, 480, PF_STDFORMAT )

' get the pointers to the first pixel in each pixmap
Global spritePtr:Byte Ptr = sprite.PixelPtr( 0, 0 )
Global bufferPtr:Byte Ptr = backBuffer.PixelPtr( 0, 0 )

' fill the sprite with white pixels
For Local x:Int = 0 To (32 * 32 * 4) -1 ' need to set 4 bytes for every pixel
	spritePtr[x] = 255
Next

' this clears the pixmap memory with
Function clearBackBuffer()
	Cls
	MemClear( bufferPtr, 640 * 480 * 4 )
End Function

' this draws the pixmap
Function presentBackBuffer()
	DrawPixmap( backBuffer, 0, 0 )
	Flip
End Function

' this draws the sprite (we know which sprite and it's width / height )
Function drawSprite( iX:Int, iY:Int )
	For Local y:Int = 0 To 31
			' do these calcs once in the outer loop
			Local iBufferStart:Int = (((y + iY) * 640) + iX) * 4
			Local iSpriteStart:Int = y * 32
		For Local x:Int = 0 To (32 * 4) - 1 ' need to write 4 bytes for every pixel
			bufferPtr[ iBufferStart + x ] = spritePtr[ iSpriteStart + x ]
		Next
	Next
End Function

' draw 100 sprites at a time
While ( Not KeyHit( KEY_ESCAPE ) )
	clearBackBuffer()
	For Local count:Int = 0 To 99
		Local iX:Int = Rand( 0, 600 ) ' careful not to go past edge of screen
		Local iY:Int = Rand( 0, 440 ) ' or even worse, past the end of memory!
		drawSprite( iX, iY )
	Next
	presentBackBuffer()
End While
</textarea> <br><br></td></tr></table><br>
<a name="963524"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >mic_pringle</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> @matibee<br><br>Thanks for this, I will have a proper look at it when I get home from work.<br><br>Just out of curiosity, did you implement the same program using the standard ReadPixel/WritePixel as well ? <br><br>I was wondering if you'd done any comparisons between the two methods to measure the speed difference if any ?<br><br>Thanks<br><br>-Mic <br><br></td></tr></table><br>
<a name="963527"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >matibee</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Haha Mic, that comes under the often used phrase; 'such exercises are left for the reader' :)<br><br>Just look at the pixmap source and you'll see how lengthy the Read/Write pixel functions have to be.  It's always going to be faster to work to a bunch of knowns (pixel format, texture sizes, etc) than write code for every case. <br><br></td></tr></table><br>
<a name="963564"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >mic_pringle</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just found this example of using vertex arrays ... may be worth looking at this as well ?<br><br><a href="/posts.php?topic=66184" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=66184</a><br><br>Thanks<br><br>-Mic <br><br></td></tr></table><br>
<a name="963593"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >matibee</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Vertex arrays won't help with pixel plotting as they're used for drawing triangles (meshes, quads in 2d etc).  The idea being to store geometry on the video card. <br><br></td></tr></table><br>
<a name="963602"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >mic_pringle</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> I actually have to disagree as you can use GL_POINTS as the type, which is exactly what 'Plot' uses to draw single pixels to the screen. <br><br></td></tr></table><br>
<a name="963640"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >matibee</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> You're way off target with GL_POINTS.<br><br>You don't want to draw single pixels to the screen. You want to draw to a buffer in ram then upload it in one chunk.  The frame rate wouldn't be hit too hard simply making a new texture from your ram buffer and drawing it with the 3d api - it only has to be done once per frame.<br><br>Even if you had a vertex buffer of GL_POINTS on the video card, with one GL_POINT for each pixel, there's no way you could get the color data to them every frame in a way that's faster than the dynamic texture.<br><br>If you want the ultimate in performance, do it all on the video card:<br><a href="http://www.gamedev.net/community/forums/topic.asp?topic_id=346775&amp;whichpage=1&amp;#2291866" target="_blank">http://www.gamedev.net/community/forums/topic.asp?topic_id=346775&amp;whichpage=1&amp;#2291866</a> <br><br></td></tr></table><br>
<a name="963827"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >mic_pringle</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Matibee<br><br>I'm having no luck using the methods you've described, so I was wondering if you'd be prepared to have a look at my source ?<br><br>You can get it <a href="http://www.dotmic.com/raycast.zip" target="_blank">here</a><br><br>I've included the version I have with no optimizations so you can see how slow it is.<br><br>Thanks<br><br>-Mic <br><br></td></tr></table><br>
<a name="963853"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >matibee</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nice one Mic.  I'll have a look tomorrow. <br><br></td></tr></table><br>
<a name="963855"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >mic_pringle</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Matibee<br><br>Fantastic, I appreciate it. Let me know how you get on.<br><br>Thanks<br><br>-Mic <br><br></td></tr></table><br>
<a name="964032"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >matibee</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hmm. That was an interesting learning exercise.<br><br>Here's a list of major changes (some may be more questionable than others and most are easy to comment out to see the difference);<br><br>[] using 24 bit rgb pixel format throughout<br>[] using raw pixel access instead of read/write pixel<br>[] drawing TWO identical vertical lines for every ray cast<br>[] the timing code now checks how long the frame took to render and draw, ignoring the flip time<br>[] it only raycasts (rebuilds the pixmap) on movement.  this shows the time it takes to draw the pixmap (on my system about 7ms)<br>[] changed the movement code so it's time bound.  slow frame rates meant it felt like you were running through mud so it made a big psychological difference when it didn't need to<br><br>For testing, I simply started the program and held the right arrow key down for a couple of full turns and noting the highest ms reading.<br><br>Results:<br>RGB pixel format:-<br>Read/Write pixel: 20ms<br>Memcopy: 17ms<br>neither: 11ms (commented out the for/next vertical line loop)<br><br>Memcopy takes 6ms and Read/WritePixel takes 9ms.  Remember, drawing the pixmap takes around 7ms on my system so the scan code and logic took the other 4ms.<br><br>RGBA pixel format:-<br>Read/Write pixel: 24ms<br>Memcopy: 18ms<br>neither: 13ms<br><br>There's obviously some conversion of pixel formats going on here.  The memcopy time has gone down to 5ms probably due to only ever accessing memory on 32 bit boundaries, while every thing else takes longer.<br><br>These tests were done at 640 x 480, windowed, with the double line drawing.<br><br>So where do you go from here?<br>Continue with raycasting?<br>There's some micro optimisations to be had such as forcing textures to be 128 width/height and replacing all '* texturewidth' code with shl 7.  (A profiler would be the next stop though, I wonder if something like AMD's code analyst is still around and would work on a bmax debug exe.)<br>Move to a 8 bit palettized texture format (retrieving a pixel color from a texture MIGHT be quicker, but placing it won't be affected unless you go for a 16 bit screen mode).<br>Stop drawing the pixmap and make a dynamic texture, but drawing the pixmap is already pretty quick so it wouldn't surprise me if this is already going on under the hood.<br><br>Move to 3d?<br>Even basic 3d abilities would beat this raycaster hands down, especially has the resolution increases.  Even moving this simple level onto the 3d card will make it lightning fast.  You can store the geometry and textures in video ram and all you're doing is updating the camera position.  There's the added benefit of bilinear/trilinear filtering of the textures too so you don't see those horrible big pixels when you're up close to a wall.  It just depends on your needs and expectations.<br><br>Source is <a href="http://www.matibee.co.uk/temp" target="_blank">here</a>.<br><br>Cheers<br>Matt <br><br></td></tr></table><br>
<a name="964058"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >mic_pringle</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Matibee<br><br>Thanks for this, it is greatly appreciated. I now intend to go through the changes you made with a fine tooth-comb :-)<br><br><div class="quote"> Continue with raycasting?<br>There's some micro optimisations to be had such as forcing textures to be 128 width/height and replacing all '* texturewidth' code with shl 7. (A profiler would be the next stop though, I wonder if something like AMD's code analyst is still around and would work on a bmax debug exe.)<br>Move to a 8 bit palettized texture format (retrieving a pixel color from a texture MIGHT be quicker, but placing it won't be affected unless you go for a 16 bit screen mode).<br>Stop drawing the pixmap and make a dynamic texture, but drawing the pixmap is already pretty quick so it wouldn't surprise me if this is already going on under the hood. <br></div><br>The whole raycasting thing came about as a bit of a learning exercise after re-discovering Rise of the Triad, Doom &amp; Duke Nukem through DosBox. I figured if those guys could make such an engine that ran so sweet on a 386's &amp; 486's, I wondered if I could do something similar using modern technology. Since then it's become a bit of an obsession, so I'm not sure where I'm going to go with it ... I do however think there are some more optimizations to be had, such as tidying up some of the ray calculations, using Cos and Sin instead of Sqrt and caching them as there's only a finite number of possibilities, reusing variables instead recreating them on each pass etc.<br><br><div class="quote"> Move to 3d?<br>Even basic 3d abilities would beat this raycaster hands down, especially has the resolution increases. Even moving this simple level onto the 3d card will make it lightning fast. You can store the geometry and textures in video ram and all you're doing is updating the camera position. There's the added benefit of bilinear/trilinear filtering of the textures too so you don't see those horrible big pixels when you're up close to a wall. It just depends on your needs and expectations. <br></div><br>Perhaps that's the next move after this, I'm not sure. I don't really know much about 3D so wouldn't know where to get started. Especially using a language designed mainly for 2D games. I know MiniB3D exists, but if went that way it'd want to start from scratch so I'd know exactly what was happening.<br><br>Thanks again for this, it's greatly appreciated.<br><br>-Mic <br><br></td></tr></table><br>
<a name="964070"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >mic_pringle</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Matibee<br><br><div class="quote"> There's some micro optimisations to be had such as forcing textures to be 128 width/height and replacing all '* texturewidth' code with shl 7. (A profiler would be the next stop though, I wonder if something like AMD's code analyst is still around and would work on a bmax debug exe.)<br>Move to a 8 bit palettized texture format (retrieving a pixel color from a texture MIGHT be quicker, but placing it won't be affected unless you go for a 16 bit screen mode). <br></div><br><br>Would you mind at all expanding on these comments ? I know a bit about bit shifting, but not a lot about palettes ?<br><br>Thanks<br><br>-Mic <br><br></td></tr></table><br>
<a name="964106"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >matibee</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> It was a bit different in the days of Doom.  Small resolutions meant there were less pixels to shift and programmers had direct access to video memory - so where we're writing pixels to an intermediate buffer they could stick them straight into the display.  They still made some very impressive optimisations though to make them work but not all of them are relevant today.<br><br>Implementing a bsp tree system would be crucial here too and to be honest is probably more difficult than moving onto 3d and leaving ray casting behind :)  <br><br>(It can be really easy to manage objects in 3d space for a 2d game, where X=posX, Y=0, Z=posY just kinda leaves them 'on the ground')<br><br>Palettes:  At the moment (for every pixel) we are getting 3 bytes from the texture and writing 3bytes to the video buffer.  Suppose we had a pallete of 256 predefined 16 bit colors (2bytes each), textures were a single byte per pixel as indices into that array, and the final video format was 16 bit.<br><br>We could now read 1 byte per pixel (instead of 3) and write 2 bytes per pixel instead of 3.  But we've added the overhead of a lookup.  I guess we could drop the look up and have 16 bit textures too - but the paletting thing was used heavily on old hardware and programmers would mess with the palette to create graphical effects - so if you're going old skool it's got to be palettised :)<br><br>All of this is moot tho, as I've noticed bmax doesn't seem to have any 16 bit pixel formats defined so I doub't we could get it play nice in 16 bit modes.  I'll have another look. <br><br></td></tr></table><br>
<a name="964422"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >mic_pringle</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> Okay, so I've been looking for some of the alternatives to ray-casting as mentioned here, and I've found <a href="http://nehe.gamedev.net/data/lessons/lesson.asp?lesson=10" target="_blank">...THIS...</a><br><br>Is this the kind of thing you were meaning when you said go to true 3D ?<br><br>-Mic <br><br></td></tr></table><br>
<a name="964504"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >matibee</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, that's the easiest transition from where you are and what your trying to achieve. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
