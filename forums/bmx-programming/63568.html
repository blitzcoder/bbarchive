<!DOCTYPE html><html lang="en" ><head ><title >Inheritance bug or strange behavior?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Inheritance bug or strange behavior?</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Inheritance bug or strange behavior?</a><br><br>
<a name="709575"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> The following source produces the output<br>0<br>B: 2<br>C: 3<br><br>This is an extremely broken output.<br><br>z is defined on "a" level, so it should be the same field for all extended as well even if default initialized?<br>But it is able to have 3 different values, what the heck is the compiler doing there? creating dublicates of the same field for every extended class???<br><br><br><pre class=code>
Type a
	Field z%
End Type
Type b Extends a
	Field z% = 2
End Type
Type c Extends b
	Field z% = 3
End Type
Local me:a = New c
handleit(me)
End

Function handleit(it:a)
 Print it.z
 If b(it)	Print "B: " + b(it).z
 If c(it)	Print "C: " + c(it).z
End Function</pre><br><br><br>The following code indeed returns the expected output of<br>3<br>B: 3<br>C: 3<br><br><pre class=code>
Type a
	Field z%
End Type
Type b Extends a
	Method New()
		z = 2
	End Method
End Type
Type c Extends b
	Method New()
		z = 3
	End Method
End Type
Local me:a = New c
handleit(me)
End

Function handleit(it:a)
 Print it.z
 If b(it)	Print "B: " + b(it).z
 If c(it)	Print "C: " + c(it).z
End Function</pre> <br><br></td></tr></table><br>
<a name="709613"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Augen</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> This won't help, but i find it freaky that a Method New can be made in BMax even thought there is inbuilt NEW! Cool.<br><br>Edit: See next post.  Thanks for that explanation Dreamora; I didn't realize they were the exact same thing.  I have looked at the documentation, but I find the tutorials posted on this site much more helpful. <br><br></td></tr></table><br>
<a name="709671"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> method new is exactly what is called when you use new - its the default constructor. See the documentation for further information. <br><br></td></tr></table><br>
<a name="710419"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is correct, and is the same in most OO languages. Fields declared in extending types will 'hide' those in base types. <br><br></td></tr></table><br>
<a name="710709"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> so I was partly correct. although I didn't know, that  when you upcast to a base you access the base field and that the field can be declared  in the base and in extended types. <br> I thing it would be be better to access the base with a super or a self rather than a cast. But That is just my opinion "not an experts' ". <br><br>Don't bother, I'll just stick to learning. :-) <br><br></td></tr></table><br>
<a name="710714"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >H&amp;K</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well you can access the base field with a super, as long as you have cast your object to the extended type. In your original example the Me needed to be cast back to the extended type, then the original field would have been available via super<br><br>I only disagreed with Dream in that I thought it wasnt an error. I however agree with him that its a stupid thing to do. You are using 8 btyes to store one int. (in a single extention)<br><br>I agree with Dream totaly, that you should have just the one field, that you allocate either inside "New", or in your create function <br><br></td></tr></table><br>
<a name="710718"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> so what is the difference global int, constant , field just 8 bytes. it was just a general example. I could have other uses for it. Maybe not a great deal of options but usefull none the less. <br><br></td></tr></table><br>
<a name="710721"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >H&amp;K</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh I agree that it <i>could</i> be useful, but in the code you first published it in, it was the wrong tool.<br>In that code, Dreams first post,  were the value was allocated to the same field each time in  the "New" function was a better way to do it.<br><br>(And an Int Field is normaly just 4 bytes, all this double name does, is hide an int variable from you. Now be Honest, did you think that you were createing a second variable or just changing the value of the first?) <br><br></td></tr></table><br>
<a name="710727"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> and, from Mark's post<br><div class="quote"> Fields declared in extending types will 'hide' those in base types.  <br></div><br>What would 'hiding' achieve? What could it be used for?<br>They *can* be different variables types (e.g. string, float etc) but I'm not sure how that would help either. <br><br></td></tr></table><br>
<a name="710730"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> It would allow you some great things.<br><br>But to me its an extremely critical thing. It removes the consistency from inheritance which is something that I thought a "modern language" (which the GC and typesafeness indicates) wouldn't break. At least not unless the language has true support for selection and redefition on extension.<br><br>Critical because of this little thingy here:<br><br><pre class=code>
Type a
	Field z% = 3
End Type
Type b Extends a
	Field z% = 2
End Type
Type c Extends b

End Type
Local me:a = New c
me.z		= 17
handleit(me)
End

Function handleit(it:a)
 Print it.z
 If b(it)	Print "B: " + b(it).z
 If c(it)	Print "C: " + c(it).z
End Function
</pre><br><br>Now asume how much you can actually break due to that "feature".<br><br>There is actually no way to tell Class C to use z from Class A. It will always use z from Class B. (yeah I know I can always do A(self).z but thats after all inacceptable if I want to assign c.z statically to a.z as I know that b.z will only be needed if casted to b for some reason! Pointers are no solution as c.z points to b.z so changing c.z pointer will change b.z as well)<br><br>Result is that you can use Class A anymore for general type declaration for list iteration and the like because the field on the class is totally useless for any extended type because Class B block the whole following inheritance.<br><br>So until BM learns the needed selection and redifinition mechanics, this "feature" to me is more of a bug than actually a feature as it isn't as controllable and fully implemented as it would be needed to be.<br>But it is a start for something that could turn out to be something really usefull.<br><br>PS: Mark, might I suggest having a look at Eiffel if you are interested in expanding BM more towards modern OO . It offers an extremely usefull way of how inheritance and selection/undefine/redefine should work in any modern language.<br>As well as how export / access should work as you can define for each field / method / function, which classes are allowed to use it. <br><br></td></tr></table><br>
<a name="710737"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> @H&amp;K,  yes I thought I was craeting a second variable, that is what my whole confusion came about. where I thought I knew something I had no real understanding. <br><br></td></tr></table><br>
<a name="710820"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Koriolis</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> But to me its an extremely critical thing. It removes the consistency from inheritance which is something that I thought a "modern language <br></div>Critical? Consistency?<br>Most modern and pragmatic OO languages work just like that. First point : you just can't "override" a field in  an inherited type, as a field is just a piece of data in BlitzMax, just like in C# or Java. If member access was unified as in a 100% OO language, then there would actually not even be any concept of simple field, and "field" access would actually imply calling a hidden getter/setter, with the cost of a virtual function dispatch. A truely, purely and consistent OO language is certainly nice, but for some time the speed cost is *not* desirable for some of the things most programmers are using BlitzMax for.<br>Second point, in fact more important: if what you expected here was some kind of overriding, does it actually make sense here?<br>Also I have a simpler question: what *exactly* did you expect BlitzMax to do in your example? Remember that the declaration <pre class=code>	Field z% = 2</pre>Is strictly a shortcut for<pre class=code>	Field z%
Method New()
    z = 2
End Method
</pre><br>If what you expected was to *not* redeclare anyy field but just have another initialization put in the constructor behind the scenes, as it does right now) then OK, that could actually be not that bad. But to me that's another special case, exception to the rule or simply put, inconsistency. <br><br></td></tr></table><br>
<a name="710823"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> It seems to work exactly I would expect it to.<br><br>Since the field is private for a given type/instance, casting to a specific type would make visible the field at that level. <br><br></td></tr></table><br>
<a name="710826"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >tonyg</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> It would allow you some great things. <br></div><br>Fantastic! Now, what could it be used for? <br><br></td></tr></table><br>
<a name="710829"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> To have the "core type" hold a given value, but to save a modified version of this value on the extended types for example.<br>So if you use it as core type it shows "untransformed" values but the extended type has transformed values (that are kept updated all the time)<br><br><br>Koriolis: What I actually assume is that field z is field z throughout the whole inheritance. It makes actually quite little sense to have a field z, that shows X when you ask for its value on core type, but that shows y if you cast it to an extended type.<br><br>I fully understand that this allows some interesting things.<br>And am aware that this sadly is needed to work like this if we want to get multi implementation of abstract types at some point, as it would badly break otherwise unless redefine / undefine / select mechanics come in.<br><br><br>PS: Check out eiffel and you will see that you don't lose anything with a clear and fully consistent OO language with re / un-define and select mechanisms. You actually get quite a lot when it comes to usefully design your OO system. That is actually a reason why Eiffel is used in critical systems like medical stuff and aircrafts, where Java and C# never will be used and C/C++ only after tousands of hour of testing normally.<br>It isn't one of those funny languages that never grow up due to too complicated ideas. Its quite the opposite, as C# already has taken a few of Eiffels mechanics (delegates for example, which are called agent in Eiffel) as other languages as well. <br><br></td></tr></table><br>
<a name="710866"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >H&amp;K</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> I dont care if it is supposed to be in a modern OO languge or not. My only difference of opinon with Dream is that I didnt thing it was an error to be able to do it.<br><br>I cannot honestly thou dissagree with Dream that it a stupid thing to do. Cos it is. Its not a useful tool at all. I did admit earlier that possibly it might be useful in some weird code model, but I just think it is a way to confuse you when you are useing the type.<br><br>If I want a different field in the exteneded type, I would give it a new name, if I wanted the same variable to have a different value in the extended type, I would simply give it a new value.<br><br>@Jesse,<br>Im really supprised that you did know you where createing a new value. But given that you did know that, can you now see that you need to cast, even if you had given different names?<br><pre class=code>Type a
	Field z%
End Type
Type b Extends a
	Field y% = 2
End Type
Type c Extends a
	Field x% = 3
End Type
Local me:a = New c
Print C(me).x
'Print me.x</pre> <br><br></td></tr></table><br>
<a name="710870"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thats correct, you're overriding fields, that's a BMax feature. <br><br></td></tr></table><br>
<a name="710872"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Koriolis</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well in fact ziggy that's precisely the point: you're NOT overriding anything, you create a new field that hides the one in the parent type. But anyway I would indeed call that a by design feature, surely not a bug. <br><br></td></tr></table><br>
<a name="710885"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >H&amp;K</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> you create a new field that hides the one in the parent type <br></div><br>Err, thats what overriding is. (Its just that noramally we'd only do it for functions/Methods) <br><br></td></tr></table><br>
<a name="710905"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> @H&amp;K, Just note that I admitted to have misunderstood the whole concept.  I had originally created a field name index for each of the types to identify the type of operation I was doing. 1 was for the addition type, 2 for subtraction type..... it was kind of like a constant.  Considering what I just learned from the language, under normal circumstances its not possible but now I know.  <br>I am not the kind of person that denies something just to look good. I am more humble than that. I am not afraid to make mistakes just scared that when I point them out somebody crucifies me. its OK I do it anyway. <br><br></td></tr></table><br>
<a name="710909"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >H&amp;K</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Jessie. <br><br>I wasnt having a go, I was just pointing out that if you had used different names in the first place, it would have been more obvious that you had to cast, because the field in "C" wouldnt exist, as apposed to the program using the field in the base type.<br><br>When you first posted it, I had thought that your understanding was that you were only createing one field. As you have said other, then I believe you. Was just shocked that you understood it to that level, yet did realize that you needed to cast.<br><br>I do however think its a silly thing to do (duplicate names), as it gains you no memory, just makes it harder to see iif any future problem is one of allocation or casting. <br><br></td></tr></table><br>
<a name="710910"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> Koriolis: Yes it is a feature. but I'm not sure if a language should really have a "non-name uniqueness" features within inheritance of non-abstract types.<br><br>(I agree that it is needed when you actually implement an Abstract Type, at least *and only then* if Mark is planning to add the possibility to implement multiple abstract types within a single type as C# / Java allow it. But I think this is the only circumstance where a new instance of the name should be created after all, not if you define a field with the same value on an extended type of a non-abstract type) <br><br></td></tr></table><br>
<a name="710911"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> I didn't know about the cast. I learned it from the explanations given by others. <br><br></td></tr></table><br>
<a name="710913"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >H&amp;K</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> If you are going to use fields of the same name, then you have to make sure that the object is cast to the right type.<br><br>In your example you have cast your type C to an A, so it trys to use the field in A. If you recast it back to a C, or make Me a C in the first place, you should get the value you expect <br></div><br><br>As it was I, who first posted that you needed to cast, Then you could at least imply that I had something to do with it rather than saying "the explanations given by others"<br><br>(This is not important, but you made me cry)<br><br>In that thread you had a specific problem that was anwsered (by MEEEEE), this thread tho is a disscustion of if its a valid thing to do. ;) And I dont think it is. I didnt say so in your thread, because it was not my place to say so. However in this thread, you are the only person I know who is acctualy using it, so thats why I keep questioning you. <br><br></td></tr></table><br>
<a name="710918"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> sorry that I wasn't too concerned with who posted what. in the future I'll try to be more in touch with who I read from. In my blured out memories I can kind of recall that post.  And yes it was your post.<br><br>edit:<br>don't miss understand me. your opinion is important to me, It's just that it didn't sink in  until a couple of posts down the thread with further explanation. <br><br></td></tr></table><br>
<a name="710930"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Dreamora: I understand your point, but I think this is a very important feature, if not, an update of a base class (an update of a module) could cause inherited classes to become incompatible. <br><br></td></tr></table><br>
<a name="710933"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >H&amp;K</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Jesse,<br><br>If you want a laugh at how long it took me to get it then read this<br><a href="http://www.blitzbasic.com/Community/posts.php?topic=60015#669484" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=60015#669484</a> <br><br></td></tr></table><br>
<a name="710970"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> ziggy: and how are they not incompatible with dublicate fields?<br><br>What is the use if the module updates the field but your extended class does not get updated? Thats about pointless as the main use of extending is to have the full functionality of the base class and <b>extend</b> it, not replace it. <br><br></td></tr></table><br>
<a name="710973"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> Good one H&amp;K. thanks. Now I don't feel alone in this. <br><br></td></tr></table><br>
<a name="711123"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Koriolis</td><td align="right"><font class=tiny>(Posted 2006)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Koriolis: Yes it is a feature. but I'm not sure if a language should really have a "non-name uniqueness" features within inheritance of non-abstract types. <br></div>Actually I agree here. BlitzMax would probably better generate an error. But IMHO *not* do any kind of overridng here, for speed concerns.<br><br><div class="quote"> Err, thats what overriding is. (Its just that noramally we'd only do it for functions/Methods <br></div>No, that's not overriding at all. Not in the sense commonly admitted in OO languages (that would be overloading, not overriding). Overriding is a dynamic (runtime) feature  ( in general implemented via virtual tables) allowing a method to have multiple implementations (or if you prefer to have several methods to be transparently selected at runtime based on the object's runtime type). Here there is absolutely nothing that imply runtime support. You have two completly different pieces of data, they just happen to have the same name in the parent and the inherited type. The parent and inherited type just form different namespaces here, that's about all. And because they have the same name, from the inherited type perspective the homonym field in the base type is hidden. Everything works at compile time in this area, and the object's runtime type never enter the equation. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
