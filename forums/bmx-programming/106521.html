<!DOCTYPE html><html lang="en" ><head ><title >Cross engine (DX, OGL) Water surface/waves ?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Cross engine (DX, OGL) Water surface/waves ?</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Cross engine (DX, OGL) Water surface/waves ?</a><br><br>
<a name="1311395"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>before trying for ages (without result) I thought of asking you first:<br><br>Is there a way (with default modules) to have a polygon-set being displaced correctly to simulate some kind of water?<br><br>I want to avoid diving into "3d" at all, but still want a "bird's view" ocean/water with wave movement (not just ripples). Doing this by textures ends in having a huge amount of textures (animated -&gt; and each 512x512). My intention is, to avoid this.<br><br>It would also be good if the ocean does take "y" as z-index, so a ship's trunk (in "birds view") would get partially hidden by the waves. Same for fish jumping out of the water. Maybe with some kind of "z-Mask" (which is then an "y-mask") instead of a "viewport".<br><br><br>I somehow doubt that this is possible easily, but who knows - maybe one of you already tackled this ages ago?<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1311563"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hiya,<br><br>Without thinking too hard about it and kind of throwing ideas in the air to see where they land, plus you may well have tried this already, but you can create your own grid mesh in your app and have a couple of sin / cos waves displace the vertices, and/or displace the uvs to achieve a <a href="http://www.acs.psu.edu/drussell/Demos/waves/wavemotion.html" target="_blank">wave like effect</a>. With a good texture it may achieve the effect that youre looking for?<br><br>I've not done this myself but it sounds interesting. <br><br></td></tr></table><br>
<a name="1311564"></a>

<a name="1311565"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> I thought of such thing too (a grid and sin-wave-plus-whatever-vertice-movement).<br><br>While this might work: how to tackle the "overlapping" then? Wait... I have an old game prototype here... which could benefit from this:<br><br><img src="http://i.imgur.com/PWjNnoc.png"><br><br><br>See those ice blocks? and the top-icy-ground ?<br>They should be partially covered by the waves, to the blocks do not "float" on the water but are sunken in a bit.<br><br>In this very special case I could use multiple grids with each "starting" right below the ice blocks ... but then I need to make sure that the bottom part of the water-grid "above" fits exactly to the "top part" of the one below (like in a repeatable pattern).<br><br><br><br><br>So I need to see the "surface" covering parts of 2D sprites.<br>I assume it needs a "3D"-approach with the sprites being rotated planes, the ocean being a grid and the camera being in a position making it look as if it was "birds view 2D-rendered".<br><br>Is this doable in a way that I only tell "max2D" (+ little initialization code)  to do that? I want to avoid recoding things then, when eg. switching to the SDL-graphics-driver of Brucey, or when using srs' DX11.mod .<br><br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1311566"></a>

<a name="1311567"></a>

<a name="1311568"></a>

<a name="1311569"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ahh I see now, a picture is a thousand words eh :p<br><br>With regards to the icy blocks... could you not split the icy block into 2 sprites purely for animated texture reasons. The flat part that the character stands on would be one sprite with a 'fixed' texture, then you'd use another sprite that would be the vertical part that 'dips' into the water.<br><br>For the sprite that dips in the water...<br>With some math and knowing the animation pattern of the waves underneath, and also knowing the position of the 'ice block sprites' in relation to the water waves, can you then animate a texture which has a mix of the ice block and the water?<br>I imagine if you want random waves them you'd need one texture for each wave pattern that you use - 2 sin waves = 2 textures etc then mask/blend them.<br><br>Sounds initially complicated but maybe doable.<br><br>EDIT:- BTW is this a retro remake of 'Frostbite' from Acitivision? :p<br>Looks fun! <br><br></td></tr></table><br>
<a name="1311582"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Doing it in 3d would probably give the best effect for sure - you can still use an orthographic projection to keep everything 2d but do the work in a 3d environment.<br><br>To have one poly 'intersect' with the other in the way that you're thinking then you need a depth buffer, however, I'm not sure if the DEPTH_BUFFER flag was implemented in any of the d3d graphics drivers though. Sure it's supposed to be implemented but from memory I'm sure d3d7, d3d9 and d3d11 don't do anything with that flag parameter. <br><br></td></tr></table><br>
<a name="1311587"></a>

<a name="1311588"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, Frostbite ;-)<br><br>Played this for hours on the Atari 2600.<br><br><br>@ multiple textures<br>It isn't just the ice blocks, it then needs to work with fish, jumping out and in of the water, and I believe there were crabs too :-)<br><br>Also I would like to see that water to be "versatile" (eg. a sandy-pirate-arcade-game).<br><br>So preparing multiple textures is very complex then: you need to know the block-dimensions, the space between blocks, the position of the blocks in the world... argh that is never working "easily" ;-)<br><br>So doing a "3D-thingy" is surely the better solution. if working directly with polygons in 3D space there should be no need for a depth_buffer (wasn't there a flag to enable it - defaulting to "GRAPHICS_BACKBUFFER|GRAPHICS_DEPTHBUFFER")).<br>I then would have it done this way:<br><br><pre class=code>

    |   
    |  |       |       
       |       |
~~~~~~~|~~~~~~~~|

    A  B       CD

A = Sprite of figure
B = Sprite of ice block (affected by "wavy grid")
C = Sprite of tree
D = Sprite of coast (affected by "wavy grid")
</pre><br><br>The projection matrix / camera should then be located so the sprites look like "2D" and the wavy grid is correctly hiding and exposing parts of "B" and "C".<br>(A and C are offset to expose the "order of drawing" - most right is drawn first - at least when it comes to sprites)<br><br><br>Hope this "picture" explains it good enough.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1311652"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh my god, I used to play that for hours and hours too!<br>It was sooo addictive hehe.<br><br>Yeah when you then want to include the other sprites then things would get too complex and out of hand very quickly, so that's a no go :p<br><br>I'd definitely attempt 3d in that case then.<br><br>I still think that you would need the depth buffer if you want the water to be partially penetrated by the ice blocks ( and only because of this 'partial penetration effect' ), otherwise I'm sure that you will see what you have now. On top of which it looks as though the GRAPHICS_DEPTHBUFFER flag is completely disregarded in all of the d3d drivers. Unless I'm reading the source incorrectly - which is very possible nowadays :D <br><br></td></tr></table><br>
<a name="1311658"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Away from "3D": <br><br>I know it is not the most realistic approach: but once knowing the water position and the lowest Y ("bottom start-position") of a sprite, we could use the "darkness/brightness" of the water texture to calculate some "waves".<br><br>Then we prepare a new spriteset for this very position. Cutting "off" what is a "non-wave-top" then. And also cutting things below a given "wave-height" (to save on sprite memory).<br><br>This new sprite is then drawn on top of the water and the blocks.<br><br>advantage: <br>- dynamically createable<br>- "relatively" simple to create<br>- does only rely on (Max)2D<br><br>disadvantage: <br>- the more y's used for objects on the water, the more you need<br>- you cannot use additional blend modes to add "shinyness, reflection-simulation ..." as they would become visible with the new sprite overlaying things then<br><br><br>BTW I tried to convert some c-code last night:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict
Framework BRL.GlMax2D

Import BRL.System
Import BRL.Basic
Import BRL.pngloader
Import BRL.Retro
SetGraphicsDriver GLMax2DDriver()


Graphics 640,480,0

Global image:TImage = LoadImage("someImage.png")


const RESOLUTION:int = 64
global rotate_x:float = 30
global rotate_y:float = 15
global translate_z:float = 4

global surface:float[] = new float[6 * RESOLUTION * (RESOLUTION + 1)]
global normal:float[] = new float[6 * RESOLUTION * (RESOLUTION + 1)]
global length:int = 2 * (RESOLUTION + 1)


glClearColor (0, 0, 0, 0)
glEnable (GL_DEPTH_TEST)
glEnable (GL_BLEND)
glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
glPolygonMode (GL_FRONT_AND_BACK, GL_FILL)
glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST)


While Not KeyDown(Key_Escape)
	local v1x:float, v1y:float, v1z:float
	local v2x:float, v2y:float, v2z:float
	local v3x:float, v3y:float, v3z:float
	local vax:float, vay:float, vaz:float
	local vbx:float, vby:float, vbz:float
	local nx:float, ny:float, nz:float
	local l:float
	local t:float = Millisecs() / 1000.0

	local x:float, y:float
	local delta:float = 2.0 / RESOLUTION
	local xn:float = (RESOLUTION + 1) * delta + 1
	local indice:int = 0
	local preindice:int = 0

	'config
	local drawNormals:int = True
	local drawWireframe:int = False

	'Cls

	glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)

	glLoadIdentity ()
	glTranslatef (0, 0, -translate_z)
	glRotatef (rotate_y, 1, 0, 0)
	glRotatef (rotate_x, 0, 1, 0)


	'Vertices
	for local j:int = 0 until RESOLUTION
		y = (j + 1) * delta - 1
		
		for local i:int = 0 until RESOLUTION
			indice = 6 * (i + j * (RESOLUTION + 1))

			x = i * delta - 1
			surface[indice + 3] = x
			surface[indice + 4] = z (x, y, t)
			surface[indice + 5] = y
			if j
				'Values were computed during the previous loop
				preindice = 6 * (i + (j - 1) * (RESOLUTION + 1))
				surface[indice] = surface[preindice + 3]
				surface[indice + 1] = surface[preindice + 4]
				surface[indice + 2] = surface[preindice + 5]
			else
				surface[indice] = x
				surface[indice + 1] = z (x, -1, t)
				surface[indice + 2] = -1
			endif
		next
	next

	'Normals
	for local j:int = 0 until RESOLUTION
		for local i:int = 0 until RESOLUTION
			indice = 6 * (i + j * (RESOLUTION + 1))

			v1x = surface[indice + 3]
			v1y = surface[indice + 4]
			v1z = surface[indice + 5]

			v2x = v1x
			v2y = surface[indice + 1]
			v2z = surface[indice + 2]

			if i &lt; RESOLUTION
				v3x = surface[indice + 9]
				v3y = surface[indice + 10]
				v3z = v1z
			else
				v3x = xn
				v3y = z (xn, v1z, t)
				v3z = v1z
			endif

			vax =  v2x - v1x
			vay =  v2y - v1y
			vaz =  v2z - v1z

			vbx = v3x - v1x
			vby = v3y - v1y
			vbz = v3z - v1z

			nx = (vby * vaz) - (vbz * vay)
			ny = (vbz * vax) - (vbx * vaz)
			nz = (vbx * vay) - (vby * vax)

			l = sqr (nx * nx + ny * ny + nz * nz)
			if l &lt;&gt; 0
				l = 1.0 / l
				normal[indice + 3] = nx * l
				normal[indice + 4] = ny * l
				normal[indice + 5] = nz * l
			else
				normal[indice + 3] = 0
				normal[indice + 4] = 1
				normal[indice + 5] = 0
			endif

			if j &lt;&gt; 0
				'Values were computed during the previous loop
				preindice = 6 * (i + (j - 1) * (RESOLUTION + 1))
				normal[indice] = normal[preindice + 3]
				normal[indice + 1] = normal[preindice + 4]
				normal[indice + 2] = normal[preindice + 5]
			else
				'/* 	    v1x = v1x; */
				v1y = z (v1x, (j - 1) * delta - 1, t)
				v1z = (j - 1) * delta - 1

				'/* 	    v3x = v3x; */
				v3y = z (v3x, v2z, t)
				v3z = v2z

				vax = v1x - v2x
				vay = v1y - v2y
				vaz = v1z - v2z

				vbx = v3x - v2x
				vby = v3y - v2y
				vbz = v3z - v2z

				nx = (vby * vaz) - (vbz * vay)
				ny = (vbz * vax) - (vbx * vaz)
				nz = (vbx * vay) - (vby * vax)

				l = sqr (nx * nx + ny * ny + nz * nz)

				if l &lt;&gt; 0
					l = 1 / l
					normal[indice] = nx * l
					normal[indice + 1] = ny * l
					normal[indice + 2] = nz * l
				else
					normal[indice] = 0
					normal[indice + 1] = 1
					normal[indice + 2] = 0
				endif
			endif
		Next
	Next



	glPolygonMode (GL_FRONT_AND_BACK, GL_FILL)
	glDisable (GL_TEXTURE_2D)
	glColor3f (1, 0.9, 0.7)
	glBegin (GL_TRIANGLE_FAN)
	glVertex3f (-1, 0, -1)
	glVertex3f (-1, 0,  1)
	glVertex3f ( 1, 0,  1)
	glVertex3f ( 1, 0, -1)
	glEnd

	glTranslatef (0, 0.2, 0)

	if drawWireframe
		glPolygonMode (GL_FRONT_AND_BACK, GL_LINE)
	endif

	'water
	glEnable (GL_TEXTURE_2D)
	glColor3f (1, 1, 1)
	glEnableClientState (GL_NORMAL_ARRAY)
	glEnableClientState (GL_VERTEX_ARRAY)
	glNormalPointer (GL_FLOAT, 0, normal)
	glVertexPointer (3, GL_FLOAT, 0, surface)
    for local i:int = 0 until RESOLUTION
		glDrawArrays (GL_TRIANGLE_STRIP, i * length, length)
	Next


	if drawNormals
		glDisable (GL_TEXTURE_2D)
		glColor4f (1, 0, 0, 1.0)
		glBegin (GL_LINES)
      
		for local j:int = 0 until RESOLUTION
			for local i:int = 0 to RESOLUTION
				indice = 6 * (i + j * (RESOLUTION + 1))
				glVertex3fv (Float Ptr VarPtr (surface[indice]) )
				glVertex3f (surface[indice] + normal[indice] / 50, surface[indice + 1] + normal[indice + 1] / 50, surface[indice + 2] + normal[indice + 2] / 50)
			Next
		Next
		glEnd()
    endif


	'reset back for drawimage
	glEnable (GL_TEXTURE_2D)


	SetColor 255 , 255 , 255
	if image
		DrawImage( image , 100 , 100)
	else
		Drawrect(100,100,50,50)
	endif

	Flip
Wend



function z:float(x:float, y:float, t:float)
  local x2:float = x - 3
  local y2:float = y + 1
  local xx:float = x2 * x2
  local yy:float = y2 * y2

  return ((2 * sin (20 * sqr (xx + yy) - 4 * t) + Noise(10 * x, 10 * y, t, 0)) / 200)
End function

Function Noise:float(x:float, y:float, t:Float, a:float)
	return Rand(100)/100.0
End Function
</textarea><br>C-source: <a href="http://www.lousodrome.net/opengl/#water" target="_blank">http://www.lousodrome.net/opengl/#water</a><br><br><br>But it only displays "nothing". Surely missed something (I do know nothing about OGL/3D-programming-stuff as I never done something with that directly).<br>So without knowing what "might be not working" I am lost a bit for now. Also the motivation to make it work is a bit lower, as it is - of course - not cross-engine, so it gets a bit "lower level" than desired.<br><br><br>@ Frostbite<br>Yes, I thought that time: it surely would do well on smartphones - and nowerdays I thought of using it to have it as test-case for BlitzMax-NG (the best thing to find bugs, is to use a tool in the real world).<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1311665"></a>

<a name="1311669"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> I can't run the code at the mo but initially it looks as though all vertice positions would be in the -1 to 1 range?, max2d would have set up an ortho matrix and viewport to put 0,0 to the top left with width/height of the screen/window so that you can use screen pixel coordinates.<br><br>You could try scaling the vertices to regular max2d screen pixel coordinates?<br><br>EDIT:<br>I just looked through the original source code... I think you should port over the ReshapeFunc function too, plug in the correct width and height and see if that helps. That reshape function looks like it will set the correct projection matrix for that specific demo to work. <br><br></td></tr></table><br>
<a name="1311671"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, adding the "reshape"-portion (without the glut***-code) made it display something ... of course untextured etc. but it displays something.<br><br>Thanks.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1311672"></a>

<a name="1311729"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok extended it a bit:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict
Framework BRL.GlMax2D

Import BRL.System
Import BRL.Basic
Import BRL.pngloader
Import BRL.jpgloader
Import BRL.Retro
SetGraphicsDriver GLMax2DDriver()


Graphics 640,480,0


'setup projection
glMatrixMode(GL_PROJECTION)
glLoadIdentity ()
gluPerspective (20, 640 / 480.0, 0.1, 15)
glViewport (0, 0, 640, 480)
glMatrixMode(GL_MODELVIEW)

Global image:TImage = LoadImage("someImage.png")


const RESOLUTION:int = 64
global rotate_x:float = 30
global rotate_y:float = 15
global translate_z:float = 4

global surface:float[] = new float[6 * RESOLUTION * (RESOLUTION + 1)]
global normal:float[] = new float[6 * RESOLUTION * (RESOLUTION + 1)]
global length:int = 2 * (RESOLUTION + 1)



'Const _NoiseSize:Int = 256
Global _Noise:SimplexNoise = New SimplexNoise


'=== INIT WINDOW ==
glClearColor (0, 0, 0, 0)
glEnable (GL_DEPTH_TEST)
glEnable (GL_BLEND)
glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
glPolygonMode (GL_FRONT_AND_BACK, GL_FILL)
glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST)



'=== CREATE TEXTURE ===
global texture:int 'pointer
global alphaTex:TPixmap = loadpixmap("alpha.jpg")
global reflectionTex:TPixmap = loadpixmap("reflection.jpg")
global total_texture:Byte[4 * 256 * 256]

'Texture loading
glGenTextures (1, varptr texture)
for local i:int = 0 to 256*256
	total_texture[4 * i] = (reflectionTex.Pixels[i] Shr 16) &amp; $ff
	total_texture[4 * i + 1] = (reflectionTex.Pixels[i] Shr 8) &amp; $ff
	total_texture[4 * i + 2] = reflectionTex.Pixels[i] &amp; $ff
	'total_texture[4 * i + 3] = alphaTex.Pixels[i];
Next

glBindTexture (GL_TEXTURE_2D, texture)
'this command seems to have trouble
gluBuild2DMipmaps (GL_TEXTURE_2D, GL_RGBA, 256, 256, GL_RGBA, GL_UNSIGNED_BYTE,  total_texture)
glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP)
glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP)
glEnable (GL_TEXTURE_GEN_S)
glEnable (GL_TEXTURE_GEN_T)
glTexGeni (GL_S, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP)
glTexGeni (GL_T, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP)


'=== MAIN LOOP ==
local start:int = Millisecs()
While Not KeyDown(Key_Escape)
	local v1x:float, v1y:float, v1z:float
	local v2x:float, v2y:float, v2z:float
	local v3x:float, v3y:float, v3z:float
	local vax:float, vay:float, vaz:float
	local vbx:float, vby:float, vbz:float
	local nx:float, ny:float, nz:float
	local l:float
	local t:float = (Millisecs()-start) / 1000.0

	local x:float, y:float
	local delta:float = 2.0 / RESOLUTION
	local xn:float = (RESOLUTION + 1) * delta + 1
	local indice:int = 0
	local preindice:int = 0

	'config
	local drawNormals:int = False
	local drawWireframe:int = False

	'Cls

	glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)

	glLoadIdentity ()
	glTranslatef (0, 0, -translate_z)
	glRotatef (rotate_y, 1, 0, 0)
	glRotatef (rotate_x, 0, 1, 0)


	'Vertices
	for local j:int = 0 until RESOLUTION
		y = (j + 1) * delta - 1
		
		for local i:int = 0 until RESOLUTION
			indice = 6 * (i + j * (RESOLUTION + 1))

			x = i * delta - 1
			surface[indice + 3] = x
			surface[indice + 4] = z (x, y, t)
			surface[indice + 5] = y
			if j
				'Values were computed during the previous loop
				preindice = 6 * (i + (j - 1) * (RESOLUTION + 1))
				surface[indice] = surface[preindice + 3]
				surface[indice + 1] = surface[preindice + 4]
				surface[indice + 2] = surface[preindice + 5]
			else
				surface[indice] = x
				surface[indice + 1] = z (x, -1, t)
				surface[indice + 2] = -1
			endif
		next
	next

	'Normals
	for local j:int = 0 until RESOLUTION
		for local i:int = 0 until RESOLUTION
			indice = 6 * (i + j * (RESOLUTION + 1))

			v1x = surface[indice + 3]
			v1y = surface[indice + 4]
			v1z = surface[indice + 5]

			v2x = v1x
			v2y = surface[indice + 1]
			v2z = surface[indice + 2]

			if i &lt; RESOLUTION
				v3x = surface[indice + 9]
				v3y = surface[indice + 10]
				v3z = v1z
			else
				v3x = xn
				v3y = z (xn, v1z, t)
				v3z = v1z
			endif

			vax =  v2x - v1x
			vay =  v2y - v1y
			vaz =  v2z - v1z

			vbx = v3x - v1x
			vby = v3y - v1y
			vbz = v3z - v1z

			nx = (vby * vaz) - (vbz * vay)
			ny = (vbz * vax) - (vbx * vaz)
			nz = (vbx * vay) - (vby * vax)

			l = sqr (nx * nx + ny * ny + nz * nz)
			if l &lt;&gt; 0
				l = 1.0 / l
				normal[indice + 3] = nx * l
				normal[indice + 4] = ny * l
				normal[indice + 5] = nz * l
			else
				normal[indice + 3] = 0
				normal[indice + 4] = 1
				normal[indice + 5] = 0
			endif

			if j &lt;&gt; 0
				'Values were computed during the previous loop
				preindice = 6 * (i + (j - 1) * (RESOLUTION + 1))
				normal[indice] = normal[preindice + 3]
				normal[indice + 1] = normal[preindice + 4]
				normal[indice + 2] = normal[preindice + 5]
			else
				'/* 	    v1x = v1x; */
				v1y = z (v1x, (j - 1) * delta - 1, t)
				v1z = (j - 1) * delta - 1

				'/* 	    v3x = v3x; */
				v3y = z (v3x, v2z, t)
				v3z = v2z

				vax = v1x - v2x
				vay = v1y - v2y
				vaz = v1z - v2z

				vbx = v3x - v2x
				vby = v3y - v2y
				vbz = v3z - v2z

				nx = (vby * vaz) - (vbz * vay)
				ny = (vbz * vax) - (vbx * vaz)
				nz = (vbx * vay) - (vby * vax)

				l = sqr (nx * nx + ny * ny + nz * nz)

				if l &lt;&gt; 0
					l = 1 / l
					normal[indice] = nx * l
					normal[indice + 1] = ny * l
					normal[indice + 2] = nz * l
				else
					normal[indice] = 0
					normal[indice + 1] = 1
					normal[indice + 2] = 0
				endif
			endif
		Next
	Next



	glPolygonMode (GL_FRONT_AND_BACK, GL_FILL)
	glDisable (GL_TEXTURE_2D)
	glColor3f (1, 0.9, 0.7)
	glBegin (GL_TRIANGLE_FAN)
	glVertex3f (-1, 0, -1)
	glVertex3f (-1, 0,  1)
	glVertex3f ( 1, 0,  1)
	glVertex3f ( 1, 0, -1)
	glEnd

	glTranslatef (0, 0.2, 0)

	if drawWireframe
		glPolygonMode (GL_FRONT_AND_BACK, GL_LINE)
	endif

	'water
	glEnable (GL_TEXTURE_2D)
	glColor3f (1, 1, 1)
	glEnableClientState (GL_NORMAL_ARRAY)
	glEnableClientState (GL_VERTEX_ARRAY)
	glNormalPointer (GL_FLOAT, 0, normal)
	glVertexPointer (3, GL_FLOAT, 0, surface)
    for local i:int = 0 until RESOLUTION
		glDrawArrays (GL_TRIANGLE_STRIP, i * length, length)
	Next


	if drawNormals
		glDisable (GL_TEXTURE_2D)
		glColor4f (1, 0, 0, 1.0)
		glBegin (GL_LINES)
      
		for local j:int = 0 until RESOLUTION
			for local i:int = 0 to RESOLUTION
				indice = 6 * (i + j * (RESOLUTION + 1))
				glVertex3fv (Float Ptr VarPtr (surface[indice]) )
				glVertex3f (surface[indice] + normal[indice] / 50, surface[indice + 1] + normal[indice + 1] / 50, surface[indice + 2] + normal[indice + 2] / 50)
			Next
		Next
		glEnd()
    endif


	'reset back for drawimage
	glEnable (GL_TEXTURE_2D)


	SetColor 255 , 255 , 255
	if image
		DrawImage( image , 100 , 100)
	else
		Drawrect(100,100,50,50)
	endif

	Flip
Wend



function z:float(x:float, y:float, t:float)
  local x2:float = x - 3
  local y2:float = y + 1
  local xx:float = x2 * x2
  local yy:float = y2 * y2

  return ((2 * sin (20 * sqr (xx + yy) - 4 * t) + _Noise.Noise_3D(10 * x, 10 * y, t)) / 200)
'  return ((2 * sin (20 * sqr (xx + yy) - 4 * t) + Noise(10 * x, 10 * y, t, 0)) / 200)
End function




'==== SIMPLEX NOISE by KITTOMER =====
' <a href="http://www.blitzbasic.com/codearcs/codearcs.php?code=2935" target="_blank">http://www.blitzbasic.com/codearcs/codearcs.php?code=2935</a>

'Simplex noise in 2D and 3D
Type SimplexNoise
	
	'Gradient table
	Field grad3:grad[] = [New Grad.Create(1, 1, 0), New Grad.Create(-1, 1, 0), New Grad.Create(1, -1, 0), New Grad.Create(-1, -1, 0),  ..
						 New Grad.Create(1, 0, 1), New Grad.Create(-1, 0, 1), New Grad.Create(1, 0, -1), New Grad.Create(-1, 0, -1),  ..
						 New Grad.Create(0, 1, 1), New Grad.Create(0, -1, 1), New Grad.Create(0, 1, -1), New Grad.Create(0, -1, -1)]
	
	'Permutation table.
	Field perm:Int[] = New Int[512]
	
	'Permutation table containing precomputed, mod12'd perm table.
	Field permMod12:Int[] = New Int[512]
	
	'Precomputed skew factors.
	Field F2:Float = 0.5 * (Sqr(3.0) - 1.0)
	Field G2:Float = (3.0 - Sqr(3.0)) / 6.0
	Field F3:Float = 1.0 / 3.0
	Field G3:Float = 1.0 / 6.0
  	
	Method New()
	
		'Randomize the permutation tables.
		For Local I:Int = 0 To 511
			perm[I] = Rand (0, 255)
			permMod12[I] = perm[I] Mod 12
		Next
		
	End Method
	
	'Re-Randomize the permutation tables.
	Method Randomize()
	
		For Local I:Int = 0 To 511
			perm[I] = Rand (0, 255)
			permMod12[I] = perm[I] Mod 12
		Next
		
	End Method
	
	'Should be faster than Floor()
	Method FastFloor:Int(x:Float)
	
		Local y:Int
	
		If x &gt; 0
			y = Int (x)
		Else
			y = Int (x - 1)
		End If
		
		Return y
		
	End Method
	
	'Dot product for 3D Noise
	Method Dot3D:Float (g:Grad, x:Float, y:Float, z:Float)
	
	Return g.x * x + g.y * y + g.z * z
	
	EndMethod
	
	'Dot product for 2D Noise
	Method Dot2D:Float (g:Grad, x:Float, y:Float)
	
	Return g.x * x + g.y * y
	
	EndMethod
	
  	' 2D simplex noise
  	Method Noise_2D:Float (xin:Float, yin:Float)
		
		' Noise contributions from the three corners
	    Local n0:Float, n1:Float, n2:Float
		
	    ' Skew the input space to determine which simplex cell we're in
		Local s:Float = (xin + yin) * F2 ' Hairy factor for 2D
		
	    Local I:Int = FastFloor(xin + s)
	    Local j:Int = FastFloor(yin + s)
		
	    Local t:Float = (I + j) * G2
		
		' Unskew the cell origin back to (x,y) space
	    Local X0:Float = I - t
	    Local Y0:Float = j - t
		
		' The x,y distances from the cell origin
	    X0 = xin - X0
	    Y0 = yin - Y0
		
	    'For the 2D case, the simplex shape is an equilateral triangle.
	    'Determine which simplex we are in.
		
		'Offsets for second (middle) corner of simplex in (i,j) coords
	    Local i1:Int, j1:Int
		
	    If X0 &gt; Y0 Then
			' lower triangle, XY order: (0,0)-&gt;(1,0)-&gt;(1,1)
	    	i1 = 1
			j1 = 0
	    Else
			' upper triangle, YX order: (0,0)-&gt;(0,1)-&gt;(1,1)
			i1 = 0
			j1 = 1
		EndIf
		
	    ' A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
	    ' a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
	    ' c = (3-sqrt(3))/6
		
		' Offsets for middle corner in (x,y) unskewed coords
	    Local x1:Float = x0 - i1 + G2
	    Local y1:Float = y0 - j1 + G2
		
		' Offsets for last corner in (x,y) unskewed coords
	    Local x2:Float = x0 - 1.0 + 2.0 * G2
	    Local y2:Float = y0 - 1.0 + 2.0 * G2
		
	    ' Work out the hashed gradient indices of the three simplex corners
	    Local ii:Int = I &amp; 255
	    Local jj:Int = j &amp; 255
	    Local gi0:Int = permMod12[ii + perm[jj]]
	    Local gi1:Int = permMod12[ii + i1 + perm[jj + j1]]
	    Local gi2:Int = permMod12[ii + 1 + perm[jj + 1]]
		
	    ' Calculate the contribution from the three corners
	    Local t0:Float = 0.5 - X0 * X0 - Y0 * Y0
		
	    If t0 &lt; 0 Then
			n0 = 0.0
	    Else
	    	t0 = t0 * t0
	    	n0 = t0 * t0 * Dot2D(grad3[gi0], X0, Y0) ' (x,y) of grad3 used for 2D gradient
	    EndIf
		
	    Local t1:Float = 0.5 - x1 * x1 - y1 * y1
		
	    If t1 &lt; 0 Then
			n1 = 0.0
	    Else
			t1 = t1 * t1
	    	n1 = t1 * t1 * Dot2D(grad3[gi1], x1, y1)
	    EndIf
		
	    Local t2:Float = 0.5 - x2 * x2 - y2 * y2
		
	    If t2 &lt; 0 Then
			n2 = 0.0
	    Else
	    	t2 = t2 * t2
	    	n2 = t2 * t2 * Dot2D(grad3[gi2], x2, y2)
	    EndIf
		
	    ' Add contributions from each corner to get the final noise value.
	    ' The result is scaled to return values in the interval [-1,1].
	    Return 70.0 * (n0 + n1 + n2)
		
  	EndMethod
	
	' 3D simplex noise
	Method Noise_3D:Float(xin:Float, yin:Float, zin:Float)
	    
		' Noise contributions from the four corners
		Local n0:Float, n1:Float, n2:Float, n3:Float
	    
		' Skew the input space to determine which simplex cell we're in
	    Local s:Float = (xin + yin + zin) * F3 ' Very nice And simple skew factor For 3D
	    Local I:Int = fastfloor(xin + s)
	    Local j:Int = fastfloor(yin + s)
	    Local k:Int = fastfloor(zin + s)
		
	    Local t:Float = (I + j + k) * G3
		
		' Unskew the cell origin back to (x,y,z) space
	    Local X0:Float = I - t
	    Local Y0:Float = j - t
	    Local Z0:Float = k - t
		
		' The x,y,z distances from the cell origin
	    X0 = xin - X0
	    Y0 = yin - Y0
	    Z0 = zin - Z0
		
	    ' For the 3D case, the simplex shape is a slightly irregular tetrahedron.
	    ' Determine which simplex we are in.
		
		' Offsets for second corner of simplex in (i,j,k) coords
	    Local i1:Int, j1:Int, k1:Int
		
		' Offsets for third corner of simplex in (i,j,k) coords
	    Local i2:Int, j2:Int, k2:Int
		
	    If X0 &gt;= Y0 Then
	    	If Y0 &gt;= Z0 Then
	        	i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0 ' X Y Z order
	        Else If X0 &gt;= Z0
				i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1 ' X Z Y order
	        Else
				i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1 ' Z X Y order
	    	EndIf
	    Else ' x0&lt;y0
	    	If Y0 &lt; Z0
		  		i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1 ' Z Y X order
		  	Else If X0 &lt; Z0
				i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1 ' Y Z X order
	      	Else
				i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0 ' Y X Z order
			EndIf
	    EndIf
		
	    ' A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
	    ' a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
	    ' a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
	    ' c = 1/6.
		
		' Offsets for second corner in (x,y,z) coords
	    Local x1:Float = X0 - i1 + G3
	    Local y1:Float = Y0 - j1 + G3
	    Local z1:Float = Z0 - k1 + G3
		
		' Offsets for third corner in (x,y,z) coords
	    Local x2:Float = X0 - i2 + 2.0 * G3
	    Local y2:Float = Y0 - j2 + 2.0 * G3
	    Local z2:Float = Z0 - k2 + 2.0 * G3
		
		' Offsets for last corner in (x,y,z) coords
	    Local x3:Float = X0 - 1.0 + 3.0 * G3
	    Local y3:Float = Y0 - 1.0 + 3.0 * G3
	    Local z3:Float = Z0 - 1.0 + 3.0 * G3
		
	    ' Work out the hashed gradient indices of the four simplex corners
	    Local ii:Int = I &amp; 255
	    Local jj:Int = j &amp; 255
	    Local kk:Int = k &amp; 255
	    Local gi0:Int = permMod12[ii + perm[jj + perm[kk]] ]
	    Local gi1:Int = permMod12[ii + i1 + perm[jj + j1 + perm[kk + k1]] ]
	    Local gi2:Int = permMod12[ii + i2 + perm[jj + j2 + perm[kk + k2]] ]
	    Local gi3:Int = permMod12[ii + 1 + perm[jj + 1 + perm[kk + 1]] ]
		
	    ' Calculate the contribution from the four corners
		
	    Local t0:Float = 0.6 - x0 * x0 - y0 * y0 - z0 * z0
		
	    If t0 &lt; 0
			n0 = 0.0
		Else
	      t0 = t0 * t0
	      n0 = t0 * t0 * Dot3D (grad3[gi0], X0, Y0, Z0)
	    EndIf
		
	    Local t1:Float = 0.6 - x1 * x1 - y1 * y1 - z1 * z1
		
	    If t1 &lt; 0
			n1 = 0.0
	    Else
	      t1 = t1 * t1
	      n1 = t1 * t1 * Dot3D(grad3[gi1], x1, y1, z1)
	    EndIf
		
	    Local t2:Float = 0.6 - x2 * x2 - y2 * y2 - z2 * z2
		
	    If t2 &lt; 0
			n2 = 0.0
	    Else
	      t2 = t2 * t2
	      n2 = t2 * t2 * Dot3D(grad3[gi2], x2, y2, z2)
	    EndIf
		
	    Local t3:Float = 0.6 - x3 * x3 - y3 * y3 - z3 * z3
		
	    If t3 &lt; 0
			n3 = 0.0
	    Else
	      t3 = t3 * t3
	      n3 = t3 * t3 * Dot3D(grad3[gi3], x3, y3, z3)
	    EndIf
		
	    ' Add contributions from each corner to get the final noise value.
	    ' The result is scaled to stay just inside [-1,1]
	    Return 32.0 * (n0 + n1 + n2 + n3)
		
	EndMethod

EndType

'Custom data type for simplex noise gradient definition.
Type Grad

	Field x:Float, y:Float, z:Float
	
	Method Create:grad(x:Float, y:Float, z:Float = 0.0)
	
		Self.x = x
		Self.y = y
		Self.z = z
		
		Return Self
	
	End Method

EndType

Function argb:Int(_red:Int, _green:Int, _blue:Int, _alpha:Int)
	
	Local _argb:Int = 256 * 256 * 256 * _alpha + 256 * 256 * _blue + 256 * _green + _red
	
	Return _argb
		
End Function

</textarea><br>(instead of the noise written in the sample, I used "Simplex Noise" out of the code archives).<br><br>I tried to load the textures but must be doing something wrong... as it does not generate valid mipmaps (if the mipmap-command is run, the "surface" is invisible).<br><br>Any clues or hints?<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1311675"></a>

<a name="1311676"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Cool that you're starting to get somewhere :p<br><br>If you're having texture issues the first thing I would check is that the BlitzMax format and the actual texture format are the same - same depth/pixel format etc. Reason I suggest this is looking at your code you've commented out the alpha channel of the pixels, does this mean that the image is 24bit? if so then try picking a format in the Build2DMipmaps function that matches the same endianess and bytes per pixel. At the moment you have GL_RGBA which is expecting a 32bit pixel layout? Try GL_RGB? <br><br></td></tr></table><br>
<a name="1311677"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Your GL is not portable, btw ;-) <br><br></td></tr></table><br>
<a name="1311678"></a>

<a name="1311679"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> I wouldn't have a clue what's portable or not in the world of GL.<br>:O)<br><br>What's the deal there? Less/more functions? Different functions/parameters? Government cutbacks? :D <br><br></td></tr></table><br>
<a name="1311681"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> For example, things like glBegin() are not available on GLES 2. (and knowing that Derron would like to consider his game for (at least) Android...)<br><br>Therefore it would probably be better to implement something shader-based. <br><br></td></tr></table><br>
<a name="1311682"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ahh, so the fixed function pipeline is out, and only the programmable one is available? <br><br></td></tr></table><br>
<a name="1311683"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yep :-) <br><br></td></tr></table><br>
<a name="1311684"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> The best option would be not to deal with all this gl stuff but having some generic access to vertices...aka cross-engine functions.<br><br>@crossplatform<br>I know...thought of getting it done first...and then trying to make it compatible to the rest.<br><br>Shaders...as long as it includes / handles all the hiding of sprite portions covered by waves..it. would be nice to have... but I doubt it ia that easy then.<br><br>With vertices I have my experiences...but with shaders...hmm and then I surely land in OGL/OGLES-country.<br><br><br>@textures even if I mix things up with rgb..it should at least show some odd colors then?!<br><br><br>Bye<br>Ron <br><br></td></tr></table><br>
<a name="1311687"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Brucey,<br>I can only see that as a good thing :p<br><br>@textures<br><br>Not necessarily, if the driver can't access all of the memory for the texture is may just quit the whole process.<br><br>Specifying that the texture is larger than whats available could get the texture upload kicked out altogether, whereas yes, if you said the pixel format was smaller then I would go with you school of thought with getting strange colour effects. My experience would suggest not to make any assumptions of what the driver is doing but be 100% certain everything is as expected.<br><br>To be honest I find shaders easier to know whats going on, instead of trying to remember state binding/settings for matrices - that's just me.<br><br>@crossplatform<br>You can wrap the lower level functionality that you need into some Types with a base Interface. There's only 1 gpu and it still does the same thing no matter which api is driving it. If using shaders, then sure the shader language syntax will be different but again, math is math, a vector is a vector and a matrix is still a matrix so the calculations are the same. You're only doing basic shader stuff, ie mimicking the fixed function pipeline, so I would think it's pretty straight forward.<br><br>You could possibly use this heirarchy<br><br>Type TGLShader Extends IShader<br>    Field _vertexshader:IVertexShader<br>    Field _pixelshader:IPixelShader<br> <br>    Method SetParameters( worldmatrix, vertices:float[] )<br>    [....]<br>    EndMethod<br>EndType<br><br>Type TD3D9Shader<br>    Field _vertexshader:IVertexShader<br>    Field _pixelshader:IPixelShader<br> <br>    Method SetParameters( worldmatrix, vertices:float[] )<br>    [....]<br>    EndMethod<br>EndType<br><br>Then would also do the same for each shader stage... the vertex shader, pixelshader etc.<br><br>Everything is always possible, just whether its worth investing the time. I personally think it would be as you can then reuse the shader codes for future projects. <br><br></td></tr></table><br>
<a name="1311725"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> &gt; Try GL_RGB? <br><br>This indeed changed things...<br><br><br>@ extending types<br><br>Yes, I know that this would be possible then ... but I did not was enthusiastic about learning something new (shaders) "just for this single purpose" (I know, I could use it later for something I do not know yet).<br><br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1311734"></a>

<a name="1311736"></a>

<a name="1311737"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok, So I adjusted the code a bit, fixed some "to -vs.- until" thingies<br><br>(both images from the download/website linked above)<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict
Framework BRL.GlMax2D

Import BRL.System
Import BRL.Basic
Import BRL.pngloader
Import BRL.jpgloader
Import BRL.Retro
SetGraphicsDriver GLMax2DDriver()

const WIDTH:int = 320
const HEIGHT:int = 240

Graphics WIDTH,HEIGHT,0


'setup projection
glMatrixMode(GL_PROJECTION)
glLoadIdentity ()
gluPerspective (20, WIDTH / Float(HEIGHT), 0.1, 15)
glViewport (0, 0, WIDTH, HEIGHT)
glMatrixMode(GL_MODELVIEW)

Global image:TImage = LoadImage("someImage.png")


const RESOLUTION:int = 64
global rotate_x:float = 0
global rotate_y:float = 40
global translate_z:float = 4

global surface:float[] = new float[6 * RESOLUTION * (RESOLUTION + 1)]
global normal:float[] = new float[6 * RESOLUTION * (RESOLUTION + 1)]
global length:int = 2 * (RESOLUTION + 1)



'Const _NoiseSize:Int = 256
Global _Noise:SimplexNoise = New SimplexNoise


'=== INIT WINDOW ==
glClearColor (0, 0, 0, 0)
glEnable (GL_DEPTH_TEST)
glEnable (GL_BLEND)
glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)
glPolygonMode (GL_FRONT_AND_BACK, GL_FILL)
glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST)



'=== CREATE TEXTURE ===
global texture:int 'pointer
global alphaTex:TPixmap = loadpixmap("alpha.jpg")
global reflectionTex:TPixmap = loadpixmap("reflection.jpg")
global total_texture:Byte[4 * 256 * 256]

'Texture loading
glGenTextures (1, varptr texture)
for local i:int = 0 to 256*256
	total_texture[4 * i] =  ((reflectionTex.Pixels[i] Shr 16) &amp; $ff)
	total_texture[4 * i + 1] = ((reflectionTex.Pixels[i] Shr 8) &amp; $ff)
	total_texture[4 * i + 2] = (reflectionTex.Pixels[i] &amp; $ff)
	total_texture[4 * i + 3] = 2* (alphaTex.Pixels[i] &amp; $ff)
Next

glBindTexture (GL_TEXTURE_2D, texture)
'this command seems to have trouble
gluBuild2DMipmaps (GL_TEXTURE_2D, GL_RGBA, 256, 256, GL_RGBA, GL_UNSIGNED_BYTE,  total_texture)
glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP)
glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP)
glEnable (GL_TEXTURE_GEN_S)
glEnable (GL_TEXTURE_GEN_T)
glTexGeni (GL_S, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP)
glTexGeni (GL_T, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP)


'=== MAIN LOOP ==
local start:int = Millisecs()
While Not KeyDown(Key_Escape)
	local v1x:float, v1y:float, v1z:float
	local v2x:float, v2y:float, v2z:float
	local v3x:float, v3y:float, v3z:float
	local vax:float, vay:float, vaz:float
	local vbx:float, vby:float, vbz:float
	local nx:float, ny:float, nz:float
	local l:float
	local t:float = (Millisecs()-start) / 1000.0

	local x:float, y:float
	local delta:float = 2.0 / RESOLUTION
	local xn:float = (RESOLUTION + 1) * delta + 1
	local indice:int = 0
	local preindice:int = 0

	'config
	local drawNormals:int = False
	local drawWireframe:int = False

	'Cls

	glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)

	glLoadIdentity ()
	'zoom out/in
	glTranslatef (0, 0, -translate_z)
	'rotate scenery
	glRotatef (rotate_y, 1, 0, 0)
	glRotatef (rotate_x, 0, 1, 0)


	'Vertices
	for local j:int = 0 until RESOLUTION
		y = (j + 1) * delta - 1
		
		for local i:int = 0 to RESOLUTION
			indice = 6 * (i + j * (RESOLUTION + 1))

			x = i * delta - 1
			surface[indice + 3] = x
			surface[indice + 4] = z (x, y, t)
			surface[indice + 5] = y
			if j
				'Values were computed during the previous loop
				preindice = 6 * (i + (j - 1) * (RESOLUTION + 1))
				surface[indice] = surface[preindice + 3]
				surface[indice + 1] = surface[preindice + 4]
				surface[indice + 2] = surface[preindice + 5]
			else
				surface[indice] = x
				surface[indice + 1] = z (x, -1, t)
				surface[indice + 2] = -1
			endif
		next
	next

	'Normals
	for local j:int = 0 until RESOLUTION
		for local i:int = 0 to RESOLUTION
			indice = 6 * (i + j * (RESOLUTION + 1))

			v1x = surface[indice + 3]
			v1y = surface[indice + 4]
			v1z = surface[indice + 5]

			v2x = v1x
			v2y = surface[indice + 1]
			v2z = surface[indice + 2]

			if i &lt; RESOLUTION
				v3x = surface[indice + 9]
				v3y = surface[indice + 10]
				v3z = v1z
			else
				v3x = xn
				v3y = z (xn, v1z, t)
				v3z = v1z
			endif

			vax =  v2x - v1x
			vay =  v2y - v1y
			vaz =  v2z - v1z

			vbx = v3x - v1x
			vby = v3y - v1y
			vbz = v3z - v1z

			nx = (vby * vaz) - (vbz * vay)
			ny = (vbz * vax) - (vbx * vaz)
			nz = (vbx * vay) - (vby * vax)

			l = sqr (nx * nx + ny * ny + nz * nz)
			if l &lt;&gt; 0
				l = 1.0 / l
				normal[indice + 3] = nx * l
				normal[indice + 4] = ny * l
				normal[indice + 5] = nz * l
			else
				normal[indice + 3] = 0
				normal[indice + 4] = 1
				normal[indice + 5] = 0
			endif

			if j &lt;&gt; 0
				'Values were computed during the previous loop
				preindice = 6 * (i + (j - 1) * (RESOLUTION + 1))
				normal[indice] = normal[preindice + 3]
				normal[indice + 1] = normal[preindice + 4]
				normal[indice + 2] = normal[preindice + 5]
			else
				'/* 	    v1x = v1x; */
				v1y = z (v1x, (j - 1) * delta - 1, t)
				v1z = (j - 1) * delta - 1

				'/* 	    v3x = v3x; */
				v3y = z (v3x, v2z, t)
				v3z = v2z

				vax = v1x - v2x
				vay = v1y - v2y
				vaz = v1z - v2z

				vbx = v3x - v2x
				vby = v3y - v2y
				vbz = v3z - v2z

				nx = (vby * vaz) - (vbz * vay)
				ny = (vbz * vax) - (vbx * vaz)
				nz = (vbx * vay) - (vby * vax)

				l = sqr (nx * nx + ny * ny + nz * nz)

				if l &lt;&gt; 0
					l = 1 / l
					normal[indice] = nx * l
					normal[indice + 1] = ny * l
					normal[indice + 2] = nz * l
				else
					normal[indice] = 0
					normal[indice + 1] = 1
					normal[indice + 2] = 0
				endif
			endif
		Next
	Next



	glPolygonMode (GL_FRONT_AND_BACK, GL_FILL)
	glDisable (GL_TEXTURE_2D)
	glColor3f (1, 0.9, 0.7)
	glBegin (GL_TRIANGLE_FAN)
	glVertex3f (-1, 0, -1)
	glVertex3f (-1, 0,  1)
	glVertex3f ( 1, 0,  1)
	glVertex3f ( 1, 0, -1)
	glEnd

	glTranslatef (0, 0.2, 0)

	if drawWireframe
		glPolygonMode (GL_FRONT_AND_BACK, GL_LINE)
	endif

	'water
	glEnable (GL_TEXTURE_2D)
	glColor3f (1, 1, 1)
	glEnableClientState (GL_NORMAL_ARRAY)
	glEnableClientState (GL_VERTEX_ARRAY)
	glNormalPointer (GL_FLOAT, 0, normal)
	glVertexPointer (3, GL_FLOAT, 0, surface)
    for local i:int = 0 until RESOLUTION
		glDrawArrays (GL_TRIANGLE_STRIP, i * length, length)
	Next


	if drawNormals
		glDisable (GL_TEXTURE_2D)
		glColor4f (1, 0, 0, 1.0)
		glBegin (GL_LINES)
      
		for local j:int = 0 until RESOLUTION
			for local i:int = 0 to RESOLUTION
				indice = 6 * (i + j * (RESOLUTION + 1))
				glVertex3fv (Float Ptr VarPtr (surface[indice]) )
				glVertex3f (surface[indice] + normal[indice] / 50, surface[indice + 1] + normal[indice + 1] / 50, surface[indice + 2] + normal[indice + 2] / 50)
			Next
		Next
		glEnd()
    endif


	'reset back for drawimage
	glEnable (GL_TEXTURE_2D)


	SetColor 255 , 255 , 255
	if image
		DrawImage( image , 100 , 100)
	else
		Drawrect(100,100,50,50)
	endif

	Flip
Wend



function z:float(x:float, y:float, t:float)
  local x2:float = x - 3
  local y2:float = y + 1
  local xx:float = x2 * x2
  local yy:float = y2 * y2

  return ((2 * sin (20 * sqr (xx + yy) - 4 * t) + _Noise.Noise_3D(10 * x, 10 * y, t)) / 200)
'  return ((2 * sin (20 * sqr (xx + yy) - 4 * t) + Noise(10 * x, 10 * y, t, 0)) / 200)
End function




'==== SIMPLEX NOISE by KITTOMER =====
' <a href="http://www.blitzbasic.com/codearcs/codearcs.php?code=2935" target="_blank">http://www.blitzbasic.com/codearcs/codearcs.php?code=2935</a>

'Simplex noise in 2D and 3D
Type SimplexNoise
	
	'Gradient table
	Field grad3:grad[] = [New Grad.Create(1, 1, 0), New Grad.Create(-1, 1, 0), New Grad.Create(1, -1, 0), New Grad.Create(-1, -1, 0),  ..
						 New Grad.Create(1, 0, 1), New Grad.Create(-1, 0, 1), New Grad.Create(1, 0, -1), New Grad.Create(-1, 0, -1),  ..
						 New Grad.Create(0, 1, 1), New Grad.Create(0, -1, 1), New Grad.Create(0, 1, -1), New Grad.Create(0, -1, -1)]
	
	'Permutation table.
	Field perm:Int[] = New Int[512]
	
	'Permutation table containing precomputed, mod12'd perm table.
	Field permMod12:Int[] = New Int[512]
	
	'Precomputed skew factors.
	Field F2:Float = 0.5 * (Sqr(3.0) - 1.0)
	Field G2:Float = (3.0 - Sqr(3.0)) / 6.0
	Field F3:Float = 1.0 / 3.0
	Field G3:Float = 1.0 / 6.0
  	
	Method New()
	
		'Randomize the permutation tables.
		For Local I:Int = 0 To 511
			perm[I] = Rand (0, 255)
			permMod12[I] = perm[I] Mod 12
		Next
		
	End Method
	
	'Re-Randomize the permutation tables.
	Method Randomize()
	
		For Local I:Int = 0 To 511
			perm[I] = Rand (0, 255)
			permMod12[I] = perm[I] Mod 12
		Next
		
	End Method
	
	'Should be faster than Floor()
	Method FastFloor:Int(x:Float)
	
		Local y:Int
	
		If x &gt; 0
			y = Int (x)
		Else
			y = Int (x - 1)
		End If
		
		Return y
		
	End Method
	
	'Dot product for 3D Noise
	Method Dot3D:Float (g:Grad, x:Float, y:Float, z:Float)
	
	Return g.x * x + g.y * y + g.z * z
	
	EndMethod
	
	'Dot product for 2D Noise
	Method Dot2D:Float (g:Grad, x:Float, y:Float)
	
	Return g.x * x + g.y * y
	
	EndMethod
	
  	' 2D simplex noise
  	Method Noise_2D:Float (xin:Float, yin:Float)
		
		' Noise contributions from the three corners
	    Local n0:Float, n1:Float, n2:Float
		
	    ' Skew the input space to determine which simplex cell we're in
		Local s:Float = (xin + yin) * F2 ' Hairy factor for 2D
		
	    Local I:Int = FastFloor(xin + s)
	    Local j:Int = FastFloor(yin + s)
		
	    Local t:Float = (I + j) * G2
		
		' Unskew the cell origin back to (x,y) space
	    Local X0:Float = I - t
	    Local Y0:Float = j - t
		
		' The x,y distances from the cell origin
	    X0 = xin - X0
	    Y0 = yin - Y0
		
	    'For the 2D case, the simplex shape is an equilateral triangle.
	    'Determine which simplex we are in.
		
		'Offsets for second (middle) corner of simplex in (i,j) coords
	    Local i1:Int, j1:Int
		
	    If X0 &gt; Y0 Then
			' lower triangle, XY order: (0,0)-&gt;(1,0)-&gt;(1,1)
	    	i1 = 1
			j1 = 0
	    Else
			' upper triangle, YX order: (0,0)-&gt;(0,1)-&gt;(1,1)
			i1 = 0
			j1 = 1
		EndIf
		
	    ' A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
	    ' a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
	    ' c = (3-sqrt(3))/6
		
		' Offsets for middle corner in (x,y) unskewed coords
	    Local x1:Float = x0 - i1 + G2
	    Local y1:Float = y0 - j1 + G2
		
		' Offsets for last corner in (x,y) unskewed coords
	    Local x2:Float = x0 - 1.0 + 2.0 * G2
	    Local y2:Float = y0 - 1.0 + 2.0 * G2
		
	    ' Work out the hashed gradient indices of the three simplex corners
	    Local ii:Int = I &amp; 255
	    Local jj:Int = j &amp; 255
	    Local gi0:Int = permMod12[ii + perm[jj]]
	    Local gi1:Int = permMod12[ii + i1 + perm[jj + j1]]
	    Local gi2:Int = permMod12[ii + 1 + perm[jj + 1]]
		
	    ' Calculate the contribution from the three corners
	    Local t0:Float = 0.5 - X0 * X0 - Y0 * Y0
		
	    If t0 &lt; 0 Then
			n0 = 0.0
	    Else
	    	t0 = t0 * t0
	    	n0 = t0 * t0 * Dot2D(grad3[gi0], X0, Y0) ' (x,y) of grad3 used for 2D gradient
	    EndIf
		
	    Local t1:Float = 0.5 - x1 * x1 - y1 * y1
		
	    If t1 &lt; 0 Then
			n1 = 0.0
	    Else
			t1 = t1 * t1
	    	n1 = t1 * t1 * Dot2D(grad3[gi1], x1, y1)
	    EndIf
		
	    Local t2:Float = 0.5 - x2 * x2 - y2 * y2
		
	    If t2 &lt; 0 Then
			n2 = 0.0
	    Else
	    	t2 = t2 * t2
	    	n2 = t2 * t2 * Dot2D(grad3[gi2], x2, y2)
	    EndIf
		
	    ' Add contributions from each corner to get the final noise value.
	    ' The result is scaled to return values in the interval [-1,1].
	    Return 70.0 * (n0 + n1 + n2)
		
  	EndMethod
	
	' 3D simplex noise
	Method Noise_3D:Float(xin:Float, yin:Float, zin:Float)
	    
		' Noise contributions from the four corners
		Local n0:Float, n1:Float, n2:Float, n3:Float
	    
		' Skew the input space to determine which simplex cell we're in
	    Local s:Float = (xin + yin + zin) * F3 ' Very nice And simple skew factor For 3D
	    Local I:Int = fastfloor(xin + s)
	    Local j:Int = fastfloor(yin + s)
	    Local k:Int = fastfloor(zin + s)
		
	    Local t:Float = (I + j + k) * G3
		
		' Unskew the cell origin back to (x,y,z) space
	    Local X0:Float = I - t
	    Local Y0:Float = j - t
	    Local Z0:Float = k - t
		
		' The x,y,z distances from the cell origin
	    X0 = xin - X0
	    Y0 = yin - Y0
	    Z0 = zin - Z0
		
	    ' For the 3D case, the simplex shape is a slightly irregular tetrahedron.
	    ' Determine which simplex we are in.
		
		' Offsets for second corner of simplex in (i,j,k) coords
	    Local i1:Int, j1:Int, k1:Int
		
		' Offsets for third corner of simplex in (i,j,k) coords
	    Local i2:Int, j2:Int, k2:Int
		
	    If X0 &gt;= Y0 Then
	    	If Y0 &gt;= Z0 Then
	        	i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0 ' X Y Z order
	        Else If X0 &gt;= Z0
				i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1 ' X Z Y order
	        Else
				i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1 ' Z X Y order
	    	EndIf
	    Else ' x0&lt;y0
	    	If Y0 &lt; Z0
		  		i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1 ' Z Y X order
		  	Else If X0 &lt; Z0
				i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1 ' Y Z X order
	      	Else
				i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0 ' Y X Z order
			EndIf
	    EndIf
		
	    ' A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
	    ' a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
	    ' a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
	    ' c = 1/6.
		
		' Offsets for second corner in (x,y,z) coords
	    Local x1:Float = X0 - i1 + G3
	    Local y1:Float = Y0 - j1 + G3
	    Local z1:Float = Z0 - k1 + G3
		
		' Offsets for third corner in (x,y,z) coords
	    Local x2:Float = X0 - i2 + 2.0 * G3
	    Local y2:Float = Y0 - j2 + 2.0 * G3
	    Local z2:Float = Z0 - k2 + 2.0 * G3
		
		' Offsets for last corner in (x,y,z) coords
	    Local x3:Float = X0 - 1.0 + 3.0 * G3
	    Local y3:Float = Y0 - 1.0 + 3.0 * G3
	    Local z3:Float = Z0 - 1.0 + 3.0 * G3
		
	    ' Work out the hashed gradient indices of the four simplex corners
	    Local ii:Int = I &amp; 255
	    Local jj:Int = j &amp; 255
	    Local kk:Int = k &amp; 255
	    Local gi0:Int = permMod12[ii + perm[jj + perm[kk]] ]
	    Local gi1:Int = permMod12[ii + i1 + perm[jj + j1 + perm[kk + k1]] ]
	    Local gi2:Int = permMod12[ii + i2 + perm[jj + j2 + perm[kk + k2]] ]
	    Local gi3:Int = permMod12[ii + 1 + perm[jj + 1 + perm[kk + 1]] ]
		
	    ' Calculate the contribution from the four corners
		
	    Local t0:Float = 0.6 - x0 * x0 - y0 * y0 - z0 * z0
		
	    If t0 &lt; 0
			n0 = 0.0
		Else
	      t0 = t0 * t0
	      n0 = t0 * t0 * Dot3D (grad3[gi0], X0, Y0, Z0)
	    EndIf
		
	    Local t1:Float = 0.6 - x1 * x1 - y1 * y1 - z1 * z1
		
	    If t1 &lt; 0
			n1 = 0.0
	    Else
	      t1 = t1 * t1
	      n1 = t1 * t1 * Dot3D(grad3[gi1], x1, y1, z1)
	    EndIf
		
	    Local t2:Float = 0.6 - x2 * x2 - y2 * y2 - z2 * z2
		
	    If t2 &lt; 0
			n2 = 0.0
	    Else
	      t2 = t2 * t2
	      n2 = t2 * t2 * Dot3D(grad3[gi2], x2, y2, z2)
	    EndIf
		
	    Local t3:Float = 0.6 - x3 * x3 - y3 * y3 - z3 * z3
		
	    If t3 &lt; 0
			n3 = 0.0
	    Else
	      t3 = t3 * t3
	      n3 = t3 * t3 * Dot3D(grad3[gi3], x3, y3, z3)
	    EndIf
		
	    ' Add contributions from each corner to get the final noise value.
	    ' The result is scaled to stay just inside [-1,1]
	    Return 32.0 * (n0 + n1 + n2 + n3)
		
	EndMethod

EndType

'Custom data type for simplex noise gradient definition.
Type Grad

	Field x:Float, y:Float, z:Float
	
	Method Create:grad(x:Float, y:Float, z:Float = 0.0)
	
		Self.x = x
		Self.y = y
		Self.z = z
		
		Return Self
	
	End Method

EndType

Function argb:Int(_red:Int, _green:Int, _blue:Int, _alpha:Int)
	
	Local _argb:Int = 256 * 256 * 256 * _alpha + 256 * 256 * _blue + 256 * _green + _red
	
	Return _argb
		
End Function


</textarea><br><br>result:<br><img src="https://abload.de/img/water.mkv.optimizedtpu0t.gif"><br><br><br>At least it works somehow (think the slight "moire" comes from the simplex-noise).<br><br>So even if now tackling this via "shader", above's code might be helpful for someone else.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1311801"></a>

<a name="1311802"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> That looks cool.<br>Good job!<br><br>For the moire effect you may be able to bias the wave noise function based on whatever axis you have setup for depth - to, in effect, lessen the noise as the distance/axis position increases. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
