<!DOCTYPE html><html lang="en" ><head ><title >Simple scripting in a seperate thread</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Simple scripting in a seperate thread</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Simple scripting in a seperate thread</a><br><br>
<a name="1265714"></a>

<a name="1265715"></a>

<a name="1265716"></a>

<a name="1265717"></a>

<a name="1265718"></a>

<a name="1265720"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >RifRaf</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey guys, <br><br>So I was wondering if anyone had an opinion on this. I tossed together the start of a very thin scripting language that I was going to use for rpg hack/slash type of game for AI / QUESTS ect.   I've never attempted threaded work before and am new to BlitzMax learning as I go. Ive got a Blitz3D version too, but no threading in B3D. Curious if anyone has used anything this crude successfully in a fully featured game, and if its worth working on it further<br><br>Here is the mockup document of that I have so far<br><a href="http://www.empowergames.com/myscript.rtf" target="_blank">http://www.empowergames.com/myscript.rtf</a><br><br>As well as the code thus far <br>EASYSCRIPT<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
'/////////////////////////////////////////////////////////////////////////////////////////////////////////
'====================================================
'Escrpit_LoadScriptMain (filename$, title$)           
'====================================================
'______________________________________________________________________________________
'. this loads the script into memory.. This copy of the script is never executed 
'. it resides in memory so that it may be copied into an 'instance script that is 
'. executed. Filename is the text file script. Title is the name/label you want To
'. give To this script. scripts can change their name at runtime via commands
'. RETURNS ID OF SLOT THIS SCRIPT WILL RESIDE IN. (0 -To- MAXSCRIPTS) 
'
'
'______________________________________________________________________________________
'====================================================
'Escrpit_CreateInstance(SLOTID,NAME$)                 
'====================================================
'______________________________________________________________________________________
'.This will Create a Type instance of the Main script And Return the Type Handle
'.you can assign a name$ To search by script label If you do Not want To use the slotid
'.RETURNS ESCRIPT Type
'______________________________________________________________________________________
'
'
'====================================================
'Escrpit_EXECUTEALL()                                 
'====================================================
'. will execute one line on each script instance, Then increment the code line
'. In bmax you should be able to call this function inside its own thread.
'______________________________________________________________________________________
'
'
'====================================================
'Escript_CopyToInstance.escript(slotid) ; used internally by CreateInstance
'====================================================
' SEE THE CASE/SELECT SECTION INSIDE FUNCTION ESCRIPT_EXECUTE LINE FOR CURRENTLY SUPPORTED FUNCTIONS/ABILITIES
'////////////////////////////////////////////////////////////////////////////////////////////////////////////


'================================================================
'================================================================
'EASY SCRIPT ( Rifraf / Jeff Frazier )
'================================================================
'================================================================
'
'////////////////////////////////////////////////////////////////
'================================================================
'BEGIN MATH EVALATOR DECLARATIONS
'================================================================
Global GLOBAL_line:Int
'---[ Operators ]------------------
Const OpTotal:Int=6
Global op:String[opTotal]
	op$[1]="^"'POW
	op$[2]="*"'MUL
	op$[3]="/"'DIV
	op$[4]="+"'ADD
	op$[5]="-"'SUB
	
'---[ Reserverd ]------------------
Const ResTotal:Int=12
Global res:String[ResTotal]
	res$[1]="0"
	res$[2]="1"
	res$[3]="2"
	res$[4]="3"
	res$[5]="4"
	res$[6]="5"
	res$[7]="6"
	res$[8]="7"
	res$[9]="8"
   res$[10]="9"
   res$[11]="."

'---[  Special  ]------------------
Global SPEC_quote:String=Chr$(34)

'---[  Error's  ]------------------
Global ers:String[9]
	ers$[1]="Unexpected ')'"
	ers$[2]="Expecting expression"
	ers$[3]="Expecting operator"
	ers$[4]="Ilegal character"
	ers$[5]="Missing ')'"
	ers$[6]="Missing " + SPEC_quote$ + " end quote"
	ers$[7]="Value types incorrect"
	ers$[8]="Result of expression out of range"
'================================================================
'END MATH EVALATOR DECLARATIONS
'================================================================
'
'////////////////////////////////////////////////////////////////
'================================================================
'BEGIN EASY SCRIPT DECLARATIONS
'================================================================
Const Script_INT:Int=0
Const Script_FLT:Int=1
Const Script_STR:Int=2

Const Maxlines:Int=255    'MAX LINES PER SCRIPT. 
Const Maxvars:Int=64      '64 LOCAL VARS PER SCRIPT INSTANCE
Const MaxScripts:Int=10000'max master scripts loaded (not running instances but the master)

Const Escript_ENDCODE:Int=-1
Const Escript_ERROR:Int=1

Global ScriptCopy_name:String[maxscripts+1]
Global ScriptCopy_code:String[maxscripts+1,maxlines+1]

  Global Escript_List:TList=New TList
  Global TOKEN_List:TList=New TList
  Global SuperGlobal_List:TList=New TList

Type SuperGlobal 'UNUSED AT THE MOMENT
  Method New()
        SuperGlobal_List.addlast(Self)
  End Method
  Method Destroy()
	SuperGlobal_List.Remove(Self)
  End Method
  Function DestroyEach()
		SuperGlobal_List.clear()
  EndFunction
  Function Last:SuperGlobal()
 		Return SuperGlobal(SuperGlobal_List.last())
  EndFunction
  Function First:SuperGlobal()
 		Return SuperGlobal(SuperGlobal_List.first())
  EndFunction

  Field S_int%[10]
  Field s_Str$[10]
  Field s_flt#[10]
  Field s_timer#[5]
  Field param$
  Field name$
  Field connectedScript:Escript
End Type

Type TOKEN 
  Method New()
        TOKEN_List.addlast(Self)
  End Method
  Method Destroy()
	TOKEN_List.Remove(Self)
  End Method
  Function DestroyEach()
		TOKEN_List.clear()
  EndFunction
  Function Last:TOKEN()
 		Return TOKEN(TOKEN_List.last())
  EndFunction
  Function First:TOKEN()
 		Return TOKEN(TOKEN_List.first())
  EndFunction

	Field txt$
End Type

Type Escript 
  Method New()
        Escript_List.addlast(Self)
  End Method
  Method Destroy()
	Escript_List.Remove(Self)
  End Method
  Function DestroyEach()
		Escript_List.clear()
  EndFunction
  Function Last:Escript()
 		Return Escript(Escript_List.last())
  EndFunction
  Function First:Escript()
 		Return Escript(Escript_List.first())
  EndFunction
  Field parent_scriptslot:Int 'UNUSED AT THE MOMENT
  Field scriptname:String
  Field varname:String[maxvars+1]
  Field varvalue:String[maxvars+1]
  Field vartype:String[maxvars+1]
  Field currentline:Int
  Field FORNEXT:Int[11]
  Field NEXTCOUNT:Int[11]
  Field NEXTMAX:Int[11]
  Field FORCOUNT:Int
  Field gosubline:Int[11]
  Field gosubcount:Int
  Field code:String[maxlines+1]

  Field NestCount:Int
  Field ForNextName:String[10]
  Field ForNextFrom:Int[10]
  Field ForNextTo:Int[10]
  Field ForNextCount:Int[10]
  Field ForStartingLine:Int[10]
End Type
'================================================================
'END EASY SCRIPT DECLARATIONS
'================================================================


'DEMO SAMPLE SCRIPT.. USE DEBUGMODE TO SEE ALL OUTPUT
Local thisslot:Int=escript_loadscriptMain("test_script.txt","test")
Escript_CreateInstance(thisslot,"")

While Not KeyDown(KEY_ESCAPE)
Escript_executeAll()
Wend
'END DEMO / TEST


'================================================================
'================================================================
'================================================================
'================================================================
'BEGIN EASYSCRIPT CORE CODE
'================================================================
'================================================================
'================================================================
'================================================================
Function EScript_ExecuteAll()
Local result:Int
For Local ascript:Escript=EachIn Escript_List
    DebugLog "running script"
    result=escript_Executeline(ascript:Escript,ascript.currentline)
    If result&lt;&gt;Escript_ENDCODE Then  
	    ascript.currentline=ascript.currentline+1
    	If ascript.currentline=&gt;maxlines Then Escript_EndScript(ascript:Escript)
    Else
		Escript_EndScript(ascript:Escript)
	EndIf
Next    
End Function 

Function Escript_EndScript(active:Escript)
         active.destroy()
End Function 

Function EScript_ExecuteLine:Int(active:Escript,CodeLine:Int)
	'get command
	Local singlecommand:Int=0
	Local codecopy:String=(Trim$(Active.code$[codeline]))
	Local codelen:Int=Len(codecopy$)
	Local CommandEnd:Int=Instr(CodeCopy$," ",1)
    Local ThisCommand:String,Param:String
    Local break1:Int
    Local varname:String
	Local math:String
    Local Varid:Int
    Local I:Int
    Local COPYCURRENTLINE:Int
    Local FOUNDNEXT:Int
    Local nextmax:Int
    Local oldline:Int
    Local Operator:Int
	Local OPERATOR_ST:String
	Local NextOperator:String
	Local Block1:String
	Local Block2:String
	Local b1:Float
	Local b2:Float
	Local codecopy2:String
    Local codelen2:Int
    Local commandend2:Int
	Local thiscommand2:String
	Local Param2:String


    DebugLog "EXECUTING LINE "+CODECOPY$
	If CommandEnd&lt;&gt;0 Then
		ThisCommand$=Mid$(codecopy$,1,commandend-1)
	    Param$=Mid$(codecopy$,commandend,codelen-(commandend-1))
        param$=Replace(param$," = ","=")
        If thiscommand$&lt;&gt;"LET$" And thiscommand$&lt;&gt;"IF"  Then param$=Replace(param$," ","")
        param$=EScript_ReplaceVars(active:Escript,param$)
        'param$=EScript_replaceRand(param$) 
        'param$=EScript_replaceRnd(param$) 
		Else
	 	ThisCommand$=Codecopy$
    	PARAM$=""
	EndIf
	Select thiscommand$
		Case "ENDSCRIPT"
             Return ESCRIPT_ENDCODE
		Case "LET$"
              DebugLog "executing script command LET$ "
			  'get variable name we are assigning a value to
			  break1=Instr(param$,"=",1)
              If break1=0 Then 
					DebugLog "equals sign missing from let$ command"
					Return ESCRIPT_ERROR
			  EndIf 
              varname$=Trim$(Mid$(param$,1,break1-1))
	   	      math$=Trim$(Mid$(param$,break1+1,Len(param$)-(break1)))
              Varid=Escript_CreateVar(active:Escript,varname$)  
              If varid=-1 Then 
                 DebugLog "script variable memory exceeded.. var decalare failed"
					Return ESCRIPT_ERROR
              EndIf
              active.varvalue$[varid]=Escript_stringmath(active:Escript,math$) 
'              RuntimeError active\varNAME$[varid]+" "+varid+" :: "+active\varvalue$[varid]
		Case "LET"
              DebugLog "executing script command LET "
			  'get variable name we are assigning a value to
			  break1=Instr(param$,"=",1)
              If break1=0 Then 
					DebugLog "equals sign missing from let command"
					Return ESCRIPT_ERROR
			  EndIf 
              varname$=Mid$(param$,1,break1-1)
	   	      math$=Trim$(Mid$(param$,break1+1,Len(param$)-(break1))  )
              Varid=Escript_CreateVar(active:Escript,varname$)  
              If varid=-1 Then 
                 DebugLog "script variable memory exceeded.. var decalare failed"
					Return ESCRIPT_ERROR
              EndIf
              active.varvalue$[varid]=calculate (math$) 
		Case "FOR"
              'get the loop max
              COPYCURRENTLINE=ACTIVE.CURRENTLINE
              FOUNDNEXT=0 
              For I=COPYCURRENTLINE To MAXLINES
                  If Left$(ACTIVE.CODE$[I],4)="NEXT" Then
                  	foundnext=i
                    Exit
                  EndIf
              Next
              If foundnext=0 Then
                  DebugLog "script error : for without next at line "+active.currentline
				 Return ESCRIPT_ERROR
			  EndIf
			  If active.forcount&gt;10 Then 
				 active.forcount=10
				 DebugLog "script error : too many nested loops "
				 Return ESCRIPT_ERROR
			  EndIf
			  active.forcount=active.forcount+1
              active.Fornext[active.forcount]=active.currentline
              nextmax=Int(Trim$(PARAM$))
			  active.nextmax[active.forcount]= NEXTMAX
              DebugLog "------------------------------------STARTED FOR LOOP.. MAX OF "+ACTIVE.NEXTMAX[ACTIVE.FORCOUNT]
        Case "EXITLOOP"
              oldline=active.currentline 
		  	  active.nextcount[active.forcount]=0
 		 	  ACTIVE.FORCOUNT=ACTIVE.FORCOUNT-1
		      For I=active.currentline To MAXLINES
              	If Left$(ACTIVE.CODE$[I],4)="NEXT" Then
                	active.currentline=i
                   	Exit
                EndIf
              Next 
              If active.forcount&lt;0 Then 
                 active.forcount=0
                 DebugLog "Script Error : NEXT WITHOUT FOR"
                 Return ESCRIPT_ERROR
              EndIf 
              'If our currentline did Not move Then we had an exitloop without Next 
		      If oldline=active.currentline
				 DebugLog "script error : EXITLOOP WITHOUT NEXT"
				 Return ESCRIPT_ERROR
              EndIf 

		Case "NEXT"
              If active.forcount&lt;0 Then 
                 active.forcount=0
                 DebugLog "Script Error : NEXT WITHOUT FOR"
                 Return ESCRIPT_ERROR
              Else 
                     oldline=active.currentline 
 		             active.currentline=active.fornext[active.forcount]
                      DebugLog "repeating looop........................................................................................" 
		              ACTIVE.NEXTCOUNT[active.forcount]=active.nextcount[active.forcount]+1
                      If active.nextcount[active.forcount]&gt;=active.nextmax[active.forcount] Then  
						active.nextcount[active.forcount]=0
 		 		      	ACTIVE.FORCOUNT=ACTIVE.FORCOUNT-1
	                    active.currentline = oldline
	                  EndIf
              EndIf
 		Case "GOTO"
              ACTIVE.CURRENTLINE=Int(PARAM$)
'              RuntimeError PARAM$ 
 		Case "GOSUB"
              active.gosubline[active.gosubcount]=active.currentline   
              active.gosubcount=active.gosubcount+1
              ACTIVE.CURRENTLINE=Int(PARAM$)
      		  If active.gosubcount&gt;10 Then 
                 DebugLog "Script Error : TOO MANY NESTED GOSUBS"
                 Return ESCRIPT_ERROR
              EndIf  
        Case "RETURN"
              active.gosubcount=active.gosubcount-1
              ACTIVE.CURRENTLINE=active.gosubline[active.gosubcount]
              If active.gosubcount&lt;0 Then 
                 DebugLog "Script Error : RETURN WITHOUT GOSUB"
                 Return ESCRIPT_ERROR
              EndIf  
		Case "MARK"
        Case "PRINT$"
              Varid=Escript_Createvar(active:Escript,Mid$(param$,1,break1-1))
              DebugLog param$
              DebugLog "print: "+active.varname$[varid]+" = "+active.varvalue$[varid]+" "+varid

        Case "PRINT"
              DebugLog "print: "+param$
	Case "IF"
		'find the operand
		Operator=ESCRIPT_NextIFOperator(param$, 1)
		If OPERATOR=Len(param$)+1 Then  
			DebugLog "IF Operator Syntax Error"
  			Return ESCRIPT_ERROR
		EndIf
		If thiscommand$="IF" Then
			If Right$(param$,5)&lt;&gt;" THEN" Then  
				DebugLog "IF Syntax Error: Expecting THEN"
				Return ESCRIPT_ERROR
			EndIf
		EndIf
'		If thiscommand$="ELSEIF" Then
'			If Right$(codecopy$,5)=" THEN" Then  
'				DebugLog "ELSEIF/ELSE Syntax Error: THEN not required"
'				;Return ESCRIPT_ERROR
'			Else
'				CODECOPY$=CODECOPY$+" THEN"
'			EndIf
'		EndIf
		OPERATOR_ST$=Mid$(param$,OPERATOR,2)
		NextOperator$=Mid$(param$,operator,2)
		Block1$=Trim$(Mid$(param$,1,operator-1))
		Block2$=Trim$(Mid$(param$,operator+2,Len(param$)-(operator+2+4)))
		block1$=Replace(block1$," ","") ; block1$=calculate("0+"+block1$) 
		block2$=Replace(block2$," ","") ; block2$=calculate("0+"+block2$)
		b1#=Float(block1$)
		b2#=Float(block2$)

		Local test:Int=False
		Select Operator_ST$
		Case "=="
			If b1=b2 Then test=True
			Case "&gt;=","=&gt;"
			If b1&gt;=b2 Then test=True
		Case "&lt;=","=&lt;"
			If b1&lt;=b2 Then test=True
		Case "&lt;&gt;"
			If b1&lt;&gt;b2 Then test=True
		Case "&gt;&gt;"
			If b1&gt;b2 Then test=True
		Case "&lt;&lt;"
			If b1&lt;b2 Then test=True
		End Select
		If test=False Then 
			active.nestcount=1
	    	While active.currentline&lt;MAXLINES
        		active.currentline=active.currentline+1
	            codecopy2$=active.code$[active.currentline]
    	        codelen2=Len(codecopy2$)
        	    commandend2=Instr(codecopy2$," ",1) 
				If commandend2&lt;&gt;0 Then 
					thiscommand2$=Mid$(codecopy2$,1,commandend2-1)
		 		    Param2$=Mid$(codecopy2$,commandend2,codelen2-(commandend2-1))
		           	param2$=Replace(param2$," = ","=")
		            Else
		            thiscommand2$=codecopy2$
		            param2$=" "
	            EndIf  
                If ThisCommand2$="ELSE" Then
					active.nestcount=active.nestcount-1
       		 		active.currentline=active.currentline
                    Return 0
                EndIf
	        	If Thiscommand2$="IF" Then active.nestcount=active.nestcount+1
    	    	If thiscommand2$="ENDIF" Then 
        			active.nestcount=active.nestcount-1 
        			If active.nestcount=0 Then 
	    				'active\currentline=active\currentline-1
	        			Return 0
    	    		EndIf
       			EndIf 
	  		Wend
  		    DebugLog "IF without ENDIF : if"
	EndIf
	Case "ENDIF"
	Case "ELSE"
			active.nestcount=1
	    	While active.currentline&lt;MAXLINES
        		active.currentline=active.currentline+1
	            codecopy2$=active.code$[active.currentline]
    	        codelen2=Len(codecopy2$)
        	    commandend2=Instr(codecopy2$," ",1) 
				If commandend2&lt;&gt;0 Then 
					thiscommand2$=Mid$(codecopy2$,1,commandend2-1)
		 		    Param2$=Mid$(codecopy2$,commandend2,codelen2-(commandend2-1))
		           	param2$=Replace(param2$," = ","=")
		            Else
		            thiscommand2$=codecopy2$
		            param2$=" "
	            EndIf  
                If ThisCommand2$="ELSE" Then
					active.nestcount=active.nestcount-1
       		 		active.currentline=active.currentline
                    Return 0
                EndIf
	        	If Thiscommand2$="IF" Then active.nestcount=active.nestcount+1
    	    	If thiscommand2$="ENDIF" Then 
        			active.nestcount=active.nestcount-1 
        			If active.nestcount=0 Then 
	    				'active\currentline=active\currentline-1
	        			Return 0
    	    		EndIf
       			EndIf 
	  		Wend
  		    DebugLog "IF without ENDIF : else"

	End Select 


End Function 

Function EScript_LoadScriptMain:Int(filename:String,scriptname:String="",forceslot:Int=-1)
Local TL:String
Local TL2:String
Local SLOT:Int
Local i:Int
Local thisline:Int
Local sfile:TStream
Local ex_slot:Int
Local comlen:Int
Local CURRENT_POS:Int
Local label:String
Local found_Goto:Int
Local fline:Int
Local eq_Spot:Int
Local newname:String

    If forceslot&lt;&gt;-1 Then
    	If forceslot&gt;0 And forceslot&lt;=maxscripts Then 
            'set slot to forced spot, and remove any existing name &amp; code in that slot before loading new code 
			slot=forceslot   
            scriptcopy_name$[slot]=""
            For i=1 To maxlines
                  scriptcopy_code$[slot,i]=""
            Next 
		Else
			DebugLog "Script load failed.. forced slot index out of range."
            Return 0
		EndIf
	Else
	    slot=escript_findscriptslot()
    	If slot=-1 Then 
       		DebugLog "Script load failed.. script memory full."
       		Return 0
	    EndIf
    EndIf
	If FileType(filename$)&lt;&gt;1 Then 
		DebugLog "failed to load script "+filename$+" file Not found."
		Return -1
	EndIf

	Sfile:TStream=ReadFile(filename$)
    thisline=0
	If scriptname$&lt;&gt;"" And Escript_CheckScriptExists(scriptname$)=-1 Then
		scriptcopy_name$[Slot]=scriptname$
   	    DebugLog "Script name accepted, and loaded"
    Else 
        ex_slot= Escript_CheckScriptExists(filename$)
		If ex_slot=1 Then
			DebugLog "Script load failed : script name already exists.. returning existing slot with that name "
            Return ex_slot
        Else
		scriptcopy_name$[Slot]=filename$
   	    DebugLog "script name already exists.. loading with the filename as name"
		EndIf
	EndIf	
	While Not Eof(sfile)
		TL$= Trim$(ReadLine(sfile))
        If Upper$(Left$(TL$,4))="LET$" Then
	        'WE DONT WANT TO AUTOCAP THE PARAMETER PORTION OF A TEXT ASSIGNMENT, THE SCRIPT MAY WANT TO USE SMALL LETTERS
			TL2$=TL$
			tl$="LET$ " + (Mid$(TL2$,5,Len(TL2$)-4)) 
           Else
           'IF ITS MATH, SIMPLY CAP IT ALL 
           TL$=Upper$(TL$) 
        EndIf 

    	If Left(TL$,1)&lt;&gt;";" And tl$&lt;&gt;"" Then 
            'convert GOTO &amp; gosub labels to GOTO (line number)

            If Left$(tl$,4)="GOTO" Or Left$(tl$,5)="GOSUB" Then
               If Left$(tl$,4)="GOTO" Then comlen=4 Else comlen=5
               CURRENT_POS=StreamPos(SFILE)
	           label$=Mid$(tl$,comlen+2,Len(tl$)-comlen+1)
               SeekStream sfile,0
	               found_Goto  = 0 
                   fline=0    
 	               While Not Eof(sfile)
 				   		tl2$=ReadLine$(sfile)
				    	If Left(TL2$,1)&lt;&gt;";" And tl2$&lt;&gt;"" Then 
	                   	    If tl2$="MARK "+label$ Then 
    	                       found_goto=fline	              	           
        	                EndIf
            	            fline=fline+1 
						EndIf                
					Wend
                   SeekStream sfile,current_pos
                   If comlen=4 Then 
						tl$="GOTO "+String(FOUND_GOTO)
					Else
						tl$="GOSUB "+String(FOUND_GOTO)
				   EndIf		
            EndIf             

            If Left$(tl$,10)="SCRIPTNAME" 
         	   tl$=Replace$(tl$," = ","=")
               eq_Spot= Instr(tl$,"=",1)
               If  eq_spot Then 
                   newname$=Mid$(tl$,eq_spot+1,Len(tl$)-eq_spot)
						DebugLog "script name for slot "+slot+" changed at script runtime To "+newname$
	               If escript_checkscriptexists(newname$)=1 Then 
						Scriptcopy_name$[slot]=newname$
					EndIf
               EndIf
            EndIf 
			Scriptcopy_code$[slot,thisline]=(TL$)
	        DebugLog "Line ( "+thisline+" ) = "+Upper$(tl$)  
    	    THISLINE=THISLINE+1
	    EndIf
	Wend
			Scriptcopy_code$[slot,thisline]="ENDSCRIPT"
	        DebugLog "Line ( "+thisline+" ) = "+Upper$(tl$)  

CloseFile sfile
DebugLog "loaded script : "+scriptcopy_name$[slot] +" into slot id "+slot +" ."
Return slot
End Function 

Function Escript_FindScriptSlot:Int()
Local i:Int
For I=1 To maxscripts
    If scriptcopy_name$[i]="" Then Return i
Next
End Function 

Function Escript_RemoveScriptMain(slot:Int)
 Scriptcopy_name$[slot]="" 
 For Local i:Int=1 To maxlines
   scriptcopy_code$[slot,i]=""
 Next
End Function 

Function Escript_CheckScriptExists:Int(newname$)
    Local i:Int
	For i=1 To maxscripts
	    If scriptcopy_name$[i]=newname$ Then Return i
	Next
	Return -1
End Function     
	


Function Escript_Createvar:Int(active:Escript,varname$,varvalue$="") 
    'if the variable in question is a real number , and not a word variable.. dont change assign to it
	If Float(varname$)&lt;&gt;0.0 Then Return -1
    Local i:Int
	For i=1 To maxvars
    	If active.varname$[i]=varname$ Then Return i
	Next      
	For i=1 To maxvars
    	If active.varname$[i]="" Then 
        	active.varname$[i]=varname$
          	active.varvalue$[i]=varvalue$ 
          	Select Right$(varname$,1)
            	Case "$"
                	active.vartype[i]=script_str
                Case "%"
                	active.vartype[i]=script_int
                Case "#"
                	active.vartype[i]=script_flt
                Default
                	active.vartype[i]=script_int
	        End Select
	        Return I  
		EndIf
	Next      
Return -1
End Function 


Function Escript_ReplaceVars$(active:Escript,param$)
'if this is a LET command or there is an = we must not remove the original variable name
'that is left of the equals, so that it can still be referenced by name.. all others can be replaced by real values
Local prefix$=""
Local eq_Start%
Local i:Int
EQ_START=Instr(PARAM$,"=")
If EQ_START Then 
 prefix=Left$(param$,eq_start)
 param$=Mid$(PARAM$,eq_start+1,Len(param$)-eq_Start)
EndIf
'now replace all the vars right of the equal
For i=1 To maxvars
  If ACTIVE.VARNAME$[I]&lt;&gt;""  Then  
  param$=Replace$(param$,active.varname$[i],active.varvalue$[i])
  EndIf
Next
'combine prefix and everything right of equal again and return them
DebugLog "returning code from replace vars routine ::"
DebugLog prefix$+param$
Return prefix$+param$
End Function 


Function Escript_CreateInstance:Escript(SlotID:Int,ScriptName:String="")
Local i:Int
Local acs:Escript
 If Scriptname$&lt;&gt;"" Then
	For I=1 To maxscripts
	    If ScriptCopy_name$[i]=scriptname$ Then
        	 acs:Escript=Escript_copytoinstance(i)
         	Return Acs:Escript
	    EndIf
    Next
 Else
     If Trim$(scriptcopy_name$[slotid])="" Then Return Null
     acs:Escript=Escript_copytoinstance(slotid)
     Return Acs:Escript
 EndIf
End Function  

Function Escript_copytoinstance:Escript(slotid:Int)
   Local acs:Escript
   Acs:Escript=New Escript
   acs.parent_scriptslot=slotid
   acs.scriptname$=scriptcopy_name$[slotid]
   acs.currentline=0
   Local i:Int
   For i=1 To 5
	   acs.gosubline[i]=-1
   Next
   acs.gosubcount=0
   For i=1 To maxvars
     acs.varname$[i]=""
     acs.vartype[i]=Script_INT
     acs.varvalue$[i]="0"
   Next
   For I=1 To maxlines
   	 acs.code$[i]=scriptcopy_code$[slotid,i]
   Next
End Function 


Function ESCRIPT_TOKENIZE:Int(txt$,devider$=" ")
    TOKEN.DestroyEach
    Local t:token
	Local n:Int=0
    Local spl:TOKEN
	If Instr(txt$,devider$)=0 Then 
            t:TOKEN=New TOKEN
            t.txt$=txt$
			Return 0
		EndIf
		While txt$&lt;&gt;""
			spl:TOKEN=New TOKEN
			If Instr(txt$,devider$)&lt;&gt;0 Then
				spl.txt$=Left$(txt$,Instr(txt$,devider$)-1)
				txt$=Mid$(txt$,Instr(txt$,devider$)+Len(devider$))
			Else
				spl.txt$=txt$
				txt$=""
			End If
		Wend
End Function




Function Escript_StringMath$(ACTIVE:Escript,params$)
 ' params$=Replace$(params$,space$," ")
 Local totalch:String=""
 Local tk:TOKEN
 escript_tokenize(params$,"+")
 For tk:TOKEN=EachIn token_list
	 totalch$=totalch$+tk.tXT$
 Next
 Replace$(TOTALCH$,"+","")
 Return totalch$
End Function 

Function Escript_betweenquotes:Int(txt:String,spot:Int)
 Local q:Int =-1
 Local i:Int
 For i= spot To 1 Step -1
        If Mid$(txt$,i,1)="" Then 
			q=q+1
     		Exit
		EndIf
 Next
 For i= spot To Len(txt$) Step 1
        If Mid$(txt$,i,1)="" Then 
			q=q+1
     		Exit
		EndIf
 Next
'will return -1 or 0 if there are not quotes on both sides
'will return 1 if there ARE quotes on both sides
Return q
End Function 


Function Escript_NextOperator:Int(St:String, Pos:Int)
	Local InQuote:Int = False
    Local i:Int
	For i = Pos + 1 To Len(St$)
		If Mid$(St$, i, 1) = Chr$(34)
			InQuote = Not InQuote
		ElseIf InQuote = False
			Select Mid$(St$, i, 1)
				Case "+", "*", "/", "\", "&amp;", "|","&lt;", "&gt;"
					
					Return i
                    
				Case "-"
					If i &gt; Pos + 1 Then Return i
			End Select
		EndIf
	Next
	Return Len(St$) + 1
End Function

Function ESCRIPT_NextIFOperator:Int(St:String, Pos:Int)
    Local i:Int
	For i = Pos + 1 To Len(St$)
		Select Mid$(St$, i, 2)
			Case  "==", "=&lt;","&lt;=","=&gt;","&gt;=","&lt;&gt;","&gt;&gt;","&lt;&lt;"  'those are , below or equal to (both ways), above or equal to (both ways) 
			    ' not equal to, greater than, less than
				Return i
			End Select
	Next
	Return  Len(ST$)+1
End Function


Function ReadString$(in:TStream)
	Local	length:Int
	length=ReadInt(in)
	If length&gt;0 And length&lt;1024*1024 Return brl.stream.ReadString(in,length)
End Function
'================================================================
'================================================================
'================================================================
'================================================================
'END EASYSCRIPT CODE
'================================================================
'================================================================
'================================================================
'================================================================





'////////////////////////////////////////////////////////////////
'================================================================
'================================================================
'================================================================
'================================================================
'BEGIN MATH EVALUATOR CODE
'================================================================
'================================================================
'================================================================
'================================================================

Function error:String(message$)
	'temp error message
	DebugLog message$ + "  AT:line " + GLOBAL_line
End Function

Function calculate:String(sum$)
    sum$=Replace$(sum$," ","")
	Local BRAK_x:Int=1
	Local BRAK_found:Int=0
	Local BRAK_getchar:String=""
	Local BRAK_mode:Int=False
	Local BRAK_marker:Int=1
						'Calculate bracket contents
	Local GET_left:String
	Local GET_sum:String
	Local GET_right:String

	
	'--[ Info ] ----
	'This loop cycles through the String 'sum$' finding the 
	'highest bracket. Once it finds it will calculate within the bracket.
	'With the result from that calculation, it replaces the (x) bracket
	'And its contense wit hthe result of the calculation.
	Repeat
		'Get character from 'sum$' using the offset of 'BRAK_x'
		BRAK_getchar$=Mid$(sum$,BRAK_x,1)
		'Test character's properties
		If BRAK_mode=False Then
			If BRAK_getchar$=SPEC_quote$ Then
				BRAK_mode=True
				BRAK_x=BRAK_x+1
			ElseIf BRAK_getchar$="("
				BRAK_found=BRAK_found+1
				BRAK_marker=BRAK_x
				BRAK_x=BRAK_x+1
			ElseIf BRAK_getchar$=")"
				'--&lt; ERROR &gt;--"Unexpected ')'"
				If BRAK_found=0 Then
					error ers$[1]
				Else
					If BRAK_x=BRAK_marker+1 Then
						'--&lt; ERROR &gt;--"Expecting statement"
						error ers$[2]
					Else
						'--[ Found suitable bracket ]----
						'Calculate bracket contents
						GET_left$=Left$(sum$,BRAK_marker-1)
						GET_sum$=Mid$(sum$,BRAK_marker+1,BRAK_x-BRAK_marker-1)
						GET_right$=Right$(sum$,Len(sum$)-BRAK_x)
						sum$=GET_left$ + calculateSUB$(GET_sum$) + GET_right$
						'reset values
						BRAK_x=1
						BRAK_found=BRAK_found-2
						BRAK_marker=1
					End If
				End If
			Else
				If BRAK_x&gt;Len(sum$) Then
					If BRAK_found&gt;0 Then
						error ers$[5]
					Else
						'--[ Found End of sum sucessfully ]----
						'check Not End
						'Calculate sum$
						If Len(sum$)&gt;2 Then
							sum$=calculateSUB$(sum$)
						End If
						'End
						Return sum$
					End If
				Else
					BRAK_x=BRAK_x+1
				End If
			End If
		Else
			'--[ Info ] ----
			'This section is To make sure quotes are read properly.
			If BRAK_getchar$=SPEC_quote$ Then
				BRAK_x=BRAK_x+1
				BRAK_mode=False
			Else
				'--&lt; ERROR &gt;--"Unexpected End to statement"
				If BRAK_x&gt;=Len(sum$) Then
					error ers$[6]
				Else
					BRAK_x=BRAK_x+1
				End If
			End If
		End If
		
	Forever 
End Function






Function calculateSUB:String(sum:String)
   'sum$=Replace$(sum$," ","")
	Local MAKE_left:String
	Local MAKE_right:String
	Local MAKE_sum:String
    Local TEST_array:Int

	Local GETSUB:String=""
	Local TEST_skip:Int=False
    Local TEST_found:Int=False
	Local CALC_x:Int=1
	Local CALC_mode:Int=1
	Local CALC_start:Int=False
	Local CALC_getchar:String=""
	Local CALC_makeTok:String=""
	Local CALC_marker:Int=1
	
	Local CALC_op:String=""
	
	Local CALC_val1:String=""
	Local CALC_readtype1:String=""
	
	Local CALC_val2:String=""
	Local CALC_readtype2:String=""
	
	Local CALC_type:String=""
	'---LOOP---
	'This loop checks the entire sum in order of OP preferance
    Local TEST_loop:Int
	For TEST_loop=1 To optotal
		Repeat
			CALC_getchar$=Mid$(sum$,CALC_x,1)

			If CALC_mode=1 Then
				'expected End of statement
				If CALC_x&gt;Len(sum$) Then
					CALC_x=1
					CALC_start=False
					Exit
				End If
				'Find start of first value
				If CALC_Start=False Then
					If CALC_getchar$=" " Then
						CALC_x=CALC_x+1
					Else
						CALC_marker=CALC_x
						'Detect Type of value To read in
						If CALC_getchar$=SPEC_quote$ Then
							'IS a String
							CALC_readtype1$="string"
							CALC_start=True
							CALC_maketok$=""
							CALC_x=CALC_x+1
						Else
							'IS a value
							CALC_readtype1$="value"
							CALC_start=True
							CALC_maketok$=""
						End If
					End If
				Else
					'---[ Parse value Until operater is met ]------
					If CALC_readtype1$="string" Then
						'Looking For String
						If CALC_getchar$=SPEC_quote$ Then
							If CALC_x=Len(sum$) Then
								CALC_x=1
								CALC_start=False
								Exit
							Else
								'Find operator after quote
								GETSUB$=""
								Repeat
									CALC_x=CALC_x+1
									If CALC_x=Len(sum$) Then
										CALC_x=1
										CALC_start=False
										Exit
									End If
									GETSUB$=Mid$(sum$,CALC_x,1)
								Until GETSUB$&lt;&gt;" "
								'Character after quote has been found
								'
								'If character = add And test loop Then Continue
								If op$[TEST_loop]=GETSUB$ Then
									'Everything matches And is ready
									
									'Check needs expression error
									If CALC_x=Len(sum$) Then
										error ers$[2]
									Else
										'SWITCH To MODE 2
										CALC_val1$=CALC_maketok$
										CALC_op$=op$[4]
										CALC_mode=2
										CALC_x=CALC_x+1
										CALC_maketok$=""
										CALC_start=False
										'Stop
									End If
								Else
									'Character was Not ADD 
									'(only OP that can follow a String)
									'so check OP is valid
									TEST_skip=False
									For TEST_array=1 To optotal
										If op$[TEST_array]=GETSUB$ Then
											TEST_skip=True
											Exit
										End If
									Next
									If TEST_skip=True Then
										CALC_start=False
										CALC_x=CALC_x+1
									Else
										error ers$[4]
									End If
								End If
							End If
						Else
							If CALC_x=Len(sum$) Then
								error ers$[6]
							Else
								CALC_maketok$=CALC_maketok$+CALC_getchar$
								CALC_x=CALC_x+1
							End If
						End If
					Else
						'Looking For Int / Float
						'--[info]--
						'Look For negative value symol First
						If CALC_getchar$="-" And Len(CALC_maketok$)=0 Then
							CALC_maketok$=CALC_maketok$+CALC_getchar$
							If CALC_x=Len(sum$) Then
								error ers$[2]
							Else
								CALC_x=CALC_x+1
							End If
						Else
							'CALC_getchar$ is Not a negative symbol
							'of the number so detect reserved chars
							TEST_found=False
							For TEST_array=1 To restotal-1
								If res$[TEST_array]=CALC_getchar$ Then
									'Test To see If it turns Int into Float
									If TEST_Array=11 Then
										If CALC_readtype1$="float" Then
											'--&lt; ERROR &gt;--Float Type already set extra '.'
											error ers$[4]
										Else
											CALC_readtype1$="float"
										End If
									End If
									TEST_found=True
									Exit
								End If
							Next
							'If Reserved character was met Then add it To the token
							If TEST_found=True Then
								CALC_maketok$=CALC_maketok$+CALC_getchar$
								CALC_x=CALC_x+1
							Else
								If op$[TEST_loop]=CALC_getchar$ Then
									If Len(CALC_maketok$)=0 Then
										error ers$[4]
									Else
									
									
										If CALC_x=Len(sum$) Then
											error ers$[2]
										Else
											'set values
											CALC_val1$=CALC_maketok$
											CALC_op$=CALC_getchar$
											CALC_mode=2
											'reset values
											CALC_start=False
											CALC_x=CALC_x+1
											CALC_maketok$=""
										End If
									
									End If
								Else
									'Make sure is proper character
									TEST_found=False
									For TEST_array=1 To optotal
										If op$[TEST_array]=CALC_getchar$ Then
											TEST_found=True
											Exit
										End If
									Next
									
									If TEST_found=True Then
										'reset values
										CALC_start=False
										CALC_x=CALC_x+1
										CALC_maketok$=""
										CALC_readtype1$=""									
									Else
										error ers$[4]
									End If
								End If
							End If
						End If
					End If
				End If
				
			'---[ INFO ]--------------
			'The all important condition.
			'This will compare the two values And effect them with the
			'VAL1 And the OP that was got in MODE1
			
			ElseIf CALC_mode=2
				If CALC_start=False Then
					If CALC_getchar$=" " Then
						CALC_x=CALC_x+1
					Else
						'Value 3=String
						If CALC_getchar$=SPEC_quote$ Then
							'set
							CALC_readtype2$="string"
							CALC_x=CALC_x+1
							CALC_start=True
							CALC_maketok$=""
						Else
							CALC_readtype2$="value"
							CALC_start=True
							CALC_maketok$=""
						End If
					End If
				Else
					'Parse Until End
					If CALC_readtype2$="string" Then
						If CALC_getchar$=SPEC_quote$ Then
							'----------------------
							'VALUE found finish off
							'----------------------
							'End quote found so do sum And update
							MAKE_left$=Left$(sum$,CALC_marker-1)
							MAKE_right$=Right$(sum$,Len(sum$)-CALC_x)
							MAKE_sum$=CALC_val1$+CALC_maketok$
							sum$=MAKE_left$+SPEC_quote$+MAKE_sum$+SPEC_quote$+MAKE_right$
							'reset
							CALC_x=1
							CALC_mode=1
							CALC_start=False
							CALC_type$=""
							CALC_val1$=""
							CALC_val2$=""
							CALC_op$=""
							CALC_readtype1$=""
							CALC_readtype2$=""
							CALC_maketok$=""
							CALC_marker=1
						Else
							If CALC_x=Len(sum$) Then
								CALC_x=1
								CALC_start=False
							End If
							CALC_maketok$=CALC_maketok$+CALC_getchar$
							CALC_x=CALC_x+1
						End If
					Else
						'Look To make value negative ?
						If CALC_getchar$="-" And Len(CALC_maketok$)=0 Then
							CALC_maketok$=CALC_maketok$+CALC_getchar$
							If CALC_x=Len(sum$) Then
								error ers$[2]
							Else
								CALC_x=CALC_x+1
							End If
						Else
							'Is character a reserved character
							TEST_found=False
							For TEST_array=1 To restotal-1
								If res$[TEST_array]=CALC_getchar$ Then
									TEST_found=True
									If TEST_Array=11 Then
										CALC_readtype2$="float"
									End If
									Exit
								End If
							Next
							'Character matches reserved character
							If TEST_found=True Then
								If CALC_x=Len(sum$) Then
									CALC_maketok$=CALC_maketok$+CALC_getchar$
									'----------------------
									'VALUE found finish off
									'----------------------
									MAKE_left$=Left$(sum$,CALC_marker-1)
									MAKE_right$=Right$(sum$,Len(sum$)-CALC_x)
									CALC_val2$=CALC_maketok$
									
									If CALC_readtype1$="string" Then
										MAKE_sum$=CALC_val1$+CALC_val2$
										sum$=MAKE_left$+SPEC_quote$+MAKE_sum$+SPEC_quote$+MAKE_right$
									Else
										If CALC_readtype1$="value" Then
											Select CALC_op$
												Case op$[1]'POW
													MAKE_sum$=(Int(CALC_val1$)^Int(CALC_val2$))
												Case op$[2]'MUL
													MAKE_sum$=(Int(CALC_val1$)*Int(CALC_val2$))
												Case op$[3]'DIV
													MAKE_sum$=(Int(CALC_val1$)/Int(CALC_val2$))
												Case op$[4]'ADD
													MAKE_sum$=(Int(CALC_val1$)+Int(CALC_val2$))
												Case op$[5]'SUB
													MAKE_sum$=(Int(CALC_val1$)-Int(CALC_val2$))
											End Select
										Else
											Select CALC_op$
												Case op$[1]'POW
													MAKE_sum$=(Float(CALC_val1$)^Float(CALC_val2$))
												Case op$[2]'MUL
													MAKE_sum$=(Float(CALC_val1$)*Float(CALC_val2$))
												Case op$[3]'DIV
													MAKE_sum$=(Float(CALC_val1$)/Float(CALC_val2$))
												Case op$[4]'ADD
													MAKE_sum$=(Float(CALC_val1$)+Float(CALC_val2$))
												Case op$[5]'SUB
													MAKE_sum$=(Float(CALC_val1$)-Float(CALC_val2$))
											End Select
										End If
										'NUMBEr OUT OF RANGE
										If MAKE_sum$="Infinity" Then
											error ers$[8]
										Else
											sum$=MAKE_left$+MAKE_sum$+MAKE_right$
										End If
									End If
									'RESET VALUES
									CALC_x=1
									CALC_mode=1
									CALC_start=False
									CALC_type$=""
									CALC_val1$=""
									CALC_val2$=""
									CALC_op$=""
									CALC_readtype1$=""
									CALC_readtype2$=""
									CALC_maketok$=""
									CALC_marker=1
									'///////////FINISH End/////////////
									
								Else
									CALC_maketok$=CALC_maketok$+CALC_getchar$
									CALC_x=CALC_x+1
								End If
							Else
								'is Not reserved character
								If CALC_x&gt;Len(sum$) Then
									error ers$[2]
								Else
									'Check it is a valid character
									TEST_found=False
									For TEST_array=1 To optotal
										If op$[TEST_array]=CALC_getchar$ Then
											TEST_found=True
											Exit
										End If
									Next
									If TEST_found=True Then
										'----------------------
										'VALUE found finish off
										'----------------------
										MAKE_left$=Left$(sum$,CALC_marker-1)
										MAKE_right$=Right$(sum$,Len(sum$)-CALC_x+1)
										CALC_val2$=CALC_maketok$
										
										If CALC_readtype1$="string" Then
											MAKE_sum$=CALC_val1$+CALC_val2$
											sum$=MAKE_left$+SPEC_quote$+MAKE_sum$+SPEC_quote$+MAKE_right$
										Else
											If CALC_readtype1$="value" Then
												Select CALC_op$
													Case op$[1]'POW
														MAKE_sum$=(Int(CALC_val1$)^Int(CALC_val2$))
													Case op$[2]'MUL
														MAKE_sum$=(Int(CALC_val1$)*Int(CALC_val2$))
													Case op$[3]'DIV
														MAKE_sum$=(Int(CALC_val1$)/Int(CALC_val2$))
													Case op$[4]'ADD
														MAKE_sum$=(Int(CALC_val1$)+Int(CALC_val2$))
													Case op$[5]'SUB
														MAKE_sum$=(Int(CALC_val1$)-Int(CALC_val2$))
												End Select
											Else
												Select CALC_op$
													Case op$[1]'POW
														MAKE_sum$=(Float(CALC_val1$)^Float(CALC_val2$))
													Case op$[2]'MUL
														MAKE_sum$=(Float(CALC_val1$)*Float(CALC_val2$))
													Case op$[3]'DIV
														MAKE_sum$=(Float(CALC_val1$)/Float(CALC_val2$))
													Case op$[4]'ADD
														MAKE_sum$=(Float(CALC_val1$)+Float(CALC_val2$))
													Case op$[5]'SUB
														MAKE_sum$=(Float(CALC_val1$)-Float(CALC_val2$))
												End Select
											End If
											'NUMBEr OUT OF RANGE
											If MAKE_sum$="Infinity" Then
												error ers$[8]
											Else
												sum$=MAKE_left$+MAKE_sum$+MAKE_right$
											End If
										End If
										'RESET VALUES
										CALC_x=1
										CALC_mode=1
										CALC_start=False
										CALC_type$=""
										CALC_val1$=""
										CALC_val2$=""
										CALC_op$=""
										CALC_readtype1$=""
										CALC_readtype2$=""
										CALC_maketok$=""
										CALC_marker=1
										'///////////FINISH End/////////////
									Else
										error ers$[4]
									End If
								End If
									
							End If
						End If
					End If
					
				End If
			End If
		
		Forever
	Next
	If Left$(sum$,1)=SPEC_quote$ Then
		Return Mid$(sum,2,Len(sum$)-2)
	Else
		Return sum$
	End If
End Function
'================================================================
'================================================================
'================================================================
'================================================================
'END MATH EVALUATOR CODE
'================================================================
'================================================================
'================================================================
'================================================================
</textarea><br><br><br>EXAMPLE TEST SCRIPTS ( test_script.txt )<br><pre class=code>
;script test 1
SCRIPTNAME = RIFS SCRIPT
LET$ Me=Rif + Raf
LET$ JEFF$=BlitzUser_ + me
;jeff$ now equals BlitzUser_RifRaf
Print$ jeff$
LET JEFF% = 500.10 - 5.3
LET DEREK% = 0
LET KATIE% = (JEFF% + DEREK%) * 2

PRINT JEFF%

For 10
 For 5
  LET DEREK% = DEREK% + 1
  If derek% &gt;&gt; 40 Then
	PRINT$ ABOVE 40
	  If DEREK% &gt;&gt; 60 Then 
	     Goto MARK_SKIP
	  EndIf
  GOSUB FUNCTION1
  EndIf
 Print DEREK%
 Next
Next

MARK MARK_SKIP
ENDSCRIPT

;example function using Dgosub
MARK FUNCTION1
 PRINT$ FUNC1
 GOSUB FUNCTION2
RETURN


MARK FUNCTION2
 PRINT$ FUNC2
RETURN
</pre> <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
