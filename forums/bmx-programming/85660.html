<!DOCTYPE html><html lang="en" ><head ><title >Some code you may find useful.</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Some code you may find useful.</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Some code you may find useful.</a><br><br>
<a name="969497"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> App.bmx:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Include "rawinput.bmx"
Include "mouse.bmx"


Const DEFAULT_IMAGE_FLAGS% = MIPMAPPEDIMAGE|FILTEREDIMAGE  		' BlitzMax defaults to MASKEDIMAGE|MIPMAPPEDIMAGE|FILTEREDIMAGE.


Type App

	Global Name$
	
	Global Width%										' The current resolution the app is running at, either in windowed or fullscreen mode.
	Global Height%
	Global Depth%

	Global Window:TGadget
	Global Canvas:TGadget
	Global Panel:TGadget
		
	Global TG_FullScreen:TGraphics
	Global TG_Canvas:TGraphics
	
	Global Windowed%

	Const VIRTUAL_WIDTH%    = 800							' The virtual resolution with which everything in the game is positioned.
	Const VIRTUAL_HEIGHT%   = 500							' This, combined with the current resolution, determines if the game will be letterboxed or not.
	
	Global Windowed_Width%  = 800							' The resolution of the game when running in a window.	
	Global Windowed_Height% = 500								
	Global Windowed_Depth%  
	
	Global Full_Width%									' The resolution when running in fullscreen.
	Global Full_Height%
	Global Full_Depth%
	
	Global hWnd%										' Window pointer, when running in Windows.
	
	
	' -------------------------------------------------------------------------------------------------------------------------------------------------------
	' This function creates the game window, and sets up the graphics objects for windowed and fullscreen modes. 
	' -------------------------------------------------------------------------------------------------------------------------------------------------------

		Function Create(AppName$, AppWidth%, AppHeight%, AppDepth%=0, Fullscreen%=False, UseGL%=False)
	
			Local X%, Y%	
			
			' If we should use OpenGL on all platforms, then enable the openGL driver.
				If UseGL% Then SetGraphicsDriver GLMax2DDriver()
			
			' Warn programmer if the game is running in debug mode so they don't wonder why game is running choppy.
				DebugLog("WARNING: Game running debug mode - Performance will be reduced!")
									
			' Store application settings.
				Name$  = AppName$
								
				Full_Width  = AppWidth
				Full_Height = AppHeight	
				
				' If Depth is 0, try to find a suitable fullscreen bit depth.
			
					If AppDepth = 0
						If GraphicsModeExists(Full_Width, Full_Height, 16) Then AppDepth = 16
						If GraphicsModeExists(Full_Width, Full_Height, 24) Then AppDepth = 24
						If GraphicsModeExists(Full_Width, Full_Height, 32) Then AppDepth = 32
					EndIf		
					
				Full_Depth     = AppDepth
				Windowed_Depth = AppDepth
					
			' Create a window in the center of the screen.
			' ClientWidth/Height is used because GadgetWidth/Height returns the entire width of the desktop in dual screen setups.
		
				X = ClientWidth(Desktop())/2  - Windowed_Width/2
				Y = ClientHeight(Desktop())/2 - Windowed_Height/2
				
				'Window = CreateWindow(Name$, X, Y, Windowed_Width, Windowed_Height, Null, WINDOW_TITLEBAR|WINDOW_RESIZABLE|WINDOW_CLIENTCOORDS|WINDOW_HIDDEN)
				'SetMinWindowSize(Window, GadgetWidth(Window), GadgetHeight(Window))

				
				' Create a non-resizable window.
					Window = CreateWindow(Name$, X, Y, Windowed_Width, Windowed_Height, Null, WINDOW_TITLEBAR|WINDOW_CLIENTCOORDS|WINDOW_HIDDEN)
				
				' If running on Windows, add minimize button to window.

					?Win32 
				
						Local xs%
				
						' Get window pointer.
							App.hWnd = QueryGadget(Window, QUERY_HWND) 
	
						' Get window appearance flags, and add Minimize button.
							xs = GetWindowLongA(hWnd, -16) | $20000 

						' Set new window appearance, and apply changes.
							SetWindowLongA(hWnd, -16, xs)
							UpdateWindowMenu(Window)
												
					?
											
			' Create a panel in the window, drawn behind the canvas, which fills the empty space around the gameplay area when the window is maximized.
				
			'	Panel = CreatePanel(0, 0, Windowed_Width, Windowed_Height, Window)
				
			'		SetPanelColor(Panel, 0, 0, 0)
			'		SetGadgetLayout(Panel, EDGE_ALIGNED, EDGE_ALIGNED, EDGE_ALIGNED, EDGE_ALIGNED)
			
			' If running on windows, hook the window's event handler so we can capture events not exposed by BlitzMax.
				?Win32
					HookWinProc(App.hWnd) 
				?
			
			' Set game to windowed or fullscreen as desired.
				Select Fullscreen
					Case False SetWindowed()
					Case True  SetFullscreen()
				End Select
			
			' Enable polled input.
				EnablePolledInput()

			' Load mouse cursor and create mouse sprite.
				InitMouse()
			
			' If running on windows, use the directsound audio driver to fix sound delays in Vista.
				?Win32
					If Not SetAudioDriver("directsound") Then DebugLog("Error in App.Create(): Could not set DirectSound audio driver!")
				?
															
		End Function
		

	' -------------------------------------------------------------------------------------------------------------------------------------------------------
	' This function toggles between fullscreen or windowed mode, choosing the opposite of whichever is currently enabled.
	' -------------------------------------------------------------------------------------------------------------------------------------------------------
	
		Function ToggleFullscreen()
		
			Select Windowed
				Case False SetWindowed()
				Case True  If (Depth &lt;&gt; 0) Then SetFullscreen()
			End Select
			
		End Function

	' -------------------------------------------------------------------------------------------------------------------------------------------------------
	' This function puts the application in windowed mode.
	' -------------------------------------------------------------------------------------------------------------------------------------------------------
		
		Function SetWindowed()

			Width  = Windowed_Width 
			Height = Windowed_Height
			Depth  = Windowed_Depth 
					
			' End fullscreen mode if enabled.
				
				If TG_Fullscreen &lt;&gt; Null
					CloseGraphics TG_Fullscreen
					TG_Fullscreen = Null 
				EndIf	

			' Create a canvas.
											
				If Canvas = Null 
					
					' IMPORTANT NOTE:
					' If using a panel to create a black background, Canvas must be made a child of it, and not the window, so that they draw in the correct order.
					
					Canvas    = CreateCanvas(ClientWidth(Window)/2-Windowed_Width/2, ClientHeight(Window)/2-Windowed_Height/2, Windowed_Width, Windowed_Height, Window)
					TG_Canvas = CanvasGraphics(Canvas)
					
				EndIf	

				If Canvas = Null    Then RuntimeError("Error in Application.SetWindowed() : Could not create canvas!")															
				If TG_Canvas = Null Then RuntimeError("Error in Application.SetWindowed() : Could not get canvas graphics context!")
				
				SetGraphics TG_Canvas
				
				ShowGadget Window
				ActivateGadget Canvas
				
			' Record that windowed mode is enabled.
				Windowed = True
							
			' Canvas must be activated for input or else game will make user click on canvas before any polled keyboard input is returned.
			' (Why am I no longer enabling polled input here?  Does it remain enabled for the window?)
			'	EnablePolledInput()			
			
			' Show mouse if mouse is currently supposed to be visible.
			'	If MouseVisible Then ShowMouse(True)					
			
			' Set the blending mode to alpha.
				SetBlend(ALPHABLEND)
				
			' Set mask color to magenta so black pixels are not made transparent when images without an alpha mask are loaded.
				SetMaskColor(255, 0, 255)

			' Set midhandle so images are loaded properly.
				AutoMidHandle True
			
			' Set image flags.
				AutoImageFlags(DEFAULT_IMAGE_FLAGS)
								
			' Buffer sprite images in video memory.	
			'	Sprite.BufferImages()									

			' Scale the graphics onscreen and display them letterboxed if needed.
				ProjectionMatrix.SetLetterBox(App.VIRTUAL_WIDTH, App.VIRTUAL_HEIGHT)
				Sprite.SetOrigin((ProjectionMatrix._Width-ProjectionMatrix._VirtualWidth)/2, (ProjectionMatrix._Height-ProjectionMatrix._VirtualHeight)/2)

			' Reset mouse so that the player doesn't jump in position suddenly during the next update.
				ResetMouse()
				
		End Function


	' -------------------------------------------------------------------------------------------------------------------------------------------------------
	' This method sets the application to fullscreen mode, unless no fullscreen mode in the desired resolution exists.
	' -------------------------------------------------------------------------------------------------------------------------------------------------------

		Function SetFullscreen()

			Width  = Full_Width 
			Height = Full_Height
			Depth  = Full_Depth 
			
			' If no fullscreen mode is available, set windowed mode instead.
				If Depth = 0
					DebugLog("Error in Application.SetFullscreen() : Depth = 0.  Could not set full screen mode!") 
					SetWindowed()
					Return
				EndIf
			
			' Hide window, free canvas.			
				HideGadget Window
				
				If Canvas &lt;&gt; Null 

					CloseGraphics(TG_Canvas) 
					FreeGadget Canvas
					
					Canvas    = Null
					TG_Canvas = Null
										
				EndIf						
														
			' Set drawing operations to fullscreen.
				If TG_Fullscreen = Null Then TG_Fullscreen = Graphics(Full_Width, Full_Height, Full_Depth, 0)
				
			' If the attempt to set a fullscreen mode fails, put us back in windowed mode. 
				If TG_Fullscreen = Null 
					DebugLog("Error in Application.SetFullscreen() : TG_Fullscreen = Null.  Could not set full screen mode!") 
					DebugLog(Full_Width + "," + Full_Height + "," + Full_Depth)
					SetWindowed()
					Return
				EndIf

			' Record that fullscreen is enabled.
				Windowed = False

			' Show mouse if mouse is currently supposed to be visible.
			'	If MouseVisible Then ShowMouse(True)
				
			' Set the blending mode to alpha.		
				SetBlend(ALPHABLEND)

			' Set mask color to magenta so black pixels are not made transparent when images without an alpha mask are loaded.
				SetMaskColor(255, 0, 255)
				
			' Set midhandle so images are loaded properly.
				AutoMidHandle True

			' Set image flags.
				AutoImageFlags(DEFAULT_IMAGE_FLAGS) 
				
			' Buffer sprite images in video memory.	
			'	Sprite.BufferImages()									

			' Scale the graphics onscreen and display them letterboxed if needed.
				ProjectionMatrix.SetLetterBox(App.VIRTUAL_WIDTH, App.VIRTUAL_HEIGHT)
				Sprite.SetOrigin((ProjectionMatrix._Width-ProjectionMatrix._VirtualWidth)/2, (ProjectionMatrix._Height-ProjectionMatrix._VirtualHeight)/2)

			' Reset mouse so that the player doesn't jump in position suddenly during the next update.
				ResetMouse()
																		
		End Function

				
End Type						


' -----------------------------------------------------------------------------------------------------------------------------------------------------------
' These functions override the regular image loading functions so that we can display an error when an image is missing. 
' -----------------------------------------------------------------------------------------------------------------------------------------------------------

	Function LoadImage:TImage(Url:Object, Flags%=-1, ReturnNull%=False)
	
		Local Image:TImage
					
		Image = Brl.Max2D.LoadImage(Url, Flags)
		
		If Image = Null 
			If ReturnNull  
				DebugLog("LoadImage(): Failed to load image " + String(Url))
				LoadScreen.Update(Url)
				Return Null
			Else	
				RuntimeError("The following image failed to load: '" + String(Url) + "'.  Please reinstall the game.")
			EndIf
		Else
			DebugLog("LoadImage(): Loaded " + String(Url))
		EndIf
		
		' Buffer image in video ram.
			DrawImage Image, App.Width, App.Height
		
		LoadScreen.Update(Url)
		
		Return Image
		
	End Function
	

	Function LoadAnimImage:TImage(Url:Object, Cell_Width%, Cell_Height%, First_Cell%, Cell_Count%, Flags%=-1, ReturnNull%=False)
	
		Local Image:TImage
		Local Frame%

		Image = Brl.Max2D.LoadAnimImage(Url, Cell_Width, Cell_Height, First_Cell, Cell_Count, Flags)
		
		If Image = Null 
			If ReturnNull  
				DebugLog("LoadAnimImage(): Failed to load image " + String(Url))
				LoadScreen.Update(Url)
				Return Null
			Else	
				RuntimeError("The following image failed to load: '" + String(Url) + "'.  Please reinstall the game.")
			EndIf
		Else
			DebugLog("LoadAnimImage(): Loaded " + String(Url))
		EndIf
		
		' Buffer image in video ram.
			For Frame = First_Cell To First_Cell+(Cell_Count-1)
				DrawImage Image, App.Width, App.Height, Frame
			Next  
		
		LoadScreen.Update(Url)
		
		Return Image
		
	End Function


	Function LoadPixmap:TPixmap(Url:Object, ReturnNull%=False)
	
		Local Pixmap:TPixmap
					
		Pixmap = Brl.Pixmap.LoadPixmap(Url)
		
		If Pixmap = Null 
			If ReturnNull  
				Return Null
			Else	
				RuntimeError("The following image failed to load: '" + String(Url) + "'.  Please reinstall the game.")
			EndIf
		EndIf
		
		LoadScreen.Update(Url)
		
		Return Pixmap
		
	End Function		


' -----------------------------------------------------------------------------------------------------------------------------------------------------------
' This function overrides the standard RuntimeError function which does not work properly.  (Assert also does not work.)
' -----------------------------------------------------------------------------------------------------------------------------------------------------------

	Function RuntimeError(Error$)
		EndGraphics
		DebugLog(Error$)
		Notify(Error$, True)
		End
	End Function
	

' -----------------------------------------------------------------------------------------------------------------------------------------------------------
' This function checks for events in the event queue and acts upon them.
' -----------------------------------------------------------------------------------------------------------------------------------------------------------

	Function EventHandler()
				
		MouseHit_Left   = False
		MouseHit_Right  = False
		MouseHit_Middle = False

		While PollEvent() &lt;&gt; 0
		
			'DebugLog("EventID: " + EventID())
			
			Select EventID()
					
				Case EVENT_APPSUSPEND 		' Application suspended. Triggered when window is minimized.
					
					' Pause music.
						If Sound.MusicChannel &lt;&gt; Null Then Sound.MusicChannel.SetPaused(True)
				
				Case EVENT_APPRESUME  		' Application resumed.
				
					' Resume music.
						If Sound.MusicChannel &lt;&gt; Null Then Sound.MusicChannel.SetPaused(False)
				
					' Scale the graphics onscreen and display them letterboxed if needed.
					' (BlitzMax resets the projection matrix when returning to the game after it has been minimized.)
					'	ProjectionMatrix.SetLetterBox(VIRTUAL_WIDTH%, VIRTUAL_HEIGHT%)
				 
				Case EVENT_APPTERMINATE 		' Application wants to terminate. 
				Case EVENT_KEYDOWN 			' Key pressed. Event data contains keycode. 
					
					'If Not KeyState[EventData()]
					'	KeyState[EventData()] = True
					'	KeyHits[EventData()] = KeyHits[EventData()] + 1
					'EndIf	
				
				Case EVENT_KEYUP 			' Key released. Event data contains keycode. 
				Case EVENT_KEYCHAR 			' Key character. Event data contains unicode value. 
				
				Case EVENT_MOUSEDOWN 		' Mouse button pressed. Event data contains mouse button code. (Why am I reading mouse input in the event handler?)
				
					Select EventData()
					
						Case 1 
							MouseDown_Left   = True
							MouseHit_Left    = True
							
						Case 2 
							MouseDown_Right  = True
							MouseHit_Right   = True
							
						Case 3 
							MouseDown_Middle = True
							MouseHit_Right   = True
							
					End Select
					
					
				Case EVENT_MOUSEUP 			' Mouse button released. Event data contains mouse button code. 
				
					Select EventData()
						Case 1 	MouseDown_Left   = False
						Case 2 	MouseDown_Right  = False
						Case 3 	MouseDown_Middle = False
					End Select
				
				
				Case EVENT_MOUSEMOVE 		' Mouse moved. Event x and y contain mouse coordinates.
				
					'Mouse_X# = EventX()
					'Mouse_Y# = EventY()
					
					'DebugLog("E: " + EventX() + "," + EventY())
									 
				Case EVENT_MOUSEWHEEL 		' Mouse wheel spun. Event data contains delta clicks. 
				Case EVENT_MOUSEENTER 		' Mouse entered gadget area. 
				Case EVENT_MOUSELEAVE 		' Mouse left gadget area. 
				Case EVENT_TIMERTICK 		' Timer ticked. Event source contains timer object. 
				Case EVENT_HOTKEYHIT 		' Hot key hit. Event data and mods contains hotkey keycode and modifier.
				Case EVENT_MENUACTION 		' Menu has been selected. 
				Case EVENT_WINDOWMOVE 		' Window has been moved. 
				Case EVENT_WINDOWSIZE 		' Window has been resized.
				Case EVENT_WINDOWCLOSE 		' Window close icon clicked. 
					
					If Not DEMO_VERSION ' Don't allow user to exit game with X if this is demo verison.  That presents too many problems with displaying upsell screen.
						Sound.StopMusic()
						MinimizeWindow(App.Window)
						End 
					EndIf
					
				Case EVENT_WINDOWACTIVATE	' Window activated. 
				Case EVENT_WINDOWACCEPT 		' Drag and drop operation was attempted. 
				Case EVENT_GADGETACTION 		' Gadget state has been updated. 
				Case EVENT_GADGETPAINT 		' A canvas gadget needs to be redrawn. 
				Case EVENT_GADGETSELECT		' A treeview node has been selected. 
				Case EVENT_GADGETMENU 		' User has right clicked a treeview node or textarea gadget. 
				Case EVENT_GADGETOPEN 		' A treeview node has been expanded. 
				Case EVENT_GADGETCLOSE 		' A treeview node has been collapsed. 
				Case EVENT_GADGETDONE 		' An HTMLview has completed loading a page. 

			End Select

		Wend

	End Function


' -----------------------------------------------------------------------------------------------------------------------------------------------------------
' This hooks the gadget paint event so it can redraw the canvas as needed while another window is dragged over the game window.
' -----------------------------------------------------------------------------------------------------------------------------------------------------------

		
	AddHook EmitEventHook, MyHook	
		
	Function MyHook:Object(iId:Int, tData:Object, tContext:Object)
	
 		Local Event:TEvent=TEvent(tData)
		
		If App.Canvas &lt;&gt; Null
			If (Event.Source = App.Canvas) And (Event.ID = EVENT_GADGETPAINT)
				Flip	0	
				Return Null
			EndIf	
		EndIf

		Return tData
		
	End Function
</textarea> <br><br></td></tr></table><br>
<a name="969498"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Mouse.bmx:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">


' These functions rely on code in app.bmx and rawinput.bmx.


' -----------------------------------------------------------------------------------------------------------------------------------------------------------
' These functions override the standard mouse visibility functions so that we can keep track of the mouse visible state.
'
' For ShowMouse:
'
' If Force% is False, then the mouse will not be shown if the current state indicates it is visible.  This is to avoid mouse flicker which is caused by
' showing the mouse over and over.
'
' If Force% is True, the mouse is shown regardless of what state MouseVisible indicates it is in.  This is used during fullscreen/window mode switches where
' the mouse is hidden by the system automatically.
' -----------------------------------------------------------------------------------------------------------------------------------------------------------

' This stuff should all be in a type!

	Global MouseDown_Left%, MouseDown_Right%, MouseDown_Middle%
	Global MouseHit_Left%, MouseHit_Right%, MouseHit_Middle%
	
	Global Mouse_X#, Mouse_Y#				' This is the current postion the mouse.  It us updated when you call UpdateMouse().
	
	Global Old_Mouse_X# = MouseX()			' This was the last position of the mouse.  It's used to calculate Mouse_Vx# and Mouse_Vy#.
	Global Old_Mouse_Y# = MouseY()
	
	Global Mouse_Vx#, Mouse_Vy#				' This is the speed of the mouse onscreen.  These speeds are affected by pointer ballistics.  (Speed is represented as "pixels since last update")
	Global Mouse_RawVx#, Mouse_RawVy#			' This is the raw speed of the mouse.  It is unaffected by pointer ballistics on Win32 systems.  On non Win32 systes, these values will be the same as the above.
	
	Global Mouse_Speed_Multiplier# = 0.5'1.0	' Adjusting this allows you to adjust the values returned by Mouse_Vx#, Mouse_Vy#, Mouse_RawVx#, and Mouse_RawVy#.
	
	Global MouseVisible% = False				' True if the mouse pointer is being drawn.
	Global MouseRelative% = False				' True if the mouse is currently in relative positioning mode.  When in realtive positioning mode, only the mouse speed is available, and the mouse is hidden and kept near the center of the screen.
	
	Global MouseSprite:Sprite 				' This is the sprite which represents the mouse cursor.  It is shown, hidden, and positioned as needed.
		
?Win32
	Global Mouse_NetDeltaX#, Mouse_NetDeltaY#	' Used to accumulate raw mouse movement data each frame so we can calculate Mouse_RawVx# and Mouse_RawVy#.
?
	
	Function InitMouse()

		MouseSprite = Sprite.Create(LoadImage("gfx\menus\mouse.png"))
			
			MouseSprite.SetShadow(DROPSHADOW_DISTANCE#, DROPSHADOW_ANGLE#, DROPSHADOW_ALPHA#)
			MouseSprite.SetOrder(ORDER_MOUSE)
			MouseSprite.SetScale(0.5)
			
		If Not MouseVisible Then MouseSprite.Hide()
		
		Brl.System.HideMouse()	

		' If running on windows:
			?Win32
				RegisterRID_MOUSE(App.hWnd) ' Register the mouse as a raw input device so the more accurate WM_INPUT events which aren't affected by mouse ballistics will be generated.
			?
			
	End Function


	Function ShowMouse(Force%=False)
		If (MouseVisible = False) Or (Force = True)
			MouseVisible = True
			If MouseSprite Then MouseSprite.Show() 'Brl.System.ShowMouse()
		EndIf
	End Function

	
	Function HideMouse()
		MouseVisible = False
		If MouseSprite Then MouseSprite.Hide() 'Brl.System.HideMouse()	
	End Function
	
	
' -----------------------------------------------------------------------------------------------------------------------------------------------------------
' These functions replace the standard mouse functions with ones that take into account a game's virtual screen resolution.  
'
' Because the Blitz functions take integer coordinates, the value returned by MouseX#() and MouseY#() may not match the values passed to MoveMouse().
'
' Normally, this should not cause an issue, but if you do something funny like move the mouse to the position reported by those functions each frame for whatever reason,
' it may make the mouse cursor get stuck.
' -----------------------------------------------------------------------------------------------------------------------------------------------------------
		
	Function MouseX#()
		Return Float(Brl.PolledInput.MouseX()) * (Float(App.VIRTUAL_WIDTH) / Float(App.Width))
	End Function
	
	Function MouseY#()
		Return Float(Brl.PolledInput.MouseY()) * (Float(App.VIRTUAL_HEIGHT) / Float(App.Height))
	End Function
		
	Function MoveMouse(X#, Y#)
		Brl.System.MoveMouse(X# * (Float(App.Width) / Float(App.VIRTUAL_WIDTH)), Y# * (Float(App.Height) / Float(App.VIRTUAL_HEIGHT)))
	End Function


' -----------------------------------------------------------------------------------------------------------------------------------------------------------
' These functions enable and disable relative mouse movement.
'
' Relative mouse movement allows you to work with Mouse_Speed_X# and Mouse_Speed_Y# without worrying about the mouse escaping the window.
'
' Enabling relative mouse movement will cause the mouse to be hidden and stay centered in a "safe zone" in the middle of the window.
' When enabling absolute mouse movement, you should reposition the mouse over the player if possible, so the change in control scheme won't be jarring.
' -----------------------------------------------------------------------------------------------------------------------------------------------------------

	Function NormalMouse()	
				
		MouseRelative = False
		ShowMouse()
		
	End Function

	
	Function RelativeMouse() 
				
		MouseRelative = True
		
		HideMouse()
		MoveMouse App.Width/2, App.Height/2
		
	End Function	
	

' -----------------------------------------------------------------------------------------------------------------------------------------------------------
' This function resets the mouse to the center of the screen/canvas, and negates any recorded change in position.
' It is used when changing the screen res.
' -----------------------------------------------------------------------------------------------------------------------------------------------------------

	Function ResetMouse()
	
		MoveMouse App.Width/2, App.Height/2
		Mouse_X# = MouseX()
		Mouse_Y# = MouseY()
		Old_Mouse_X# = Mouse_X#
		Old_Mouse_Y# = Mouse_Y#
		
	End Function
	
	
' -----------------------------------------------------------------------------------------------------------------------------------------------------------
' This function gets the mouse input for this frame.
' -----------------------------------------------------------------------------------------------------------------------------------------------------------

	Function UpdateMouse()								
		
		Const SAFEZONE_RADIUS# = 100		
		
		Mouse_X# = MouseX()
		Mouse_Y# = MouseY()
		
		Mouse_Vx# = (Mouse_X# - Old_Mouse_X#) * Mouse_Speed_Multiplier#
		Mouse_Vy# = (Mouse_Y# - Old_Mouse_Y#) * Mouse_Speed_Multiplier#
		
		?Win32
				
			Mouse_RawVx# = Mouse_NetDeltaX# * Mouse_Speed_Multiplier#
			Mouse_RawVy# = Mouse_NetDeltaY# * Mouse_Speed_Multiplier#
			
			Mouse_NetDeltaX# = 0
			Mouse_NetDeltaY# = 0
							
		?Not Win32 ' Since we don't know how to read the raw mouse speed on non-windows systems, set the raw mouse speed using our fallback code that relies on mouse recentering.

			Mouse_RawVx# = Mouse_Vx#
			Mouse_RawVy# = Mouse_Vy#

		?
		
		MouseDown_Left   = MouseDown(1)
		MouseDown_Right  = MouseDown(2)
		MouseDown_Middle = MouseDown(3)	
				
		MouseHit_Left    = MouseHit(1)
		MouseHit_Right   = MouseHit(2)
		MouseHit_Middle  = MouseHit(3)
		
		If MouseRelative
						
			' Recenter mouse if it has gone outside a safe zone.
			' Mouse recentering is used when you only want to track how fast the mouse is moving.

			' I forget what the purpouse of having a safe zone rather than recentering it every frame is.
			' I think maybe it allows you to average the mouse speed over several frames if need be for very fine movments of less than a pixel per frame?	
						
			If (Abs(App.Width/2 - Mouse_X#) &gt; SAFEZONE_RADIUS#) Or (Abs(App.Height/2 - Mouse_Y#) &gt; SAFEZONE_RADIUS#)

				MoveMouse App.Width/2, App.Height/2
					
				Old_Mouse_X# = App.Width/2  - (Mouse_X# - Old_Mouse_X#) ' App.Width/2  - Mouse_Speed_X# 
				Old_Mouse_Y# = App.Height/2 - (Mouse_Y# - Old_Mouse_Y#) ' App.Height/2 - Mouse_Speed_Y#
					
			Else
				
				Old_Mouse_X# = Mouse_X#
				Old_Mouse_Y# = Mouse_Y#
									
			EndIf			
				
		Else

			' If the mouse is behaving normally, and the app is running fullscreen, prevent it from moving off the screen too far.
		
			If Not App.Windowed
		
				If (Mouse_X# &lt; 0) Or (Mouse_Y# &lt; 0) Or (Mouse_X# &gt; App.VIRTUAL_WIDTH) Or (Mouse_Y# &gt; App.VIRTUAL_HEIGHT)
					
					If Mouse_X# &lt; 0 Then Mouse_X# = 0
					If Mouse_Y# &lt; 0 Then Mouse_Y# = 0 
					If Mouse_X# &gt; App.VIRTUAL_WIDTH  Then Mouse_X# = App.VIRTUAL_WIDTH
					If Mouse_Y# &gt; App.VIRTUAL_HEIGHT Then Mouse_Y# = App.VIRTUAL_HEIGHT 
					
					MoveMouse Mouse_X#, Mouse_Y#
					
				EndIf

			EndIf
		
		EndIf
			
		MouseSprite.SetPosition(Mouse_X#+MouseSprite.Width(True)/2, Mouse_Y#+MouseSprite.Height(True)/2)		
	
	End Function
</textarea><br><br><br>Rawinput.bmx:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

' This code is used only on Win32 systems.

?Win32

Extern "Win32"
	Function RegisterRawInputDevices:Int(pRawInputDevices:Byte Ptr, uiNumDevices:Int, cbSize:Int)
	Function GetRawInputData:Int(hRawInput:Byte Ptr, uiCommand:Int, pData:Byte Ptr, pcbSize:Int Ptr, cbSizeHeader:Int)
End Extern


Global OldWinProc:Int ' This is the old blitzmax WinProc() function pointer.  This is set when you call HookWinProc().  


Const HID_USAGE_PAGE_GENERIC%  = $1
Const HID_USAGE_GENERIC_MOUSE% = $2
Const RIDEV_INPUTSINK% = $100
Const RIM_TYPEMOUSE% = 0
Const RID_INPUT% = $10000003


' If more than one raw input device needs to be registered, you will need to duplicate the fields in this type, because BltizMax types don't work like C structs,
' and creating arrays of them creates arrays of pointers to the data, rather than arranging multiple copies of the data within the array itself.

Type RAWINPUTDEVICE
   Field usUsagePage:Short
   Field usUsage:Short
   Field dwFlags:Int
   Field hwndTarget:Int
End Type

Global Rid:RAWINPUTDEVICE = New RAWINPUTDEVICE


' This type is a combination of the Windows structs RAWINPUTHEADER, RAWINPUT, and RAWMOUSE.
' This was done to avoid the need for unions (which BlitzMAx does not support) and issues with type variables being a pointer to data rather than having the data at that location.

Type RAWINPUT 
	
	' RAWINPUTHEADER:
		Field dwType:Int
		Field dwSize:Int
		Field hDevice:Byte Ptr
		Field WPARAM:Int Ptr 
	
	' RAWMOUSE:
		Field usFlags:Short 
		Field ulButtons:Int ' Depending on flags, can either be single long value ulButtons or short values usButtonFlags in low word, and usButtonData in high word.  Again, a work around for unions.
	  	Field ulRawButtons:Int 
		Field lLastX:Int 
	  	Field lLastY:Int 
  		Field ulExtraInformation:Int 

End Type 


' ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
' This function registers the mouse as a raw input device, so that WM_INPUT events will be generated for it.
' hWnd is the pointer to your window.  See HookWinProc() above for more details.
' ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


	Function RegisterRID_MOUSE(hWnd:Int)
		
		Rid.usUsagePage = HID_USAGE_PAGE_GENERIC
		Rid.usUsage = HID_USAGE_GENERIC_MOUSE 
		Rid.dwFlags = RIDEV_INPUTSINK   
		Rid.hwndTarget = hWnd			

		RegisterRawInputDevices(Rid, 1, SizeOf(Rid))

	End Function


' ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
' hWnd is the pointer to your window.  hWnd is not the gadget pointer! 
' You can get hWnd with hWnd = GetActiveWindow(), or with hWnd = QueryGadget(Window, QUERY_HWND), where Window is your window's gadget pointer.
' ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	Function HookWinProc(hWnd:Int)
		Local GWL_WNDPROC:Int = -4
		OldWinProc = SetWindowLongA(hWnd, GWL_WNDPROC, Int(Byte Ptr(WinProc)))
	End Function  


' ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
' This function is called automatically.  It grabs raw windows events before Blitzmax processes them, so that you can handle events that Blitzmax doesn't provide an interface for.
'
' Blitzmax has its own function like this internally, and this one calls that when it is done processing.
' Presumably, events handled by this function will still be passsed onto BlitzMax, so avoid processing the same data in both event handlers!
' ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	Function WinProc:Int(hWnd:Int, Msg:Int, wParam:Int, lParam:Int) "win32"
	
		Const WM_INPUT% = $00FF
	
		Function LWord:Short(I:Int) ' Returns the lower 16 bits of a 32 bit integer.
			Return I &amp; $FFFF
		End Function
	
		Function HWord:Short(I:Int) ' Returns the upper 16 bits of a 32 bit integer.
			Return I Shr 16
		End Function
		
		Mouse_RawVx# = 0
		Mouse_RawVy# = 0
		
		Select Msg
	
		    Case WM_INPUT

	    			Local dwSize:Int = 40
				Local Raw:RAWINPUT = New RAWINPUT
    
				GetRawInputData(Byte Ptr(lParam), RID_INPUT, Raw, Varptr dwSize, 16) ' Get data in RAWINPUT structure.
    
				If Raw.dwType = RIM_TYPEMOUSE
				
					Mouse_NetDeltaX# = Mouse_NetDeltaX# + Raw.lLastX
					Mouse_NetDeltaY# = Mouse_NetDeltaY# + Raw.lLastY
				
					'Mouse_RawVx# = Raw.lLastX
					'Mouse_RawVy# = Raw.lLastY
					
					'DebugLog("Raw LastX = " + Raw.lLastX)
					'DebugLog("Raw LastY = " + Raw.lLastY)
					
				EndIf
				
			'Default
			'	DebugLog("Unknown Msg: " + Msg)
					
		End Select
	
		If OldWinProc &lt;&gt; 0 Then Return CallWindowProcA(Byte Ptr(OldWinProc), hWnd, Msg, wParam, lParam)   
		
	End Function

?
</textarea><br><br>Projectionamtrix.bmx:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
' This type allows you to make games that can run at any resolution.
' ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Type ProjectionMatrix
	
	Global _Width%				' The size of the screen, in BlitzMax coordinates. 
	Global _Height%			' Normally BlitzMax coordinates correspond 1:1 with pixels on the screen, but when you adjust the projection matrix, that relationship changes.
	
	Global _VirtualWidth%		' The size of the visible region in which gameplay takes place.  The area inside the letterbox.
	Global _VirtualHeight%


	' -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	' This function sets the scale of the projection matrix.
	'
	' If you simply wish your game to stretch vertically and horizontally to match the current resolution, and fill the screen, call this function with your desired "virtual" resolution.
	' Ie, if you want to build your game around an 800x600 resolution, then set Width and Height to 800,600.  If the game is then run at 1920x1200, it will be squashed vertically.
	'
	' If you want letterboxing however, call InitLetterbox() and then DrawLetterBox() every frame just before you flip.
	' -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		
		Function SetScale(Width%, Height%)
			
			_Width  = Width
			_Height = Height
			
			_VirtualWidth  = Width
			_VirtualHeight = Height
				
			?Win32

				Local D3D7Driver:TD3D7Max2DDriver = TD3D7Max2DDriver(_max2dDriver)
    
				If D3D7Driver
			
					Local Matrix#[] = [2.0/Width, 0.0, 0.0, 0.0,..
   		    	    			     	    0.0, -2.0/Height, 0.0, 0.0,..
       		    	      			    0.0, 0.0, 1.0, 0.0,..
           		    	  			    -1-(1.0/Width), 1+(1.0/Height), 1.0, 1.0]
    
				    D3D7Driver.device.SetTransform(D3DTS_PROJECTION, Matrix)

				Else
			? 
					' If on platform other than Win32, or using OpenGL run this code.
		
					glMatrixMode(GL_PROJECTION)
					glLoadIdentity()
    
					glortho(0, Width, Height, 0, 0, 1)
    
					glMatrixMode(GL_MODELVIEW)
					glLoadIdentity()
		
			?Win32

				EndIf
			?
		
		End Function


	' -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	' This function initializes the letterbox.
	'
	' Call it with the virtual resolution you want to use for your game after you have set the graphics mode, and then DrawLetterBox() every frame just before you flip.
	'
	' These functions will automatically handle both letterboxing on screens which are too tall, and pillarboxing on screens which are too wide.  So if you design your game for 800x600,
	' then InitLetterbox() will squash things horizontally to maintain the proper aspect ratio, and DrawLetterbox() will add black bars to the sides of the display for you.
	'
	' 
	' -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		
		Function SetLetterbox(Width%, Height%)	

			Local NewWidth#, NewHeight#
						
			NewWidth#  = Width
			NewHeight# = Float(GraphicsHeight()) / (Float(GraphicsWidth()) / Float(Width))
		
			' If screen is wider than the desired apsect ratio...

				If NewHeight# &lt; Height
				
					' Use pillarboxing instead of letterboxing.
										
						NewHeight# = Height
						NewWidth#  = Float(GraphicsWidth()) / (Float(GraphicsHeight())/Float(Height)) 	' Commenting this out will squash the game vertically on screens which are too wide.
																						' But without additional changes, black bars will still be drawn.						
				EndIf
			
			' Adjust the scale of the projection matrix to achieve the desired result.
				ProjectionMatrix.SetScale(NewWidth#, NewHeight#)
		
			' Store the size of the visible game region.
				_VirtualWidth  = Width
				_VirtualHeight = Height
	
		End Function 
		
		
	' -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	' This function draws black bars over the portions of the screen which are outside the gameplay area.
	' -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

		Function DrawLetterbox()
		
			Local Size%
			
			RenderState.Push()	
			
			If _VirtualHeight &lt; _Height
				
				' Draw Letterbox.
				
					Size = (_Height-_VirtualHeight) / 2
				
					SetColor(0,0,0) 
							
					DrawRect(0,            0, _Width, Size)
					DrawRect(0, _Height-Size, _Width, Size)
					
			Else
				
				' Draw pillarbox.

					Size = (_Width-_VirtualWidth) / 2
				
					SetColor(0,0,0) 
							
					DrawRect(          0, 0, Size, _Height)
					DrawRect(_Width-Size, 0, Size, _Height)
				
			EndIf			
			
			RenderState.Pop() 	' Render push and pop simply resets the color and other display properties to whatever they were beforehand.  These two functions are in the code archives.
			
		End Function


	' -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	' These functions return the virtual width and height of the usuable region of the screen, inside any letterboxing.
	'
	' Basically, these functions are equivalent to GraphicsWidth() and GraphicsHeight() when using a projection matrix where coordinates don't match up 1:1 to pixels
	' and/or letterboxing is being used.
	'
	' These functions will not return useful values until either ProjectionMatrix.SetScale() is called, or ProjectonMatrix.SetLetterbox() is called!
	' -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

		Function Width#()
			Return _VirtualWidth
		End Function
		
		Function Height#()
			Return _VirtualHeight
		End Function
		
	
	' -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	' These functions tell you where the center of the screen is when using letterboxing.  
	'
	' Note thwt using these functions is uneccessary and will return the wrong value if you have used Sprite.SetOrigin() to correct the position of the top left corner of the screen.
	'
	' Also note that they do not calculate this using the width and height of the visible area of the screen, but rather, the size of the whole screen including the letterboxed regions.
	' This is important, because if you draw objects using the size of the visible region only, they will be higher on the screen than they should be, or more to the left.
	'
	' In my games, what I do is create a pivot called Origin, and place it in the center of the screen, and attach all my sprites to that, so the only time I need to worry about where
	' the center of the screen really is is when I position that pivot initially. 
	'
	' Then when I've done that, the top of the screen is at -ProjectionMatrix.Height#()/2, half the height I passed to SetLetterbox(), and so on.
	' -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		
		Function CenterX#()
			Return _Width/2
		End Function
			
		Function CenterY#()
			Return _Height/2
		End Function
				
		
End Type
</textarea> <br><br></td></tr></table><br>
<a name="969499"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> App.bmx allows you to set up a game which runs at any resolution and can toggle between windowed and fullscreen mode.  It also contains an enhanced runtimeerror function as well as image loading functions which buffer the images in video ram, provide error handling, and can update a loading screen.<br><br>Mouse.bmx replaces the standard mouse input functions.  With it you can get absolute or relative mouse movement with auotmatic mouse recentering code, and on Win32 systems, you can get raw mouse movement which is unaffected by pointer ballistics and allows you to take full advantage of high definition mice, which the standard mouse input functions would treat as being 400dpi. <br><br></td></tr></table><br>
<a name="969532"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Who was John Galt?</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nice one, thanks Swifty. <br><br></td></tr></table><br>
<a name="969571"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Slight update to the mouse code to make it work when the resolution is lower than the virtual resolution, and work better when it's higher and you're in windowed mode. <br><br></td></tr></table><br>
<a name="969602"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tachyon</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Possible Community Framework submission? <br><br></td></tr></table><br>
<a name="969657"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Looks like some really good stuff (the projection/letterboxing is particularly interesting to me), thanks a lot.<br><br>(Can we assume it's to be treated as public domain code?) <br><br></td></tr></table><br>
<a name="969661"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> (Can we assume it's to be treated as public domain code?)  <br></div><br><br>Yep! <br><br></td></tr></table><br>
<a name="969676"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GfK</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> I just had a play with the projectionmatrix code.  When using letterboxing with the code below, the "800x600" window is drawn at the left of the screen, not in the middle.  Why?<br><br><pre class=code>Graphics 640,400 'equivalent of 1280x800 WS

ProjectionMatrix.SetScale(800,600)
ProjectionMatrix.SetLetterbox(800,600)


While Not KeyDown(key_escape)
	Cls
	SetColor 255,255,255
	DrawLine 0,0,799,0
	DrawLine 799,0,799,599
	DrawLine 799,599,0,599
	DrawLine 0,599,0,0
	ProjectionMatrix.drawLetterbox()
	Flip
Wend
End</pre><br><br>[edit] Actually I can use the following at the start of my draw loop:<br><pre class=code>	SetOrigin ProjectionMatrix.centerx() - (projectionmatrix.width()/2),projectionmatrix.centery() - (projectionmatrix.height()/2)
</pre>I guess I could stick the result of those two calculations into a var to avoid recalculating it every time.<br>Then modify the drawLetterbox() function to reset the origin to 0,0.  Two SetOrigin's per cycle isn't going to break the bank - clocked it at 76ms for one million iterations.<br><br>Would the RenderState.Pop/Push stuff do this?  Code wouldn't compile so I commented it out. <br><br></td></tr></table><br>
<a name="969699"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> You actually benchmarked that? :-)<br><br>But yes, that's exactly what you should do.<br><br>In regards to renderstate, here's the code for that:<br><br>Renderstate.bmx:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Type RenderState


	Global RenderStateList:TList = CreateList()
				
	
	Field Alpha#
	Field Blend%
	Field ClsColor_R%, ClsColor_G%, ClsColor_B%
	Field Color_R%, Color_G%, Color_B%
	Field Handle_X#, Handle_Y#
	Field ImageFont:TImageFont
	Field LineWidth#
	Field MaskColor_R%, MaskColor_G%, MaskColor_B%
	Field Origin_X#, Origin_Y#
	Field Rotation#
	Field Scale_X#, Scale_Y#
	Field Viewport_X%, Viewport_Y%, Viewport_Width%, Viewport_Height%


	' -------------------------------------------------------------------------------------------------------------------------------------------------------
	' These methods allow you to save and restore the current render settings
	'
	' Each time you call the push method, the current state is placed on the stack.
	' Each time you call the pop method, the last state placed on the stack is restored and removed from the stack.
	' -------------------------------------------------------------------------------------------------------------------------------------------------------

		
		Function Push()

			Local RS:RenderState = New RenderState

			RS.Alpha# = GetAlpha#()
			RS.Blend  = GetBlend()
			GetClsColor(RS.ClsColor_R, RS.ClsColor_G, RS.ClsColor_B)
			GetColor(RS.Color_R, RS.Color_G, RS.Color_B) 
			GetHandle(RS.Handle_X#, RS.Handle_Y#)
			RS.ImageFont = GetImageFont()
			RS.LineWidth# = GetLineWidth#()
			GetMaskColor(RS.MaskColor_R, RS.MaskColor_G, RS.MaskColor_B)
			GetOrigin(RS.Origin_X#, RS.Origin_Y#)
			RS.Rotation# = GetRotation#()
			GetScale(RS.Scale_X#, RS.Scale_Y#)
			GetViewport(RS.Viewport_X, RS.Viewport_Y, RS.Viewport_Width, RS.Viewport_Height)
		
			RenderStateList.AddLast(RS)
		
		End Function		


		Function Pop()
		
			Local RS:RenderState = RenderState(RenderStateList.RemoveLast())	
				
			SetAlpha(RS.Alpha#)
			SetBlend(RS.Blend)
			SetClsColor(RS.ClsColor_R, RS.ClsColor_G, RS.ClsColor_B)
			SetColor(RS.Color_R, RS.Color_G, RS.Color_B) 
			SetHandle(RS.Handle_X#, RS.Handle_Y#)
			SetImageFont(RS.ImageFont)
			SetLineWidth(RS.LineWidth#)
			SetMaskColor(RS.MaskColor_R, RS.MaskColor_G, RS.MaskColor_B)
			SetOrigin(RS.Origin_X#, RS.Origin_Y#)
			SetRotation(RS.Rotation#)
			SetScale(RS.Scale_X#, RS.Scale_Y#)
			SetViewport(RS.Viewport_X, RS.Viewport_Y, RS.Viewport_Width, RS.Viewport_Height)

		End Function


End Type
</textarea><br><br><br>The purpouse of which is to allow the drawletterbox function (and any other functions you might wish to use it in) to alter properties like the current draw color and reset them back to their previous state.  Ths includes the origin, so if you put a SetOrigin after the push operation in the drawletterbox function, then it will be reset for you to whatever it was originally when the function exits.  I suppose that would make your code a little cleaner, but it wouldn't improve the performance. :-) <br><br></td></tr></table><br>
<a name="969704"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here's something else you might find useful:<br><br>Savegames.bmx:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Type SaveGames
	
	
	Const Filename$ = "data\savegames.dat"
	Const MAX_SAVEGAMES% = 9

	Global _Name$[MAX_SAVEGAMES]
	Global _Level%[MAX_SAVEGAMES]
	Global _Score%[MAX_SAVEGAMES]
	
	Global Active%						' Currently active savegame.  Zero indexed.


	' -------------------------------------------------------------------------------------------------------------------------------------------------------
	' This function loads all the savegames.
	' -------------------------------------------------------------------------------------------------------------------------------------------------------
	
		Function LoadAll()

			Local File:TStream
			Local Loop%
			Local Count%
			
			' Set default names and scores.
				For Loop = 0 To MAX_SAVEGAMES-1
					Reset(Loop)
				Next	
				
			' Attempt to open the data file for reading.
			' If the file does not exist, then there are no savegames to load, and we exit the function.
				If FileType(Filename$) &lt;&gt; 1 Then Return

			' Load the data.
		
				File = ReadFile(Filename$)
				
				' Load the active savegame.  Will default to 0 if this line does not exist in the file.
					Active = Int(ReadLine$(File))

				' Make sure Active does not index a savegame slot which is beyond the end of the array.  Will be corrected on next save.
					If Active &gt;= MAX_SAVEGAMES Then Active = 0
				
				While Not Eof(File) And (Count &lt; MAX_SAVEGAMES)
			
					' Load the user's name, highest level achieved, and score.
						_Name$[Count] = ReadLine$(File)
						_Level[Count] = Int(ReadLine$(File)) 
						_Score[Count] = Int(ReadLine$(File))
			
					' Incremement the number of save games loaded.
						Count = Count + 1
			
				Wend
									
			' Close the data file.
				CloseFile File
		
		End Function	


	' ------------------------------------------------------------------------------------------------------------------------------------------------------
	' This function saves all the savegames.
	' ------------------------------------------------------------------------------------------------------------------------------------------------------

		Function SaveAll()

			Local File:TStream
			Local Loop%
		
			' Delete the savegame data file if one exists.
				If FileType(Filename$) = 1 Then DeleteFile Filename$

			' Create a new data file and save the savegames to it.

				File = WriteFile(Filename$)
				
				' Write the number of the currently active savegame.
					WriteLine(File, Active)
				
				' Write the savegame data.
				
					For Loop = 0 To MAX_SAVEGAMES-1
					
						WriteLine(File, _Name$[Loop])
						WriteLine(File, _Level[Loop])
						WriteLine(File, _Score[Loop])
						
					Next
				
				' Close the file.
					CloseFile File
	
		End Function


	' ------------------------------------------------------------------------------------------------------------------------------------------------------
	' This function sets the active player.
	' ------------------------------------------------------------------------------------------------------------------------------------------------------

		Function SetActive(NewActive%)
			Active = NewActive
		End Function


	' ------------------------------------------------------------------------------------------------------------------------------------------------------
	' This function resets the specified slot to the default name, score, and level.
	' ------------------------------------------------------------------------------------------------------------------------------------------------------
	
		Function Reset(Slot%)
			_Name$[Slot] = "Player " + String(Slot+1)
			_Level[Slot] = 1
			_Score[Slot] = 0
		End Function
		
		
	' ------------------------------------------------------------------------------------------------------------------------------------------------------
	' This function sets the active player's name.
	' ------------------------------------------------------------------------------------------------------------------------------------------------------
	
		Function SetName(NewName$)
			_Name$[Active] = NewName$
		End Function
		
		
	' ------------------------------------------------------------------------------------------------------------------------------------------------------
	' This function sets the active player's level.
	' ------------------------------------------------------------------------------------------------------------------------------------------------------
	
		Function SetLevel(NewLevel%)
			_Level[Active] = NewLevel
		End Function
		
		
	' ------------------------------------------------------------------------------------------------------------------------------------------------------
	' This function sets the active player's score.
	' ------------------------------------------------------------------------------------------------------------------------------------------------------
	
		Function SetScore(NewScore%)
			_Score[Active] = NewScore
		End Function
		
		
	' ------------------------------------------------------------------------------------------------------------------------------------------------------
	' This function adjusts the active player's score up or down.
	' ------------------------------------------------------------------------------------------------------------------------------------------------------
	
		Function AdjustScore(Adjustment%)
			_Score[Active] = _Score[Active] + Adjustment
		End Function

		
	' ------------------------------------------------------------------------------------------------------------------------------------------------------
	' This function gets the active player's name.
	' ------------------------------------------------------------------------------------------------------------------------------------------------------
	
		Function Name$()
			Return _Name$[Active]
		End Function
		
		
	' ------------------------------------------------------------------------------------------------------------------------------------------------------
	' This function gets the active player's level.
	' ------------------------------------------------------------------------------------------------------------------------------------------------------
	
		Function Level%()
			Return _Level[Active]
		End Function
		
		
	' ------------------------------------------------------------------------------------------------------------------------------------------------------
	' This function gets the active player's score.
	' ------------------------------------------------------------------------------------------------------------------------------------------------------
	
		Function Score%()
			Return _Score[Active]
		End Function
		
	
End Type
</textarea><br><br><br>A realtively simple type which stores player names, scores, and current level, and the player that last played the game in a data file.  If the data file doesn't exist, it recreates it.<br><br>Could use a function to find a good directory to save the data in on Vista so it can be shared between user accounts, but it works as is if you don't care about that. <br><br></td></tr></table><br>
<a name="969762"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Wiebo</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> nice. but why not in the code archives? <br><br></td></tr></table><br>
<a name="969778"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GfK</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> You actually benchmarked that? :-) <br></div>Sure.  Its the only way to find out how fast (or not) something is.  I didn't want to do it if there'd be a performance hit. <br><br></td></tr></table><br>
<a name="969815"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >sswift</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> I never benchmark anything unless I actually notice it causing a speed hit.<br><br><div class="quote"> <br>nice. but why not in the code archives? <br> <br></div><br><br>Cause it was a spur of the moment decision and I didn't feel like writing a ton of really good documentation? :-)<br><br>Also, as is, these types aren't plug and play, they have some references to my sprite system in them. <br><br></td></tr></table><br>
<a name="969947"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >levelord</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Really cool stuff, O' Swift One!  Thanks so much for all the help! <br><br></td></tr></table><br>
<a name="1011596"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Charrua</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> hi sswift<br>i used most of your code to handle multiple keyboards, instead of register mouse i register keyboards: <br><br><a href="http://blitzbasic.com/Community/posts.php?topic=88832" target="_blank">http://blitzbasic.com/Community/posts.php?topic=88832</a><br><br>thank's a lot<br><br>Juan <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
