<!DOCTYPE html><html lang="en" ><head ><title >Circle-&gt;Line Collision Response, stop jittering?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Circle-&gt;Line Collision Response, stop jittering?</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Circle-&gt;Line Collision Response, stop jittering?</a><br><br>
<a name="1207220"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >codermax</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm using circle to line collision with Oddball's source from the archives, and the detection part works. But here's the thing - the circle jitters as it moves along a line. I want the circle to be able to "slide" along a line... The response should be that the circle is pushed back enough distance to keep the circle away from the line point(making sure that the circle isn't stuck, not being able to move), but keep it close enough NOT to intersect a great distance into the line, making it jitter as it's relocated.<br><br>I've been at this for a couple days and I'm out of ideas, so I'm asking the Blitzmax community for help! I've looked in MANY places here and around the web, but I haven't found the appropriate collision response for this code.<br><br>Keep in mind that I didn't indent most of the code, however I indented the problem area and higlighted it here. :)<br><br>This is where the problem lies.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
'PROBLEM IS HERE.
Type Player
Field Pos:Vector2,Speed,Size:Float,HP,MaxHP,MP,MaxMP
Field CollisionShape:Polygon, Test:Polygon
Field OldPos:Vector2[4], Block[4]
	Function Create:Player()
		Local tmp:Player=New Player
			For Local p=0 Until 4 Step+1
			tmp.Block[p]=0 tmp.OldPos[p]=New Vector2
			Next
		Return tmp
	End Function
	Method Move(Dir)
		Local BaseSpeed:Float=0.5
		Local s=Self.Speed
		For Local p=0 Until 4 Step+1
		Self.Block[p]=0
		Next
	
		OldPos[0].X=Pos.X OldPos[0].Y=Pos.Y
		For Local p=0 Until Self.Speed Step+1
			If Dir=0
			If Block[0]=0 Then Self.Pos.Y:- BaseSpeed
			EndIf
			If Dir=1 
			If Block[1]=0 Then Self.Pos.Y:+ BaseSpeed
			EndIf
			If Dir=2
			If Block[2]=0 Then Self.Pos.X:- BaseSpeed
			EndIf
			If Dir=3
			If Block[3]=0 Then Self.Pos.X:+ BaseSpeed
			EndIf
		Next
	'collision between the circle(player) and the line(wall).
	Local V:Vector2=LineToCircle(WallLine.X,WallLine.Y,WallLine.X2,WallLine.Y2, Pos.X,Pos.Y,Size)
		If V&lt;&gt;Null
			Pos.X=OldPos[0].X Pos.Y=OldPos[0].Y
			Print "pos "+Pos.X+","+Pos.Y
			SetColor 180,0,255
			DrawLine Pos.X,Pos.Y,V.X,V.Y
			SetColor 255,255,255
			'get the outward angle of the two points.
			Local VA:Float=GetAngle2D(V.X,V.Y,Pos.X,Pos.Y) Print "outward "+VA
			'get the inward angle of the two points.
			Local VIA:Float=GetAngle2D(Pos.X,Pos.Y,V.X,V.Y) Print "inward "+VIA
			
			'get the distance between the two points.
			Local VD:Float=GetDistance2D(V.X,V.Y,Pos.X,Pos.Y) Print "dist "+(VD+(s*BaseSpeed))
			'get the position of the edge point, that intersected the line.
			Local VP:Vector2=GetCircleEdgePoint:Vector2(Pos,Size,VIA) Print "edge "+VP.X+","+VP.Y
			Print "Push "+(LengthDirX(BaseSpeed,VIA))+","+(LengthDirY(BaseSpeed,VIA))
			'Move the player in the outward angle direction, at its movement speed.
			Print "Len "+LengthDirX((VD+(s*BaseSpeed)),VIA)+","+LengthDirY((VD+(s*BaseSpeed)),VIA)
			Pos.X:+(LengthDirX(s*BaseSpeed,VIA))
			Pos.Y:+(LengthDirY(BaseSpeed,VIA)) 
			SetColor 0,200,55
			DrawCircle VP.X,VP.Y,2
			SetColor 255,255,255
		EndIf
	End Method
End Type
</textarea><br><br>Here's the entire source, so no one has to figure out how to make an example to test properly.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict
  Import BRL.EventQueue
  Import BRL.Event

Extern "win32" ' Crazy WinAPI stuff
	Function GetActiveWindow%()
	Function IsZoomed%(hwnd%)
End Extern

Include "polycollision.bmx"

Global GX=DesktopWidth()
Global GY=DesktopHeight()
Global GSlide:Float=0

Graphics GX-64,GY-48
SetBlend ALPHABLEND

Global hWnd% = GetActiveWindow() ' Save current Window handle

' Init Buttons
enableMinimize( hwnd% )
enableMaximize( hwnd% )

AppTitle$="Game Name"
SetVirtualResolution 600,400
Global GameRun=1
Global Overlap:Vector2=New Vector2

Global GamePaused=1
	Global FPS:FramesPerSecond=New FramesPerSecond
'create player.
Global MainPlayer:Player=Player.Create()
MainPlayer.Pos=New Vector2 MainPlayer.Pos.X=60 MainPlayer.Pos.Y=120

MainPlayer.Size=10 MainPlayer.Speed=5
MainPlayer.CollisionShape=Polygon.Create(6,30,Vector2.Create(0,0))
MainPlayer.Test=Polygon.Create(6,30,Vector2.Create(0,0))

Global MainWall:Wall=Wall.Create(190,300,6,40)
MainWall.Shape=Polygon.Create(6,30,Vector2.Create(0,0))
Global WallLine:Vector4=Vector4.Create(70,260,190,310)
'MAIN LOOP.
While GameRun=1
Cls
SetColor 255,255,255
DrawText MainPlayer.Pos.X+","+MainPlayer.Pos.Y,300,5
If AppTerminate() Or KeyDown(KEY_ESCAPE) Then GameRun=0

DrawCircle(MainPlayer.Pos.X,MainPlayer.Pos.Y,MainPlayer.Size)
DrawCircle(MainWall.Pos.X,MainWall.Pos.Y,10)
SetColor 60,60,80
DrawLine WallLine.X,WallLine.Y,WallLine.X2,WallLine.Y2
SetColor 255,255,255
MainPlayer.CollisionShape.UpdatePolygon(Vector2.Create(MainPlayer.Pos.X,MainPlayer.Pos.Y))
MainWall.Shape.UpdatePolygon(Vector2.Create(MainWall.Pos.X,MainWall.Pos.Y))

'DrawPolyEX(MainPlayer.CollisionShape.APoints,0)
'DrawPolyEX(MainWall.Shape.APoints,0)
'MainPlayer.CollisionShape.UpdatePolygon(Vector2.Create(MainPlayer.Pos.X,MainPlayer.Pos.Y))
'MainWall.Shape.UpdatePolygon(Vector2.Create(MainWall.Pos.X,MainWall.Pos.Y))

'MainPlayer.CollisionShape.DrawVertexes()  
'MainPlayer.CollisionShape.DrawVertexData(Vector2.Create(100,0)) 
'MainWall.Shape.DrawVertexes()
'MainWall.Shape.DrawVertexData(Vector2.Create(160,60))
'MainPlayer.CollisionShape.DrawPoints() MainWall.Shape.DrawPoints()
Rem
Local ft:Float[][]=CheckOvalToLineCollision(MainPlayer.Pos,MainPlayer.Size,Wall)
Local Count=0
			For Local tmp:Float[] = EachIn ft
					'DrawText tmp[0]+","+tmp[1],30,500+(24*Count)
					Count:+1
			Next
			End Rem
SetColor 0,255,0
				DrawText "FPS: "+FPS.Calc(),10,30
				
				CheckInput()
Flip

    GCCollect() 'Garbage Collection
Wend

Function CheckInput()
If KeyDown(KEY_UP) 
MainPlayer.Move(0)
EndIf
If KeyDown(KEY_DOWN)
MainPlayer.Move(1)
EndIf
If KeyDown(KEY_LEFT)
MainPlayer.Move(2)
EndIf
If KeyDown(KEY_RIGHT) 
MainPlayer.Move(3)
EndIf

Rem
Local Test:Polygon=MainPlayer.CollisionShape
Test.Center.X=MainPlayer.Pos.X+MoveTrace[0] Test.Center.Y=MainPlayer.Pos.Y+MoveTrace[1]
Test.UpdatePolygon(Vector2.Create(Test.Center.X,Test.Center.Y)) 
If Test.Collision(Wall)=True
If MainPlayer.OldPos.Y&lt;0 Then MainPlayer.Block[0]=1 MainPlayer.Pos.Y:+(MainPlayer.OldPos.Y*-1)
EndIf
End Rem
End Function

Function enableMaximize(hWnd:Long)
' Adds the Maximize Button "[]"
	Local tmp:Int = GetWindowLongA(hWnd, GWL_STYLE)
	tmp = tmp | WS_MAXIMIZEBOX
	SetWindowLongA(hWnd, GWL_STYLE, tmp)
	DrawMenuBar(hWnd)
End Function

Function enableMinimize(hWnd:Long)
' Adds the Minimize Button "_"
	Local tmp:Long = GetWindowLongA(hWnd, GWL_STYLE)
	tmp = tmp | WS_MINIMIZEBOX
	SetWindowLongA(hWnd, GWL_STYLE, tmp)
	DrawMenuBar(hWnd)
End Function

'GAME OBJECTS.
Type Wall
Field Pos:Vector2, Shape:Polygon 
Function Create:Wall(X,Y,Sides,Size)
Local tmp:Wall=New Wall
tmp.Pos=Vector2.Create(X,Y)
'tmp.Shape=Polygon.Create(Sides,Size,Vector2.Create(X,Y))
Return tmp
End Function

End Type

'PROBLEM HERE.
Type Player
Field Pos:Vector2,Speed,Size:Float,HP,MaxHP,MP,MaxMP
Field CollisionShape:Polygon, Test:Polygon
Field OldPos:Vector2[4], Block[4]
	Function Create:Player()
		Local tmp:Player=New Player
			For Local p=0 Until 4 Step+1
			tmp.Block[p]=0 tmp.OldPos[p]=New Vector2
			Next
		Return tmp
	End Function
	Method Move(Dir)
		Local BaseSpeed:Float=0.5
		Local s=Self.Speed
		For Local p=0 Until 4 Step+1
		Self.Block[p]=0
		Next
	
		OldPos[0].X=Pos.X OldPos[0].Y=Pos.Y
		For Local p=0 Until Self.Speed Step+1
			If Dir=0
			If Block[0]=0 Then Self.Pos.Y:- BaseSpeed
			EndIf
			If Dir=1 
			If Block[1]=0 Then Self.Pos.Y:+ BaseSpeed
			EndIf
			If Dir=2
			If Block[2]=0 Then Self.Pos.X:- BaseSpeed
			EndIf
			If Dir=3
			If Block[3]=0 Then Self.Pos.X:+ BaseSpeed
			EndIf
		Next
	'collision between the circle(player) and the line(wall).
	Local V:Vector2=LineToCircle(WallLine.X,WallLine.Y,WallLine.X2,WallLine.Y2, Pos.X,Pos.Y,Size)
		If V&lt;&gt;Null
			Pos.X=OldPos[0].X Pos.Y=OldPos[0].Y
			Print "pos "+Pos.X+","+Pos.Y
			SetColor 180,0,255
			DrawLine Pos.X,Pos.Y,V.X,V.Y
			SetColor 255,255,255
			'get the outward angle of the two points.
			Local VA:Float=GetAngle2D(V.X,V.Y,Pos.X,Pos.Y) Print "outward "+VA
			'get the inward angle of the two points.
			Local VIA:Float=GetAngle2D(Pos.X,Pos.Y,V.X,V.Y) Print "inward "+VIA
			
			'get the distance between the two points.
			Local VD:Float=GetDistance2D(V.X,V.Y,Pos.X,Pos.Y) Print "dist "+(VD+(s*BaseSpeed))
			'get the position of the edge point, that intersected the line.
			Local VP:Vector2=GetCircleEdgePoint:Vector2(Pos,Size,VIA) Print "edge "+VP.X+","+VP.Y
			Print "Push "+(LengthDirX(BaseSpeed,VIA))+","+(LengthDirY(BaseSpeed,VIA))
			'Move the player in the outward angle direction, at its movement speed.
			Print "Len "+LengthDirX((VD+(s*BaseSpeed)),VIA)+","+LengthDirY((VD+(s*BaseSpeed)),VIA)
			Pos.X:+(LengthDirX(s*BaseSpeed,VIA))
			Pos.Y:+(LengthDirY(BaseSpeed,VIA)) 
			SetColor 0,200,55
			DrawCircle VP.X,VP.Y,2
			SetColor 255,255,255
		EndIf
	End Method
End Type

Type Enemy
Field Pos:Vector2,Speed,Size:Float,HP,MaxHP
Field CollisionShape:Polygon, Test:Polygon
Field OldPos:Vector2, Block[4]
Function Create:Enemy()
Local tmp:Enemy=New Enemy
tmp.OldPos=New Vector2
For Local p=0 Until 4 Step+1
tmp.Block[p]=0
Next
Return tmp
End Function
Method Move(Dir)

End Method
End Type

Type List
Field ListPos:Vector2,MaxPlaces:Vector2,MaxDisplayPlaces:Vector2,Scrolling
End Type

Type Vector2
Field X:Float,Y:Float, Angle:Float

Function Create:Vector2(X2:Float,Y2:Float)
Local tmp:Vector2=New Vector2
tmp.X=X2 tmp.Y=Y2
Return tmp
End Function

	Method DivEq(_scale#)
		X:/ _scale
		Y:/ _scale
	End Method
	
	Method MulEq(_scale#)
		X:* _scale
		Y:* _scale
	End Method
	
	Method AddEq(v:Vector2)
		X:+ v.X
		Y:+ v.Y
	End Method
	
	Method MinEq(v:Vector2)
		X:- v.X
		Y:- v.Y
	End Method
	
	Method Mul:Vector2(_scale#)
		Return Vector2.Create(X * _scale, Y * _scale)
	End Method
	
	Method Div:Vector2(_scale#)
		Return Vector2.Create(X / _scale, Y / _scale)
	End Method
	
	Method Add:Vector2(v:Vector2)
		Return Vector2.Create(X + v.X, Y + v.Y)
	End Method
	
	Method Sub:Vector2(v:Vector2)
		Return Vector2.Create(X - v.X, Y - v.Y)
	End Method
	
	Method Length#()
		Return Sqr(X * X + Y * Y)
	End Method

	Method CrossProduct#(v:Vector2)
		Return X * v.Y- Y * v.X
	End Method
	
	Method Dot#(v:Vector2)
		Return X * v.X + Y * v.Y
	End Method



	Rem
		Do two vectors intersect along a given axis
	EndRem
	Function Intersect@(a:Vector2[], b:Vector2[], xa:Vector2, _offset:Vector2, P1C:Vector2,P2C:Vector2)
	
		Local min0#, max0#
		Local min1#, max1#
		min0 = IntervalMin(a, xa)
		max0 = IntervalMax(a, xa)
		min1 = IntervalMin(b, xa)
		max1 = IntervalMax(b, xa)

	Local h# = _offset.Dot(xa)

		'Print "do"+xa.X+","+xa.Y
		min0:+ h
		max0:+ h	
		Local d0# = min0 - max1
		Local d1# = min1 - max0
		If d0 &gt; 0.0 Or d1 &gt; 0.0 Then
			Return False
		Else
				Rem				
		Local dist:Float=IntervalDistance:Float(min0,max0,min1,max1)
		'if the polygons overlap.
		If d0&gt;d1
		 dist=d0
		Else
		dist=d1
		EndIf
		
		Local Taxis:Vector2
		Local mindist:Float=-100.0/0

			' Check If the Current interval distance is the minimum one. If so store
	        ' the interval distance And the Current distance.
	        ' This will be used To calculate the minimum translation vector
	       dist = Abs(dist)
			Print "dist "+dist			
	        If dist &lt; mindist
	            mindist = dist
	            Taxis = xa'axis
		Print "taxis "+Taxis.X+","+Taxis.Y
	            Local d:Vector2=Vector2.Create(P1C.X - P2C.X,P1C.Y - P2C.Y)
	            If d.Dot(Taxis) &lt; 0
		Print "dot "+d.Dot(Taxis)
	               Taxis.X:*-1 Taxis.Y:*-1
		        EndIf
		    EndIf
	
	    'The minimum translation vector
	    'can be used To push the polygons apart.
	   Local P:Vector2=Vector2.Create(Taxis.X*mindist,Taxis.Y*mindist)
		Print "push!"+P.X+","+P.Y
		End Rem
		Return True
		EndIf
	End Function
	
	Rem
		Min / Max functions
		nothing sepcial
	EndRem
	Function IntervalMin#(verts:Vector2[], xa:Vector2)
		Local m# = verts[0].Dot(xa)
		
		For Local i% = 0 To verts.Length - 1
			Local d# = verts[i].Dot(xa)
			If d &lt; m Then m = d
		Next
		
		Return m
	End Function
	
	Function IntervalMax#(verts:Vector2[], xa:Vector2)
		Local m# = verts[0].Dot(xa)
		
		For Local i% = 0 To verts.length - 1
			Local d# = verts[i].Dot(xa)
			If d &gt; m Then m = d
		Next
		
		Return m
	End Function
End Type

Type Vector4
Field X:Float,Y:Float,X2:Float,Y2:Float
Function Create:Vector4(X2:Float,Y2:Float,X3:Float,Y3:Float)
Local tmp:Vector4=New Vector4
tmp.X=X2 tmp.Y=Y2 tmp.X2=X3 tmp.Y2=Y3
Return tmp
End Function
End Type

Type Polygon
Rem
MaxSides=vertex count
Points=vx and vy
Center=x and y
End Rem
Field MaxSides,MaxSidesF:Float,Size:Float,Points:Vector2[],APoints:Float[],Angle:Float
Field Center:Vector2,DrawOffset:Vector2
Function Create:Polygon(MSides,Scale,Pos:Vector2)
Local tmp:Polygon=New Polygon
tmp.Size=Scale tmp.Center=Pos tmp.DrawOffset=Vector2.Create(0,0)
tmp.MaxSides=MSides tmp.MaxSidesF=MSides
tmp.Points=New Vector2[tmp.MaxSides] 
tmp.APoints=New Float[tmp.MaxSides*2]

For Local g=0 Until tmp.MaxSides Step+1
tmp.Points[g]=Vector2.Create(tmp.Center.X,tmp.Center.Y-tmp.Size)
tmp.Points[g].Angle=g*(360/tmp.MaxSidesF)
'----If current angle = 0 degrees-----
Local dx:Float = tmp.Points[g].X-tmp.Center.X
Local dy:Float = tmp.Points[g].Y-tmp.Center.Y
Local AddAngle:Float = ATan2(dy,dx)
Local CenterDistance:Float = Sqr(dx^2+dy^2)
'----when you change angle--------
Local NewAngle:Float=tmp.Points[g].Angle+AddAngle
'--------New position after rotation-------
tmp.Points[g].X =tmp.Center.X+(Cos(NewAngle)* CenterDistance)
tmp.Points[g].Y=tmp.Center.Y+(Sin(NewAngle)* CenterDistance)
Next
Local TotalSides=0, Count=0

Repeat
tmp.APoints[Count]=tmp.Points[TotalSides].X
tmp.APoints[Count+1]=tmp.Points[TotalSides].Y
TotalSides:+1 Count:+2
Until TotalSides=tmp.MaxSides
Return tmp
End Function

Function Length(P1:Polygon)
Local VLen=0
VLen=P1.MaxSides
Return VLen
End Function

Method UpdatePolygon(Pos:Vector2)
Center.X=Pos.X Center.Y=Pos.Y

For Local g=0 Until MaxSides Step+1
Points[g]=Vector2.Create(Center.X,Center.Y-Size)
Points[g].Angle=g*(360/MaxSidesF)
'----If current angle = 0 degrees-----
Local dx:Float = Points[g].X-Center.X
Local dy:Float = Points[g].Y-Center.Y
Local AddAngle:Float = ATan2(dy,dx)
Local CenterDistance:Float = Sqr(dx^2+dy^2)
'----when you change angle--------
Local NewAngle:Float=Points[g].Angle+AddAngle
'--------New position after rotation-------
Points[g].X =Center.X+(Cos(NewAngle)* CenterDistance)
Points[g].Y=Center.Y+(Sin(NewAngle)* CenterDistance)
Next
Local TotalSides=0, Count=0

Repeat
APoints[Count]=Points[TotalSides].X
APoints[Count+1]=Points[TotalSides].Y
TotalSides:+1 Count:+2
Until TotalSides=MaxSides
Rem
For Local g=0 Until Self.MaxSides Step+1
Self.Points[g]=Vector2.Create(Self.Center.X,Self.Center.Y-Self.Size)
Self.Points[g].Angle=g*(360/Self.MaxSidesF)

'----If current angle = 0 degrees-----
Local dx:Float = Self.Points[g].X-Self.Center.X
Local dy:Float = Self.Points[g].Y-Self.Center.Y
Local AddAngle:Float = ATan2(dy,dx)
Local CenterDistance:Float = Sqr(dx^2+dy^2)
'----when you change angle--------
Local NewAngle:Float=Self.Points[g].Angle+AddAngle
'--------New position after rotation-------
Self.Points[g].X=Self.Center.X+(Cos(NewAngle)* CenterDistance)
Self.Points[g].Y=Self.Center.Y+(Sin(NewAngle)* CenterDistance)
Next
End Rem
End Method

Method RotatePolygon(XAngle:Float=-1)
Self.Angle=XAngle
If Self.Angle&gt;360 Then Self.Angle:-360
DrawText Self.Angle,300,400
For Local g=0 Until MaxSides Step+1
'----If current angle of Room = 0 degrees-----
Local dx:Float = Self.Points[g].X-Self.Center.X
Local dy:Float = Self.Points[g].Y-Self.Center.Y
Local AddAngle:Float = ATan2(dy,dx)
Local CenterDistance:Float = Sqr(dx^2+dy^2)
'----when you change RoomAngle--------
Local NewAngle:Float=Self.Points[g].Angle+Self.Angle
'--------New position of circle-------
Self.Points[g].X = Self.Center.X+(Cos(NewAngle)* CenterDistance)
Self.Points[g].Y =Self.Center.Y+(Sin(NewAngle)* CenterDistance)
Next
End Method

Method DrawPoints()
SetColor 90,90,160
For Local g=0 Until Self.MaxSides Step+1
DrawCircle Self.Points[g].X,Self.Points[g].Y,1.5
Next
DrawCircle Self.Center.X,Self.Center.Y,1.5
SetColor 255,255,255
End Method

	Method DrawVertexData(P:Vector2)
			SetColor 0, 255, 0
		
		Local _vx#[2], _vy#[2]
		For Local i% = 0 To MaxSides - 2
			_vx[0] = Points[i].X + Center.X
			_vy[0] = Points[i].Y + Center.Y
			_vx[1] = Points[i+1].X + Center.X
			_vy[1] = Points[i+1].Y + Center.Y
			'draw position of vertex.
					SetColor 255,255,255 SetScale 0.8,0.8
			DrawText Int(_vx[0])+","+Int(_vy[0]),_vx[0]+P.X, _vy[0]+P.Y
					SetColor 0, 255, 0  SetScale 1,1
		Next
		
		_vx[0] = Points[MaxSides  - 1].X + Center.X
		_vy[0] = Points[MaxSides  - 1].Y + Center.Y
		_vx[1] = Points[0].X + Center.X
		_vy[1] = Points[0].Y + Center.Y
					'draw position of vertex.
					SetColor 255,255,255 SetScale 0.8,0.8
			DrawText Int(_vx[0])+","+Int(_vy[0]),_vx[0]+P.X, _vy[0]+P.Y
					SetColor 0, 255, 0 SetScale 1,1
		SetColor 0, 0, 0
	End Method
	
	
	Method DrawVertexes()
		SetColor 0, 255, 0
		
		Local _vx#[2], _vy#[2]
		For Local i% = 0 To (MaxSides*2) - 4
			_vx[0] = APoints[i] + Center.X
			_vy[0] = APoints[i+1] + Center.Y
			_vx[1] = APoints[i+2] + Center.X
			_vy[1] = APoints[i+3] + Center.Y
			DrawLine _vx[0], _vy[0], _vx[1], _vy[1]
			'draw position of vertex.
					SetColor 255,255,255 SetScale 0.8,0.8

					SetColor 0, 255, 0  SetScale 1,1
		Next
		
		_vx[0] = APoints[(MaxSides*2) - 4] + Center.X
		_vy[0] = APoints[(MaxSides*2)  - 3] + Center.Y
		_vx[1] = APoints[0] + Center.X
		_vy[1] = APoints[1] + Center.Y
		DrawLine _vx[0], _vy[0], _vx[1], _vy[1]
					'draw position of vertex.
					SetColor 255,255,255 SetScale 0.8,0.8
					SetColor 0, 255, 0 SetScale 1,1
		SetColor 0, 0, 0
	End Method
Rem
separating axis theorem(SAT) intersection calculation, which tests a circle against the sides
of a polygon.
ARGUMENTS:
-circle: 2d vector representing the circle's position, which is the center of the circle.
-circle radius: the outer size of the circle, or how far away from the circle's center 
should it be tested for collision.
-polygon: an array of 2d vectors. Each index in the 2d vector array holds a X and Y coordinate, which
represents one of a polygon's sides to be tested for collision
Circle:Vector2, CircleRadius:Float, 
End Rem
Rem
Method Collision:Vector3()
    'Are the polygons going To intersect forward in time?
    Local WillIntersect
    'Are the polygons currently intersecting?
    Local Intersect
    'The translation To apply To the first polygon To push the polygons apart.
    Local MinimumTranslationVector:Vector2
End Method

'Calculate the projection of a polygon on an axis
'And returns it as a [Min, Max] interval
Method ProjectPolygon(axis:Vector2, Poly:Polygon)
   'To project a point on an axis use the dot product
    Float dotProduct = axis.Dot(Poly.Points[0])
    Local Min0:Float = dotProduct
    Local Max0:Float = dotProduct
    For Local i = 0 Until Len(Poly.MaxSides) Step+1
        dotProduct = Poly.Points[i].Dot(axis)
        If d &lt; Min0
            Min0 = dotProduct
         Else 
            If dotProduct&gt; Max0
                Max0 = dotProduct
            EndIf
        EndIf
Next
End Method
End Rem

Rem
Method Collision(Poly:Polygon,_offset:Vector2 = Null)
		'get the offset. if it doesn't exist, set the offset as a created vector.
		If _offset = Null Then
			_offset = Vector2.Create(Center.X, Center.Y).Sub(Vector2.Create(Poly.Center.X, Poly.Center.Y))
		EndIf		
				
		Local a:Vector2[], b:Vector2[]
		Local i%
		
		a = New Vector2[MaxSides]
		For i = 0 To MaxSides - 1
			a[i] = New Vector2
			a[i].X = Points[i].X
			a[i].Y = Points[i].Y
		Next
		
		b = New Vector2[Poly.MaxSides]
		For i = 0 To Poly.MaxSides- 1
			b[i] = New Vector2
			b[i].X = Poly.Points[i].X
			b[i].Y = Poly.Points[i].Y
		Next
		
		Local xv:Vector2[64]
		Local ai% = 0
					Local BF:Vector4=Vector4.Create(0,0,0,0)

		Local j% = MaxSides - 1
		For Local i% = 0 To MaxSides - 1
			Local e0:Vector2 = a[j]
			Local e1:Vector2 = a[i]
			Local e:Vector2 = e1.Sub(e0)
			xv[ai] = Vector2.Create(-e.y, e.x)

		Local MoveVector:Vector2=Vector2.Intersect(a, b, xv[ai], _offset,Center,Poly.Center)
 		If Not Vector2.Intersect(a, b, xv[ai], _offset,Center,Poly.Center)
				Return 0
			EndIf
			
 		If MoveVector&lt;&gt;Null
			Local MoveIt:Float=ATan2(MoveVector.X,MoveVector.Y)

		'	Print "angle: "+MoveIt'+","+g.X+","+g.Y
		'	Print "ONE: "+"side: "+i+"("+a[i].X+","+a[i].Y+")"
		'	Print "XV.X:"+e0.X+","+"XV.Y:"+e0.Y+"    "+"XV2.X:"+e1.X+","+"XV2.Y:"+e1.Y
		'	Print "AIX1: "+xv[ai].X+"    "+"AIX2: "+xv[ai].Y
		'	Print "PPos: "+MainPlayer.Pos.X+","+MainPlayer.Pos.Y
		'	Print "WPos: "+MainWall.Shape.Center.X+","+MainWall.Shape.Center.Y
			EndIf
			j = i
			ai:+ 1
		Next
		
		j% = Poly.MaxSides - 1
		For Local i% = 0 To Poly.MaxSides- 1
			Local e0:Vector2 = b[j]
			Local e1:Vector2 = b[i]
			Local e:Vector2 = e1.Sub(e0)
			xv[ai] =Vector2.Create(-e.y, e.x)
			
		Local MoveVector:Vector2=Vector2.Intersect(a, b, xv[ai], _offset,Center,Poly.Center)
 		If MoveVector=Null
				Return 0
			EndIf
			
			j = i
			ai:+ 1
		Next		
		Return 1
		
End Method
End Rem
End Type

Type LevelEditorSettings

End Type

'class to store FPS.
' --------------------------------------------
Type FramesPerSecond
Global Counter:Float=0
Global Time:Float=0
Global TFPS:Float=0

Function Calc:Float()
Counter:+1
If Time &lt; MilliSecs()
TFPS = Counter ' &lt;-Frames/Sec
Time = MilliSecs() + 1000 'Update
Counter = 0
EndIf
Return TFPS
End Function

End Type
' -------------------------------------------

        Function LengthDirX:Float(length:Float,direction:Float)
          Local x_com:Float= 0
            x_com = Float(Sin(direction) * length)
            Return x_com
       End Function

        Function LengthDirY:Float(length:Float,direction:Float)
          Local y_com:Float= 0
            y_com = Float(Cos(direction) * length)
            Return y_com
       End Function

Function RectsOverlap:Int(x0:Double,y0:Double,w0:Double,h0:Double,x2:Double,y2:Double,w2:Double,h2:Double)
            If (x0 &gt; (x2 + w2) Or (x0 + w0) &lt; x2)
            Return 0
			EndIf
            If (y0 &gt; (y2 + h2) Or (y0 + h0) &lt; y2)
            Return 0
			EndIf
            Return 1
End Function

Function DrawCircle(xCentre:Float, yCentre:Float, Radius:Float) 
	DrawOval(xCentre - (Radius), yCentre - (Radius), Radius*2, Radius*2) 
EndFunction

Function DrawPolygon(P:Polygon) 
Local Tri:Float[P.MaxSides*2]
Local Count=0
For Local g=0 Until Len(Tri) Step+2
Tri[g]=P.Points[Count].X Tri[g+1]=P.Points[Count].Y
Count:+1 
Next

	DrawPoly Tri
EndFunction

       Function ClosestPointFromCircle:Vector2(CirclePos:Vector2,Radius, Line:Vector4)  
           Local closest:Vector2=Vector2.Create(0,0)
           Local segmentVector:Vector2=SubtractVectors(Vector2.Create(Line.X2,Line.Y2),Vector2.Create(Line.X,Line.Y))
           Local circleRelative:Vector2=SubtractVectors(CirclePos,Vector2.Create(Line.X,Line.Y))

           Local segmentUnit:Vector2=NormalizeVector(segmentVector) 

            Local projection:Float=DotProduct(circleRelative,segmentUnit)
		 Print "proj"+projection
            If projection &lt;= 0
                closest.X=Line.X closest.Y=Line.Y
                Return closest
              EndIf
            If (projection * projection) &gt;=(segmentVector.Length()*segmentVector.Length())    
                closest.X=Line.X2 closest.Y=Line.Y2
               Return closest
            EndIf
 
            Local projectionVector:Vector2 = Vector2.Create(segmentUnit.X * projection,segmentUnit.Y * projection)
            closest = AddVectors(projectionVector,Vector2.Create(Line.X,Line.Y))
		Print "closest"+closest.X
               Return closest
        End Function

        Function CircleToLineCollision:Vector2(CirclePos:Vector2,Radius:Float, Line:Vector4)  
            Local depth:Vector2=New Vector2  
             Local closest:Vector2=ClosestPointFromCircle(CirclePos,Radius,Line)
 
           Local distanceVector:Vector2 =SubtractVectors(CirclePos,closest)
 	Print "closest"+closest.X+","+closest.Y+"dist vec"+(distanceVector.Length()*distanceVector.Length())+"/"+ (Radius * Radius)  
            If (distanceVector.Length()*distanceVector.Length()) &gt; (Radius * Radius)  
               Return depth
            EndIf

            If (distanceVector.Length()*distanceVector.Length()) &lt;= 0  
            Return Null
			'Throw New ApplicationException("Circle center is exactly on line segment");
            EndIf
		
            Local unitDist:Vector2=NormalizeVector(distanceVector)  
 			Print "unit"+unitDist.X+","+unitDist.Y
			Local Cdist:Float=(Radius - distanceVector.Length())
			
			 	Print "CD"+CDIst
            depth = Vector2.Create(unitDist.X *CDist,unitDist.Y * CDist)  
			Return depth
        EndFunction
    
Function NormalizeVector:Vector2(a:Vector2)
Local len_v:Float = Sqr(a.X*a.X + a.Y*a.Y)
a.X:/ len_v
a.Y:/ len_v 
End Function

	Function AddVectors:Vector2(a:Vector2,b:Vector2)
		Return Vector2.Create(a.X + b.X, a.Y + b.Y)
	End Function
	
	Function SubtractVectors:Vector2(a:Vector2,b:Vector2)
		Return Vector2.Create(a.X - b.X, a.Y - b.Y)
	End Function
	
	Function VectorLength:Float(a:Vector2)
		Return Sqr(a.X * a.X + a.Y * a.Y)
	End Function

	Function DotProduct:Float(a:Vector2,b:Vector2)
		Return (a.X * b.X) + (a.Y * b.Y)
	End Function

Rem
bbdoc: returns the distance between two points in 2D space
about: return value is an absolute float
EndRem
Function GetDistance2D:Float(X1:Float, Y1:Float, X2:Float, Y2:Float)
	Local l1:Float = Abs(x1-x2)
	Local l2:Float = Abs(y1-y2)
	Return Sqr((l1*l1)+(l2*l2))
End Function

Rem
bbdoc: returns an angle between 0 and 360 degrees
about: return value is an Float
EndRem
Function GetAngle2D:Float(X1:Float,Y1:Float,X2:Float,Y2:Float)
         Local dx# = x2 - x1
         Local dy# = y2 - y1
         Return ATan2(dy#,dx#)+360 Mod 360
End Function

Function GetCircleCircumference:Float(Radius:Float)
Return (Radius*2)*Pi
End Function

Function GetCircleEdgePoint:Vector2(CirclePos:Vector2,Radius:Float,Angle:Float)
Local r:Float=Radius
Local x0:Float=CirclePos.X
Local y0:Float=CirclePos.Y
Local NewX:Double= x0 + r * Cos(Angle)
Local NewY:Double= y0 + r * Sin(Angle)
Local V:Vector2=Vector2.Create(NewX,NewY)
Return V
Rem
'X POS
'Find the cosine of the angle
Local S1:Float=Cos(Angle)
'Multiply the cosine of the angle by the radius
Local S2:Float=S1*Radius
'Add the origin's X coordinate of the circle to the product
Local S3:Float=CirclePos.X+S2
'Y POS
'Find the sine of the angle
Local S4:Float=Sin(Angle)
'Multiply the sine of the angle by the radius
Local S5:Float=S4*Radius
'Add the y-coordinate of the origin of the circle to the product
Local S6:Float=CirclePos.Y+S5
Local V:Vector2=Vector2.Create(S3,S6)
Return V
End Rem
End Function
</textarea><br><br>And oddball's source, used as "polycollision.bmx" in the main source.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
'Code by Dave 'Oddball' Williamson
Rem
TFormPolyToTFormPoly()
Checks for collisions between two transformed polygons.

PolyToTFormPoly()
Checks for collisions between a standard polygon and a transformed polygon.

PolyToPoly()
Checks for collision between two standard polygon arrays.

CircleToTFormPoly()
Checks for collision between a circle and a transformed polygon.

CircleToPoly()
Checks for collision between a circle and a standard polygon array.

LineToTFormPoly()
Checks for collision between a line and a transformed polygon.

LineToPoly()
Checks for collision between a line and a standard polygon array.

PointInTFormPoly()
Checks if the given point is in a transformed polygon.

PointInPoly()
Checks if the given point is in a standard polygon array.

TFormPoly()
Returns a transformed polygon from a standard polygon array.

TFormGlobalToLocal()
Transforms a point from global/screen coordinates too local/polygon/image coordinates.

TFormLocalToGlobal()
Transforms a point from local/polygon/image coordinates to global/screen coordinates.

LinesCross()
Checks if two lines intersect. Adapted from code by Fredborg.

LineToCircle()
Checks for collision between a line and a circle. Adapted from code by TomToad.

End Rem

Function TFormPolyToTFormPoly( p1_xy:Float[], p1_x:Float=0, p1_y:Float=0,..
						p1_rot:Float=0, p1_scale_x:Float=1, p1_scale_y:Float=1,..
						p1_handle_x:Float=0, p1_handle_y:Float=0,..
						p1_origin_x:Float=0, p1_origin_y:Float=0,..
						p2_xy:Float[], p2_x:Float=0, p2_y:Float=0,..
						p2_rot:Float=0, p2_scale_x:Float=1, p2_scale_y:Float=1,..
						p2_handle_x:Float=0, p2_handle_y:Float=0,..
						p2_origin_x:Float=0, p2_origin_y:Float=0)
	
	If p1_xy.length&lt;6 Or (p1_xy.length&amp;1) Return False
	If p2_xy.length&lt;6 Or (p2_xy.length&amp;1) Return False
	
	Local tform1_xy:Float[]=TFormPoly(p1_xy,p1_x,p1_y,p1_rot,p1_scale_x,p1_scale_y,..
						p1_handle_x,p1_handle_y,p1_origin_x,p1_origin_y)
	
	Local tform2_xy:Float[]=TFormPoly(p2_xy,p2_x,p2_y,p2_rot,p2_scale_x,p2_scale_y,..
						p2_handle_x,p2_handle_y,p2_origin_x,p2_origin_y)
	
	If PolyToPoly(tform1_xy,tform2_xy)
		Return True
	Else
		Return False
	EndIf
	
End Function

Function PolyToTFormPoly( p1_xy:Float[], p2_xy:Float[],..
						p2_x:Float=0, p2_y:Float=0, rot:Float=0,..
						scale_x:Float=1, scale_y:Float=1,..
						handle_x:Float=0, handle_y:Float=0,..
						origin_x:Float=0, origin_y:Float=0 )
	
	If p1_xy.length&lt;6 Or (p1_xy.length&amp;1) Return False
	If p2_xy.length&lt;6 Or (p2_xy.length&amp;1) Return False
	
	Local tform_xy:Float[]=TFormPoly(p2_xy,p2_x,p2_y,rot,scale_x,scale_y,..
						handle_x,handle_y,origin_x,origin_y)
	
	If PolyToPoly(p1_xy,tform_xy)
		Return True
	Else
		Return False
	EndIf
	
End Function

Function PolyToPoly( p1_xy:Float[], p2_xy:Float[] )
	
	If p1_xy.length&lt;6 Or (p1_xy.length&amp;1) Return False
	If p2_xy.length&lt;6 Or (p2_xy.length&amp;1) Return False
	
	For Local i:Int=0 Until p1_xy.Length Step 2
		If PointInPoly(p1_xy[i],p1_xy[i+1],p2_xy) Then Return True
	Next
	For Local i:Int=0 Until p2_xy.Length Step 2
		If PointInPoly(p2_xy[i],p2_xy[i+1],p1_xy) Then Return True
	Next
	
	Local l1_x1:Float=p1_xy[p1_xy.Length-2]
	Local l1_y1:Float=p1_xy[p1_xy.Length-1]
	For Local i1:Int=0 Until p1_xy.Length Step 2
		Local l1_x2=p1_xy[i1]
		Local l1_y2=p1_xy[i1+1]
		
		Local l2_x1:Float=p2_xy[p2_xy.Length-2]
		Local l2_y1:Float=p2_xy[p2_xy.Length-1]
		For Local i2:Int=0 Until p2_xy.Length Step 2
			Local l2_x2=p2_xy[i2]
			Local l2_y2=p2_xy[i2+1]
			
			If LinesCross(l1_x1,l1_y1,l1_x2,l1_y2,l2_x1,l2_y1,l2_x2,l2_y2)
							Return True
			EndIf
			
			l2_x1=l2_x2
			l2_y1=l2_y2
		Next
		l1_x1=l1_x2
		l1_y1=l1_y2
	Next
	Return False
End Function

Function CircleToTFormPoly( circle_x:Float, circle_y:Float, radius:Float,..
						xy:Float[], poly_x:Float=0, poly_y:Float=0, rot:Float=0,..
						scale_x:Float=1, scale_y:Float=1,..
						handle_x:Float=0, handle_y:Float=0,..
						origin_x:Float=0, origin_y:Float=0 )
	
	If xy.length&lt;6 Or (xy.length&amp;1) Return False
	
	Local tform_xy:Float[]=TFormPoly(xy,poly_x,poly_y,rot,scale_x,scale_y,..
						handle_x,handle_y,origin_x,origin_y)
	
	Return CircleToPoly(circle_x,circle_y,radius,tform_xy)
End Function

Function CircleToPoly( circle_x:Float, circle_y:Float, radius:Float, xy:Float[] )
	
	If xy.length&lt;6 Or (xy.length&amp;1) Return False
	
	If PointInPoly(circle_x,circle_y,xy) Then Return True
	
	Local x1:Float=xy[xy.Length-2]
	Local y1:Float=xy[xy.Length-1]
	
	For Local i:Int=0 Until Len xy Step 2
		Local x2:Float=xy[i]
		Local y2:Float=xy[i+1]
		
		If LineToCircle(x1,y1,x2,y2,circle_x,circle_y,radius) Then Return True
		x1=x2
		y1=y2
	Next
	
	Return False
End Function

Function LineToTFormPoly( line_x1:Float, line_y1:Float, line_x2:Float, line_y2:Float,..
						xy:Float[], poly_x:Float=0, poly_y:Float=0,..
						rot:Float=0, scale_x:Float=1, scale_y:Float=1,..
						handle_x:Float=0, handle_y:Float=0,..
						origin_x:Float=0, origin_y:Float=0 )
	
	If xy.length&lt;6 Or (xy.length&amp;1) Return False
	
	TFormGlobalToLocal(line_x1,line_y1,poly_x,poly_y,rot,scale_x,..
						scale_y,handle_x,handle_y,origin_x,origin_y)
	
	TFormGlobalToLocal(line_x2,line_y2,poly_x,poly_y,rot,scale_x,..
						scale_y,handle_x,handle_y,origin_x,origin_y)
	
	Return LineToPoly(line_x1,line_y1,line_x2,line_y2,xy)
End Function

Function LineToPoly( line_x1:Float, line_y1:Float, line_x2:Float, line_y2:Float, xy:Float[] )
	
	If xy.length&lt;6 Or (xy.length&amp;1) Return False
	
	If PointInPoly(line_x1,line_y1,xy) Then Return True
	
	Local poly_x1:Float=xy[xy.Length-2]
	Local poly_y1:Float=xy[xy.Length-1]
	
	For Local i:Int=0 Until Len xy Step 2
		Local poly_x2:Float=xy[i]
		Local poly_y2:Float=xy[i+1]
		
		If LinesCross(line_x1,line_y1,line_x2,line_y2,..
						poly_x1,poly_y1,poly_x2,poly_y2) Then Return True
		poly_x1=poly_x2
		poly_y1=poly_y2
	Next
	
	Return False
	
End Function

Function PointInTFormPoly( point_x:Float, point_y:Float, xy:Float[],..
						poly_x:Float=0, poly_y:Float=0, rot:Float=0,..
						scale_x:Float=1, scale_y:Float=1,..
						handle_x:Float=0, handle_y:Float=0,..
						origin_x:Float=0, origin_y:Float=0 )
	
	If xy.length&lt;6 Or (xy.length&amp;1) Return False
	
	TFormGlobalToLocal(point_x,point_y,poly_x,poly_y,rot,scale_x,..
						scale_y,handle_x,handle_y,origin_x,origin_y)
	
	Return PointInPoly(point_x,point_y,xy)
End Function

Function PointInPoly( point_x:Float, point_y:Float, xy:Float[] )
	
	If xy.length&lt;6 Or (xy.length&amp;1) Return False
	
	Local x1:Float=xy[xy.Length-2]
	Local y1:Float=xy[xy.Length-1]
	Local cur_quad:Int=GetQuad(point_x,point_y,x1,y1)
	Local next_quad:Int
	Local total:Int
	
	For Local i=0 Until Len xy Step 2
		Local x2:Float=xy[i]
		Local y2:Float=xy[i+1]
		next_quad=GetQuad(point_x,point_y,x2,y2)
		Local diff:Int=next_quad-cur_quad
		
		Select diff
		Case 2,-2
			If ( x2 - ( ((y2 - point_y) * (x1 - x2)) / (y1 - y2) ) )&lt;point_x
				diff=-diff
			EndIf
		Case 3
			diff=-1
		Case -3
			diff=1
		End Select
		
		total:+diff
		cur_quad=next_quad
		x1=x2
		y1=y2
		Print x1+","+y1
	Next
	
	If Abs(total)=4 
	 Return True
	 Else
	 Return False
	EndIf
End Function

Function TFormPoly:Float[]( xy:Float[], tform_x:Float=0, tform_y:Float=0, rot:Float=0,..
						scale_x:Float=1, scale_y:Float=1,..
						handle_x:Float=0, handle_y:Float=0,..
						origin_x:Float=0, origin_y:Float=0 )
	
	If xy.length&lt;6 Or (xy.length&amp;1) Return Null
	
	Local tform_xy:Float[]=xy[..]
	
	For Local i=0 Until tform_xy.Length Step 2
		TFormLocalToGlobal(tform_xy[i],tform_xy[i+1],tform_x,tform_y,rot,..
						scale_x,scale_y,handle_x,handle_y,origin_x,origin_y)
	Next
	
	Return tform_xy
End Function

Function TFormGlobalToLocal( point_x:Float Var, point_y:Float Var,..
						tform_x:Float=0, tform_y:Float=0, rot:Float=0,..
						scale_x:Float=1, scale_y:Float=1,..
						handle_x:Float=0, handle_y:Float=0,..
						origin_x:Float=0, origin_y:Float=0 )
	
	point_x:-origin_x
	point_y:-origin_y
	
	point_x:-tform_x
	point_y:-tform_y
	
	Local mag:Float=Sqr(point_x*point_x+point_y*point_y)
	Local ang:Float=ATan2(point_y,point_x)
	point_x=Cos(ang-rot)*mag
	point_y=Sin(ang-rot)*mag
	
	point_x:/scale_x
	point_y:/scale_y
	
	point_x:+handle_x
	point_y:+handle_y
End Function

Function TFormLocalToGlobal( point_x:Float Var, point_y:Float Var,..
						tform_x:Float=0, tform_y:Float=0, rot:Float=0,..
						scale_x:Float=1, scale_y:Float=1,..
						handle_x:Float=0, handle_y:Float=0,..
						origin_x:Float=0, origin_y:Float=0 )
	
	point_x:-handle_x
	point_y:-handle_y
	
	point_x:*scale_x
	point_y:*scale_y
	
	Local mag:Float=Sqr(point_x*point_x+point_y*point_y)
	Local ang:Float=ATan2(point_y,point_x)
	point_x=Cos(ang+rot)*mag
	point_y=Sin(ang+rot)*mag
	
	point_x:+tform_x
	point_y:+tform_y
	
	point_x:+origin_x
	point_y:+origin_y
End Function

'Adapted from Fredborg's code
Function LinesCross( x0:Float, y0:Float , x1:Float, y1:Float,..
						x2:Float ,y2:Float, x3:Float, y3:Float )
	  
	Local n:Float=(y0-y2)*(x3-x2)-(x0-x2)*(y3-y2)
	Local d:Float=(x1-x0)*(y3-y2)-(y1-y0)*(x3-x2)
	
	If Abs(d) &lt; 0.0001 
		' Lines are parallel!
		Return False
	Else
		' Lines might cross!
		Local Sn:Float=(y0-y2)*(x1-x0)-(x0-x2)*(y1-y0)

		Local AB:Float=n/d
		If AB&gt;0.0 And AB&lt;1.0
			Local CD:Float=Sn/d
			If CD&gt;0.0 And CD&lt;1.0
				' Intersection Point
				Local X=x0+AB*(x1-x0)
		       	Local Y=y0+AB*(y1-y0)
				Return True
			End If
		End If
	
		' Lines didn't cross, because the intersection was beyond the end points of the lines
	EndIf

	' Lines do Not cross!
	Return False

End Function

'Adapted from TomToad's code
Function LineToCircle:Vector2( x1:Float, y1:Float, x2:Float, y2:Float, px:Float, py:Float, r:Float )
	
	Local sx:Float = x2-x1
	Local sy:Float = y2-y1
	Local V:Vector2=New Vector2
	Local q:Float = ((px-x1) * (x2-x1) + (py - y1) * (y2-y1)) / (sx*sx + sy*sy)
	
	If q &lt; 0.0 Then q = 0.0
	If q &gt; 1.0 Then q = 1.0
	
	Local cx:Float=(1-q)*x1+q*x2
	Local cy:Float=(1-q)*y1 + q*y2	
	
	If PointToPointDist(px,py,cx,cy)&lt;r
		V.X=cx V.Y=cy
		Return V
	Else		
		Return Null	
	EndIf	
End Function 

Function PointToPointDist:Float( x1:Float, y1:Float, x2:Float, y2:Float )

	Local dx:Float = x1-x2
	Local dy:Float = y1-y2
	
	Return Sqr(dx*dx + dy*dy)
End Function


Function GetQuad(axis_x:Float,axis_y:Float,vert_x:Float,vert_y:Float)
	If vert_x&lt;axis_x
		If vert_y&lt;axis_y
			Return 1
		Else
			Return 4
		EndIf
	Else
		If vert_y&lt;axis_y
			Return 2
		Else
			Return 3
		EndIf	
	EndIf

End Function

Rem
?win
SetGraphicsDriver GLMax2DDriver()
?
Graphics 800,600,32,60
HideMouse

Local verts:Float[]=[-25.0,0.0,-75.0,75.0,0.0,50.0,100.0,100.0,..
50.0,25.0,100.0,0.0,50.0,-25.0,100.0,-100.0,0.0,-50.0,-75.0,-75.0]
Local cursor:Float[]=[0.0,-50.0,100.0,-100.0,50.0,0.0,100.0,100.0,..
0.0,50.0,-100.0,100.0,-50.0,0.0,-100.0,-100.0]

Local ang:Float=0

Local coltype:Int=0

Local rad:Float=20

Repeat
	
	If KeyHit(KEY_1) Then coltype=0
	If KeyHit(KEY_2) Then coltype=1
	If KeyHit(KEY_3) Then coltype=3
	If KeyHit(KEY_4) Then coltype=2
	
	Local x:Float=400
	Local y:Float=300
	Local rot:Float=ang/2
	Local sx:Float=Cos(ang)/2+1.5
	Local sy:Float=Sin(ang)/2+1.5
	Local hx:Float=Cos(ang)*50
	Local hy:Float=Sin(ang)*50
	Local ox:Float=Cos(ang/2)*50
	Local oy:Float=Sin(ang/2)*50
	Local lx:Float=400+Cos(-ang)*300
	Local ly:Float=300+Sin(-ang)*300
	
	SetRotation rot
	SetScale sx,sy
	SetHandle hx,hy
	SetOrigin ox,oy
	
	Local mx:Int=MouseX()
	Local my:Int=MouseY()
	
	Cls
	
	Select coltype
	Case 0
		If PointInTFormPoly(mx,my,verts,x,y,rot,sx,sy,hx,hy,ox,oy)
			SetColor 0,255,255
		Else
			SetColor 0,128,128
		EndIf
	Case 1
		If CircleToTFormPoly(mx,my,rad,verts,x,y,rot,sx,sy,hx,hy,ox,oy)
			SetColor 0,255,255
		Else
			SetColor 0,128,128
		EndIf
	Case 2
		If TFormPolyToTFormPoly(verts,x,y,rot,sx,sy,hx,hy,ox,oy,cursor,mx,my,-rot,0.5,0.5)
			SetColor 0,255,255
		Else
			SetColor 0,128,128
		EndIf
	Case 3
		If LineToTFormPoly(mx,my,lx,ly,verts,x,y,rot,sx,sy,hx,hy,ox,oy)
			SetColor 0,255,255
		Else
			SetColor 0,128,128
		EndIf
	End Select
	
	DrawPoly verts,True,x,y
	
	SetRotation 0
	SetScale 1,1
	SetHandle 0,0
	SetOrigin 0,0
	SetColor 255,255,255
	DrawText "Select 1, 2, 3 or 4",5,0
	DrawText "1: PointToTFormPoly",5,20
	DrawText "2: CircleToTFormPoly",5,35
	DrawText "3: LineToTFormPoly",5,50
	DrawText "4: TFormPolyToTFormPoly",5,65
	SetColor 255,0,0
	
	Select coltype
	Case 0
		DrawLine mx,my-10,mx,my+10,True
		DrawLine mx-10,my,mx+10,my,True
	Case 1
		DrawOval mx-rad,my-rad,rad*2,rad*2
	Case 2
		SetRotation -rot
		SetScale 0.5,0.5
		DrawPoly cursor,True,mx,my
	Case 3
		DrawLine mx,my,lx,ly,True
	End Select
	Flip
	
	ang:+1
	
Until KeyHit(KEY_ESCAPE)
End Rem
Function DrawPolyEX( xy:Float[], fill:Int=True, x:Float=0, y:Float=0 )
	Local origin_x:Float
	Local origin_y:Float
	GetOrigin origin_x,origin_y
	Local handle_x:Float
	Local handle_y:Float
	GetHandle handle_x,handle_y
	
	If fill
		_max2dDriver.DrawPoly xy,..
		-handle_x,-handle_y,..
		x+origin_x,y+origin_y
	Else
		Local x1:Float=xy[xy.Length-2]
		Local y1:Float=xy[xy.Length-1]
		For Local i:Int=0 Until Len xy Step 2
			Local x2:Float=xy[i]
			Local y2:Float=xy[i+1]
			_max2dDriver.DrawLine..
			-handle_x+x1,-handle_y+y1,..
			-handle_x+x2,-handle_y+y2,..
			x+origin_x-0.5,y+origin_y-0.5
			x1=x2
			y1=y2
		Next
	EndIf
End Function
</textarea> <br><br></td></tr></table><br>
<a name="1207232"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pete Rigz</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> I wrote a collision module a while go that can do this. you can get it through SVN here: <a href="http://subversion.assembla.com/svn/timelinefx-module/" target="_blank">http://subversion.assembla.com/svn/timelinefx-module/</a><br><br>There's a few examples in the doc folder, and here's one that uses circle to line specifically:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

Import rigz.collision

Graphics 800, 600

'create a line to collide with
Local line:tlLine = CreateLine(100, 120, 500, 200)

'create a box to move about
Local circle:tlCircle = CreateCircle(100, 100, 20)

'a local collision result to store the result of the collision test
Local result:tlCollisionResult = New tlCollisionResult

'some velocity vectors to move the box about
Local VelVector:tlVector2 = CreateVector2(0, 0)
Local VelMatrix:tlMatrix2 = CreateMatrix2()
Local Direction:Float
Local speed:Float = 4

While Not KeyDown(KEY_ESCAPE)
	
	Cls
		
	'some basic movement controls for the box
	If KeyDown(KEY_UP) direction = 0
	If KeyDown(KEY_RIGHT) direction = 90
	If KeyDown(KEY_DOWN) direction = 180
	If KeyDown(KEY_LEFT) direction = 270
	If KeyDown(KEY_RIGHT) And KeyDown(KEY_DOWN) direction = 135
	If KeyDown(KEY_DOWN) And KeyDown(KEY_LEFT) direction = 225
	If KeyDown(KEY_UP) And KeyDown(KEY_RIGHT) direction = 45
	If KeyDown(KEY_LEFT) And KeyDown(KEY_UP) direction = 315
	If KeyDown(KEY_UP) Or KeyDown(KEY_DOWN) Or KeyDown(KEY_LEFT) Or KeyDown(KEY_RIGHT)
		velvector.SetPosition(0, -speed)
	Else
		velvector.SetPosition(0, 0)
	End If
	velmatrix.set(Cos(direction) , Sin(direction) , -Sin(direction) , Cos(direction))
	velvector = velmatrix.transformvector(velvector).Unit()
	'set the box velocity so that the collision check can see whether the 2 objects will collide
	'the next frame. You don't *have* to do this, but it makes for more accurate collisions
	circle.velocity = VelVector.Scale(speed)

	'check for a collision with the line
	result = CheckCollision(circle, line)
	
	'prevent the circle from overlapping the poly
	PreventOverlap(result)
	
	'move the circle. Important to do this after the collision check, but only if you're setting
	'the box velicity.
	circle.Move(circle.velocity.x, circle.velocity.y)
	
	circle.draw()
	line.draw()
	
	Flip
	
Wend
</textarea><br><br>In the case of your code it could be the order in which you're checking for a collision and moving the circle, but that's a guess without looking too closely. <br><br></td></tr></table><br>
<a name="1207251"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >codermax</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey Pete, thanks a lot for your help. I suck at compiling modules, however yours is just plain bmx code, so it actually worked! Great source by the way.<br><br>I've changed my source to use your modules instead, and it works like a charm. Thanks again! :) <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
