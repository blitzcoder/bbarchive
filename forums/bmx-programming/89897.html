<!DOCTYPE html><html lang="en" ><head ><title >Feature request : tListOf (tList/Array hybrid)</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Feature request : tListOf (tList/Array hybrid)</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Feature request : tListOf (tList/Array hybrid)</a><br><br>
<a name="1021614"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Difference</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I often end up using tList and putting only one type in it.<br><br>I'd like to benefit from the strong typecasting of arrays, but still have the easy insert and remove features of tList, therefore:<br><br>I'd like a tList type that only accepted only one userdefined type, and did automatic typecasting when using first() last(),  ListToArray() etc.<br><br>Is it possible to add this feature to blitzmax?<br><br>I can't really think of a notation for such a variable type, but maybe someone knows this feature from another programming language and can suggest a syntax?<br><br>Sort of like this:<br><br>Local lo:tListOf[myType] = new tListOf <br><br></td></tr></table><br>
<a name="1021617"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >matibee</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm not sure how well you know C++ and the <a href="http://en.wikipedia.org/wiki/Standard_Template_Library" target="_blank">Sandard Template Library</a> for containers like this.<br><br><div class="quote"> Is it possible to add this feature to blitzmax? <br></div><br><br>Probably not without template support, which imho, would be a major and unlikely leap. <br><br></td></tr></table><br>
<a name="1021618"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> You want generics?  Cool :-)<br><br>That'll keep you busy for a while I'm sure! <br><br></td></tr></table><br>
<a name="1021619"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Difference</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> After a little googling: yes I think what I'm after might be generics, but just for the tList type<br><br><a href="http://msdn.microsoft.com/en-us/library/0zk36dx2%28v=VS.80%29.aspx" target="_blank">http://msdn.microsoft.com/en-us/library/0zk36dx2%28v=VS.80%29.aspx</a> shows  the missing syntax I was looking for.<br><br>The c# version seems to be evaluating at runtime, I was imagining something that was resolved at compile time.<br><pre class=code>Local lo:tListOf&lt;myType&gt; = new tListOf&lt;myType&gt;</pre><br><pre class=code>Function MyFunc:tListOf&lt;myType&gt;()
End Function</pre> <br><br></td></tr></table><br>
<a name="1021621"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ziggy</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> I have something similar in a BLIde template. I'll look for it later and post it. It is hardcoded, not generics, but a workaround. <br><br></td></tr></table><br>
<a name="1021625"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mahan</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> If it's just TList you could write a utility that generates source-code for types that inherit TList and adds "type casted overrides" of the usual content accessor methods.<br><br>I've made similar things for other languages that didn't have generics, and it worked great.<br><br>edit: made it (hopefully) more understandable. <br><br></td></tr></table><br>
<a name="1021628"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Difference</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks guys, I've used the utility approach before, but I keep coming back to thinking that it would be a nice feature to have in the language.<br><br>It is of cause a "Nice To Have" rather than a "Need to Have", but I still thought I'd put it out here. <br><br></td></tr></table><br>
<a name="1021637"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> i use arrays but have background code that resizes the array if it is too small, - to make the array act like a list. <br><br></td></tr></table><br>
<a name="1021649"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> <pre class=code>
i use arrays but have background code that resizes the array if it is too small, - to make the array act like a list.
</pre><br>that doesn't sound too efficient. <br><br></td></tr></table><br>
<a name="1021669"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mahan</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> @slenkar: Just as Jesse said that is inefficient, and it gets worse the bigger the arrays grow. (that is unless you use elaborate logic to optimize the growt of the arrays)<br><br>Not only does each "growt" on an array force a reallocation of the array + time to copy all the original contents: It might also lead to heavy memory fragmentation, which may lead to very strange "out of memory" errors when your application clearly does not use up all the available ram in the machine.<br><br>Note: If you're normal array sizes are low like some 10s or 100s you'll normally get away with it. But one day you use that app on a huge dataset or something and hell breaks lose =) (slower, slower, slower and finally app crash) <br><br></td></tr></table><br>
<a name="1021728"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kurator</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hm, what about extending the current TList, overriding the various add methods, that the compare the actual type of the parameter with the type of the element first putted in.<br><br>Easy to implement, but the disadvantage is, that you don not have type safety at compiletime. <br><br></td></tr></table><br>
<a name="1021744"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> i made it so that the array grows by 50 if it is too small,<br> so it doesnt change size much <br><br></td></tr></table><br>
<a name="1021745"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >xlsior</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Programs like Microsoft SQL grows its transaction logs by 10% when it runs out of space -- that way you can sort of limit the number of re-allocations, because you do have some room for growth that is based on realistic usage.<br><br>If there *is* a lot of growth, simply adding 50 each time may lead to a LOT or re-allocations in memory. <br><br></td></tr></table><br>
<a name="1021754"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Normally you make arrays grow by *2 and shrink by *2.<br>Grow when you try to add the first element post its size. Shrink when you use less than 0.3 - 0.45 * arraySize.<br><br>That way you have near constant costs for grow / shrink and copy, making it realistically usable.<br>Above a given size you can make it grow / shrink differently but that "given size" should be quite large, past the 10k elements for sure. <br><br></td></tr></table><br>
<a name="1021767"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >theHand</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Peter, are you sure you're not looking for a <a href="http://en.wikipedia.org/wiki/Hash_table" target="_blank">hash table</a>? <br><br></td></tr></table><br>
<a name="1021781"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Difference</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> @theHand : Yes , but now that you mention hash tables/maps, I'm thinking an "at compiletime typecasted" tMap would be very nice too.<br><br>MyTypeMap:tMap&lt;myType&gt; = Createmap(myType) <br><br></td></tr></table><br>
<a name="1021792"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Otus</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> You can Extend the TList type for automatic type checks in return types for First and the like (covariance):<br><pre class=code>Type TMyTypeList Extends TList
  Method First:TMyType()
    Return TMyType( Super.First() )
  End Method
  ' Etc.
End Type</pre><br>However, you will still be without compile time type safety in Add methods, unless you actually rename the methods... <br><br></td></tr></table><br>
<a name="1021816"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Difference</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Otus: Yes, that seems to be the most consistent solution as the BlitzMax language is now.<br><br>It can't however be done with typecasted objects for all methods, because some methods can only be overridden with the object type:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict

Type tMyType
	Field somevalue:Int = Rand(10000000)
End Type

Type tListOfMyType Extends TList
	Method First:tMyType()
		Return tMyType( Super.First() )
	End Method

	Method Last:tMyType()
		Return tMyType( Super.Last() )
	End Method

	Method AddFirst:TLink(value:Object)
		Assert tMyType(value) Else "tListOfMyType AddFirst() only accepts tMyType"
		Return Super.AddFirst(value) 
	End Method

	Method AddLast:TLink(value:Object)
		Assert tMyType(value) Else "tListOfMyType AddLast() only accepts tMyType"
		Return Super.AddLast(value) 
	End Method

	Method Remove(value:Object)
		Assert tMyType(value) Else "tListOfMyType Remove() only accepts tMyType"
		Super.Remove(value)
	End Method
	
	Method RemoveFirst:tMyType()
		Return tMyType(Super.RemoveFirst())
	End Method
	
	Method RemoveLast:tMyType()
		Return tMyType(Super.RemoveLast())
	End Method	
	

	
End Type




Local ml:tListOfMyType = New tListOfMyType

Local mt1:tMyType = New tMyType
Local mt2:tMyType = New tMyType


ml.addLast(mt1)
ml.addFirst(mt2)

'ml.addlast("Cheese")

Local d:tMytype = ml.RemoveLast()
Print d.somevalue


Print ml.last().somevalue
Print ml.first().somevalue

</textarea> <br><br></td></tr></table><br>
<a name="1021817"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Otus</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah, exactly what I meant. Argument types are contravariant, so you need to declare as Object.<br><br>It's not very pretty and causes unnecessary function calls and casts compared to writing your own list type (or generics support). <br><br></td></tr></table><br>
<a name="1021818"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Difference</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> yes, or not extending and having a list field instead, which I guess makes it cleaner:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict

Type tMyType
	Field somevalue:Int = Rand(10000000)
End Type

Type tListOfMyType
	Field list:TList
	
	Method New()
		list = New TList
	End Method
	
	Method First:tMyType()
		Return tMyType( list.First() )
	End Method

	Method Last:tMyType()
		Return tMyType( list.Last() )
	End Method

	Method AddFirst:TLink(value:tMyType)
		Return list.AddFirst(value) 
	End Method

	Method AddLast:TLink(value:tMyType)
		Return list.AddLast(value) 
	End Method

	Method Remove(value:tMyType)
		list.Remove(value)
	End Method
	
	Method RemoveFirst:tMyType()
		Return tMyType(list.RemoveFirst())
	End Method
	
	Method RemoveLast:tMyType()
		Return tMyType(list.RemoveLast())
	End Method	
	

	
End Type




Local ml:tListOfMyType = New tListOfMyType

Local mt1:tMyType = New tMyType
Local mt2:tMyType = New tMyType


ml.addLast(mt1)
ml.addFirst(mt2)

'ml.addlast("Cheese")

Local d:tMytype = ml.RemoveLast()
Print d.somevalue


Print ml.last().somevalue
Print ml.first().somevalue</textarea> <br><br></td></tr></table><br>
<a name="1021844"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2010)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Either make your own list (or copy and paste the TList code and change all Objects to your type), or live with the casting, as this not something to spend a long time worrying about :) <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
