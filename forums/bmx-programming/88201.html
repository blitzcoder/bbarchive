<!DOCTYPE html><html lang="en" ><head ><title >How's MT GC speed doing?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >How's MT GC speed doing?</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >How's MT GC speed doing?</a><br><br>
<a name="1001310"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Does anyone have some benchmarks for recent versions of BMX for MT GC vs. single-threaded GC speed?  I understand the MT GC has gotten faster and I am curious to see how they compare. <br><br></td></tr></table><br>
<a name="1001333"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >xlsior</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> I don't have any benchmark numbers handy, but I can tell you that I definitely saw a huge speedup compared to the old MT GC.<br><br>The initial MT release was 10-20 times slower than single-threaded in my app, the current one maybe one and a half times slower.<br>The original MT GC meant that any speed increase by splitting into multiple threads was completely off-set by the extra GC overhead -- that appears to be no longer the case. <br><br></td></tr></table><br>
<a name="1001394"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> I just did some threaded stuff, 4 threads, and it seems the garbage collector has much less impact on the speed, and saw a better speedup from using threads. Also I am no longer seeing the glitchy framerate stuttering which used to be caused by the old one. <br><br></td></tr></table><br>
<a name="1001405"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> BlitzMax 1.36<br>This is just running the default project the engine project wizard creates<br><br>MT=336 FPS<br>ST=356 FPS<br><br>So in this test, MT mode was 94% the speed of ST.  Of course, I don't know if that percentage will stay the same in a more complex environment. <br><br></td></tr></table><br>
<a name="1001407"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> When I try this code:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">'	====================================================================
'	This file was generated by Leadwerks C++/LEO/BlitzMax Project Wizard
'	Written by Rimfrost Software
'	<a href="http://www.rimfrost.com" target="_blank">http://www.rimfrost.com</a> 
'	====================================================================

SuperStrict

Framework leadwerks.ENGINE

Local world:TWorld
Local gbuffer:TBuffer
Local camera:TCamera
Local mesh:TMesh
Local light:TLight
Local ground:TMesh
Local material:TMaterial

RegisterAbstractPath( "C:/Program Files (x86)/Leadwerks Engine SDK" ) 

Graphics(800,600)

world=CreateWorld()
If Not world RuntimeError "Failed to create world."

gbuffer=CreateBuffer(GraphicsWidth(),GraphicsHeight(),BUFFER_DEPTH|BUFFER_COLOR0|BUFFER_COLOR1|BUFFER_COLOR2)

camera=CreateCamera()
PositionEntity camera,[0.0,0.0,-2.0]

material=LoadMaterial("abstract::cobblestones.mat")

mesh=CreateCube()
PaintEntity mesh,material

ground=CreateCube()
ScaleEntity ground,[10.0,1.0,10.0]
PositionEntity ground,[0.0,-2.0,0.0]
PaintEntity ground,material

For Local n:Int=1 To 1000
	Local c:TEntity=CopyEntity(mesh)
	PositionEntity( c, Vec3( Rnd(-10,10),Rnd(-10,10),Rnd(-10,10) ) )
Next

light=CreateDirectionalLight()

RotateEntity light,[45.0,45.0,45.0]

Repeat

	TurnEntity mesh,[AppSpeed()*0.5,AppSpeed()*0.5,AppSpeed()*0.5]
	
	If KeyHit(KEY_ESCAPE) Exit
	If AppTerminate() Exit
	
	UpdateAppTime()
	UpdateWorld(AppSpeed())

	SetBuffer(gbuffer)
	RenderWorld()
	SetBuffer(BackBuffer())
	RenderLights(gbuffer)
	
	DrawText UPS(),0,0
	DrawText GCMemAlloced(),0,20
	Flip(0)

Forever</textarea><br><br>MT=160<br>ST=200<br><br>In this case, MT is 80% as fast.  That's not very encouraging.  You might be able to offload some parallel problems onto other cores, but it's going to be a struggle if all your code automatically drops to 80% speed. <br><br></td></tr></table><br>
<a name="1001440"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Azathoth</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> In this case, MT is 80% as fast. That's not very encouraging. You might be able to offload some parallel problems onto other cores, but it's going to be a struggle if all your code automatically drops to 80% speed. <br></div>If you haven't changed your code to take advantage of multiple threads you are not going to see a speed increase. This isn't just a Blitzmax thing. <br><br></td></tr></table><br>
<a name="1001446"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> If you haven't changed your code to take advantage of multiple threads you are not going to see a speed increase.  <br></div><br>I was going to mention that too, but it seemed rather obvious. <br><br></td></tr></table><br>
<a name="1001450"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tommo</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>If you haven't changed your code to take advantage of multiple threads you are not going to see a speed increase. This isn't just a Blitzmax thing.<br> <br></div><br>It's not about speed increase, but speed loss with same source code.<br><br>I think there are something more Mark can do to improve his MT GC. Although it's actually fast enough now. <br><br></td></tr></table><br>
<a name="1001473"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> The original 94% quoted is not correct because fps rates do not decrease linearly. ;-D .. just teasing.<br><br>A 20% drop does sound a bit alarming. 90-100% would be good. I would be happy with that provided that by using other threads to do extra work I overall gain much more than 100% of the single-threaded speed. For me I found that with 4 threads on a 4-core machine a threaded routine was at least 2-3 times faster, and on a dual-core it was almost twice as fast. <br><br></td></tr></table><br>
<a name="1001476"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Azathoth</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> It's not about speed increase, but speed loss with same source code. <br></div>Ofcourse thats going to happen if you're using the thread safe GC with code thats designed to run as one thread, its doing redundant checks. <br><br></td></tr></table><br>
<a name="1001483"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> If you haven't changed your code to take advantage of multiple threads you are not going to see a speed increase. This isn't just a Blitzmax thing. <br></div><br>Well obviously, but when parallelizing code, you aren't just fighting the part of the code you are making parallel.  You are fighting a 20% drop in speed across all code.<br><br>Let's say parallel programming results in 30% of the program loop being twice as fast.  But there is that 20% reduction in speed across the board.<br><br>30 * 0.8 * 2.0 = 48<br><br>Now the remaining 70% of the code is 20% slower:<br><br>70 * 0.8 = 56<br><br>Add them together:<br><br>56 + 48 = 104<br><br>The net result is only a 4% increase in speed.  So in this case, all your effort was basically wasted. <br><br></td></tr></table><br>
<a name="1001504"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >H&amp;K</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> First you have the maths wrong. (Not important, just FYI)<br><br>70*1.2     = 84        That is took 70 units of time now takes 84<br>30*0.5*1.2 = 18        That is took 30 units of time now takes 18<br><br>           = 102 percent of the original TIME, Meaning 2 % SLOWER.<br><br>My main question is, are you running this on a single thread machine?<br>If we can assume you are, not then we need lots better speed. If it is a single thread, then nothing can be taken from you times. <br><br></td></tr></table><br>
<a name="1001505"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> I have a quad core, but my app runs on all configurations.<br><br>The point is even with a quad core, it is questionable whether any savings can be achieved in the overall program speed.  Realistically, I think we might be looking at 10-15% improvement in the best case scenario. <br><br></td></tr></table><br>
<a name="1001534"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's not true. Like I said in my little app, I have two pieces of cpu-intensive code - a large particle simulation and a fluid dynamics simulation. I do both in 4 threads. The two routines together do maybe 80% of the app's work, the rest is graphics rendering. On a dual core I now see it using around 70% of the total cpu time, whereas it used to use only 50%. On a quad core it uses up to about 60% of the total cpu time. The end result is that the app runs considerably smoother, I'd say somewhere between 170% and 250% faster.<br><br>We have to remember also that a) the amount of memory accesses can stall all of the cpu's because there is only so much bus bandwidth, b) memory accesses all have to share the same bus so even though you can process `in parallel` once the data is in the cpu/cache, if it's not there is a fight for resources, and c) having 4 times as many cores doesn't give you 400% speedup because the rest of the architecture is not 4 times faster or 4 times `as parallel`. <br><br></td></tr></table><br>
<a name="1001540"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >JoshK</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's good to hear. <br><br></td></tr></table><br>
<a name="1001605"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Otus</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> We have to remember also that a) the amount of memory accesses can stall all of the cpu's because there is only so much bus bandwidth, b) memory accesses all have to share the same bus so even though you can process `in parallel` once the data is in the cpu/cache, if it's not there is a fight for resources <br></div><br>On the other hand, a program that is limited by memory latencies (as opposed to bandwidth) could scale even better by running two threads per core. With even DDR2 bandwidth well in the GB-range few programs need all the bandwidth. I have a program which I think is memory latency limited (it accesses hundreds of MB in a nonlinear fashion), but I haven't gotten around to multi-threading it yet. However, since I now have a quad-core it is on my todo list. I hope the new GC will work well.<br><br><div class="quote"> having 4 times as many cores doesn't give you 400% speedup because the rest of the architecture is not 4 times faster or 4 times `as parallel`. <br></div><br>Yes and a CPU with 4 times the frequency won't give a 400% speedup either (other things constant). Realistically, one shouldn't expect multi-threaded performance to be a multiple of the old performance in most cases, but it's encouraging if that is the case in some situations. <br><br></td></tr></table><br>
<a name="1001669"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2009)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think also that if you go multithreaded you may want to take another look at optimizing your code more to reduce memory accesses - try to use as many local variables as you can, try to design the algorithms/structure to favor only needing a small subset of locals at a time, try pipelining some of your commands so that they do stuff with locals in-between doing stuff with globals/memory variables. etc I think that helped in my case. I also saw some forums elsewhere talking about this and that it helps if either all the threads run on the same data so that the caches get shared, (I do my fluid simulation with an interleaved skip through the data by each thread), and also it may help to make each thread's data accesses not dependent on or use the same data as other threads (I do my particle thing that way, each thread had its own set of particles) and state which is completely separate from the other threads. I would also try to avoid having to need to use mutexes or any of the other o/s api commands regarding threads as in general this will slow things down if you use them a lot. I don't use any mutexes whatsoever in my app, but having said that it is not thread safe and there are some errors - but within the context of what I'm using it for you don't really notice the effects. And finally, the more threads you have, the more time the o/s has to take to do all the context switches, they use more memory for stacks and stuff, so more threads is not necessarily more efficient. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
