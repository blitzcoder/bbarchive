<!DOCTYPE html><html lang="en" ><head ><title >Boulderdash mechanics</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Boulderdash mechanics</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Boulderdash mechanics</a><br><br>
<a name="1298454"></a>

<a name="1298455"></a>

<a name="1298456"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is a Bulderdash mechanics which uses a small portion of a huge world to update itself on a regular basis.<br><br>You could use this to well I don't know really. Games or just having fun with tiles and explore.<br><br><pre class=code>
' How to use
'
' Draw some boulders using the mouse
' Press 1, 2 or 3 to change tiles
'
' Move around inside the world using cursor keys


Global buffer:Int[256*256] ; Local img2:TPixmap=LoadPixmap(LoadBank("http::s9.postimg.org/rfaelk9m3/128x128.png"))  ' Load a 128x128 Atlas with 8x8 tiles
For yy=0 To 127 ; For xx=0 To 127 ; buffer(xx+yy*128) = ReadPixel(img2,xx,yy) ; Next ; Next
Global map[4096,4096] , wx:Int , wy:Int , c:Int = buffer[0] , s:Int = 2 , xres:Int = 1024 , yres:Int = 768 , pixels:Int[xres*yres]
Local a:Float = 0 , x:Float = 0 , y:Float = 0 , dx:Float = 0 , dy:Float = 0 , speed:Float = 0
Global space_z:Float = 50 , horizon:Int = 20, scale:Float = 1000 , obj_scale:Float = 50 , pmap:Int[1024*1024] 
Global cx

' Prepare something here, you can do alot here to improve it into a fun world, I think I will just put some text
For y=0 To 316 ; For x=0 To 475; map[x,y]=Rnd(127) ; Next ; Next ' This fills with garbage (uncomment line below if you want garbage)
For y=0 To 316 ; For x=0 To 475; map[x,y]=32 Next ; Next ' Clear the space

Global cmap[4096,4096] ; For y=0 To 316 ; For x=0 To 475; cmap[x,y]=Rnd(15) ; Next ; Next
Global worldx,worldy,currentx ; Global cols[16] 
RestoreData colors 
For temp=0 To 15 ; ReadData cols[temp] ; Next

writetomap "                                        ",0,0
writetomap "    **** COMMODORE 64 BASIC V2 ****     ",0,1
writetomap "                                        ",0,2
writetomap " 64K RAM SYSTEM  38911 BASIC BYTES FREE ",0,3
writetomap "                                        ",0,4
writetomap "READY.                                  ",0,5
writetomap "                                        ",0,4
writetomap "----------------------------------- ",0,20

GLGraphics(xres,yres,0,60,GRAPHICS_BACKBUFFER | GRAPHICS_DEPTHBUFFER) 
glViewport(0,0,xres,yres) ; glMatrixMode(GL_PROJECTION) ; glLoadIdentity() ; glOrtho(0,xres,yres,0,0,1) ; glPixelZoom(1,-1) ; glRasterPos2i(0,0)

s=2
Global Current=79, current2=7
Repeat
	For y=0 To yres-1 Step 1 ; For x=0 To xres-1 Step 1 ; pixels[(y*xres+x)] = 0 ; Next ; Next

	worldx=worldx-s*KeyDown(KEY_LEFT)+s*KeyDown(KEY_RIGHT) ; worldy=worldy-s*KeyDown(KEY_UP)+s*KeyDown(KEY_DOWN)
        worldx=Max(0,Min(10000,worldx)) ; worldy=Max(0,Min(10000,worldy))

	alive() ' This one makes things alive, comment it if you don´t want things changing in life. You bore.

	display(worldx,worldy,0,0,1024,768)
	glDrawPixels(xres,yres,GL_BGRA,GL_UNSIGNED_BYTE,Varptr(Pixels[0]))
	
	ddd=Ddd+1 ; If ddd = 4 Then boulders() ; ddd=0
	If KeyDown(49) Then Current=79 ; current2=7
    If KeyDown(50) Then Current=17 ; current2=8
    If KeyDown(51) Then Current=32 ; current2=7
    mx=MouseX()*6 ; my=MouseY()*6
	mx=mx/6 ; my=my/6 ; xxx=(worldx+mx) Sar 4 ; yyy=(worldy+my) Sar 4 
	If MouseDown(1) Then If map(xxx,yyy)&lt;&gt;79 And map(xxx,yyy)&lt;&gt;111 And map(xxx,yyy)&lt;&gt;112 Then map(xxx,yyy)=Current;cmap(xxx,yyy)=current2
	Delay 1 ; Flip 1
Until MouseDown(2)
End

Function alive()
For temp=1 To 16 ; buffer[Int(Rand(0,15))+Int((Rand(0,15))*128)]=$ffffffff * Int(Rand(0,1)) ; Next
currentx=(currentx+1) Mod 128 ; For tempy=0 To 15 ; For temp=0 To 15+32
buffer[16+temp+((0+tempy)*128)]=buffer[0+temp+currentx+((16+tempy)*128)] ; Next ; Next ; For temp=1 To 1600 ; cmap[Rnd(400),Rnd(250)]=Rnd(16) ; Next
End Function

Function display(worldx,worldy,ofx=0,ofy=0,sx=640,sy=400) 
scrx=worldx &amp; 15 ; scry=worldy &amp; 15 ; mapx=worldx Shr 4 ; mapy=worldy Shr 4
cnty = 0 ; For y=mapy To mapy+((sy Shr 4)+1)
cntx = 0 ; For x=mapx To mapx+((sx Shr 4)+1)
tilex=map(x,y) &amp; 15 ; tiley=map(x,y) Shr 4
colour=cols(cmap(x,y))
xx=cntx - scrx + ofx ; yy=cnty - scry + ofy
For ty=0 To 7 ; For tx=0 To 7
If ((xx+tx+tx)=&gt;ofx) And ((yy+ty+ty)=&gt;ofy) And ((xx+tx+tx)&lt;(ofx+sx)) And ((yy+ty+ty)&lt;(ofy+sy))
If buffer[tilex Shl 3 + tx + (tiley Shl 3 + ty)*128] &lt;&gt; c Then pixels[xx+tx+tx + (yy+ty+ty)*xres] = colour 
EndIf
Next ; Next
cntx=cntx+16 ; Next
cnty=cnty+16 ; Next
End Function


Function boulders()
For y=100 To 0 Step -1 ; For x=0 To 100

If map(x,y)=79 ' BOULDER
     If map(x,y+1) = 32
        map(x,y) = 111
     ElseIf map(x,y+1) = 79 And map(x-1,y) = 32 And map(x-1,y+1) = 32
        map(x,y) = 32 ; map(x-1,y) = 111
     ElseIf map(x,y+1) = 79 And map(x+1,y) = 32 And map(x+1,y+1) = 32
        map(x,y) = 32 ; map(x+1,y) = 112 ' 111
    EndIf
EndIf

If map(x,y)=111 ' FALLINGBOULDER
     If map(x,y+1) = 32
        map(x,y)=32 ; map(x,y+1) = 111
     ElseIf map(x,y+1)=79 And map(x-1,y) = 32 And map(x-1,y+1) = 32
        map(x,y) = 32 ; map(x-1,y+0) = 111
     ElseIf map(x,y+1)=79 And map(x+1,y) = 32 And map(x+1,y+1) = 32
        map(x,y) = 32 ; map(x+1,y+0) = 112 ' 111
     Else
        map(x,y)=79
    EndIf
EndIf

If map(x,y)=112 Then map(x,y)=111 ' added

Next ; Next
End Function

Function writetomap(t$,x,y)
	For tempx=x To Len(t$)-1 ; temp=Asc(Mid$(t$,1+tempx,1)) ; map[tempx,y]=temp ; cmap[tempx,y]=14 ; Next 
End Function

#colors
DefData $000000, $FFFFFF,$68372B,$70A4B2,$6F3D86,$588D43,$352879,$B8C76F,$6F4F25,$433900,$9A6759,$444444,$6C6C6C,$9AD284,$6C5EB5,$959595
</pre> <br><br></td></tr></table><br>
<a name="1298460"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi Casaber. I'm trying it out. Maybe not getting the same effect as Boulderdash ?<br><br>In Boulderdash, you have a player tile that navigates around a map. There are boulders being supported by ledges. Now if the player walks through a ledge then the boulders can come crashing down.<br><br>The player is expected to retrieve jewels in the map and not get clobbered by the boulders. Additionally the player must be intelligent to know where the boulders will fall so they will not block his path from continuing through the map.<br><br>Here is a video to show the mechanics.<br><br>[a https://www.youtube.com/watch?v=FiEVfa1OK_ohttps://www.youtube.com/watch?v=FiEVfa1OK_o]<b>VIDEO</b>[/a]. <br><br></td></tr></table><br>
<a name="1298463"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> The left/right pushing crashing down I havn't implemented that part yet. Good point.<br><br>Let's call it. Boulder without the dash. <br><br></td></tr></table><br>
<a name="1298464"></a>

<a name="1298465"></a>

<a name="1298466"></a>

<a name="1298467"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> My fingers are cold but it would be easy once you've got a man in the picture<br>The mechanics run magically in the background so if you do this<br><br>' if any boulder(O or o) where you push then if space on the boulderside = AIR then swap tiles and delay abit<br><br>If you look closely I missuse o and O to store information. I can't remember what I stored I think it has to do with the falling bit. <br>Ya one of those tiles are representing falling tiles and one of them represents tiles on steady ground.<br><br>You could easly use a flag for that but I used o and O to flag movement and stability. <br>This code has so many logical traps to get working equally on both sides. Boulders should be equally balanced <br>if you drop alot of them on a pointy pyramid for example. That was hard. <br><br></td></tr></table><br>
<a name="1298488"></a>

<a name="1298490"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> It's actually pretty neat what it does, Casaber. There was a series of games written for the Apple years ago that used this kind of object technology.<br><br>If you want to see a Golden Crown of this method, check out ZZT For the PC.<br><br>Every single character has an identity. Well worth investigating if you're interested in this method.<br><br><a href="http://www.dosgamesarchive.com/download/zzt/" target="_blank">http://www.dosgamesarchive.com/download/zzt/</a><br><br>Many MANY games were written with it. If text characters are too primitive you can always try Megazeux. A considerably more powerful alternative w higher control over object elements.<br><br><a href="http://vault.digitalmzx.net/index.php" target="_blank">http://vault.digitalmzx.net/index.php</a><br><br>One advantage of Megazeux is it runs just fine in Windows 8. ZZT, it's predecessor, however, does require DOS BOX to run best. <br><br></td></tr></table><br>
<a name="1298492"></a>

<a name="1298493"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nice. Mind you though that here you have all that and also have pixel perfect position of everything .Without drawbacks, everything moved tile by tile I do on purpose (important detail). <br>I collected all the goodies from 1975-1995 (graphic modes I liked and features I was fond of and find useful in practice).<br><br>The rest I put in a graphic library I'm still working on called "Graphene". <br><br></td></tr></table><br>
<a name="1298516"></a>

<a name="1298517"></a>

<a name="1298518"></a>

<a name="1298519"></a>

<a name="1298520"></a>

<a name="1298521"></a>

<a name="1298523"></a>

<a name="1298524"></a>

<a name="1298526"></a>

<a name="1298528"></a>

<a name="1298530"></a>

<a name="1298531"></a>

<a name="1298532"></a>

<a name="1298533"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> dw817 I tried to make one for you, but it's not finished lots of possible, not bugs but lots of undesisive options to make. <br><br>I wanted it to be not smooth but you know..as if the character pushed the a heavy stone and it suddenly gives away. <br>It didn't go all to well I think but it's a start. There's lots of questionmarks how to go about best to implement this. <br>Things like.. when he's inbetween 2 tiles, and both happen to be moveable stones, what to do? Anyway here it is, I wished it was abit more readable to toy around with.<br><br><br>But I wrote some dashes around the interesting area which controls the figure.<br><br>I forgot to say, now cursor moves man, lshift+cursor moves world.<br>Also I made him able to move in ONE direction at a time instead of being entirely free.<br>I don´t like the logic on the movement, the previous one was like a classic Pacman movement before (you know.. blockage does not hinder the free dimension). His not like that anymore. It's weird. But his not by any means finished. This is just the buggy beginning. You need to be spot on vertically to be able to move anything (which I don´t like)<br><br>I call him.. the buggy man. He's very very VERY buggy. It's sexy.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' How to use
'
' Draw some boulders using the mouse
' Press 1, 2 or 3 to change tiles
'
' Move around inside the world using cursor keys, scroll using lshift + cursor


Global buffer:Int[256*256] ; Local img2:TPixmap=LoadPixmap(LoadBank("http::s9.postimg.org/rfaelk9m3/128x128.png"))  ' Load a 128x128 Atlas with 8x8 tiles
For yy=0 To 127 ; For xx=0 To 127 ; buffer(xx+yy*128) = ReadPixel(img2,xx,yy) ; Next ; Next
Global map[4096,4096] , wx:Int , wy:Int , c:Int = buffer[0] , s:Int = 2 , xres:Int = 1024 , yres:Int = 768 , pixels:Int[xres*yres]
Local a:Float = 0 , x:Float = 0 , y:Float = 0 , dx:Float = 0 , dy:Float = 0 , speed:Float = 0
Global space_z:Float = 50 , horizon:Int = 20, scale:Float = 1000 , obj_scale:Float = 50 , pmap:Int[1024*1024] 
Global cx

' Prepare something here, you can do alot here to improve it into a fun world, I think I will just put some text
For y=0 To 316 ; For x=0 To 475; map[x,y]=Rnd(127) ; Next ; Next ' This fills with garbage (uncomment line below if you want garbage)
For y=0 To 316 ; For x=0 To 475; map[x,y]=32 Next ; Next ' Clear the space

Global cmap[4096,4096] ; For y=0 To 316 ; For x=0 To 475; cmap[x,y]=5 ; Next ; Next
Global worldx,worldy,currentx ; Global cols[16] 
RestoreData colors 
For temp=0 To 15 ; ReadData cols[temp] ; Next

writetomap "                                        ",0,0
writetomap "    **** COMMODORE 64 BASIC V2 ****     ",0,1
writetomap "                                        ",0,2
writetomap " 64K RAM SYSTEM  38911 BASIC BYTES FREE ",0,3
writetomap "                                        ",0,4
writetomap "READY.                                  ",0,5
writetomap "                                        ",0,4
writetomap "----------------------------------- ",0,20

GLGraphics(xres,yres,0,60,GRAPHICS_BACKBUFFER | GRAPHICS_DEPTHBUFFER) 
glViewport(0,0,xres,yres) ; glMatrixMode(GL_PROJECTION) ; glLoadIdentity() ; glOrtho(0,xres,yres,0,0,1) ; glPixelZoom(1,-1) ; glRasterPos2i(0,0)

s=2
Global Current=79, current2=7
Global speed2:Int=1
spritex = 128+8*16 ; spritey = 128+8*16
Repeat
	For y=0 To yres-1 Step 1 ; For x=0 To xres-1 Step 1 ; pixels[(y*xres+x)] = 0 ; Next ; Next


If KeyDown(KEY_LSHIFT) Then worldx=worldx-s*KeyDown(KEY_LEFT)+s*KeyDown(KEY_RIGHT) ; worldy=worldy-s*KeyDown(KEY_UP)+s*KeyDown(KEY_DOWN)

    worldx=Max(0,Min(10000,worldx)) ; worldy=Max(0,Min(10000,worldy))

'	alive() ' This one makes things alive, comment it if you don´t want things changing in life. You bore.

	display(worldx,worldy,0,0,1024,768)
	
	' Show a moving sprite inside wthe world coordinatesystem
	drawsprite 30,spritex,spritey,worldx,worldy,0,0,16*80,16*50
	' spritex = spritex + 1 : spritey = spritey + 1
'	spritex=spritex-s*KeyDown(KEY_LEFT)+s*KeyDown(KEY_RIGHT) ; spritey=spritey-s*KeyDown(KEY_UP)+s*KeyDown(KEY_DOWN)













' -----------------------------------------------------------	
'
' Walking sprite
'

	wd = 0
If Not KeyDown(KEY_LSHIFT)
	If KeyDown(KEY_LEFT) Then wd=1
	If KeyDown(KEY_RIGHT) Then wd=2
	If KeyDown(KEY_UP) Then wd=3
	If KeyDown(KEY_DOWN) Then wd=4
EndIf

	Left1 = map((spritex-speed2)Shr 4,(spritey+0)Shr 4) ' the two interesting
	left2 = map((spritex-speed2)Shr 4,(spritey+15) Shr 4) ' hotspots for movement of left
	right1 = map((spritex+15+speed2)Shr 4,(spritey+0)Shr 4) ' same for..
    right2 = map((spritex+15+speed2)Shr 4,(spritey+15)Shr 4) ' right
    up1 = map((spritex+0)Shr 4,(spritey-speed2) Shr 4) ' same for..
    up2 = map((spritex+15)Shr 4,(spritey-speed2)Shr 4) ' up
    down1 = map((spritex+0)Shr 4,(spritey+15+speed2)Shr 4) ' same For..
    down2 = map((spritex+15)Shr 4,(spritey+15+speed2)Shr 4)' down 

	currenttile = map((spritex+8)/16,(spritey+8)/16) ' hotspot middle

	lefttile = map((spritex+8-16)/16,(spritey+8)/16)
	righttile = map((spritex+8+16)/16,(spritey+8)/16)
	bouldersleft = map((spritex+8-32)/16,(spritey+8)/16)
    bouldersright = map((spritex+8+32)/16,(spritey+8)/16)
		
	If wd = 1 Then If left1 &lt; 33 And Left2 &lt; 33 Then spritex=spritex-speed2
	If wd = 2 Then If right1 &lt; 33 And right2 &lt; 33 Then spritex=spritex+speed2
	If wd = 3 Then If up1 &lt; 33 And up2 &lt; 33 Then spritey=spritey-speed2
	If wd = 4 Then If down1 &lt; 33 And down2 &lt; 33 Then spritey=spritey+speed2

	' Should he e able to push a boulder only if TILE-LEVELLED? or inbetween tiles heightwise? if the latter then you need check TWO tiles on the boulder side, and also decide what to do do if TWO boudlers stackt ontop vertically exists, if he should move none one orb othg
	' So lets stick with TILE LEVELLED (meaning only ONE BOULDER IS CURRRENT)
	' AND MAKE o AND O BOTH BE BOULDER &lt;-- Work In Progress (making him less of antimagnetic man) abit odd boulder detection.
	temp2=temp2+1
	
	If temp2&gt;=16
	temp2=temp-16
	If left1 = 79 And left2 = 79 And bouldersleft = 32 Then If wd = 1 Then map((spritex+8-16)/16,(spritey+8)/16) = 32; map((spritex+8-32)/16,(spritey+8)/16) = 79 ; spritex = spritex - 16/2' move boulder left when possible
	If Right1 = 79 And right2 = 79 And bouldersright = 32 Then If wd = 2 Then map((spritex+8+16)/16,(spritey+8)/16) = 32; map((spritex+8+32)/16,(spritey+8)/16) = 79 ; spritex = spritex + 16/2' move boulder right when possible
    EndIf

    ' map((spritex+8)/16+Rnd(1)-Rnd(1),(spritey+8)/16+Rnd(1)-Rnd(1))=1 ; cmap((spritex+8)/16,(spritey+8)/16)=Rnd(14)+1 ' dig random
' -----------------------------------------------------------
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	



	glDrawPixels(xres,yres,GL_BGRA,GL_UNSIGNED_BYTE,Varptr(Pixels[0]))
	ddd=Ddd+1 ; If ddd = 4 Then boulders() ; ddd=0
	If KeyDown(49) Then Current=79 ; current2=7
    If KeyDown(50) Then Current=35 ; current2=8
    If KeyDown(51) Then Current=32 ; current2=7
    mx=MouseX()*6 ; my=MouseY()*6
	mx=mx/6 ; my=my/6 ; xxx=(worldx+mx) Sar 4 ; yyy=(worldy+my) Sar 4 
	If MouseDown(1) Then If map(xxx,yyy)&lt;&gt;79 And map(xxx,yyy)&lt;&gt;111 And map(xxx,yyy)&lt;&gt;112 Then map(xxx,yyy)=Current ; cmap(xxx,yyy)=current2
	Delay 1 ; Flip 1
Until MouseDown(2)
End

Function alive()
For temp=1 To 16 ; buffer[Int(Rand(0,15))+Int((Rand(0,15))*128)]=$ffffffff * Int(Rand(0,1)) ; Next
currentx=(currentx+1) Mod 128 ; For tempy=0 To 15 ; For temp=0 To 15+32
buffer[16+temp+((0+tempy)*128)]=buffer[0+temp+currentx+((16+tempy)*128)] ; Next ; Next ; For temp=1 To 1600 ; cmap[Rnd(400),Rnd(250)]=Rnd(16) ; Next
End Function

Function display(worldx,worldy,ofx=0,ofy=0,sx=640,sy=400) 
scrx=worldx &amp; 15 ; scry=worldy &amp; 15 ; mapx=worldx Shr 4 ; mapy=worldy Shr 4
cnty = 0 ; For y=mapy To mapy+((sy Shr 4)+1)
cntx = 0 ; For x=mapx To mapx+((sx Shr 4)+1)
tilex=map(x,y) &amp; 15 ; tiley=map(x,y) Shr 4
colour=cols(cmap(x,y))
xx=cntx - scrx + ofx ; yy=cnty - scry + ofy
For ty=0 To 7 ; For tx=0 To 7
If ((xx+tx+tx)=&gt;ofx) And ((yy+ty+ty)=&gt;ofy) And ((xx+tx+tx)&lt;(ofx+sx)) And ((yy+ty+ty)&lt;(ofy+sy))
If buffer[tilex Shl 3 + tx + (tiley Shl 3 + ty)*128] &lt;&gt; c Then pixels[xx+tx+tx + (yy+ty+ty)*xres] = colour 
EndIf
Next ; Next
cntx=cntx+16 ; Next
cnty=cnty+16 ; Next
End Function


Function boulders()
For y=100 To 0 Step -1 ; For x=0 To 100

If map(x,y)=79 ' BOULDER
     If map(x,y+1) = 32
        map(x,y) = 111
     ElseIf map(x,y+1) = 79 And map(x-1,y) = 32 And map(x-1,y+1) = 32
        map(x,y) = 32 ; map(x-1,y) = 111
     ElseIf map(x,y+1) = 79 And map(x+1,y) = 32 And map(x+1,y+1) = 32
        map(x,y) = 32 ; map(x+1,y) = 112 ' 111
    EndIf
EndIf

If map(x,y)=111 ' FALLINGBOULDER
     If map(x,y+1) = 32
        map(x,y)=32 ; map(x,y+1) = 111
     ElseIf map(x,y+1)=79 And map(x-1,y) = 32 And map(x-1,y+1) = 32
        map(x,y) = 32 ; map(x-1,y+0) = 111
     ElseIf map(x,y+1)=79 And map(x+1,y) = 32 And map(x+1,y+1) = 32
        map(x,y) = 32 ; map(x+1,y+0) = 112 ' 111
     Else
        map(x,y)=79
    EndIf
EndIf

If map(x,y)=112 Then map(x,y)=111 ' added

Next ; Next
End Function

Function writetomap(t$,x,y)
	For tempx=x To Len(t$)-1 ; temp=Asc(Mid$(t$,1+tempx,1)) ; map[tempx,y]=temp ; cmap[tempx,y]=14 ; Next 
End Function

Function drawsprite(sprite,xx,yy,worldx,worldy,ofx=0,ofy=0,sx=640,sy=400)
	xx=xx-worldx ; yy=yy-worldy ' xx,yy is now screen coordinates
	tilex=sprite &amp; 15 ; tiley=sprite Shr 4 ; colour=cols(1)
	For ty=0 To 7 ; For tx=0 To 7
	    If ((xx+tx+tx)=&gt;ofx) And ((yy+ty+ty)=&gt;ofy) And ((xx+tx+tx)&lt;(ofx+sx)) And ((yy+ty+ty)&lt;(ofy+sy))
		If buffer[tilex Shl 3 + tx + (tiley Shl 3 + ty)*128] &lt;&gt; c Then pixels[xx+tx+tx + (yy+ty+ty)*xres] = buffer[tilex Shl 3 + tx + (tiley Shl 3 + ty)*128] ; pixels[xx+tx+tx + 1 + (yy+ty+ty)*xres] = buffer[tilex Shl 3 + tx + (tiley Shl 3 + ty)*128]
	EndIf
	Next ; Next
End Function

#colors
DefData $000000, $FFFFFF,$68372B,$70A4B2,$6F3D86,$588D43,$352879,$B8C76F,$6F4F25,$433900,$9A6759,$444444,$6C6C6C,$9AD284,$6C5EB5,$959595
</textarea> <br><br></td></tr></table><br>
<a name="1298534"></a>

<a name="1298535"></a>

<a name="1298536"></a>

<a name="1298537"></a>

<a name="1298538"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> I really did not enjoy the one direction so I got the original movement back, here, now total freedom again.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' How to use
'
' Draw some boulders using the mouse
' Press 1, 2 or 3 to change tiles
'
' Move around inside the world using cursor keys


Global buffer:Int[256*256] ; Local img2:TPixmap=LoadPixmap(LoadBank("http::s9.postimg.org/rfaelk9m3/128x128.png"))  ' Load a 128x128 Atlas with 8x8 tiles
For yy=0 To 127 ; For xx=0 To 127 ; buffer(xx+yy*128) = ReadPixel(img2,xx,yy) ; Next ; Next
Global map[4096,4096] , wx:Int , wy:Int , c:Int = buffer[0] , s:Int = 2 , xres:Int = 1024 , yres:Int = 768 , pixels:Int[xres*yres]
Local a:Float = 0 , x:Float = 0 , y:Float = 0 , dx:Float = 0 , dy:Float = 0 , speed:Float = 0
Global space_z:Float = 50 , horizon:Int = 20, scale:Float = 1000 , obj_scale:Float = 50 , pmap:Int[1024*1024] 
Global cx

' Prepare something here, you can do alot here to improve it into a fun world, I think I will just put some text
For y=0 To 316 ; For x=0 To 475; map[x,y]=Rnd(127) ; Next ; Next ' This fills with garbage (uncomment line below if you want garbage)
For y=0 To 316 ; For x=0 To 475; map[x,y]=32 Next ; Next ' Clear the space

Global cmap[4096,4096] ; For y=0 To 316 ; For x=0 To 475; cmap[x,y]=5 ; Next ; Next
Global worldx,worldy,currentx ; Global cols[16] 
RestoreData colors 
For temp=0 To 15 ; ReadData cols[temp] ; Next

writetomap "                                        ",0,0
writetomap "    **** COMMODORE 64 BASIC V2 ****     ",0,1
writetomap "                                        ",0,2
writetomap " 64K RAM SYSTEM  38911 BASIC BYTES FREE ",0,3
writetomap "                                        ",0,4
writetomap "READY.                                  ",0,5
writetomap "                                        ",0,4
writetomap "----------------------------------- ",0,20

GLGraphics(xres,yres,0,60,GRAPHICS_BACKBUFFER | GRAPHICS_DEPTHBUFFER) 
glViewport(0,0,xres,yres) ; glMatrixMode(GL_PROJECTION) ; glLoadIdentity() ; glOrtho(0,xres,yres,0,0,1) ; glPixelZoom(1,-1) ; glRasterPos2i(0,0)

s=2
Global Current=79, current2=7
Global speed2:Int=1
spritex = 128+8*16 ; spritey = 128+8*16
Repeat
	For y=0 To yres-1 Step 1 ; For x=0 To xres-1 Step 1 ; pixels[(y*xres+x)] = 0 ; Next ; Next


If KeyDown(KEY_LSHIFT) Then worldx=worldx-s*KeyDown(KEY_LEFT)+s*KeyDown(KEY_RIGHT) ; worldy=worldy-s*KeyDown(KEY_UP)+s*KeyDown(KEY_DOWN)

    worldx=Max(0,Min(10000,worldx)) ; worldy=Max(0,Min(10000,worldy))

	'alive() ' This one makes things alive, comment it if you don´t want things changing in life. You bore.

	display(worldx,worldy,0,0,1024,768)
	
	' Show a moving sprite inside wthe world coordinatesystem
	drawsprite 30,spritex,spritey,worldx,worldy,0,0,16*80,16*50
	' spritex = spritex + 1 : spritey = spritey + 1
'	spritex=spritex-s*KeyDown(KEY_LEFT)+s*KeyDown(KEY_RIGHT) ; spritey=spritey-s*KeyDown(KEY_UP)+s*KeyDown(KEY_DOWN)













' -----------------------------------------------------------	
'
' Walking sprite
'

	wd = 0
If Not KeyDown(KEY_LSHIFT)
	If KeyDown(KEY_LEFT) Then wd = wd + 1
	If KeyDown(KEY_RIGHT) Then wd= wd + 2
	If KeyDown(KEY_UP) Then wd = wd + 4
	If KeyDown(KEY_DOWN) Then wd = wd + 8
EndIf

	Left1 = map((spritex-speed2)Shr 4,(spritey+0)Shr 4) ' the two interesting
	left2 = map((spritex-speed2)Shr 4,(spritey+15) Shr 4) ' hotspots for movement of left
	right1 = map((spritex+15+speed2)Shr 4,(spritey+0)Shr 4) ' same for..
    right2 = map((spritex+15+speed2)Shr 4,(spritey+15)Shr 4) ' right
    up1 = map((spritex+0)Shr 4,(spritey-speed2) Shr 4) ' same for..
    up2 = map((spritex+15)Shr 4,(spritey-speed2)Shr 4) ' up
    down1 = map((spritex+0)Shr 4,(spritey+15+speed2)Shr 4) ' same For..
    down2 = map((spritex+15)Shr 4,(spritey+15+speed2)Shr 4)' down 

	currenttile = map((spritex+8)/16,(spritey+8)/16) ' hotspot middle

	lefttile = map((spritex+8-16)/16,(spritey+8)/16)
	righttile = map((spritex+8+16)/16,(spritey+8)/16)
	bouldersleft = map((spritex+8-32)/16,(spritey+8)/16)
    bouldersright = map((spritex+8+32)/16,(spritey+8)/16)
		
	If wd &amp; 1 Then If left1 &lt; 33 And Left2 &lt; 33 Then spritex=spritex-speed2
	If wd &amp; 2 Then If right1 &lt; 33 And right2 &lt; 33 Then spritex=spritex+speed2
	If wd &amp; 4 Then If up1 &lt; 33 And up2 &lt; 33 Then spritey=spritey-speed2
	If wd &amp; 8 Then If down1 &lt; 33 And down2 &lt; 33 Then spritey=spritey+speed2

	' Should he e able to push a boulder only if TILE-LEVELLED? or inbetween tiles heightwise? if the latter then you need check TWO tiles on the boulder side, and also decide what to do do if TWO boudlers stackt ontop vertically exists, if he should move none one orb othg
	' So lets stick with TILE LEVELLED (meaning only ONE BOULDER IS CURRRENT)
	' AND MAKE o AND O BOTH BE BOULDER &lt;-- Work In Progress (making him less of antimagnetic man) abit odd boulder detection.
	temp2=temp2+1
	
	If temp2&gt;=16
	temp2=temp-16
	If left1 = 79 And left2 = 79 And bouldersleft = 32 Then If wd = 1 Then map((spritex+8-16)/16,(spritey+8)/16) = 32; map((spritex+8-32)/16,(spritey+8)/16) = 79 ; spritex = spritex - 16/2' move boulder left when possible
	If Right1 = 79 And right2 = 79 And bouldersright = 32 Then If wd = 2 Then map((spritex+8+16)/16,(spritey+8)/16) = 32; map((spritex+8+32)/16,(spritey+8)/16) = 79 ; spritex = spritex + 16/2' move boulder right when possible
    EndIf

    ' map((spritex+8)/16+Rnd(1)-Rnd(1),(spritey+8)/16+Rnd(1)-Rnd(1))=1 ; cmap((spritex+8)/16,(spritey+8)/16)=Rnd(14)+1 ' dig random
' -----------------------------------------------------------
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	



	glDrawPixels(xres,yres,GL_BGRA,GL_UNSIGNED_BYTE,Varptr(Pixels[0]))
	ddd=Ddd+1 ; If ddd = 4 Then boulders() ; ddd=0
	If KeyDown(49) Then Current=79 ; current2=7
    If KeyDown(50) Then Current=35 ; current2=8
    If KeyDown(51) Then Current=32 ; current2=7
    mx=MouseX()*6 ; my=MouseY()*6
	mx=mx/6 ; my=my/6 ; xxx=(worldx+mx) Sar 4 ; yyy=(worldy+my) Sar 4 
	If MouseDown(1) Then If map(xxx,yyy)&lt;&gt;79 And map(xxx,yyy)&lt;&gt;111 And map(xxx,yyy)&lt;&gt;112 Then map(xxx,yyy)=Current ; cmap(xxx,yyy)=current2
	Delay 1 ; Flip 1
Until MouseDown(2)
End

Function alive()
For temp=1 To 16 ; buffer[Int(Rand(0,15))+Int((Rand(0,15))*128)]=$ffffffff * Int(Rand(0,1)) ; Next
currentx=(currentx+1) Mod 128 ; For tempy=0 To 15 ; For temp=0 To 15+32
buffer[16+temp+((0+tempy)*128)]=buffer[0+temp+currentx+((16+tempy)*128)] ; Next ; Next ; For temp=1 To 1600 ; cmap[Rnd(400),Rnd(250)]=Rnd(16) ; Next
End Function

Function display(worldx,worldy,ofx=0,ofy=0,sx=640,sy=400) 
scrx=worldx &amp; 15 ; scry=worldy &amp; 15 ; mapx=worldx Shr 4 ; mapy=worldy Shr 4
cnty = 0 ; For y=mapy To mapy+((sy Shr 4)+1)
cntx = 0 ; For x=mapx To mapx+((sx Shr 4)+1)
tilex=map(x,y) &amp; 15 ; tiley=map(x,y) Shr 4
colour=cols(cmap(x,y))
xx=cntx - scrx + ofx ; yy=cnty - scry + ofy
For ty=0 To 7 ; For tx=0 To 7
If ((xx+tx+tx)=&gt;ofx) And ((yy+ty+ty)=&gt;ofy) And ((xx+tx+tx)&lt;(ofx+sx)) And ((yy+ty+ty)&lt;(ofy+sy))
If buffer[tilex Shl 3 + tx + (tiley Shl 3 + ty)*128] &lt;&gt; c Then pixels[xx+tx+tx + (yy+ty+ty)*xres] = colour 
EndIf
Next ; Next
cntx=cntx+16 ; Next
cnty=cnty+16 ; Next
End Function

Function boulders()
For y=100 To 0 Step -1 ; For x=0 To 100

If map(x,y)=79 ' BOULDER
     If map(x,y+1) = 32
        map(x,y) = 111
     ElseIf map(x,y+1) = 79 And map(x-1,y) = 32 And map(x-1,y+1) = 32
        map(x,y) = 32 ; map(x-1,y) = 111
     ElseIf map(x,y+1) = 79 And map(x+1,y) = 32 And map(x+1,y+1) = 32
        map(x,y) = 32 ; map(x+1,y) = 112 ' 111
    EndIf
EndIf

If map(x,y)=111 ' FALLINGBOULDER
     If map(x,y+1) = 32
        map(x,y)=32 ; map(x,y+1) = 111
     ElseIf map(x,y+1)=79 And map(x-1,y) = 32 And map(x-1,y+1) = 32
        map(x,y) = 32 ; map(x-1,y+0) = 111
     ElseIf map(x,y+1)=79 And map(x+1,y) = 32 And map(x+1,y+1) = 32
        map(x,y) = 32 ; map(x+1,y+0) = 112 ' 111
     Else
        map(x,y)=79
    EndIf
EndIf

If map(x,y)=112 Then map(x,y)=111 ' added

Next ; Next
End Function

Function writetomap(t$,x,y)
	For tempx=x To Len(t$)-1 ; temp=Asc(Mid$(t$,1+tempx,1)) ; map[tempx,y]=temp ; cmap[tempx,y]=14 ; Next 
End Function

Function drawsprite(sprite,xx,yy,worldx,worldy,ofx=0,ofy=0,sx=640,sy=400)
	xx=xx-worldx ; yy=yy-worldy ' xx,yy is now screen coordinates
	tilex=sprite &amp; 15 ; tiley=sprite Shr 4 ; colour=cols(1)
	For ty=0 To 7 ; For tx=0 To 7
	    If ((xx+tx+tx)=&gt;ofx) And ((yy+ty+ty)=&gt;ofy) And ((xx+tx+tx)&lt;(ofx+sx)) And ((yy+ty+ty)&lt;(ofy+sy))
		If buffer[tilex Shl 3 + tx + (tiley Shl 3 + ty)*128] &lt;&gt; c Then pixels[xx+tx+tx + (yy+ty+ty)*xres] = buffer[tilex Shl 3 + tx + (tiley Shl 3 + ty)*128] ; pixels[xx+tx+tx + 1 + (yy+ty+ty)*xres] = buffer[tilex Shl 3 + tx + (tiley Shl 3 + ty)*128]
	EndIf
	Next ; Next
End Function

#colors
DefData $000000, $FFFFFF,$68372B,$70A4B2,$6F3D86,$588D43,$352879,$B8C76F,$6F4F25,$433900,$9A6759,$444444,$6C6C6C,$9AD284,$6C5EB5,$959595
</textarea><br><br>I also did something akin towards a little game<br>press 3 and then you can erase trash and free his way (boulders are not eraseable)<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">' How to use
'
' Draw some boulders using the mouse
' Press 1, 2 or 3 to change tiles
'
' Move around inside the world using cursor keys


Global buffer:Int[256*256] ; Local img2:TPixmap=LoadPixmap(LoadBank("http::s9.postimg.org/rfaelk9m3/128x128.png"))  ' Load a 128x128 Atlas with 8x8 tiles
For yy=0 To 127 ; For xx=0 To 127 ; buffer(xx+yy*128) = ReadPixel(img2,xx,yy) ; Next ; Next
Global map[4096,4096] , wx:Int , wy:Int , c:Int = buffer[0] , s:Int = 2 , xres:Int = 1024 , yres:Int = 768 , pixels:Int[xres*yres]
Local a:Float = 0 , x:Float = 0 , y:Float = 0 , dx:Float = 0 , dy:Float = 0 , speed:Float = 0
Global space_z:Float = 50 , horizon:Int = 20, scale:Float = 1000 , obj_scale:Float = 50 , pmap:Int[1024*1024] 
Global cx

' Prepare something here, you can do alot here to improve it into a fun world, I think I will just put some text
For y=0 To 316 ; For x=0 To 475; map[x,y]=Rnd(127) ; Next ; Next ' This fills with garbage (uncomment line below if you want garbage)
'For y=0 To 316 ; For x=0 To 475; map[x,y]=32 Next ; Next ' Clear the space

Global cmap[4096,4096] ; For y=0 To 316 ; For x=0 To 475; cmap[x,y]=5 ; Next ; Next
Global worldx,worldy,currentx ; Global cols[16] 
RestoreData colors 
For temp=0 To 15 ; ReadData cols[temp] ; Next

writetomap "                                        ",0,0
writetomap "    **** COMMODORE 64 BASIC V2 ****     ",0,1
writetomap "                                        ",0,2
writetomap " 64K RAM SYSTEM  38911 BASIC BYTES FREE ",0,3
writetomap "                                        ",0,4
writetomap "READY.                                  ",0,5
writetomap "                                        ",0,4
writetomap "----------------------------------- ",0,20

GLGraphics(xres,yres,0,60,GRAPHICS_BACKBUFFER | GRAPHICS_DEPTHBUFFER) 
glViewport(0,0,xres,yres) ; glMatrixMode(GL_PROJECTION) ; glLoadIdentity() ; glOrtho(0,xres,yres,0,0,1) ; glPixelZoom(1,-1) ; glRasterPos2i(0,0)

s=2
Global Current=79, current2=7
Global speed2:Int=1
spritex = 128+8*16 ; spritey = 128+8*16
Repeat
	For y=0 To yres-1 Step 1 ; For x=0 To xres-1 Step 1 ; pixels[(y*xres+x)] = 0 ; Next ; Next


If KeyDown(KEY_LSHIFT) Then worldx=worldx-s*KeyDown(KEY_LEFT)+s*KeyDown(KEY_RIGHT) ; worldy=worldy-s*KeyDown(KEY_UP)+s*KeyDown(KEY_DOWN)

    worldx=Max(0,Min(10000,worldx)) ; worldy=Max(0,Min(10000,worldy))

	alive() ' This one makes things alive, comment it if you don´t want things changing in life. You bore.

	display(worldx,worldy,0,0,1024,768)
	
	' Show a moving sprite inside wthe world coordinatesystem
	drawsprite 30,spritex,spritey,worldx,worldy,0,0,16*80,16*50
	' spritex = spritex + 1 : spritey = spritey + 1
'	spritex=spritex-s*KeyDown(KEY_LEFT)+s*KeyDown(KEY_RIGHT) ; spritey=spritey-s*KeyDown(KEY_UP)+s*KeyDown(KEY_DOWN)













' -----------------------------------------------------------	
'
' Walking sprite
'

	wd = 0
If Not KeyDown(KEY_LSHIFT)
	If KeyDown(KEY_LEFT) Then wd = wd + 1
	If KeyDown(KEY_RIGHT) Then wd= wd + 2
	If KeyDown(KEY_UP) Then wd = wd + 4
	If KeyDown(KEY_DOWN) Then wd = wd + 8
EndIf

	Left1 = map((spritex-speed2)Shr 4,(spritey+0)Shr 4) ' the two interesting
	left2 = map((spritex-speed2)Shr 4,(spritey+15) Shr 4) ' hotspots for movement of left
	right1 = map((spritex+15+speed2)Shr 4,(spritey+0)Shr 4) ' same for..
    right2 = map((spritex+15+speed2)Shr 4,(spritey+15)Shr 4) ' right
    up1 = map((spritex+0)Shr 4,(spritey-speed2) Shr 4) ' same for..
    up2 = map((spritex+15)Shr 4,(spritey-speed2)Shr 4) ' up
    down1 = map((spritex+0)Shr 4,(spritey+15+speed2)Shr 4) ' same For..
    down2 = map((spritex+15)Shr 4,(spritey+15+speed2)Shr 4)' down 

	currenttile = map((spritex+8)/16,(spritey+8)/16) ' hotspot middle

	lefttile = map((spritex+8-16)/16,(spritey+8)/16)
	righttile = map((spritex+8+16)/16,(spritey+8)/16)
	bouldersleft = map((spritex+8-32)/16,(spritey+8)/16)
    bouldersright = map((spritex+8+32)/16,(spritey+8)/16)
		
	If wd &amp; 1 Then If left1 &lt; 33 And Left2 &lt; 33 Then spritex=spritex-speed2
	If wd &amp; 2 Then If right1 &lt; 33 And right2 &lt; 33 Then spritex=spritex+speed2
	If wd &amp; 4 Then If up1 &lt; 33 And up2 &lt; 33 Then spritey=spritey-speed2
	If wd &amp; 8 Then If down1 &lt; 33 And down2 &lt; 33 Then spritey=spritey+speed2

	' Should he e able to push a boulder only if TILE-LEVELLED? or inbetween tiles heightwise? if the latter then you need check TWO tiles on the boulder side, and also decide what to do do if TWO boudlers stackt ontop vertically exists, if he should move none one orb othg
	' So lets stick with TILE LEVELLED (meaning only ONE BOULDER IS CURRRENT)
	' AND MAKE o AND O BOTH BE BOULDER &lt;-- Work In Progress (making him less of antimagnetic man) abit odd boulder detection.
	temp2=temp2+1
	
	If temp2&gt;=16
	temp2=temp-16
	If left1 = 79 And left2 = 79 And bouldersleft = 32 Then If wd = 1 Then map((spritex+8-16)/16,(spritey+8)/16) = 32; map((spritex+8-32)/16,(spritey+8)/16) = 79 ; spritex = spritex - 16/2' move boulder left when possible
	If Right1 = 79 And right2 = 79 And bouldersright = 32 Then If wd = 2 Then map((spritex+8+16)/16,(spritey+8)/16) = 32; map((spritex+8+32)/16,(spritey+8)/16) = 79 ; spritex = spritex + 16/2' move boulder right when possible
    EndIf

    ' map((spritex+8)/16+Rnd(1)-Rnd(1),(spritey+8)/16+Rnd(1)-Rnd(1))=1 ; cmap((spritex+8)/16,(spritey+8)/16)=Rnd(14)+1 ' dig random
' -----------------------------------------------------------
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	



	glDrawPixels(xres,yres,GL_BGRA,GL_UNSIGNED_BYTE,Varptr(Pixels[0]))
	ddd=Ddd+1 ; If ddd = 4 Then boulders() ; ddd=0
	If KeyDown(49) Then Current=79 ; current2=7
    If KeyDown(50) Then Current=35 ; current2=8
    If KeyDown(51) Then Current=32 ; current2=7
    mx=MouseX()*6 ; my=MouseY()*6
	mx=mx/6 ; my=my/6 ; xxx=(worldx+mx) Sar 4 ; yyy=(worldy+my) Sar 4 
	If MouseDown(1) Then If map(xxx,yyy)&lt;&gt;79 And map(xxx,yyy)&lt;&gt;111 And map(xxx,yyy)&lt;&gt;112 Then map(xxx,yyy)=Current ; cmap(xxx,yyy)=current2
	Delay 1 ; Flip 1
Until MouseDown(2)
End

Function alive()
For temp=1 To 16 ; buffer[Int(Rand(0,15))+Int((Rand(0,15))*128)]=$ffffffff * Int(Rand(0,1)) ; Next
currentx=(currentx+1) Mod 128 ; For tempy=0 To 15 ; For temp=0 To 15+32
buffer[16+temp+((0+tempy)*128)]=buffer[0+temp+currentx+((16+tempy)*128)] ; Next ; Next ; For temp=1 To 1600 ; cmap[Rnd(400),Rnd(250)]=Rnd(16) ; Next
End Function

Function display(worldx,worldy,ofx=0,ofy=0,sx=640,sy=400) 
scrx=worldx &amp; 15 ; scry=worldy &amp; 15 ; mapx=worldx Shr 4 ; mapy=worldy Shr 4
cnty = 0 ; For y=mapy To mapy+((sy Shr 4)+1)
cntx = 0 ; For x=mapx To mapx+((sx Shr 4)+1)
tilex=map(x,y) &amp; 15 ; tiley=map(x,y) Shr 4
colour=cols(cmap(x,y))
xx=cntx - scrx + ofx ; yy=cnty - scry + ofy
For ty=0 To 7 ; For tx=0 To 7
If ((xx+tx+tx)=&gt;ofx) And ((yy+ty+ty)=&gt;ofy) And ((xx+tx+tx)&lt;(ofx+sx)) And ((yy+ty+ty)&lt;(ofy+sy))
If buffer[tilex Shl 3 + tx + (tiley Shl 3 + ty)*128] &lt;&gt; c Then pixels[xx+tx+tx + (yy+ty+ty)*xres] = colour 
EndIf
Next ; Next
cntx=cntx+16 ; Next
cnty=cnty+16 ; Next
End Function

Function boulders()
For y=100 To 0 Step -1 ; For x=0 To 100

If map(x,y)=79 ' BOULDER
     If map(x,y+1) = 32
        map(x,y) = 111
     ElseIf map(x,y+1) = 79 And map(x-1,y) = 32 And map(x-1,y+1) = 32
        map(x,y) = 32 ; map(x-1,y) = 111
     ElseIf map(x,y+1) = 79 And map(x+1,y) = 32 And map(x+1,y+1) = 32
        map(x,y) = 32 ; map(x+1,y) = 112 ' 111
    EndIf
EndIf

If map(x,y)=111 ' FALLINGBOULDER
     If map(x,y+1) = 32
        map(x,y)=32 ; map(x,y+1) = 111
     ElseIf map(x,y+1)=79 And map(x-1,y) = 32 And map(x-1,y+1) = 32
        map(x,y) = 32 ; map(x-1,y+0) = 111
     ElseIf map(x,y+1)=79 And map(x+1,y) = 32 And map(x+1,y+1) = 32
        map(x,y) = 32 ; map(x+1,y+0) = 112 ' 111
     Else
        map(x,y)=79
    EndIf
EndIf

If map(x,y)=112 Then map(x,y)=111 ' added

Next ; Next
End Function

Function writetomap(t$,x,y)
	For tempx=x To Len(t$)-1 ; temp=Asc(Mid$(t$,1+tempx,1)) ; map[tempx,y]=temp ; cmap[tempx,y]=14 ; Next 
End Function

Function drawsprite(sprite,xx,yy,worldx,worldy,ofx=0,ofy=0,sx=640,sy=400)
	xx=xx-worldx ; yy=yy-worldy ' xx,yy is now screen coordinates
	tilex=sprite &amp; 15 ; tiley=sprite Shr 4 ; colour=cols(1)
	For ty=0 To 7 ; For tx=0 To 7
	    If ((xx+tx+tx)=&gt;ofx) And ((yy+ty+ty)=&gt;ofy) And ((xx+tx+tx)&lt;(ofx+sx)) And ((yy+ty+ty)&lt;(ofy+sy))
		If buffer[tilex Shl 3 + tx + (tiley Shl 3 + ty)*128] &lt;&gt; c Then pixels[xx+tx+tx + (yy+ty+ty)*xres] = buffer[tilex Shl 3 + tx + (tiley Shl 3 + ty)*128] ; pixels[xx+tx+tx + 1 + (yy+ty+ty)*xres] = buffer[tilex Shl 3 + tx + (tiley Shl 3 + ty)*128]
	EndIf
	Next ; Next
End Function

#colors
DefData $000000, $FFFFFF,$68372B,$70A4B2,$6F3D86,$588D43,$352879,$B8C76F,$6F4F25,$433900,$9A6759,$444444,$6C6C6C,$9AD284,$6C5EB5,$959595
</textarea> <br><br></td></tr></table><br>
<a name="1298539"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> I see there's still movement issues that are not restored. I'll check later how I solved them or I would have to use my brain right now, that will never work.<br>It's pixel exact collision though when hes about changing direction (as in changing from x to y or the other) e.g. if there's a wall and suddenly there is an <br>opening in the other dimensional direction. That's a classic detail to miss. I'll fix that. <br><br>The boulder is a bigger problem becuase I don´t see ONE way yet, I see too many possible solutions I need to try. <br><br></td></tr></table><br>
<a name="1298559"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Wiebo</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here's a Boulderdash clone I've made some time ago. Maybe you can get some ideas from it's code: <a href="https://github.com/wiebow/boulderdash.game2d" target="_blank">https://github.com/wiebow/boulderdash.game2d</a> <br><br></td></tr></table><br>
<a name="1298617"></a>

<a name="1298626"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> I got into this tile collsiion thing yesterday, it was quiet while since I did that. I takes me back.<br><br>I guess I´m intersting in perfect tile collsion with various speeds without looping everything. <br>I would like to do that before adding angels etc on the tiles. And then comes AA rectangles I guess. But I want to try this first - square simple tiles and square simple sprites.<br><br>I thought I solved this over 30 years ago but I have to resolve it, I would really want to do it more elegantly this time.<br><br>If you want pixel perfect collision with moving objects at any speed (upto the tilesize). <br>Doing it without looping each possible substep is tricky.<br><br><img src="http://s12.postimg.org/475vdw83h/20160307_004344_001.jpg"><br><br>Say you moving an object 1 pixel to the left, while you move this direction you also want to go up in an upcoming tunnel.<br>That would work nicely, it would find its way. No problem. If we used tilesize (16) instead of 1 it would work equally nice, <br>if you started at offset of 0. Speeds of say 8, 4, or 2 Would work <br>equally nice for the same reasons and under the same circumstances.<br><br>But ither speeds (and offsets) would not. Say a speed of 5. That would miss that opportunity of this 1 tile wide tunnel if you had other <br>speed other than 1 or those special circumstances.<br><br>So, I set up 2 sensors one on each side of the object. If you're going up two upper sensors one at each corner and use them as a hotspot at a <br>predicted position (using +- current speed). So you're look ahead, where those two points will arrive. Air or Wall, and you do it on both sensors that's imporant. <br>All 4 directions works the same using 2 sensors laidout as you would expect.<br><br>If any sensor has wall then you have to tile-quantize the value (before any move has been applied using speed, we're just looking <br>ahead so that would be to quantized the current value) And the value would be either X or Y, depending on where you'trying to go. Up/Down or Left/right.<br><br>So that's good.<br><br>This would be like<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
l1 = map((spritex-speed2)Shr 4,(spritey+0)Shr 4) ' the two interesting
l2 = map((spritex-speed2)Shr 4,(spritey+15) Shr 4) ' hotspots for movement of left
r1 = map((spritex+15+speed2)Shr 4,(spritey+0)Shr 4) ' same for..
r2 = map((spritex+15+speed2)Shr 4,(spritey+15)Shr 4) ' right
u1 = map((spritex+0)Shr 4,(spritey-speed2) Shr 4) ' same for..
u2 = map((spritex+15)Shr 4,(spritey-speed2)Shr 4) ' up
d1 = map((spritex+0)Shr 4,(spritey+15+speed2)Shr 4) ' same For..
d2 = map((spritex+15)Shr 4,(spritey+15+speed2)Shr 4)' down 

' Key up
' if u1 = wall or u2 = wall then y=int(y/16)*16 (collisionspeed would be the difference)

' Key down
' if d1 = wall or d2 = wall then y=int(y/16)*16 (collisionspeed would be the difference)
	
' Key left
' if l1 = wall or l2 = wall then x=int(x/16)*16 (collisionspeed would be the difference)

' Key right
' if r1 = wall or r2 = wall then x=int(x/16)*16 (collisionspeed would be the difference)

' Previous pass used for pixel precision collision (speed handled is anything upto tilessize)
oldl1=l1 ; oldl2=l2 ; oldr1=r2 ; oldr2=r2 ; oldu1=u1 ; oldu2=u2 ; oldd1=d1 ; oldd2=d2

</textarea><br>So we could merge these into just two.<br><br>But one case is still needed and that's the one I mentioned and I tried to draw with my all too haky hands. Sorry about that. I tried me best.<br><br>To handle entering tile sized tunnels at speed greater than 1 you need to make something else aswell.<br><br>I got to this solution this time, and that is, using logic with the collision points. And to do logic I had to save the state of the <br>previous states aswell. Becuase the change is what is interesting. So we use the previous WALL/AIR state of those two, and logic between them. <br>Just as above but abit more complex.<br><br>I agree this seem overly complex, but I cannot seem to simplify this more and still have that exact detection. I really thought long about this.<br>I thought I´ve solved this long long time ago but I´m not sure, and if did I never did it this way but a simpler way.<br><br>But I don´t think I have those notes still with me, they are probably long gone. It´s an interesting problem though for me.<br>I´m not pleased with the complexity though. It's not too complex but still I feel there should be a better way I´m sure<br>I guess it's not that much when merge everything togerther and I will try that but that would get you a strange logic mess so <br>I better think well beforehand so it does not become more of a mess that it needs to be.<br><br>This is the logic that's needed<br>' aligning meaning tile-quantizing the value, and collisionspeed becomes the difference from that value and the original value.<br>' u1 and u2 are for instance the two sensores for going up, oldu1 and oldu2 are the previous states.<br><br>' It uses a clever logic of check and making sure we align the right dimension if the two are different. They can't be both AIR or both WALL then they <br>are uninteresting, and already taken cared of by the code above. We want to know when they are different, and when they are, we want to be sure that b<br>oth states where DIFFERENT inthemselves previously. Simply we're looking for    AIR AND WALL       (with previously WALL AND AIR)<br>or the other way around  WALL AND AIR   (with previosly AIR AND WALL).<br><br>If one those things happened then we know that we've passed a tile sized tunnel.<br>We only want to check this while actually moving in say x and want to go y direction. As the picture shows.<br><br>Imagine two points on that object at the top U1 (topleft) and U2 (topright). Think about the logic that happens (wall/air are true/false). <br>When you pass by that hole using different speeds. <br><br>Then you see why you want this AIR / WALL XOR pattern thing.<br><br>This is the code to do that (i can't find tilde right now, BMax I think uses tilde with 2 parameters as XOR) So I will try that later.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' Key left and right
' if (u1 xor oldu1 and u2 xor oldu2) or (d1 xor oldd1 and d2 xor oldd2) Then alignY (read collision speed from leftover)
	
' Key up and down
' if (l1 xor oldl1 and l2 xor oldl) or (r1 xor oldr1 and r1 xor oldr2) Then alignX (read collision speed from leftover)
</textarea> <br><br></td></tr></table><br>
<a name="1298618"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> My shaky hands, sorry about that. <br><br></td></tr></table><br>
<a name="1298621"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is how I would do it normally, using looping. Speeds ill be 1 (well anything really, 00000.01 would work, to max speed being whatever size of tile you´ve using).<br><br><br><a href="https://katyscode.wordpress.com/2013/01/18/2d-platform-games-collision-detection-for-dummies/" target="_blank">https://katyscode.wordpress.com/2013/01/18/2d-platform-games-collision-detection-for-dummies/</a> <br><br></td></tr></table><br>
<a name="1298637"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Casaber, you are welcome to make a Boulderdash classic design. You don't have to work with floating single pixels unless you want to. Instead make it on a grid and concentrate on how the objects would move on it.<br><br>Wiebo, thanks for the submit ! Hope this will help in the coding. <br><br></td></tr></table><br>
<a name="1298657"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Wiebo I couldn't not run that. I read the readme file and found it needs a .mod. I think that's the problem. I have not learned to install mod (I've tried few times and blew Bmax each time). Thanks though for trying and sharing.<br><br>Dw817 Maybe I'll try that sometime. I guess I just did this to learn how to use Bmax and tried to convert some old code. I think I leave both Boulderdash and subpixels for later. I would love to learn how to install a mod sometime, I really need to learn the tools. <br><br></td></tr></table><br>
<a name="1298749"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Wiebo</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> You can look at the code, and see how it also can be done. You don't need to compile it.<br>But here is a Monkey version, up and running in the browser: <a href="http://members.home.nl/wdw/monkey/bdtest/MonkeyGame.html" target="_blank">http://members.home.nl/wdw/monkey/bdtest/MonkeyGame.html</a><br><br>Mods aren't that complicated. The only thing I can say is that you're really over complicating matters in getting some basic BD logic going. :) <br><br></td></tr></table><br>
<a name="1298785"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Wiebo haha I know, I just love weird problems and sometimes I take a too deep dive. Sometimes it's actually fruitful and sometimes it goes like this. Oh well.<br><br>I'll think I´ll try adding a mod again, I would love to be able to do that kind of magic.<br>If it doesn't work I still have your code to look into as you said, thanks again.<br><br>I've bought Monkey1 to support all upcoming projects so I might try that aswell. <br><br></td></tr></table><br>
<a name="1298813"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sometime tomorrow, Casaber. I'll point out an example of where every object on the screen has its own identity.<br><br>And perhaps someone can show me a smaller way to code it as the method I will be using is likely not the most efficient. :) <br><br></td></tr></table><br>
<a name="1298912"></a>

<a name="1298913"></a>

<a name="1298921"></a>

<a name="1298926"></a>

<a name="1298927"></a>

<a name="1298928"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Okay, I´m curious to see what's that will be. I´m still struggling with the bloody collision :( I skipped the hard way, I can't seem to be able to solve it this evening.<br>My brain hurts. I'm sure I´ve solved this before but I can't see what I´m doing wrong right now. I got one screen worth of code just for the collision and still doesn't work.<br><br>Try to make it go into that 1 tile sized pit. It just won´t go there. <br><br>Most tile collision routines have nasty bugs and that's what I'm trying to avoid, or they use expansive loops to manage things. <br><br><pre class=code>
Global buffer:Int[256*256] ; Local img2:TPixmap=LoadPixmap(LoadBank("http::s9.postimg.org/rfaelk9m3/128x128.png"))
For yy=0 To 127 ; For xx=0 To 127 ; buffer(xx+yy*128) = ReadPixel(img2,xx,yy) ; Next ; Next
Global map[4096,4096] , wx:Int , wy:Int , c:Int = buffer[0] , s:Int = 2 , xres:Int = 640 , yres:Int = 480, pixels:Int[xres*yres]
Local a:Float = 0 , x:Float = 0 , y:Float = 0 , dx:Float = 0 , dy:Float = 0 , speed:Float = 0
Global space_z:Float = 50 , horizon:Int = 20, scale:Float = 1000 , obj_scale:Float = 50 , pmap:Int[1024*1024] 
Global cx ; For y=0 To 316 ; For x=0 To 475; map[x,y]=32 Next ; Next ' Clear the space

Global cmap[4096,4096] ; For y=0 To 316 ; For x=0 To 475; cmap[x,y]=5 ; Next ; Next
Global worldx,worldy,currentx ; Global cols[16] ; RestoreData colors ; For temp=0 To 15 ; ReadData cols[temp] ; Next
GLGraphics(xres,yres,0,60,GRAPHICS_BACKBUFFER | GRAPHICS_DEPTHBUFFER)
glViewport(0,0,xres,yres) ; glMatrixMode(GL_PROJECTION) ; glLoadIdentity() ; glOrtho(0,xres,yres,0,0,1) ; glPixelZoom(1,-1) ; glRasterPos2i(0,0)
s=2 ; Global Current=30, current2=7 ; Global speed2:Int=1 ; spritex = 128+8*16 ; spritey = 128+8*16

For x=13 To 25; map[x,13] = 30 ; Next ; For x=13 To 25; map[x,14]=30 ; Next ; map[20,14]=32
For y=0 To 24 ; map[0,y] = 30 ; map[39,y] = 30 ; Next ; For x=0 To 39; map[x,0]=30 ; map[x,24] = 30 ; Next
For temp = 0 To 30 ; map[Rand(0,39),Rand(0,24)] = 30 ; Next

Repeat
	For y=0 To yres-1 Step 1 ; For x=0 To xres-1 Step 1 ; pixels[(y*xres+x)] = 0 ; Next ; Next
	If KeyDown(KEY_LSHIFT) Then worldx=worldx-s*KeyDown(KEY_LEFT)+s*KeyDown(KEY_RIGHT) ; worldy=worldy-s*KeyDown(KEY_UP)+s*KeyDown(KEY_DOWN)
    worldx=Max(0,Min(10000,worldx)) ; worldy=Max(0,Min(10000,worldy))
	display(worldx,worldy,0,0,1024,768)
	drawsprite 30,spritex,spritey,worldx,worldy,0,0,16*80,16*50






' --------------------------------------------------------------------------------------------
' Collision

' Draw with mouse, change to eraser using 2 and back using 1
'
' Using 16 x 16 tiles and sprites

speed = 3
oldspritex = spritex ; oldspritey = spritey

' Read keys and create a mask for all 4 directions
wd = 0
If Not KeyDown(KEY_LSHIFT)
	If KeyDown(KEY_LEFT) Then wd = wd + 4
	If KeyDown(KEY_RIGHT) Then wd = wd + 8
	If KeyDown(KEY_UP) Then wd = wd + 1
	If KeyDown(KEY_DOWN) Then wd = wd + 2
EndIf

' For temptemp = 1 To speed
' oldspritex = spritex ; oldspritey = spritey

' Change X &amp; Y as wanted
If wd &amp; 4 Then spritex = spritex - speed ' 1
If wd &amp; 8 Then spritex = spritex + speed ' 1
If wd &amp; 1 Then spritey = spritey - speed ' 1
If wd &amp; 2 Then spritey = spritey + speed ' 1 

' Now check for collision

' Horisontal
' oldpx1 = px1 ; oldpx1=px2 ; oldpx3 = px3 ; oldpx4 = px4
px1 = map((spritex+0)Shr 4,(oldspritey+0) Shr 4) = 30 ' check for left (30 = wall, 32 = air)
px2 = map((spritex+0)Shr 4,(oldspritey+15) Shr 4) = 30 ' check for left
px3 = map((spritex+15)Shr 4,(oldspritey+0) Shr 4) = 30 '  check for right
px4 = map((spritex+15)Shr 4,(oldspritey+15) Shr 4) = 30 ' check for right

' Vertical
' oldypy1 = py1 ; oldpy1=py2 ; oldpy3 = py3 ; oldpy4 = py4
py1 = map((oldspritex+0)Shr 4,(spritey+0) Shr 4) = 30 ' check for up
py2 = map((oldspritex+0)Shr 4,(spritey+15) Shr 4) = 30 ' check for down
py3 = map((oldspritex+15)Shr 4,(spritey+0) Shr 4) = 30 ' check for up
py4 = map((oldspritex+15)Shr 4,(spritey+15) Shr 4) = 30 ' check for down

' Horisontal
If wd &amp; 4 Then If px1 Or px2 Then spritex = Int((spritex+0)/16)*16 + 16
If wd &amp; 8 Then If px3 Or px4 Then spritex = Int((spritex+15)/16)*16 - 16
' If wd &amp; 4 Or wd &amp; 8 Then If (py1 ~ oldpy1 And py3 ~ oldpy3) Or (py2 ~ oldpy2 And py4 ~ oldpy4) Then spritey = Int((spritey+0)/16)*16

' Vertical
If wd &amp; 1 Then If py1 Or py3 Then spritey = Int((spritey+0)/16)*16 + 16
If wd &amp; 2 Then If py2 Or py4 Then spritey = Int((spritey+15)/16)*16 - 16
' If wd &amp; 1 Or wd &amp; 2 Then If (px1 ~ oldpx1 And px2 ~ oldpx2) Or (px3 ~ oldpx3 And px4 ~ oldpx4) Then spritex = Int((spritex+0)/16)*16

' Next
writenumber(spritex,0,1)

' --------------------------------------------------------------------------------------------










	glDrawPixels(xres,yres,GL_BGRA,GL_UNSIGNED_BYTE,Varptr(Pixels[0]))
	If KeyDown(49) Then Current=30
    If KeyDown(50) Then Current=32
    mx=MouseX()*6 ; my=MouseY()*6
	mx=mx/6 ; my=my/6 ; xxx=(worldx+mx) Sar 4 ; yyy=(worldy+my) Sar 4 
	If MouseDown(1) Then map(xxx,yyy)=Current ; cmap(xxx,yyy)=5
	Delay 1 ; Flip 1
Until MouseDown(2)
End

Function display(worldx,worldy,ofx=0,ofy=0,sx=640,sy=400) 
	scrx=worldx &amp; 15 ; scry=worldy &amp; 15 ; mapx=worldx Shr 4 ; mapy=worldy Shr 4
	cnty = 0 ; For y=mapy To mapy+((sy Shr 4)+1)
	cntx = 0 ; For x=mapx To mapx+((sx Shr 4)+1)
	tilex=map(x,y) &amp; 15 ; tiley=map(x,y) Shr 4
	colour=cols(cmap(x,y))
	xx=cntx - scrx + ofx ; yy=cnty - scry + ofy
	For ty=0 To 7 ; For tx=0 To 7
		If ((xx+tx+tx)=&gt;ofx) And ((yy+ty+ty)=&gt;ofy) And ((xx+tx+tx)&lt;(ofx+sx)) And ((yy+ty+ty)&lt;(ofy+sy))
		If buffer[tilex Shl 3 + tx + (tiley Shl 3 + ty)*128] &lt;&gt; c Then pixels[xx+tx+tx + (yy+ty+ty)*xres] = colour 
	EndIf
	Next ; Next
	cntx=cntx+16 ; Next
	cnty=cnty+16 ; Next
End Function

Function drawsprite(sprite,xx,yy,worldx,worldy,ofx=0,ofy=0,sx=640,sy=400)
	xx=xx-worldx ; yy=yy-worldy ' xx,yy is now screen coordinates
	tilex=sprite &amp; 15 ; tiley=sprite Shr 4 ; colour=cols(1)
	For ty=0 To 7 ; For tx=0 To 7
	    If ((xx+tx+tx)=&gt;ofx) And ((yy+ty+ty)=&gt;ofy) And ((xx+tx+tx)&lt;(ofx+sx)) And ((yy+ty+ty)&lt;(ofy+sy))
		If buffer[tilex Shl 3 + tx + (tiley Shl 3 + ty)*128] &lt;&gt; c Then pixels[xx+tx+tx + (yy+ty+ty)*xres] = buffer[tilex Shl 3 + tx + (tiley Shl 3 + ty)*128] ; pixels[xx+tx+tx + 1 + (yy+ty+ty)*xres] = buffer[tilex Shl 3 + tx + (tiley Shl 3 + ty)*128]
	EndIf
	Next ; Next
End Function

Function writenumber(v,x,y) ' handles -9999 to 9999
	If v &lt; 0 Then sign = True ; x = x + 1 ; v = Abs(v) Else sign = False
	numbase = 48 ' ASCII for 0
	
	digits = 1
	thousands = Int ( v / 1000)
	hundreds = Int ((v - thousands * 1000) / 100) 
	tens = Int ((v - thousands * 1000 - hundreds * 100)  / 10)
	units = Int v - thousands * 1000 - hundreds * 100 - tens * 10

	If tens &lt;&gt; 0 Then digits = 2
	If hundreds &lt;&gt; 0 Then digits = 3
	If thousands &lt;&gt; 0 Then digits = 4

	x=x+digits-1
	map(x,y) = numbase + units ; ; cmap(x,y) = 1 ; x = x - 1 
	If digits &gt;= 2 Then map(x,y) = numbase + tens ; ; cmap(x,y) = 1; x = x - 1
	If digits &gt;= 3 Then map(x,y) = numbase + hundreds ; ; cmap(x,y) = 1 ; x = x - 1
    If digits &gt;= 4 Then map(x,y) = numbase + thousands ; cmap(x,y) = 1 ; x = x - 1 
	If sign Then map(x,y) = 45 ; cmap(x,y) = 1
End Function

#colors
DefData $000000, $FFFFFF,$68372B,$70A4B2,$6F3D86,$588D43,$352879,$B8C76F,$6F4F25,$433900,$9A6759,$444444,$6C6C6C,$9AD284,$6C5EB5,$959595
</pre> <br><br></td></tr></table><br>
<a name="1298929"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Pretty nifty, Casaber. I noticed the player cannot slide diagonally (up and right arrow key) to fit into the reverse U opening you made in the map.<br><br>How would you change your code so it can do this ?<br><br>Sliding elsewhere (diagonal keys) against a solid object work great, however. It doesn't stop the player and the player keeps moving in the only direction it can until the map changes. <br><br></td></tr></table><br>
<a name="1298951"></a>

<a name="1298952"></a>

<a name="1298953"></a>

<a name="1298954"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well that's my problem. I´m not sure if I should change the technique dramatically, but if I may solve this then this is a cheap collision for strict 90 degree tilemaps. Cheaper than pure vector collision when you add slopes and simplify it abit. When the bug is out of the way. <br><br>Horisontal collision works flawlessly on its own, and vertical aswell, As long as you do one way or the other there's no problem but when you combine them it breaks down.<br>I would like to keep out special cases of diagnoal movement..<br><br>So far I use the oldspritex &amp; oldspritey variables To still keep the dimensions separate in the actual tests, but something's missing.<br>I´m not sure what direction to make but I think I'll stick to this and try solve this.. or I'll have nightmares becuase it bugs the hell out of me haha. Ya I know.. nerdy. I confess. <br><br></td></tr></table><br>
<a name="1298963"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> One easy result I am seeing of this diagonal collision, Casaber, is that the player bounces about a bit. If you think it's too much work to determine the diagonal, be aware of when the player gets caught in this bounce and then move towards the path of least resistance.<br><br>What you are doing here is a bit of work, granted. I know back in QBasic I was working on making a solid square navigate neatly and diagonally around other hollow squares on the screen. Lots of coding.<br><br>Remember - you also have the unique collision() function available in BlitzMAX if you don't mind collisions detected at a pixel level. <br><br></td></tr></table><br>
<a name="1298979"></a>

<a name="1298980"></a>

<a name="1298981"></a>

<a name="1298982"></a>

<a name="1298983"></a>

<a name="1298985"></a>

<a name="1298986"></a>

<a name="1298988"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> You could do what NES Zelda did aswell, (it remembers the x direction and y direction, and when you move in x and the other say y is not perfectly aligned to the tiles, then for each move in x it actually also makes a move in y. Link sneaks into alignment.<br><br>This way you feel very free and never get stuck anywhere and helps to aim at enemeys and makes it very friendly. It's a nice solution.<br><br>It's pretty much as you said but it aims towards into a natural path. But I think randomised is a must at perfect 45 angles though. <br>Becuase when you have no 90 degrees walls but you do have a 45 degreee wall and just HAPPEN to go into that using a perfect diagonal then actually <br>you get a shaking player, as x and y alternates of being winning the path. I wouldn't call that a bug yet its related to this problem I think. <br><br></td></tr></table><br>
<a name="1298991"></a>

<a name="1298992"></a>

<a name="1298993"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> But I really want to do this clinica collision, i know I've done it at least 2 times in my life, but I cannot remember what I did, <br><br>I'm not even sure if I've missed any details like this but I don´t think so, as it was a big deal back then aswell. I put lot of weeks on to solve it.<br>More than you should put into anything not important in life haha. <br>But seriously. It's so frustrating.  <br><br>Coding.. you can't live with it you can't live without it. <br><br></td></tr></table><br>
<a name="1299020"></a>

<a name="1299021"></a>

<a name="1299022"></a>

<a name="1299023"></a>

<a name="1299024"></a>

<a name="1299025"></a>

<a name="1299026"></a>

<a name="1299027"></a>

<a name="1299030"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> I reached this now, it has a few lines of code to diagonal special case and loop, not what I want  but if anyone wants it. Be my guest :)<br>Hopefully soon I will have a more elegant code.<br><br>Mind that this is WIP and middle of everything. It's not finished polished code. But it is stable. Just sharing what I have that works.<br><br>Try build a diagonal without supporting 90 degrees walls and approach that tile perfectly diagnoally using a / b key and you see the "shakey bug" <br>where it cannot decide where to go, it alternates between x &amp; y. Other than this it works (this wobblyness is replaced with <br>another nasty effect when you use full tile speed of 16)<br><br>EDIT<br>I have a vauge memory of solving this using few lines and MOD, but sadly I can't remember exactly how I did it,<br>It's always interesting trying new approaches I guess, but this is kind of clumpsy in all it's trickery glory.<br><br><pre class=code>
' Stream some background music
Import MaxGui.Drivers
Local window:TGadget , mainview:tgadget , htmlview:tgadget

Global buffer:Int[256*256] ; Local img2:TPixmap=LoadPixmap(LoadBank("http::s9.postimg.org/rfaelk9m3/128x128.png"))
For yy=0 To 127 ; For xx=0 To 127 ; buffer(xx+yy*128) = ReadPixel(img2,xx,yy) ; Next ; Next
Global map[4096,4096] , wx:Int , wy:Int , c:Int = buffer[0] , s:Int = 2 , xres:Int = 640 , yres:Int = 480, pixels:Int[xres*yres]
Local a:Float = 0 , x:Float = 0 , y:Float = 0 , dx:Float = 0 , dy:Float = 0 , speed:Float = 0
Global space_z:Float = 50 , horizon:Int = 20, scale:Float = 1000 , obj_scale:Float = 50 , pmap:Int[1024*1024] 
Global cx ; For y=0 To 316 ; For x=0 To 475; map[x,y]=32 Next ; Next ' Clear the space

Global cmap[4096,4096] ; For y=0 To 316 ; For x=0 To 475; cmap[x,y]=5 ; Next ; Next
Global worldx,worldy,currentx ; Global cols[16] ; RestoreData colors ; For temp=0 To 15 ; ReadData cols[temp] ; Next
GLGraphics(xres,yres,0,60,GRAPHICS_BACKBUFFER | GRAPHICS_DEPTHBUFFER)
glViewport(0,0,xres,yres) ; glMatrixMode(GL_PROJECTION) ; glLoadIdentity() ; glOrtho(0,xres,yres,0,0,1) ; glPixelZoom(1,-1) ; glRasterPos2i(0,0)
s=2 ; Global Current=30, current2=7 ; Global speed2:Int=1 ; spritex = 128+8*16 ; spritey = 128+8*16

For x=13 To 25; map[x,13] = 30 ; Next ; For x=13 To 25; map[x,14]=30 ; Next ; map[20,14]=32
For y=0 To 24 ; map[0,y] = 30 ; map[39,y] = 30 ; Next ; For x=0 To 39; map[x,0]=30 ; map[x,24] = 30 ; Next
For temp = 0 To 30 ; map[Rand(0,39),Rand(0,24)] = 30 ; Next

intro = worldy+25*16
worldy = intro
Repeat
	For y=0 To yres-1 Step 1 ; For x=0 To xres-1 Step 1 ; pixels[(y*xres+x)] = 0 ; Next ; Next
	If KeyDown(KEY_LSHIFT) Then worldx=worldx-s*KeyDown(KEY_LEFT)+s*KeyDown(KEY_RIGHT) ; worldy=worldy-s*KeyDown(KEY_UP)+s*KeyDown(KEY_DOWN)
    worldx=Max(0,Min(10000,worldx)) ; worldy=Max(0,Min(10000,worldy))
	display(worldx,worldy,0,0,640,480)
	drawsprite 30,spritex,spritey,worldx,worldy,0,0,16*80,16*50


If intro &gt; 0 intro = intro - 2 ; worldy = intro
If intro = 0 Then window=CreateWindow("",0,0,0,0,,0) ; htmlview=CreateHTMLView(0,0,0,0,window) ; HtmlViewGo htmlview,"http://bit.ly/22Cv21e" ; intro = -1 ' Dw817's nice stream music trick

writetomap("[Shift] to scroll inside world",8,0,1)
writetomap("1 and 2 - draw and erase using mouse",2,24,1)






' --------------------------------------------------------------------------------------------
' Collision

' Draw with mouse, change to eraser using 2 and back using 1
'
' Using 16 x 16 tiles and sprites

speed = 3
oldspritex = spritex ; oldspritey = spritey

' Read keys and create a mask for all 4 directions
wd = 0
If Not KeyDown(KEY_LSHIFT)
	If KeyDown(KEY_LEFT) Then wd = wd + 4
	If KeyDown(KEY_RIGHT) Then wd = wd + 8
	If KeyDown(KEY_UP) Then wd = wd + 1
	If KeyDown(KEY_DOWN) Then wd = wd + 2
EndIf

If KeyDown(KEY_A) Then wd = 8 + 1 ' test diagnally movement with a..
If KeyDown(KEY_B) Then wd = 4 + 2 ' ..and b

' Change X &amp; Y as wanted
If wd &amp; 4 Then spritex = spritex - speed
If wd &amp; 8 Then spritex = spritex + speed
If wd &amp; 1 Then spritey = spritey - speed
If wd &amp; 2 Then spritey = spritey + speed 

' Now check for collision

' Horisontal
' oldpx1 = px1 ; oldpx2=px2 ; oldpx3 = px3 ; oldpx4 = px4
px1 = map((spritex+0)Shr 4,(oldspritey+0) Shr 4) = 30 ' check for left (30 = wall, 32 = air)
px2 = map((spritex+0)Shr 4,(oldspritey+15) Shr 4) = 30 ' check for left
px3 = map((spritex+15)Shr 4,(oldspritey+0) Shr 4) = 30 '  check for right
px4 = map((spritex+15)Shr 4,(oldspritey+15) Shr 4) = 30 ' check for right

' Vertical
' oldpy1 = py1 ; oldpy2=py2 ; oldpy3 = py3 ; oldpy4 = py4
py1 = map((oldspritex+0)Shr 4,(spritey+0) Shr 4) = 30 ' check for up
py2 = map((oldspritex+0)Shr 4,(spritey+15) Shr 4) = 30 ' check for down
py3 = map((oldspritex+15)Shr 4,(spritey+0) Shr 4) = 30 ' check for up
py4 = map((oldspritex+15)Shr 4,(spritey+15) Shr 4) = 30 ' check for down

orgspritex = spritex ; orgspritey = spritey
diagonal = False

For temptemp = speed To 1 Step -1

' Diagonal
pxy1 = map((spritex+0)Shr 4,(spritey+0) Shr 4) = 30
pxy2 = map((spritex+0)Shr 4,(spritey+15) Shr 4) = 30
pxy3 = map((spritex+15)Shr 4,(spritey+0) Shr 4) = 30
pxy4 = map((spritex+15)Shr 4,(spritey+15) Shr 4) = 30

' Diagonal (first thing that needs to be tried)
If wd = (4 + 1) Then If (pxy1 + pxy2 + pxy3 + pxy4) = 0 Then diagonal = True ' spritex = Int((spritex+0)/16)*16 + 16
If wd = (4 + 2) Then If (pxy1 + pxy2 + pxy3 + pxy4) = 0 Then diagonal = True ' spritex = Int((spritex+0)/16)*16 + 16
If wd = (8 + 1) Then If (pxy1 + pxy2 + pxy3 + pxy4) = 0 Then diagonal = True ' spritex = Int((spritex+0)/16)*16 + 16
If wd = (8 + 2) Then If (pxy1 + pxy2 + pxy3 + pxy4) = 0 Then diagonal = True ' spritex = Int((spritex+0)/16)*16 + 16

If diagonal = False
	If wd &amp; 4 Then spritex = spritex + 1
	If wd &amp; 8 Then spritex = spritex - 1
	If wd &amp; 1 Then spritey = spritey + 1
	If wd &amp; 2 Then spritey = spritey - 1
EndIf

Next

If diagonal = False

spritex = orgspritex ; spritey = orgspritey

' Horisontal
If wd &amp; 4 Then If px1 Or px2 Then spritex = Int((spritex+0)/16)*16 + 16 ' spritex = spritex - spritex Mod 16
If wd &amp; 8 Then If px3 Or px4 Then spritex = Int((spritex+15)/16)*16 - 16 ' spritex = spritex - spritex mod 16
' If wd &amp; 4 Or wd &amp; 8 Then If (py1 ~ oldpy1 And py3 ~ oldpy3) Or (py2 ~ oldpy2 And py4 ~ oldpy4) Then spritey = Int((spritey+0)/16)*16

' Vertical
If wd &amp; 1 Then If py1 Or py3 Then spritey = Int((spritey+0)/16)*16 + 16 ' spritey = spritey mod 16
If wd &amp; 2 Then If py2 Or py4 Then spritey = Int((spritey+15)/16)*16 - 16 ' spritey = spritey mod 16
' If wd &amp; 1 Or wd &amp; 2 Then If (px1 ~ oldpx1 And px2 ~ oldpx2) Or (px3 ~ oldpx3 And px4 ~ oldpx4) Then spritex = Int((spritex+0)/16)*16

EndIf

writenumber(spritex,0,1)

' --------------------------------------------------------------------------------------------















	glDrawPixels(xres,yres,GL_BGRA,GL_UNSIGNED_BYTE,Varptr(Pixels[0]))
	If KeyDown(49) Then Current=30
    If KeyDown(50) Then Current=32
    mx=MouseX()*6 ; my=MouseY()*6
	mx=mx/6 ; my=my/6 ; xxx=(worldx+mx) Sar 4 ; yyy=(worldy+my) Sar 4 
	If MouseDown(1) Then map(xxx,yyy)=Current ; cmap(xxx,yyy)=5
	Delay 1 ; Flip 1
Until False 'MouseDown(2)
End

Function display(worldx,worldy,ofx=0,ofy=0,sx=640,sy=400) 
	scrx=worldx &amp; 15 ; scry=worldy &amp; 15 ; mapx=worldx Shr 4 ; mapy=worldy Shr 4
	cnty = 0 ; For y=mapy To mapy+((sy Shr 4)+1)
	cntx = 0 ; For x=mapx To mapx+((sx Shr 4)+1)
	tilex=map(x,y) &amp; 15 ; tiley=map(x,y) Shr 4
	colour=cols(cmap(x,y))
	xx=cntx - scrx + ofx ; yy=cnty - scry + ofy
	For ty=0 To 7 ; For tx=0 To 7
		If ((xx+tx+tx)=&gt;ofx) And ((yy+ty+ty)=&gt;ofy) And ((xx+tx+tx)&lt;(ofx+sx)) And ((yy+ty+ty)&lt;(ofy+sy))
		If buffer[tilex Shl 3 + tx + (tiley Shl 3 + ty)*128] &lt;&gt; c Then pixels[xx+tx+tx + (yy+ty+ty)*xres] = colour 
	EndIf
	Next ; Next
	cntx=cntx+16 ; Next
	cnty=cnty+16 ; Next
End Function

Function drawsprite(sprite,xx,yy,worldx,worldy,ofx=0,ofy=0,sx=640,sy=400)
	xx=xx-worldx ; yy=yy-worldy ' xx,yy is now screen coordinates
	tilex=sprite &amp; 15 ; tiley=sprite Shr 4 ; colour=cols(1)
	For ty=0 To 7 ; For tx=0 To 7
	    If ((xx+tx+tx)=&gt;ofx) And ((yy+ty+ty)=&gt;ofy) And ((xx+tx+tx)&lt;(ofx+sx)) And ((yy+ty+ty)&lt;(ofy+sy))
		If buffer[tilex Shl 3 + tx + (tiley Shl 3 + ty)*128] &lt;&gt; c Then pixels[xx+tx+tx + (yy+ty+ty)*xres] = buffer[tilex Shl 3 + tx + (tiley Shl 3 + ty)*128] ; pixels[xx+tx+tx + 1 + (yy+ty+ty)*xres] = buffer[tilex Shl 3 + tx + (tiley Shl 3 + ty)*128]
	EndIf
	Next ; Next
End Function

Function writetomap(t$,x,y,c)
	For tempx = 0 To Len(t$)-1 ; temp = Asc(Mid$(t$,1+tempx,1)) ; map[tempx+x,y] = temp ; cmap[tempx+x,y] = c ; Next
End Function

Function writenumber(v,x,y) ' handles -9999 to 9999
	
	For digits = 5 To 1 Step -1 ; map(x+digits-1,y) = 32 ; Next ' erase area
	
	If v &lt; 0 Then sign = True ; x = x + 1 ; v = Abs(v) Else sign = False
	numbase = 48 ' ASCII for 0
	
	digits = 1
	thousands = Int ( v / 1000)
	hundreds = Int ((v - thousands * 1000) / 100) 
	tens = Int ((v - thousands * 1000 - hundreds * 100)  / 10)
	units = Int v - thousands * 1000 - hundreds * 100 - tens * 10

	If tens &lt;&gt; 0 Then digits = 2
	If hundreds &lt;&gt; 0 Then digits = 3
	If thousands &lt;&gt; 0 Then digits = 4

	x=x+digits-1
	map(x,y) = numbase + units ; ; cmap(x,y) = 1 ; x = x - 1 
	If digits &gt;= 2 Then map(x,y) = numbase + tens ; ; cmap(x,y) = 1; x = x - 1
	If digits &gt;= 3 Then map(x,y) = numbase + hundreds ; ; cmap(x,y) = 1 ; x = x - 1
    If digits &gt;= 4 Then map(x,y) = numbase + thousands ; cmap(x,y) = 1 ; x = x - 1 
	If sign Then map(x,y) = 45 ; cmap(x,y) = 1
End Function

#colors
DefData $000000, $FFFFFF,$68372B,$70A4B2,$6F3D86,$588D43,$352879,$B8C76F,$6F4F25,$433900,$9A6759,$444444,$6C6C6C,$9AD284,$6C5EB5,$959595
</pre> <br><br></td></tr></table><br>
<a name="1299106"></a>

<a name="1299107"></a>

<a name="1299108"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just toying around.. <br>This is for the ones who like a small puzzle.<br><br>Welcome.. to messy world. <br><br>Try finding the easteregg without glancing at the code :)<br><br><img src="http://s7.postimg.org/ucsodf6rf/findit.png"><br><br>I have decided to not yet make boulders pushing collsion, as I want to perfect the collision first. I got some ideas, <br>5 actually, some are overlapping so I want to explore that area. Abit exciting.I woke up and was all clear in my mind. How unusual.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

' Stream some background music
Import MaxGui.Drivers
Local window:TGadget , mainview:tgadget , htmlview:tgadget

Global buffer:Int[256*256] ; Local img2:TPixmap=LoadPixmap(LoadBank("http::s9.postimg.org/rfaelk9m3/128x128.png"))
For yy=0 To 127 ; For xx=0 To 127 ; buffer(xx+yy*128) = ReadPixel(img2,xx,yy) ; Next ; Next
Global map[4096,4096] , wx:Int , wy:Int , c:Int = buffer[0] , s:Int = 2 , xres:Int = 640 , yres:Int = 480, pixels:Int[xres*yres]
Local a:Float = 0 , x:Float = 0 , y:Float = 0 , dx:Float = 0 , dy:Float = 0 , speed:Float = 0
Global space_z:Float = 50 , horizon:Int = 20, scale:Float = 1000 , obj_scale:Float = 50 , pmap:Int[1024*1024] 
Global cx ; For y=0 To 316 ; For x=0 To 475; map[x,y]=32 Next ; Next ' Clear the space

Global cmap[4096,4096] ; For y=0 To 316 ; For x=0 To 475; cmap[x,y]=5 ; Next ; Next
Global worldx,worldy,currentx ; Global cols[16] ; RestoreData colors ; For temp=0 To 15 ; ReadData cols[temp] ; Next
GLGraphics(xres,yres,0,60,GRAPHICS_BACKBUFFER | GRAPHICS_DEPTHBUFFER)
glViewport(0,0,xres,yres) ; glMatrixMode(GL_PROJECTION) ; glLoadIdentity() ; glOrtho(0,xres,yres,0,0,1) ; glPixelZoom(1,-1) ; glRasterPos2i(0,0)
s=2 ; Global Current=30, current2=7 ; Global speed2:Int=1 ; spritex = 128+8*16 ; spritey = 128+8*16

For x=13 To 25; map[x,13] = 30 ; Next ; For x=13 To 25; map[x,14]=30 ; Next ; map[20,14]=32
For y=0 To 24 ; map[0,y] = 30 ; map[39,y] = 30 ; Next ; For x=0 To 39; map[x,0]=30 ; map[x,24] = 30 ; Next
For temp = 0 To 30 ; map[Rand(0,39),Rand(0,24)] = 30 ; Next

intro = worldy+25*16
worldy = intro

' For y=0 To 316 ; For x=0 To 475; map[x,y]=Rnd(127) ; Next ; Next
' For y=0 To 316 ; For x=0 To 475; cmap[x,y]=Rnd(15) ; Next ; Next

'For y = 10 To 30 ; For x=50 To 60; map[x,y]=70 ; Next ; Next
For x = 50 To 60 ; For y=10 To 12 ; map[x,y] = 30 ; Next ; Next
For x = 0 To 16 ; For y=2 To 4 ; map[x,y] = x ; Next ; Next

' For temp = 0 To 127 ; map(2,temp) = temp ; Next

' Current=79
' if KeyDown(49) Then Current=79 ; current2=7
' If KeyDown(50) Then Current=17 ; current2=8
' MAKE CORRECT GROUND AND ALLOW BOUDLERS

writetomap("[Shift] to scroll inside world",8,0,1)
writetomap("1 and 2 - draw and erase using mouse",2,24,1)
writetomap("N  t",15,21,1)
writetomap("Broken",15,22,1)

writetomap("Oh, The things ",50,18,1)
writetomap("we see when we stoP looking..  ",50,20,1)
writetomap("-------------------------------- ",50,21,1)
writetomap("-------------------------------- ",50,22,1)

'spritex=spritex + 16 + 16
'spritey = spritey -3*16
 'map[x,y] = x ;  map[x,y] = x

Repeat
	For y=0 To yres-1 Step 1 ; For x=0 To xres-1 Step 1 ; pixels[(y*xres+x)] = 0 ; Next ; Next
	If KeyDown(KEY_LSHIFT) Then worldx=worldx-s*KeyDown(KEY_LEFT)+s*KeyDown(KEY_RIGHT) ; worldy=worldy-s*KeyDown(KEY_UP)+s*KeyDown(KEY_DOWN)
    worldx=Max(0,Min(10000,worldx)) ; worldy=Max(0,Min(10000,worldy))
	'If MouseDown(1) Then map(17,22)=79 ; map(34,24)=79 
	If map(17,22) = 79 And map(34,24) = 79 Then writetomap("Easterregg !! ",8,8,2) ; easteregg = True
	alive()
	ddd=Ddd+1 ; If ddd = 4 Then boulders() ; ddd=0
	ddd2 = ddd2 + 1 ; If ddd2 = 10 Then ddd2 = 0 ; If easteregg = True tempx = Rand(1,38) ; tempy = Rand(1,24) ; map(tempx,tempy) = 79' ; cmap(tempx,tempy)=2 
	display(worldx,worldy,0,0,640,480)
	drawsprite 30,spritex,spritey,worldx,worldy,0,0,16*80,16*50

If intro &gt; 0 intro = intro - 2 ; worldy = intro
If intro = 0 Then window=CreateWindow("",0,0,0,0,,0) ; htmlview=CreateHTMLView(0,0,0,0,window) ; HtmlViewGo htmlview,"http://bit.ly/22Cv21e" ; intro = -1 ' Dw817's nice stream music trick







' --------------------------------------------------------------------------------------------
' Collision

' Draw with mouse, change to eraser using 2 and back using 1
'
' Using 16 x 16 tiles and sprites

speed = 3
oldspritex = spritex ; oldspritey = spritey

' Read keys and create a mask for all 4 directions
wd = 0
If Not KeyDown(KEY_LSHIFT)
	If KeyDown(KEY_LEFT) Then wd = wd + 4
	If KeyDown(KEY_RIGHT) Then wd = wd + 8
	If KeyDown(KEY_UP) Then wd = wd + 1
	If KeyDown(KEY_DOWN) Then wd = wd + 2
EndIf

If KeyDown(KEY_A) Then wd = 8 + 1 ' test diagnally movement with a..
If KeyDown(KEY_B) Then wd = 4 + 2 ' ..and b

' Change X &amp; Y as wanted
If wd &amp; 4 Then spritex = spritex - speed
If wd &amp; 8 Then spritex = spritex + speed
If wd &amp; 1 Then spritey = spritey - speed
If wd &amp; 2 Then spritey = spritey + speed 

' Now check for collision

' Horisontal
' oldpx1 = px1 ; oldpx2=px2 ; oldpx3 = px3 ; oldpx4 = px4
px1 = map((spritex+0)Shr 4,(oldspritey+0) Shr 4) &lt;&gt; 32 ' check for left (30 = wall, 32 = air)
px2 = map((spritex+0)Shr 4,(oldspritey+15) Shr 4) &lt;&gt; 32 ' check for left
px3 = map((spritex+15)Shr 4,(oldspritey+0) Shr 4) &lt;&gt; 32 '  check for right
px4 = map((spritex+15)Shr 4,(oldspritey+15) Shr 4) &lt;&gt; 32 ' check for right

' Vertical
' oldpy1 = py1 ; oldpy2=py2 ; oldpy3 = py3 ; oldpy4 = py4
py1 = map((oldspritex+0)Shr 4,(spritey+0) Shr 4) &lt;&gt; 32 ' check for up
py2 = map((oldspritex+0)Shr 4,(spritey+15) Shr 4) &lt;&gt; 32 ' check for down
py3 = map((oldspritex+15)Shr 4,(spritey+0) Shr 4) &lt;&gt; 32 ' check for up
py4 = map((oldspritex+15)Shr 4,(spritey+15) Shr 4) &lt;&gt; 32 ' check for down

orgspritex = spritex ; orgspritey = spritey
diagonal = False

For temptemp = speed To 1 Step -1

' Diagonal
pxy1 = map((spritex+0)Shr 4,(spritey+0) Shr 4) &lt;&gt; 32
pxy2 = map((spritex+0)Shr 4,(spritey+15) Shr 4) &lt;&gt; 32
pxy3 = map((spritex+15)Shr 4,(spritey+0) Shr 4) &lt;&gt; 32
pxy4 = map((spritex+15)Shr 4,(spritey+15) Shr 4) &lt;&gt; 32

' Diagonal (first thing that needs to be tried)
If wd = (4 + 1) Then If (pxy1 + pxy2 + pxy3 + pxy4) = 0 Then diagonal = True ' spritex = Int((spritex+0)/16)*16 + 16
If wd = (4 + 2) Then If (pxy1 + pxy2 + pxy3 + pxy4) = 0 Then diagonal = True ' spritex = Int((spritex+0)/16)*16 + 16
If wd = (8 + 1) Then If (pxy1 + pxy2 + pxy3 + pxy4) = 0 Then diagonal = True ' spritex = Int((spritex+0)/16)*16 + 16
If wd = (8 + 2) Then If (pxy1 + pxy2 + pxy3 + pxy4) = 0 Then diagonal = True ' spritex = Int((spritex+0)/16)*16 + 16

If diagonal = False
	If wd &amp; 4 Then spritex = spritex + 1
	If wd &amp; 8 Then spritex = spritex - 1
	If wd &amp; 1 Then spritey = spritey + 1
	If wd &amp; 2 Then spritey = spritey - 1
EndIf

Next

If diagonal = False

spritex = orgspritex ; spritey = orgspritey

' Horisontal
If wd &amp; 4 Then If px1 Or px2 Then spritex = Int((spritex+0)/16)*16 + 16 ' spritex = spritex - spritex Mod 16
If wd &amp; 8 Then If px3 Or px4 Then spritex = Int((spritex+15)/16)*16 - 16 ' spritex = spritex - spritex mod 16
' If wd &amp; 4 Or wd &amp; 8 Then If (py1 ~ oldpy1 And py3 ~ oldpy3) Or (py2 ~ oldpy2 And py4 ~ oldpy4) Then spritey = Int((spritey+0)/16)*16

' Vertical
If wd &amp; 1 Then If py1 Or py3 Then spritey = Int((spritey+0)/16)*16 + 16 ' spritey = spritey mod 16
If wd &amp; 2 Then If py2 Or py4 Then spritey = Int((spritey+15)/16)*16 - 16 ' spritey = spritey mod 16
' If wd &amp; 1 Or wd &amp; 2 Then If (px1 ~ oldpx1 And px2 ~ oldpx2) Or (px3 ~ oldpx3 And px4 ~ oldpx4) Then spritex = Int((spritex+0)/16)*16

EndIf

writenumber(spritex,0,1)

' --------------------------------------------------------------------------------------------















	glDrawPixels(xres,yres,GL_BGRA,GL_UNSIGNED_BYTE,Varptr(Pixels[0]))
	If KeyDown(49) Then Current=30
    If KeyDown(50) Then Current=32
    mx=MouseX()*6 ; my=MouseY()*6
	mx=mx/6 ; my=my/6 ; xxx=(worldx+mx) Sar 4 ; yyy=(worldy+my) Sar 4 
	If MouseDown(1) Then If map(xxx,yyy)&lt;&gt;79 And map(xxx,yyy)&lt;&gt;111 And map(xxx,yyy)&lt;&gt;112 Then map(xxx,yyy)=Current ; cmap(xxx,yyy)=5
	Delay 1 ; Flip 1
Until False 'MouseDown(2)
End

Function display(worldx,worldy,ofx=0,ofy=0,sx=640,sy=400) 
	scrx=worldx &amp; 15 ; scry=worldy &amp; 15 ; mapx=worldx Shr 4 ; mapy=worldy Shr 4
	cnty = 0 ; For y=mapy To mapy+((sy Shr 4)+1)
	cntx = 0 ; For x=mapx To mapx+((sx Shr 4)+1)
	tilex=map(x,y) &amp; 15 ; tiley=map(x,y) Shr 4
	colour=cols(cmap(x,y))
	xx=cntx - scrx + ofx ; yy=cnty - scry + ofy
	For ty=0 To 7 ; For tx=0 To 7
		If ((xx+tx+tx)=&gt;ofx) And ((yy+ty+ty)=&gt;ofy) And ((xx+tx+tx)&lt;(ofx+sx)) And ((yy+ty+ty)&lt;(ofy+sy))
		If buffer[tilex Shl 3 + tx + (tiley Shl 3 + ty)*128] &lt;&gt; c Then pixels[xx+tx+tx + (yy+ty+ty)*xres] = colour 
	EndIf
	Next ; Next
	cntx=cntx+16 ; Next
	cnty=cnty+16 ; Next
End Function

Function drawsprite(sprite,xx,yy,worldx,worldy,ofx=0,ofy=0,sx=640,sy=400)
	xx=xx-worldx ; yy=yy-worldy ' xx,yy is now screen coordinates
	tilex=sprite &amp; 15 ; tiley=sprite Shr 4 ; colour=cols(1)
	For ty=0 To 7 ; For tx=0 To 7
	    If ((xx+tx+tx)=&gt;ofx) And ((yy+ty+ty)=&gt;ofy) And ((xx+tx+tx)&lt;(ofx+sx)) And ((yy+ty+ty)&lt;(ofy+sy))
		If buffer[tilex Shl 3 + tx + (tiley Shl 3 + ty)*128] &lt;&gt; c Then pixels[xx+tx+tx + (yy+ty+ty)*xres] = buffer[tilex Shl 3 + tx + (tiley Shl 3 + ty)*128] ; pixels[xx+tx+tx + 1 + (yy+ty+ty)*xres] = buffer[tilex Shl 3 + tx + (tiley Shl 3 + ty)*128]
	EndIf
	Next ; Next
End Function

Function writetomap(t$,x,y,c)
	For tempx = 0 To Len(t$)-1 ; temp = Asc(Mid$(t$,1+tempx,1)) ; map[tempx+x,y] = temp ; cmap[tempx+x,y] = c ; Next
End Function

Function writenumber(v,x,y) ' handles -9999 to 9999
	
	For digits = 5 To 1 Step -1 ; map(x+digits-1,y) = 32 ; Next ' erase area
	
	If v &lt; 0 Then sign = True ; x = x + 1 ; v = Abs(v) Else sign = False
	numbase = 48 ' ASCII for 0
	
	digits = 1
	thousands = Int ( v / 1000)
	hundreds = Int ((v - thousands * 1000) / 100) 
	tens = Int ((v - thousands * 1000 - hundreds * 100)  / 10)
	units = Int v - thousands * 1000 - hundreds * 100 - tens * 10

	If tens &lt;&gt; 0 Then digits = 2
	If hundreds &lt;&gt; 0 Then digits = 3
	If thousands &lt;&gt; 0 Then digits = 4

	x=x+digits-1
	map(x,y) = numbase + units ; ; cmap(x,y) = 1 ; x = x - 1 
	If digits &gt;= 2 Then map(x,y) = numbase + tens ; ; cmap(x,y) = 1; x = x - 1
	If digits &gt;= 3 Then map(x,y) = numbase + hundreds ; ; cmap(x,y) = 1 ; x = x - 1
    If digits &gt;= 4 Then map(x,y) = numbase + thousands ; cmap(x,y) = 1 ; x = x - 1 
	If sign Then map(x,y) = 45 ; cmap(x,y) = 1
End Function

Function alive()
	For temp=1 To 16 ; buffer[Int(Rand(0,15))+Int((Rand(0,15))*128)]=$ffffffff * Int(Rand(0,1)) ; Next
	currentx=(currentx+1) Mod 128 ; For tempy=0 To 15 ; For temp=0 To 15+32
	buffer[16+temp+((0+tempy)*128)] = buffer[((0+temp+currentx+((16+tempy))*128)Mod 128)] ; Next ; Next ' ; For temp=1 To 1600 ; cmap[Rnd(400),Rnd(250)]=Rnd(16) ; Next
End Function

Function boulders()
For y=100 To 0 Step -1 ; For x=0 To 100

If map(x,y)=79 ' BOULDER
     If map(x,y+1) = 32
        map(x,y) = 111
     ElseIf map(x,y+1) = 79 And map(x-1,y) = 32 And map(x-1,y+1) = 32
        map(x,y) = 32 ; map(x-1,y) = 111
     ElseIf map(x,y+1) = 79 And map(x+1,y) = 32 And map(x+1,y+1) = 32
        map(x,y) = 32 ; map(x+1,y) = 112
    EndIf
EndIf

If map(x,y)=111 ' FALLINGBOULDER
     If map(x,y+1) = 32
        map(x,y)=32 ; map(x,y+1) = 111
     ElseIf map(x,y+1)=79 And map(x-1,y) = 32 And map(x-1,y+1) = 32
        map(x,y) = 32 ; map(x-1,y+0) = 111
     ElseIf map(x,y+1)=79 And map(x+1,y) = 32 And map(x+1,y+1) = 32
        map(x,y) = 32 ; map(x+1,y+0) = 112
     Else
        map(x,y)=79
    EndIf
EndIf

If map(x,y)=112 Then map(x,y)=111

Next ; Next
End Function

#colors
DefData $000000, $FFFFFF,$68372B,$70A4B2,$6F3D86,$588D43,$352879,$B8C76F,$6F4F25,$433900,$9A6759,$444444,$6C6C6C,$9AD284,$6C5EB5,$959595
</textarea> <br><br></td></tr></table><br>
<a name="1299131"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> POW ! Crashes out when you drag the mouse out of the graphics field when in DEBUG mode, Casaber.<br><br>I didn't hear any background music ? <br><br></td></tr></table><br>
<a name="1299133"></a>

<a name="1299134"></a>

<a name="1299135"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ya the music makes it unstable, somehow, did I miss something GUIwise? I can tell you it  gives silent errors on Mac but it won't crash. <br><br>I figured that on Bmax it's GUI and Mac there are issues so I left the music in.<br><br>You just have to wait for some sec and don't touch anything before its playing and then you need also to click the window to make it active as the music makes it unactive. <br>Do you know a way to make the windows automacally active after playing music?<br><br>Mac gets silent errors and also complains with beeps as the keyboard is not routed. So you need to click manually. I really wanted music though.<br>After that everything's fine and you can play the game, the game itself shouldn't crash after it have started. <br><br></td></tr></table><br>
<a name="1299139"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm glad that regarding collisions everything works perfect now except the diagonal problem, which you never get to see in practice. But I will fix it anyways. So I will try some of my newer solutions later and see which one that seem most elegant.<br><br>This is a good start though, It never gets stuck and it never misses a pixel. Supertight. <br><br></td></tr></table><br>
<a name="1299140"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> I see while I received no comments on my <b>Kaleidoscope</b>, the music player method I wrote for it apparently went to good use in your code, Casaber. :)<br><br><a href="/posts.php?topic=105560" target="_blank"><b>KALEIDOSCOPE SOURCE</b></a>.<br><br>That's fine. And yes, run your program in DEBUG mode, click inside the window (where it is not full-screen), then holding down the left mouse button, drag to outside the window.<br><br>It's always a good idea to run your program in DEBUG mode. Now while you may be thinking turning off debug ignores errors, the answer to that is YES and NO.<br><br>YES, no error message appears, NO, you ARE doing damage, likely to memory pointers and around your array by forcing numbers to appear outside the designated space you allocated for it.<br><br>In time, your program will be worse than crashing, but overwriting bits of important data saved in the runtime, giving bizarre numeric results, and this will clearly show up with repeated use. <br><br></td></tr></table><br>
<a name="1299141"></a>

<a name="1299142"></a>

<a name="1299144"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> you should use superstrict mode, it will highlight all variables you failed to initialize, and the arrays are not supposed to be accessed with "( )", but with "[ ]"<br><br>I did it just to be able to understand your code, and I fixed some issues with "out of bound" exception ...<br>sorted stuff by relevance, so it's more clear what is where.<br><br>My apologize for the whole indentation and rebuild, I know some people don't like when we update their code ... so, no offense, it's just for others who might think it's not readable as you posted it.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

' Stream some background music
Import MaxGui.Drivers


Function display(worldx:Int,worldy:Int,ofx:Int=0,ofy:Int=0,sx:Int=640,sy:Int=400) 
	
	Local scrx:Int = worldx &amp; 15
	Local scry:Int = worldy &amp; 15
	Local mapx:Int = worldx Shr 4
	Local mapy:Int = worldy Shr 4
	Local cnty:Int = 0
	Local cntx:Int = 0
	Local y:Int = 0
	Local x:Int = 0
	
	For y=mapy To mapy+((sy Shr 4)+1)
		cntx = 0
		For x=mapx To mapx+((sx Shr 4)+1)
			
			Local tilex:Int = map[x,y] &amp; 15
			Local tiley:Int = map[x,y] Shr 4
			Local colour:Int = cols[cmap[x,y]]
			Local xx:Int = cntx - scrx + ofx
			Local yy:Int = cnty - scry + ofy
			Local tY:Int = 0
			Local tX:Int = 0
			
			For tY=0 To 7
				For tX=0 To 7
					
					If ((xx+tX+tX)=&gt;ofx) And ((yy+tY+tY)=&gt;ofy) And ((xx+tX+tX)&lt;(ofx+sx)) And ((yy+tY+tY)&lt;(ofy+sy))
						If buffer[tilex Shl 3 + tX + (tiley Shl 3 + tY)*128] &lt;&gt; c Then Pixels[xx+tX+tX + (yy+tY+tY)*xres] = colour
					EndIf
					
				Next
			Next
			
			cntx=cntx+16
		Next
		cnty=cnty+16
	Next
	
End Function

Function drawsprite(sprite:Int,xx:Int,yy:Int,worldx:Int,worldy:Int,ofx:Int=0,ofy:Int=0,sx:Int=640,sy:Int=400)
	xx :- worldx
	yy :- worldy
	Local tilex:Int = sprite &amp; 15
	Local tiley:Int = sprite Shr 4
	
	Local tY:Int = 0
	Local tX:Int = 0
	For tY=0 To 7
		For tX=0 To 7
	    	If ((xx+tX+tX)=&gt;ofx) And ((yy+tY+tY)=&gt;ofy) And ((xx+tX+tX)&lt;(ofx+sx)) And ((yy+tY+tY)&lt;(ofy+sy))
				If buffer[tilex Shl 3 + tX + (tiley Shl 3 + tY)*128] &lt;&gt; c
					Pixels[xx+tX+tX +     (yy+tY+tY)*xres] = buffer[tilex Shl 3 + tX + (tiley Shl 3 + tY)*128]
					Pixels[xx+tX+tX + 1 + (yy+tY+tY)*xres] = buffer[tilex Shl 3 + tX + (tiley Shl 3 + tY)*128]
				EndIf
			EndIf
		Next
	Next
End Function

Function writetomap(t$,x:Int,y:Int,c:Int)
	Local tX:Int = 0
	For tX = 0 Until t.length
		map[tX+x,y] = t[tX]
		cmap[tX+x,y] = c
	Next
End Function

Function writenumber(v:Int,x:Int,y:Int) ' handles -9999 to 9999
	
	local digits:Int = 0
	Local sign:Int = False
	Local numbase:Int = 48 ' ASCII for 0
	
	For digits = 5 To 1 Step -1
		map[x+digits-1,y] = 32
	Next ' erase area
	
	If v &lt; 0
		sign = True
		x = x + 1
		v = Abs(v)
	EndIf
	
	digits = 1
	Local thousands:Int = Int ( v / 1000)
	Local hundreds:Int = Int ((v - thousands * 1000) / 100) 
	Local tens:Int = Int ((v - thousands * 1000 - hundreds * 100)  / 10)
	Local units:Int = Int v - thousands * 1000 - hundreds * 100 - tens * 10
	
	If tens &lt;&gt; 0 Then digits = 2
	If hundreds &lt;&gt; 0 Then digits = 3
	If thousands &lt;&gt; 0 Then digits = 4

	x :+ digits-1
	map[x,y] = numbase + units
	cmap[x,y] = 1
	x :- 1 
	If digits &gt;= 2 Then map[x,y] = numbase + tens ; cmap[x,y] = 1; x = x - 1
	If digits &gt;= 3 Then map[x,y] = numbase + hundreds ; cmap[x,y] = 1 ; x = x - 1
    If digits &gt;= 4 Then map[x,y] = numbase + thousands ; cmap[x,y] = 1 ; x = x - 1 
	If sign Then map[x,y] = 45 ; cmap[x,y] = 1
End Function

Function alive()
	Local y:Int
	Local x:Int
	For x=1 To 16
		buffer[Int(Rand(0,15))+Int((Rand(0,15))*128)]=$ffffffff * Int(Rand(0,1))
	Next
	currentx = (currentx+1) Mod 128
	For y=0 To 15
		For x=0 To 47
			buffer[16+x+((0+y)*128)] = buffer[((0+x+currentx+((16+y))*128)Mod 128)]
		Next
	Next
End Function

Function boulders()
	Local y:Int
	Local x:Int
	
	For y=100 To 0 Step -1
		For x=0 To 100
			
			If map[x,y]=79 ' BOULDER
			     If map[x,y+1] = 32
			        map[x,y] = 111
			     ElseIf map[x,y+1] = 79 And map[x-1,y] = 32 And map[x-1,y+1] = 32
			        map[x,y] = 32
					map[x-1,y] = 111
			     ElseIf map[x,y+1] = 79 And map[x+1,y] = 32 And map[x+1,y+1] = 32
			        map[x,y] = 32
					map[x+1,y] = 112
			    EndIf
			EndIf
			
			If map[x,y]=111 ' FALLINGBOULDER
			     If map[x,y+1] = 32
			        map[x,y]=32
					map[x,y+1] = 111
			     ElseIf map[x,y+1]=79 And map[x-1,y] = 32 And map[x-1,y+1] = 32
			        map[x,y] = 32
					map[x-1,y+0] = 111
			     ElseIf map[x,y+1]=79 And map[x+1,y] = 32 And map[x+1,y+1] = 32
			        map[x,y] = 32
					map[x+1,y+0] = 112
			     Else
			        map[x,y]=79
			    EndIf
			EndIf
			
			If map[x,y]=112 Then map[x,y]=111
			
		Next
	Next
End Function

#colors
DefData $000000, $FFFFFF,$68372B,$70A4B2,$6F3D86,$588D43,$352879,$B8C76F,$6F4F25,$433900,$9A6759,$444444,$6C6C6C,$9AD284,$6C5EB5,$959595





'#region - Init Screen -
	Global xres:Int = 640 , yres:Int = 480
	
	GLGraphics				( xres,yres, 0,0, GRAPHICS_BACKBUFFER | GRAPHICS_DEPTHBUFFER )
	glViewport				( 0,0, xres,yres )
	glMatrixMode			( GL_PROJECTION )
	glLoadIdentity			( )
	glOrtho					( 0, xres,yres, 0,0, 1 )
	glPixelZoom				( 1,-1 )
	glRasterPos2i			( 0, 0 )
'#end region

'#region - Init Arrays -
	Global buffer:Int[256*256]
	Global Pixels:Int[xres*yres]
	Global map:Int[4096,4096]
	Global cmap:Int[4096,4096]
	Global pmap:Int[1024*1024]
	Global cols:Int[16]
'#end region

'#region - init Globals -
	Global wx:Int			=	0
	Global wy:Int			=	0
	Global s:Int			=	2
	Global space_z:Float	=	50
	Global horizon:Int		=	20
	Global scale:Float		=	1000
	Global obj_scale:Float	=	50
	Global cx:Int			=	0
	Global worldx:Int		=	0
	Global worldy:Int		=	0
	Global currentx:Int		=	0
	Global c:Int			=	0
	Global Current:Int		=	30
	Global current2:Int		=	7
	Global speed2:Int		=	1
'#end region

'#region - init Locals -
	Local Window:TGadget
	Local mainview:TGadget
	Local htmlview:TGadget
	Local img2:TPixmap
	Local spritex:Int		=	0
	Local spritey:Int		=	0
	Local oldspritex:Int	=	0
	Local oldspritey:Int	=	0
	Local diagonal:Int		=	0
	Local x:Float			=	0
	Local y:Float			=	0
	Local speed:Float		=	0
	Local intro:Int			=	0
	Local easteregg:Int		=	0
	
	Local mx:Int			=	0
	Local my:Int			=	0
	Local ddd:Int			=	0
	Local ddd2:Int			=	0
	Local wd:Int			=	0
	
	Local px1:Int			=	0
	Local px2:Int			=	0
	Local px3:Int			=	0
	Local px4:Int			=	0
	
	Local py1:Int			=	0
	Local py2:Int			=	0
	Local py3:Int			=	0
	Local py4:Int			=	0
	
	Local pxy1:Int			=	0
	Local pxy2:Int			=	0
	Local pxy3:Int			=	0
	Local pxy4:Int			=	0
'#end region


'#region - fill colors -
	RestoreData colors
	For x=0 To 15
		ReadData cols[x]
	Next
'#end region

'#region - load sprites -
	img2 = LoadPixmap(LoadBank("http::s9.postimg.org/rfaelk9m3/128x128.png"))
	'img2 = LoadPixmap("128x128.png")
'#end region

'#region - set buffer -
	For y=0 To 127
		For x=0 To 127
			buffer [ x+y*128 ] = ReadPixel ( img2, x, y )
		Next
	Next
	c = buffer[0]
'#end region

'#region - fill map -
	
	' clear color map to green
	For y=0 To 316
		For x=0 To 475
			cmap[x,y] = 5
		Next
	Next
	
	' clear map to empty cells (32)
	For y=0 To 316
		For x=0 To 475
			map[x,y]=32
		Next
	Next
	
	' fill with rects of "30" blocks
	#map_rects
	DefData 13,25,13,14, 0,0,0,24, 39,39,0,24, 0,39,0,0, 0,39,24,24, 50,60,10,12, -1
	
	RestoreData map_rects
	Local x0:Int	=	0
	Local y0:Int	=	0
	Local x1:Int	=	0
	Local y1:Int	=	0
	
	Repeat
		ReadData x0 ; If x0=-1 Then Exit;
		ReadData y0 ; ReadData x1 ; ReadData y1
		For x = x0 To x1
			For y = y0 To y1
				map[x,y] = 30
			Next
		Next
	Forever
	
	' add random blocks
	For x = 0 To 30
		map[Rand(0,39),Rand(0,24)] = 30
	Next
	
	' show the available tile blocks
	For x = 0 To 16
		For y=2 To 4
			map[x,y] = x
		Next
	Next
	
	' write some stuff
	writetomap("[Shift] to scroll inside world",8,0,1)
	writetomap("1 and 2 - draw and erase using mouse",2,24,1)
	writetomap("N  t",15,21,1)
	writetomap("Broken",15,22,1)
	
	writetomap("Oh, The things ",50,18,1)
	writetomap("we see when we stoP looking..  ",50,20,1)
	writetomap("-------------------------------- ",50,21,1)
	writetomap("-------------------------------- ",50,22,1)
	
'#end region


' init player pos
spritex = 128+8*16
spritey = 128+8*16

intro = worldy+25*16
worldy = intro

Repeat
	
	'#region - mode -
		
		If intro &gt; 0
			intro = intro - 2
			worldy = intro
		EndIf
		
		If intro = 0
			Window		=	CreateWindow	( "",0,0,0,0,,0 )
			htmlview	=	CreateHTMLView	( 0,0,0,0, Window )
							HtmlViewGo		( htmlview, "http://bit.ly/22Cv21e" )
			intro = -1
		EndIf
		
	'#end region
	
	'#region - clear screen -
		
		For y=0 To yres-1 Step 1
			For x=0 To xres-1 Step 1
				Pixels[(y*xres+x)] = 0
			Next
		Next
		
	'#end region
	
	'#region * USER INPUT *******
		
		' - gameplay - god -
			
			If KeyDown(KEY_1) Then Current=30
			If KeyDown(KEY_2) Then Current=32
			mx=MouseX()*6 ; my=MouseY()*6
			
			If KeyDown(KEY_LSHIFT)
				worldx = worldx + s *( KeyDown(KEY_RIGHT) - KeyDown(KEY_LEFT) )
				worldy = worldy + s *( KeyDown(KEY_DOWN) - KeyDown(KEY_UP) )
			EndIf;
			' assert world pos is in the map
			worldx = Max(0,Min(10000,worldx))
			worldy = Max(0,Min(10000,worldy))
			
			
		' - gameplay - player -
			
			' Read keys and create a mask for all 4 directions
			wd = 0
			If Not KeyDown(KEY_LSHIFT)
				wd = 1*(KeyDown(KEY_UP)&gt;0) + 2*(KeyDown(KEY_DOWN)&gt;0) + 4*(KeyDown(KEY_LEFT)&gt;0) + 8*(KeyDown(KEY_RIGHT)&gt;0)
			EndIf
			
			If KeyDown(KEY_A) Then wd = 8 + 1 ' test diagnally movement with a..
			If KeyDown(KEY_B) Then wd = 4 + 2 ' ..and b
			
	'#end region
	
	'#region * LOGIC ************
		
		' - God -
			
			' Draw with mouse, change to eraser using 2 and back using 1
			' Using 16 x 16 tiles and sprites
			mx :/ 6
			my :/ 6
			x = (worldx+mx) Sar 4
			y = (worldy+my) Sar 4 
			If MouseDown(1)
				If ( (map[x,y]&lt;&gt;79) And (map[x,y]&lt;&gt;111) And (map[x,y]&lt;&gt;112) )
					map[x,y] = Current
					cmap[x,y] = 5
				EndIf
			EndIf
			
			
		' - Player collision -
			
			speed = 3
			oldspritex = spritex
			oldspritey = spritey
			
			' Change X &amp; Y as wanted
			If wd &amp; 4 Then spritex = spritex - speed
			If wd &amp; 8 Then spritex = spritex + speed
			If wd &amp; 1 Then spritey = spritey - speed
			If wd &amp; 2 Then spritey = spritey + speed 
			
			spritex = min(max(spritex,0), 4080)
			spritey = min(max(spritey,0), 4080)
			
			' Now check for collision
			
			' Horisontal
			px1 = map[(spritex+0)Shr 4,(oldspritey+0) Shr 4] &lt;&gt; 32 ' check for left (30 = wall, 32 = air)
			px2 = map[(spritex+0)Shr 4,(oldspritey+15) Shr 4] &lt;&gt; 32 ' check for left
			px3 = map[(spritex+15)Shr 4,(oldspritey+0) Shr 4] &lt;&gt; 32 '  check for right
			px4 = map[(spritex+15)Shr 4,(oldspritey+15) Shr 4] &lt;&gt; 32 ' check for right
			
			' Vertical
			py1 = map[(oldspritex+0)Shr 4,(spritey+0) Shr 4] &lt;&gt; 32 ' check for up
			py2 = map[(oldspritex+0)Shr 4,(spritey+15) Shr 4] &lt;&gt; 32 ' check for down
			py3 = map[(oldspritex+15)Shr 4,(spritey+0) Shr 4] &lt;&gt; 32 ' check for up
			py4 = map[(oldspritex+15)Shr 4,(spritey+15) Shr 4] &lt;&gt; 32 ' check for down
			
			oldspritex = spritex
			oldspritey = spritey
			
			diagonal = False
			
			For x = speed To 1 Step -1
				
				' Diagonal
				pxy1 = map[(spritex+0)Shr 4,(spritey+0) Shr 4] &lt;&gt; 32
				pxy2 = map[(spritex+0)Shr 4,(spritey+15) Shr 4] &lt;&gt; 32
				pxy3 = map[(spritex+15)Shr 4,(spritey+0) Shr 4] &lt;&gt; 32
				pxy4 = map[(spritex+15)Shr 4,(spritey+15) Shr 4] &lt;&gt; 32
				
				' Diagonal (first thing that needs to be tried)
				If wd = (4 + 1) Then If (pxy1 + pxy2 + pxy3 + pxy4) = 0 Then diagonal = True ' spritex = Int((spritex+0)/16)*16 + 16
				If wd = (4 + 2) Then If (pxy1 + pxy2 + pxy3 + pxy4) = 0 Then diagonal = True ' spritex = Int((spritex+0)/16)*16 + 16
				If wd = (8 + 1) Then If (pxy1 + pxy2 + pxy3 + pxy4) = 0 Then diagonal = True ' spritex = Int((spritex+0)/16)*16 + 16
				If wd = (8 + 2) Then If (pxy1 + pxy2 + pxy3 + pxy4) = 0 Then diagonal = True ' spritex = Int((spritex+0)/16)*16 + 16
				
				If diagonal = False
					If wd &amp; 4 Then spritex = spritex + 1
					If wd &amp; 8 Then spritex = spritex - 1
					If wd &amp; 1 Then spritey = spritey + 1
					If wd &amp; 2 Then spritey = spritey - 1
				EndIf
				
			Next
			
			If diagonal = False
				
				spritex = oldspritex ; spritey = oldspritey
				
				' Horisontal
				If wd &amp; 4 Then If px1 Or px2 Then spritex = Int((spritex+0)/16)*16 + 16 ' spritex = spritex - spritex Mod 16
				If wd &amp; 8 Then If px3 Or px4 Then spritex = Int((spritex+15)/16)*16 - 16 ' spritex = spritex - spritex mod 16
				' If wd &amp; 4 Or wd &amp; 8 Then If (py1 ~ oldpy1 And py3 ~ oldpy3) Or (py2 ~ oldpy2 And py4 ~ oldpy4) Then spritey = Int((spritey+0)/16)*16
				
				' Vertical
				If wd &amp; 1 Then If py1 Or py3 Then spritey = Int((spritey+0)/16)*16 + 16 ' spritey = spritey mod 16
				If wd &amp; 2 Then If py2 Or py4 Then spritey = Int((spritey+15)/16)*16 - 16 ' spritey = spritey mod 16
				' If wd &amp; 1 Or wd &amp; 2 Then If (px1 ~ oldpx1 And px2 ~ oldpx2) Or (px3 ~ oldpx3 And px4 ~ oldpx4) Then spritex = Int((spritex+0)/16)*16
				
			EndIf
			
			spritex = min(max(spritex,0), 4095)
			spritey = min(max(spritey,0), 4095)
			
	'#end region
	
	'#region * UPDATE ****************
		
		' - tiles -
			
			' animate
			alive()
			
			' counter for launching a boulder
			ddd = Ddd+1
			If ddd = 4
				boulders()
				ddd = 0
			EndIf;
			
			' if easteregg enabled : random boulders
			ddd2 = ddd2 + 1
			If ddd2 = 10
				ddd2 = 0
				If easteregg = True
					map [ Rand(1,38), Rand(1,24) ] = 79
				EndIf
			EndIf
			
	'#end region
	
	'#region * UNLOCK BONUS **********
		
		' - check easteregg ... -
			
			If ( (map[17,22] = 79) And (map[34,24] = 79) )
				writetomap("Easterregg !! ",8,8,2)
				easteregg = True
			EndIf;
			
	'#end region
	
	'#region * DRAW ******************
			
		' - draw world -
			
			display		( worldx, worldy, 0,0, 640,480 )
			
			
		' - draw player -
			
			drawsprite	( 30, spritex, spritey, worldx, worldy, 0,0,16*80,16*50 )
			
			
			writenumber(spritex,0,1)
			writenumber(spritey,5,1)
			
		glDrawPixels(xres,yres,GL_BGRA,GL_UNSIGNED_BYTE,VarPtr(Pixels[0]))
		
	'#end region
	
	Delay 1
	Flip 1
	
Until AppTerminate()

End

</textarea><br><br>ps : I replace the for/next to fill the map with some DefData.<br>It's not really nice to code with old basic things, but it's a bit less boring for me. <br><br></td></tr></table><br>
<a name="1299145"></a>

<a name="1299146"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> About superstricmode I´m learning that. So.. it's coming up. <br><br>Will check that code later, thanks so very much. <br>I guess my working code is not much to share when it comes to comprehensio, It's just that.. I love to share. <br><br>You have a point though, what you cannot understand there is not point of sharing. It gives a sense of being social and sharing ideas. I love that.  Still..  ya.<br><br>I guess it will be very lonesome to code from now on. <br><br></td></tr></table><br>
<a name="1299147"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well, if not SUPERSTRICT, use STRICT, Casaber. The main difference is you won't have to type out INTEGER for variables that are not defined via the standard $ and #.<br><br><b>local a,b,c ' Strict<br>local a:int,b:int,c:int ' Superstrict</b><br><br>Now if you plan to use more advanced variables than just INT, FLOAT (#), and STRING ($), then SUPERSTRICT just might be a good idea at that. But yes, please use one or the other.<br><br>And you should NEVER define any opening variables as GLOBAL unless you are absolutely certain you want to carry their results to your function() routines.<br><br>Some GOOD examples of global variables would be an array that carries the game map, loaded images saved as TIMAGE or TPIXMAP, audio as LOADSOUND, fonts as LOADIMAGEFONT, and music as TCHANNEL and LOADSOUND.<br><br>Perhaps a few dedicated variables that you want to be able to know the value in each and every function you write.<br><br>Some BAD examples of global would be throwaway variables needed for simple calculations and/or variables in use with FOR/NEXT loops.<br><br>For instance, if you defined variable i to be global and then in one of your functions you used a FOR/NEXT loop with it but did not earlier define it as LOCAL, while it would work, when you exit that function, the value of i would ALSO be changed back in your main code causing possible untold mayhem later. <br><br></td></tr></table><br>
<a name="1299148"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> dw817 I did mention you? Did you not see that? <br><br>I've seen those error codes before in all kinds of scenarios though most of the time it was pure GUI related guff.<br>You think it does damage? Ya I think you're right. I never felt comfortable using those GUI commands. But I sortof panicced and used them <br>just to be able to get streaming music. <br><br></td></tr></table><br>
<a name="1299149"></a>

<a name="1299150"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> I will go all the way, SUPERSTRICT or nothing haha :) I need to build a style that suits the tool. I need to get comfterable with BMax before I can tell you what I will settle for.<br><br>My hopes are, that SUPERSTRICT are well thought through and that I will like it. <br><br></td></tr></table><br>
<a name="1299151"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> Anyways, hope you like it, and enjoy it. <br><br></td></tr></table><br>
<a name="1299152"></a>

<a name="1299153"></a>

<a name="1299154"></a>

<a name="1299155"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> I feel that I should learn Bmax better before posting any more, that way I could write readable code for ppl. This could take quiet some time.<br><br>So you won´t see me for awhile I guess. I hate that as I love to be able to be social and share things inbetween work. But it won´t work I think. It just gets too cryptic for ppl I begin to reliase. <br><br></td></tr></table><br>
<a name="1299156"></a>

<a name="1299158"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Bobysait</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yep, Superstrict is really a convenient way to code, it prevents many errors in the syntax ...<br><br>By the way, i don't know if you already know it, but the way you stream audio won't work on all OS.<br>Regarding the default internet browser that the window will get the htmlview embedded in, the javascript stuff may or not be available/activated, so, as youtube stuff is full of js and ajax or probably other advanced stuff, it won't stream anything and will just return an error that won't be displayed. You'll just get a black screen.<br><br>So, it's probably not a very good way to stream audio.<br>I've never tried to stream audio so I won't give you a better way, but I'm pretty sure there are plenty of solution that better fit the purpose.<br><br><div class="quote"> <br><br>So you won´t see me for awhile I guess. I hate that as I love to be able to be social and share things inbetween work. But it won´t work I think. It just gets too cryptic for ppl I begin to reliase. <br> <br></div><br><br>Don't be afraid to post messy codes, we're used to that :)<br>Actually, I love this retro style you posted, that's the reason why I tried to make it more clean, but there is no reason you should stop here.<br>I think there is something interesting in your code, but probably not accessible to beginners. As I said, no offense, it's really just for people who "would'nt" understand your code that I updated it. And as you can see, I understood it, so it worth to be posted. <br><br></td></tr></table><br>
<a name="1299157"></a>

<a name="1299163"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> It's a good program, Casaber. Superstrict is too much for me. Reminds me of coding in C.<br><br>But no-one is going to discredit you for using Superstrict, and I suspect in time it will help you pin down difficult errors too.<br><br>And yes, I see dw817. Just a little miffed my Kaleidoscope fell into obscurity. But it's not the first nor likely the last. :)<br><br>As for your code being too cryptic. That's no reason to disappear. Just write code w comments.<br><br>Believe me, the more you do it the more it will help YOU, not just other people understand it.<br><br>And you should always deeply comment your code for major projects, including adding a bunch of comments before the code to remind you what you are doing and what you are trying to achieve. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
