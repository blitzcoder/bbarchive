<!DOCTYPE html><html lang="en" ><head ><title >In the mood for Mode 7?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >In the mood for Mode 7?</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >In the mood for Mode 7?</a><br><br>
<a name="1294281"></a>

<a name="1294282"></a>

<a name="1294283"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I was looking around the web for sources related to that old Nintendo graphic kind of things. I noticed some ideas here on this forum about "mode 7" and the solution was to put pixels on the screen with some math, one by one.<br><br>So I was thinking.. would it not be possible to do this better using textured quads instead? Quads is what Im working with anyways so that would be perfect.<br><br><img src="https://upload.wikimedia.org/wikipedia/en/4/46/Street_Fighter_II_(arcade)_screenshot.png"><br><br><img src="http://loyalkng.com/wp-content/uploads/2009/01/zelda.jpg"><br><br>Simple quads? Maybe some kind of line-per-line technique? Using scale and rotation or just directly warping the 4 points?<br>Stitching several quads together maybe? I have so many ideas right now but not very much time to try things out.<br><br>I´m wondering how your take on the problem would be? <br><br></td></tr></table><br>
<a name="1294286"></a>

<a name="1294287"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> If i had access to some 3D api, quads definitely ;)<br>Doing it in software is of course more fun.<br><br>I have done this in software before, many years ago. But cant for the life of me remember how anymore hehe.<br>I did find an old thread though, that has some code you can look at: <a href="http://www.blitzbasic.com/Community/posts.php?topic=81569" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=81569</a> <br><br></td></tr></table><br>
<a name="1294334"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Wikipedia's take on it seems fairly clear:<br><br><a href="https://en.wikipedia.org/wiki/Super_Nintendo_Entertainment_System_technical_specifications#Video" target="_blank">https://en.wikipedia.org/wiki/Super_Nintendo_Entertainment_System_technical_specifications#Video</a><br><a href="https://en.wikipedia.org/wiki/Mode_7" target="_blank">https://en.wikipedia.org/wiki/Mode_7</a><br><br>You just apply one affine transformation to the coordinates. Do this line-by-line, changing the scale with each line, and you can create fake perspective.<br><br>You could use quads instead. Sounds like it would be missing the fun though. With quads, there is no "technique", you can just use real perspective. <br><br></td></tr></table><br>
<a name="1294339"></a>

<a name="1294340"></a>

<a name="1294341"></a>

<a name="1294343"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Yasha Thanks. I'm no skipping the pixel version oh no, I´m interested in both. This was just an idea I wanted to explore. I guess I was told that affine transfoimation would be not Ortho but GLUsomething <br>I have to check that again, it was a different perspective in OpenGL.<br><br>@Grable You want a Quad? It just takes about 13 instructions to draw a quad and 2 additional ones to load and init them so that's no problem.<br><br>You just need to add some technique to handling the style of warping and projection etc aswell. <br>Right now I´m using simple vertex and no arrays, as It's just a Quad but I will change that.<br><br><pre class=code>

' Init Graphics ------------------------------------------------------------------------------------
Global xres:Int = DesktopWidth() ; yres:Int = 1080 ; SetGraphicsDriver GLMax2DDriver(),0 ' Add the 0 when you want to use frontbuffer directly instead of backbuffer
' It Seem To give about 30% additional performance without tearing And making the difference from 30 fps And 60 fps at 
' times especially in windowed mode where opengl is weaker than, fullscreen are given a boost aswell.
xres=800 ; yres = 600 ; Graphics xres,yres,0,60,GRAPHICS_BACKBUFFER + GRAPHICS_DEPTHBUFFER ; glewinit ; AutoImageFlags MASKEDIMAGE 

' Load Images --------------------------------------------------------------------------------------
exampleimage:TImage = LoadImage(LoadBank("http::icons.iconarchive.com/icons/google/chrome/64/Google-Chrome-icon.png")) ; If Not exampleimage Then RuntimeError "Unable to download file" ; End

Cls 
DrawImage exampleimage,0,0
DrawQuad exampleimage,32,32,350,64,512,380,32,318
glflush ; Flip ; WaitKey
End

Function DrawQuad(tex:TImage,x0:Float,y0:Float,x1:Float,y1:Float,x2:Float,y2:Float,x3:Float,y3:Float)
id = TGLImageFrame(tex.frame(0)).name ; glEnable GL_TEXTURE_2D ; glBindTexture GL_TEXTURE_2D,id
glBegin GL_QUADS
glTexCoord2f 0.0,0.0 ; glVertex2f x0,y0
glTexCoord2f 1.0,0.0 ; glVertex2f x1,y1
glTexCoord2f 1.0,1.0 ; glVertex2f x2,y2
glTexCoord2f 0.0,1.0 ; glVertex2f x3,y3
glEnd
glDisable GL_TEXTURE_2D
End Function
</pre> <br><br></td></tr></table><br>
<a name="1294366"></a>

<a name="1294372"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's a lovely QUAD you have there, Casaber. I asked about this earlier for myself.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict
SetGraphicsDriver GLMax2DDriver(),0
Graphics 500,500
SetBlend alphablend
glewinit
Local img:TImage=LoadImage(LoadBank("http::www.rpgbooster.com/wp-content/uploads/2013/02/rpg-maps-Wentworth-Inn_bg.jpg"))
Local x1,y1,x2,y2,x3,y3,x4,y4
x1=200 ; y1=50 ' TOP LEFT
x2=300 ; y2=50 ' TOP RIGHT
x3=50 ; y3=450 ' BOTTOM RIGHT
x4=450 ; y4=450 ' BOTTOM LEFT
drawquad img,x1,y1,x2,y2,x3,y3,x4,y4
SetAlpha .5
DrawOval x1-10,y1-10,20,20
DrawOval x2-10,y2-10,20,20
DrawOval x3-10,y3-10,20,20
DrawOval x4-10,y4-10,20,20
Flip 0
WaitKey

Function drawquad(img:TImage,x1,y1,x2,y2,x3,y3,x4,y4)
Local id=TGLImageFrame(img.frame(0)).name
  glEnable GL_TEXTURE_2D
  glBindTexture GL_TEXTURE_2D,id
  glbegin gl_quads
  glTexCoord2f 0.0,0.0 ; glVertex2f x1,y1
  glTexCoord2f 0.5,0.0 ; glVertex2f x2,y2
  glTexCoord2f 0.0,0.5 ; glVertex2f x3,y3
  glTexCoord2f 0.5,0.5 ; glVertex2f x4,y4
  glend
  gldisable gl_texture_2d
EndFunction
</textarea><br><br>Unfortunately it is warping incorrectly despite the code looking correct. <br><br></td></tr></table><br>
<a name="1294368"></a>

<a name="1294369"></a>

<a name="1294370"></a>

<a name="1294371"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> That one is not working on Imac? Why do i get a gray window? <br><br>Heres's one that paints to canvas using opengl by the way. It might come handy.<br><pre class=code>
Import maxgui.drivers
Global xres:Int = DesktopWidth() ; yres:Int = 1080 ; xres=800 ; yres = 600
AutoImageFlags MASKEDIMAGE

Global img:TImage = LoadImage(LoadBank("http::icons.iconarchive.com/icons/google/chrome/64/Google-Chrome-icon.png"))

Global MyWindow:TGadget=CreateWindow("OpenGL in MaxGUI Canvas Gadget",400,400,640,480,Null,WINDOW_TITLEBAR | WINDOW_CLIENTCOORDS | WINDOW_RESIZABLE | WINDOW_STATUS)
Global c:TGadget=CreateCanvas(0,0,GadgetWidth(MyWindow)-200,GadgetHeight(MyWindow),MyWindow)
Local GraphicContext:TGraphics=CanvasGraphics(c) ; SetGraphics GraphicContext

SetGraphicsDriver GLMax2DDriver(),0 ; glewinit ; glMatrixMode GL_PROJECTION ; glLoadIdentity ; gluOrtho2D 0,GadgetWidth(c),GadgetHeight(c),0
glMatrixMode GL_MODELVIEW ; glLoadIdentity ; glClearColor 0,0,0,1

Global x:Int=0 ; Global y:Int=0 , Vertices:Float[] = [-20.0,-20.0,0.0,-20.0,20.0,0.0,20.0,20.0,0.0,20.0,-20.0,0.0]
global Colors:Float[] = [1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0]
ActivateGadget(c) ; AddHook EmitEventHook,HookManager

Repeat
	WaitEvent
Forever
End

Function HookManager:Object(id:Int,data:Object,context:Object)
Local event:TEvent = TEvent(data) ; If event = Null Then Return Null
Select event.source
	Case c
		Select event.id
			Case EVENT_MOUSEENTER ; HideMouse
			Case EVENT_MOUSELEAVE ; ShowMouse
			Case EVENT_MOUSEMOVE ;	x=event.x ; y=event.y ; RedrawGadget c
			Case EVENT_GADGETPAINT ; drawcanvas
		End Select
	Case MyWindow
		Select event.id
			Case EVENT_WINDOWCLOSE ; End
			Case EVENT_WINDOWSIZE ; SetGadgetShape c,0,0,event.x-200,event.y
		End Select
End Select
End Function

Function drawcanvas()	
	SetGraphics CanvasGraphics (c) ; glLoadIdentity ; glClear GL_COLOR_BUFFER_BIT ; glTranslatef x,y,0 ; glEnableClientState GL_VERTEX_ARRAY 
        glEnableClientState GL_COLOR_ARRAY ; glColorPointer 3,GL_FLOAT,0,Colors ; glVertexPointer 3,GL_FLOAT,0,Vertices
	glDrawArrays GL_QUADS,0,4 ; glDisableClientState GL_VERTEX_ARRAY ; glDisableClientState GL_COLOR_ARRAY
 
       DrawImage img,0,0 ; DrawQuad img,32,32,350,64,512,380,32,318
        glflush ; Flip
End Function

Function DrawQuad(tex:TImage,x0:Float,y0:Float,x1:Float,y1:Float,x2:Float,y2:Float,x3:Float,y3:Float)
	id = TGLImageFrame(tex.frame(0)).name ; glEnable GL_TEXTURE_2D ; glBindTexture GL_TEXTURE_2D,id ; glBegin GL_QUADS
	glTexCoord2f 0.0,0.0 ; glVertex2f x0,y0 ; glTexCoord2f 1.0,0.0 ; glVertex2f x1,y1
	glTexCoord2f 1.0,1.0 ; glVertex2f x2,y2 ; glTexCoord2f 0.0,1.0 ; glVertex2f x3,y3 ; glEnd ; glDisable GL_TEXTURE_2D
End Function
</pre> <br><br></td></tr></table><br>
<a name="1294373"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> GUI is all new territory for me I wanted to try it out and see if it worked the same.<br>It seems so? I really hope it does because that would make for some interesting apps with user interfaces in the future. <br><br></td></tr></table><br>
<a name="1294374"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Casaber, I can't get this last program to run because it exceeds my resolution and you have hardwired this resolution all across the code. Could you please use window size 800x600 or smaller to test. Thanks ! <br><br></td></tr></table><br>
<a name="1294375"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> I have 800 600 hardwired (overridden) in this one?<br><br>What happens? I get a 800x600 window and no screen whatsoever shoulod pop up. just a 800x600 window. That would fit your 800x600 screen no? <br><br></td></tr></table><br>
<a name="1294380"></a>

<a name="1294381"></a>

<a name="1294382"></a>

<a name="1294383"></a>

<a name="1294386"></a>

<a name="1294387"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here, I'll send photo.<br><br><img src="http://www.writerscafe.org/uploads/rte/61f4e6cdc5c66e680e20fda8dfe255e3.png"><br><br>You can see it's attempting to draw off the edge of the screen.<br><br>...<br><br>Found problem. I was running in DEBUG mode. Disabling debug and it runs.<br><br>Does it just draw the Google circle ? That is all I'm receiving here.<br><br>If it's all the same with you, let's work on the QUADS and find out how to get a proper 3D stretch effect, Mode 7, as you said. <br><br></td></tr></table><br>
<a name="1294385"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Odd that it gives debug error, something slipped by me for sure. <br><br>By the way, this is how it should look like;<br><br><img src="http://s2.postimg.org/s9s6q61ix/pic.png"> <br><br></td></tr></table><br>
<a name="1294388"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> It does in your first code, Casaber. But how to make a trapezoid for a good 3D effect ? That's the ticket.<br><br><img src="http://img.photobucket.com/albums/v226/ccoa0/mode7.png"><br><br>Gotta run, BBL. <br><br></td></tr></table><br>
<a name="1294409"></a>

<a name="1294410"></a>

<a name="1294411"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thinking alloud now..<br><br>I guess you could change the ortho perspective temporarily and use<br>"X-plane" and "Q coordinates"  which uses extra coordinates that's not actually used and just thrown away. That's all 3d mumbo jumbo to me  right now. But I have no problem to dive into that if I feel that's the ticket. I guess that's the GLUperspective way. But it does not seem to be a perfect solution it only looks very similiar it. There's probably a way to make it correct, or it might simply be "good enough". It seem to be a common solution.<br><br>Then you could use shader..<br><a href="http://glslsandbox.com/e#26532." target="_blank">http://glslsandbox.com/e#26532.</a><br><br>..or you could use a tehcnique which uses affine and do it line by line. This is the one I´m leaning towards. Think ripping apart an image and stretch each line or chunk of an image into a new image <br>(which then becomes the map from an birds point of view, or a parallal looking floor) <br><br></td></tr></table><br>
<a name="1294416"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm back, nice Sunday. trying your link. That's some amazingly small code. Not sure how that would get converted. But no, not a checkerboard. Just tilting a single image - that to start with. <br><br></td></tr></table><br>
<a name="1294419"></a>

<a name="1294420"></a>

<a name="1294421"></a>

<a name="1294422"></a>

<a name="1294423"></a>

<a name="1294424"></a>

<a name="1294425"></a>

<a name="1294426"></a>

<a name="1294427"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> If you do it with shaders, the procedure would be to have shader that processes textures, and throwing them with correct perspective onto quads. But that's not interesting yet.<br><br>It's just one of many possible shaders later. That's not where I am now.<br><br>I wanted something more simple but ya, I got back to pixelling for a few secs to try to grasp this.<br>I found a simpler model (the one on the forum is nice, it is complex though)  I found something simpler. I have to play with it to unsderstand it as it uses negative coordinates and my heads spins when I think about that. 0,0 is the centre of the screen.<br><br>The PIXELWRITE line in use, is a 1:1 pixel copy transformation with only offset. (press left mouse button)<br><br>The commented line is the one I need to get working to get more than offset (projection, scale, rotation)<br>but i cant get it to work just yet. It's supposedly a working algorithm and it is the same as the shader one. By the same author at least. And it is refreshingly simple I like it, I would love to get this working as soon as I can.<br><br>I thought I'll throw it out here as It's bedtime. It was a good few hours of head scratching I dislike that I didn't any immediete results. These things takes time to learn correctly.<br><br>You see where I´m in the middle of trying to keep the values inside the box (with ABS and MOD) but it still crashes.. I dont´know..<br><pre class=code>

Graphics 800,600
tile:TPixmap = LoadPixmap(LoadBank("http::epicwallpapers.com/file/154/600x338/16:9/the-world-map-from-legend-of-zelda-links-awakening_8743972.png"))
buffer = CreatePixmap (800,600,PF_RGBA8888)
Local horizon:Float , fov:Float , px:Float , py:Float , pz:Float , scaling:Float, x:Float , y:Float
Local sx:Float , sy:Float , xres:Float , yres:Float = 512 , xoff:Float = 512, yoff:Float , angle:Float

Repeat
Cls
'For y = -yres/2 To y &lt; yres/2 ; For x = -xres/2 To x &lt; xres/2
For y = -256 To 256 ; For x = -256 To 256
      horizon = 20 ; fov = 200 ; px = x ; py = fov ; pz = y + horizon ; sx = px / pz ; sy = py / pz ; scaling = 100
      newsx = sx*Cos(angle)-sy*Sin(angle) ; newsy = sx*Sin(angle)+sy*Cos(angle) ' When rotation is wanted aswell

      WritePixel(buffer,256+x ,256+y,ReadPixel(tile,256+((x+xoff) Mod 256),256+y Mod 256)) 

    ' WritePixel(buffer,256+x, 256+y,ReadPixel(tile,256+   ((Abs(sx*scaling+xoff)) Mod 256) , 256+ ((Abs(sy*scaling+yoff)) Mod 256)  ))

Next ; Next
If MouseDown(1) Then xoff=xoff+1
DrawPixmap buffer,0,0
Flip
Until MouseDown(2)
</pre> <br><br></td></tr></table><br>
<a name="1294428"></a>

<a name="1294443"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm getting a crash here on that code, Casaber.<br><br><b>Unhandled Exception:Pixmap coordinates out of bounds</b><br><br>Here's a tilter I made sometime ago. It's not perfect but it does work. This uses your map image.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' David's nifty little Tilter (01-18-16) - needs work
Strict
Global x,y,i
Global img:TImage=LoadImage(LoadBank("http::epicwallpapers.com/file/154/600x338/16:9/the-world-map-from-legend-of-zelda-links-awakening_8743972.png"))
Graphics 1024,768
For i=0 To 383
  SetScale .5+i/1024.0,1
  SetViewport 0,192+i,1024,1
  DrawImage img,384-i/4.0,192
Next
Flip
WaitKey
</textarea> <br><br></td></tr></table><br>
<a name="1294444"></a>

<a name="1294445"></a>

<a name="1294446"></a>

<a name="1294447"></a>

<a name="1294448"></a>

<a name="1294449"></a>

<a name="1294450"></a>

<a name="1294451"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Your using setviewport as a clipper to get lines out instead of Drawsubimage I LOVE THAT. Actually Viewport is really cheap nowadays so I might pick up on that for some occasion.<br>My attempt to convert the Bmax code is just a big crash at the moment ya, I know I posted it anyway becuase the algorithm is so damn visible and It might give some inspiration to others while I´m working on it.<br><br>I like yours. I wonder if that could be used somehow to animate it within that trapezoid doing a fly by or something.<br>I was thinking to convert your scale + setviewport into a DrawsubImagerect, which scales a source rectangle out of an image onto the screen within a ceretain rectangle, scaling it to fit.<br><br>DrawSubImageRect img,   x,y,w,h,    x,y,w,h<br>But my brain began to seriosly hurt. You have a gift far superior than anything I´ve never EVER seen in making graphical solutions.<br><br><br>Fly by ^^ <br><pre class=code>
' David's nifty little Tilter (01-18-16) - needs work
Strict
Global x,y,i
Global img:TImage=LoadImage(LoadBank("http::epicwallpapers.com/file/154/600x338/16:9/the-world-map-from-legend-of-zelda-links-awakening_8743972.png"))
Graphics 1024,768

Repeat
Cls
For i=0 To 383
  SetScale .5+i/1024.0,1
  SetViewport 0,192+i,1024,1
  DrawImage img,(384+x)-i/4.0,(192+y)
Next
x=x+0 ; y=y +1 
Flip
Until MouseDown(1)


</pre> <br><br></td></tr></table><br>
<a name="1294452"></a>

<a name="1294453"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Pretty cool fly by, Casaber. But yes, you can see watching the animation that merely tilting the horizontal axis solely does not in any way merit Mode 7.<br><br><b>Your using setviewport as a clipper to get lines out instead of Drawsubimage I LOVE THAT.</b><br><br>I started messing with SetViewport really about a year ago. Setting it smaller than an image size shows only the portion you reveal. I thought I could do something interesting with that.<br><br>Now, if REAL math could get involved in the vertical and start to close up the top of it, it just MIGHT become true 3D without the need for quads.<br><br><b>You have a gift far superior than anything I´ve never EVER seen in making graphical solutions.</b><br><br>Well thank you ! :) That's very kind of you. Sometimes the simplest solutions are the right ones.<br><br>I'll always be an old-school programmer I'm afraid though. Not really ready for TYPE or OBJECT ORIENTED programming, and yet - I still get manage to squeak by.<br><br>Slight variation to erase trail:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' David's nifty little Tilter (01-18-16) - needs work
Strict
Global x,y,i
Global img:TImage=LoadImage(LoadBank("http::epicwallpapers.com/file/154/600x338/16:9/the-world-map-from-legend-of-zelda-links-awakening_8743972.png"))
Graphics 1024,768

Repeat
Cls
For i=0 To 383
  SetScale .5+i/1024.0,1
  SetViewport 0,192+i,1024,1
  DrawImage img,(384+x)-i/4.0,(192+y)
  SetColor 0,0,0
  DrawLine 0,192+y-1,2048,192+y-1
  SetColor 255,255,255
Next
x=x+0 ; y=y +1 
Flip
Until MouseDown(1)
</textarea> <br><br></td></tr></table><br>
<a name="1294455"></a>

<a name="1294456"></a>

<a name="1294457"></a>

<a name="1294458"></a>

<a name="1294462"></a>

<a name="1294463"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just got life in the code, still very "buggy" but it seem to work. Well starting to..<br><pre class=code>
Graphics 800,600
tile:TPixmap = LoadPixmap(LoadBank("http::epicwallpapers.com/file/154/600x338/16:9/the-world-map-from-legend-of-zelda-links-awakening_8743972.png"))
buffer = CreatePixmap (800,600,PF_RGBA8888)
Local horizon:Float , fov:Float , px:Float , py:Float , pz:Float , scaling:Float, x:Float , y:Float
Local sx:Float , sy:Float , xres:Float , yres:Float = 512 , xoff:Float = 512, yoff:Float , angle:Float

Repeat
Cls
'For y = -yres/2 To y &lt; yres/2 ; For x = -xres/2 To x &lt; xres/2
For y = -256 To 256 ; For x = -256 To 256
      horizon = 20 ; fov = 200 ; px = x ; py = fov ; pz = y + horizon ; sx = px / pz ; sy = py / pz ; scaling = 100
      newsx = sx*Cos(angle)-sy*Sin(angle) ; newsy = sx*Sin(angle)+sy*Cos(angle)

   '  WritePixel(buffer,256+x ,256+y,ReadPixel(tile,256+((x+xoff) Mod 256),256+y Mod 256)) 

     WritePixel(buffer,256+x, 256+y,ReadPixel(tile,0+   ((Abs(newsx*scaling+xoff)) Mod 256) , 0+ ((Abs(newsy*scaling+yoff)) Mod 256)  ))

Next ; Next
angle = angle +1 
If MouseDown(1) Then xoff=xoff+1
DrawPixmap buffer,0,0
Flip
Until MouseDown(2)

</pre><br><br>EDIT did some work with the Quad now, it uses fixed coordinates right now, but it might be correct perspective<br>I will try get time later this week to open the Openg book and read up on texture correction and related guff.<br><br><pre class=code>

' Init Graphics ------------------------------------------------------------------------------------
Global xres:Int = DesktopWidth() ; yres:Int = 1080 ; SetGraphicsDriver GLMax2DDriver(),0 ' Add the 0 when you want to use frontbuffer directly instead of backbuffer
' It Seem To give about 30% additional performance without tearing And making the difference from 30 fps And 60 fps at 
' times especially in windowed mode where opengl is weaker than,fullscreen are given a boost aswell.
xres=800 ; yres = 600 ; Graphics xres,yres,0,60,GRAPHICS_BACKBUFFER + GRAPHICS_DEPTHBUFFER ; glewinit ; AutoImageFlags MASKEDIMAGE 

' Load Images --------------------------------------------------------------------------------------
exampleimage:TImage = LoadImage(LoadBank("http::icons.iconarchive.com/icons/google/chrome/64/Google-Chrome-icon.png")) ; If Not exampleimage Then RuntimeError "Unable to download file" ; End

Cls 
DrawImage exampleimage,0,0
DrawQuad exampleimage,32,32,350,64,512,380,32,318
glflush ; Flip ; WaitKey
End

Function DrawQuad(tex:TImage,x0:Float,y0:Float,x1:Float,y1:Float,x2:Float,y2:Float,x3:Float,y3:Float)
id = TGLImageFrame(tex.frame(0)).name ; glEnable GL_TEXTURE_2D ; glBindTexture GL_TEXTURE_2D,id

glBegin GL_TRIANGLES
glTexCoord4f 0,0,0,600-500 ; glVertex2f 500,200				' Top Left (Triangle 1 starts here)
glTexCoord4f 0,1000-50,0,1000-50 ; glVertex2f 50,700		' Bottom Left
glTexCoord4f 1000-50,1000-50,0,1000-50 ; glVertex2f 1000,700	' Bottom Right
glTexCoord4f 1000-50,1000-50,0,1000-50 ; glVertex2f 1000,700	' Bottom Right (Triangle 2 starts here)
glTexCoord4f 600-500,0,0,600-500 ; glVertex2f 600,200		' Top Right
glTexCoord4f 0,0,0,600-500 ; glVertex2f 500,200				' Top Left
glEnd

Rem Old
glBegin GL_QUADS
glTexCoord2f 0.0,0.0 ; glVertex2f x0,y0
glTexCoord2f 1.0,0.0 ; glVertex2f x1,y1
glTexCoord2f 1.0,1.0 ; glVertex2f x2,y2
glTexCoord2f 0.0,1.0 ; glVertex2f x3,y3
glEnd
EndRem

glDisable GL_TEXTURE_2D
End Function
</pre><br><br><pre class=code>
' Init Graphics ------------------------------------------------------------------------------------
Global xres:Int = DesktopWidth() ; yres:Int = 1080 ; SetGraphicsDriver GLMax2DDriver(),0 ' Add the 0 when you want to use frontbuffer directly instead of backbuffer
' It Seem To give about 30% additional performance without tearing And making the difference from 30 fps And 60 fps at 
' times especially in windowed mode where opengl is weaker than, fullscreen are given a boost aswell.
xres=800 ; yres = 600 ; Graphics xres,yres,0,60,GRAPHICS_BACKBUFFER + GRAPHICS_DEPTHBUFFER ; glewinit ; AutoImageFlags MASKEDIMAGE 

' Load Images --------------------------------------------------------------------------------------
exampleimage:TImage = LoadImage(LoadBank("http::icons.iconarchive.com/icons/google/chrome/64/Google-Chrome-icon.png")) ; If Not exampleimage Then RuntimeError "Unable to download file" ; End

Cls 
DrawImage exampleimage,0,0
DrawQuad exampleimage,32,32,350,64,512,380,32,318
glflush ; Flip ; WaitKey
End

Function DrawQuad(tex:TImage,x0:Float,y0:Float,x1:Float,y1:Float,x2:Float,y2:Float,x3:Float,y3:Float)
id = TGLImageFrame(tex.frame(0)).name ; glEnable GL_TEXTURE_2D ; glBindTexture GL_TEXTURE_2D,id
glBegin GL_QUADS

' probably this one is the correct one
glTexCoord3f 0,0,0 ; glVertex3f x0,y0,0
glTexCoord3f 0,1,0 ; glVertex3f x1,y1,0
glTexCoord3f 1,1,0 ; glVertex3f x2,y2,0
glTexCoord3f 1,0,0 ; glVertex3f x3,y3,0

' glTexCoord3f 0,0,0 ; glVertex3f x0,y0,0
' glTexCoord3f 0,1,0 ; glVertex3f x1,y1,0
' glTexCoord3f 1,1,0 ; glVertex3f x2,y2,0
' glTexCoord3f 0,1,0 ; glVertex3f x3,y3,0 

glEnd
glDisable GL_TEXTURE_2D
End Function
</pre> <br><br></td></tr></table><br>
<a name="1294465"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> No it´s still very much like a folding paper. They behave like  2 triangles.<br><br>I will declare this to be a problem of its own. I didn't anticipate warping to be a problem. I´ve done this 25+ years ago but I can´t remember one thing of it. <br><br></td></tr></table><br>
<a name="1294466"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> I might do the Shader just to get an easy way out of it, but I really hate to leave this problem behind. I want to solve this. <br><br></td></tr></table><br>
<a name="1294469"></a>

<a name="1294470"></a>

<a name="1294471"></a>

<a name="1294472"></a>

<a name="1294473"></a>

<a name="1294474"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> <pre class=code>
' Init Graphics ------------------------------------------------------------------------------------
Global xres:Int = DesktopWidth() ; yres:Int = 1080 ; SetGraphicsDriver GLMax2DDriver(),0 ' Add the 0 when you want to use frontbuffer directly instead of backbuffer
' It Seem To give about 30% additional performance without tearing And making the difference from 30 fps And 60 fps at 
' times especially in windowed mode where opengl is weaker than, fullscreen are given a boost aswell.
xres=800 ; yres = 600 ; Graphics xres,yres,0,60,GRAPHICS_BACKBUFFER + GRAPHICS_DEPTHBUFFER ; glewinit ; AutoImageFlags MASKEDIMAGE 

Global trap_wide:Float = 600 ; Global trap_narrow:Float = 300 ; Global Midd:Float = 320

' Load Images --------------------------------------------------------------------------------------
exampleimage:TImage = LoadImage(LoadBank("http::icons.iconarchive.com/icons/google/chrome/64/Google-Chrome-icon.png")) ; If Not exampleimage Then RuntimeError "Unable to download file" ; End
Local qx0:Float = 0.0,qy0:Float = 64.0 , qx1:Float =100.0,qy1:Float = 100.0 , qx2:Float = 640.0,qy2:Float = 512.0 , qx3:Float = 0.0,qy3:Float = 320.0

Repeat
Cls
' DrawImage exampleimage,0,0
DrawQuad exampleimage,qx0,qy0,qx1,qy1,qx2,qy2,qx3,qy3

trap_wide = MouseX()
glflush ; Flip
Until MouseDown(1)

Function DrawQuad(tex:TImage,x0:Float,y0:Float,x1:Float,y1:Float,x2:Float,y2:Float,x3:Float,y3:Float)
id = TGLImageFrame(tex.frame(0)).name ; glEnable GL_TEXTURE_2D ; glBindTexture GL_TEXTURE_2D,id
glMatrixMode GL_PROJECTION ; glLoadIdentity ; glOrtho 0,640,0,480,1,1000 ; glMatrixMode GL_MODELVIEW ; glLoadIdentity
glBegin GL_TRIANGLE_STRIP ' ; glColor3f 1,1,-1

' HARDCODED WORKING EXAMPLE THAT MIGHT HELP UNDERSTAND HOW TO DO IT
' COMMENTED LINES ARE 2d COORDINATES
' THE 2 LINES UNDERNETH EACH COMMENT ARE PROJECTIVE COORDINATES THAT NEEDS TO BE SOMEHOW CALCUALTED PROGRAMTICALLY

' Correct trapzoid (but 4 hardcoded coordinates) 

' glTexCoord4f 0,0,0,1   &lt; 2d coordinate
glTexCoord4f 0,0,0,trap_wide ; glVertex3f Midd - trap_wide/2,10,-10 ' &lt; magically calculated projection coordinate from that 2d coordinate..

' glTexCoord4f 1,0,0,1
glTexCoord4f trap_narrow,0,0,trap_narrow ; glVertex3f Midd - trap_narrow/2,470,-10

' glTexCoord4f 0,1,0,1
glTexCoord4f 0,trap_wide,0,trap_wide ; glVertex3f Midd + trap_wide/2,10,-10

' glTexCoord4f 1,1,0,1
glTexCoord4f trap_narrow,trap_narrow,0,trap_narrow ; glVertex3f Midd + trap_narrow/2,470,-10

glEnd
glDisable GL_TEXTURE_2D
End Function
</pre> <br><br></td></tr></table><br>
<a name="1294476"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> I´m thinking.. this now. <br><br>As 2 triangles are so inseparatble when warping perspectives. Let's not have two but one for a sprite. And cut the edges instead. <br><br>This will also demand some serious downtime with openg few weeks from nowl. But I like the idea.<br><br><img src="http://s15.postimg.org/lzqafc2sb/Namnlo_st.png"> <br><br></td></tr></table><br>
<a name="1294477"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> Or one could skip the idea of quads until all shaders are coming along nicely?<br><br>Maybe that's a good idea to NOT have quads for awhile. I would really like that.<br>One could have software quads, easy peasy,  they are fast enough for Nintendo graphics and then some.<br><br>And we may have shader quads soon enough, but let's not have these triangular problems.<br>The solutions are ugly and old, soon non-existent, They seem to be shaders underneath the surface anyway so nothing is lost. <br><br></td></tr></table><br>
<a name="1294553"></a>

<a name="1294561"></a>

<a name="1294562"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> I wanted to see If I could learn some Monkey while at it, and convert something. Almost there. Very nice. <br><br><pre class=code>

' Simple Mode 7 (buggy conversion from Monkey)

Local XRes:Float = 640 , YRes:Float = 480 , YLines:Float = 240 , X:Float = 930 , Y:Float = 700 , Height:Float = 32 , r:Float = 90-45 , HFOV:Float = 60 , VFOV:Float = 45
Local vas:Float[Ylines] , vd:Float[Ylines] , VScale:Float[Ylines] , VDelta:Float = VFOV / YLines , va:Float = VDelta , hl:Float
Local camd:Float , camx:Float , camy:Float , cosine:Float , sine:Float , xhit:Float , yhit:Float , xpos:Float , ypos:Float

For a = 0 To YLines-1 ; vas[a] = va ; vd[a] = Height / Tan(vas[a]) ; hl = (vd[a]*Tan(HFOV)) * 2 ; VScale[a] = (1024/hl) * (1024/XRes) ; va = va + VDelta ; Next

SetGraphicsDriver GLMax2DDriver(),0 ; Graphics xres,yres,0,60,GRAPHICS_BACKBUFFER + GRAPHICS_DEPTHBUFFER ; glewinit ; AutoImageFlags MASKEDIMAGE 

Local map:TImage = LoadImage(LoadBank("http::epicwallpapers.com/file/154/600x338/16:9/the-world-map-from-legend-of-zelda-links-awakening_8743972.png"))
mapw = ImageWidth(map) ; maph = ImageHeight(map)

Repeat

If MouseDown(1) Then x = x + Cos(r) * 2 ; y = y + -Sin(r) * 2 ; r = r- ((MouseX() - (xres/2.0)) / xres)*2
x = x + (KeyDown(KEY_UP)-KeyDown(KEY_DOWN)) * Cos(r) * 4
y = y + (KeyDown(KEY_UP)-KeyDown(KEY_DOWN)) * -Sin(r) * 4
r = r - (KeyDown(KEY_RIGHT) - KeyDown(KEY_LEFT)) * 2
			
camd = Tan(22.5) * Height * 5 ; camX = X - (camd * Cos(r)) ; camY = Y - (camd * -Sin(r)) ; camDir = r ; cosine = Cos(camDir) ; sine = -Sin(camDir) ' Cam pos

For a = 8 To YLines-1 Step 1
	XHit = camX + (Cosine*vd[a]) ; yhit = camY + (Sine*vd[a]) ; xpos = XHit Mod mapw ; ypos = YHit Mod maph
	If XHit &lt; 0 Then xpos = 1024-xpos
	If YHit &lt; 0 Then ypos = 1024-ypos
	
    ' Clip, rotate, scale, translate before drawing
 	  SetViewport 0,yres/2+a,xres,1 ' CLIP
      SetHandle xpos,ypos '(MOVE) ''  SetImageHandle map,xpos,ypos '(MOVE)
    ' Translate xres/2,240+a ' TRANSLATE (another MOVE)
      SetRotation -(camDir-90) ' ROTATE
      SetScale VScale[a],VScale[a] ' SCALE 
    ' DrawImage map,xres/2,240+a ' TRANSLATE IS INBUILT HERE NOW
	  TileImage map,0,0,0
Next

SetViewport 0,0,xres,yres
Flip
Until MouseDown(2)

' Replacement for the inbuilt TILEIMAGE which otherwise ignores current SCALE and ROTATION settings.
Function TileImage(image:TImage, x:Float=0# ,y:Float=0#, frame:Int=0)
    Local scale_x#, scale_y#
    GetScale(scale_x#, scale_y#)
    Local viewport_x%, viewport_y%, viewport_w%, viewport_h%
    GetViewport(viewport_x, viewport_y, viewport_w, viewport_h)
    Local origin_x#, origin_y#
    GetOrigin(origin_x, origin_y)
    Local handle_X#, handle_y#
    GetHandle(handle_X#, handle_y#)
    Local image_h# = ImageHeight(image)
    Local image_w# = ImageWidth(image)
    Local w#=image_w * Abs(scale_x#)
    Local h#=image_h * Abs(scale_y#)
    Local ox#=viewport_x-w+1
    Local oy#=viewport_y-h+1
    origin_X = origin_X Mod w
    origin_Y = origin_Y Mod h
    Local px#=x+origin_x - handle_x
    Local py#=y+origin_y - handle_y
    Local fx#=px-Floor(px)
    Local fy#=py-Floor(py)
    Local tx#=Floor(px)-ox
    Local ty#=Floor(py)-oy
    If tx&gt;=0 tx=tx Mod w + ox Else tx = w - -tx Mod w + ox
    If ty&gt;=0 ty=ty Mod h + oy Else ty = h - -ty Mod h + oy
    Local vr#= viewport_x + viewport_w, vb# = viewport_y + viewport_h
    SetOrigin 0,0
    Local iy#=ty
    While iy&lt;vb + h
        Local ix#=tx
        While ix&lt;vr + w
            DrawImage(image, ix+fx,iy+fy, frame)
            ix=ix+w
        Wend
        iy=iy+h
    Wend
    SetOrigin origin_x, origin_y
End Function
</pre><br><br>Original .Monkey<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Rem
Original Monkey code included
Import mojo
Import tileimage

Class Mode7 Extends App

	'Horizontal and Vertical resolution
	Const XRes = 640
	Const YRes = 480
	
	'The number of Horizontal Lines to draw
	Const YLines = 240

	Field ImgTrack:Image
	Field ImgSky:Image
	Field ImgMario:Image
	
	'Starting camera positions. Height is fixed so angles can be precalculated.
	Field X:Float = 930
	Field Y:Float = 700
	Field Height:Float = 32
	Field Rotation:Float = 90-45
	
	'Field of view data
	Field HFOV = 60
	Field VFOV = 45
	Field VAngles:Float[]
	Field VDist:Float[]
	Field VScale:Float[]
	
	Method OnCreate ()
	
		ImgTrack = LoadImage("track.png",1)
		ImgSky = LoadImage("sky.png",1)
		ImgMario = LoadImage("mario.png",1,Image.MidHandle)
		
		'Precalcuate the angles
		VAngles = New Float[YLines]
		VDist = New Float[YLines]
		VScale = New Float[YLines]
		Local VDelta:Float = VFOV / float(YLines)
		Local VAngle:Float = VDelta
		
		For Local a = 0 to YLines-1
		
			'The angle for Horizontal Line A
			VAngles[a] = VAngle
			
			'The distance across the screen for that Horizontal Line
			VDist[a] = Height / Tan(VAngles[a])
			Local HorizontalLineDistance:Float = (VDist[a]*Tan(HFOV))*2		
			
			'Finally, the scale of that Horizontal Line
			VScale[a] = (1024/Float(HorizontalLineDistance)) * (1024/float(XRes))
			VAngle += VDelta
			
		Next
		
		SetUpdateRate 60

		
	End

	Method OnUpdate ()
	
		'Mouse control
		If(MouseDown(MOUSE_LEFT))
			X += Cos(Rotation) * 2
			Y += -Sin(Rotation) * 2
			Rotation -= ((MouseX()-(XRes/2.0))/float(XRes))*2
		Else
		'Keyboard control
			X += (KeyDown(KEY_UP)-KeyDown(KEY_DOWN)) * Cos(Rotation) * 4
			Y += (KeyDown(KEY_UP)-KeyDown(KEY_DOWN)) * -Sin(Rotation) * 4
			Rotation -= (KeyDown(KEY_RIGHT) - KeyDown(KEY_LEFT))*2
		EndIf

		
	End

	Method OnRender ()
	
		SetTile ImgTrack

		Cls
		
		'Position the camera behind the player's kart
		local cameraDistance:Float = Tan(22.5) * Height * 5
		local cameraX:Float = X - (cameraDistance * Cos(Rotation))
		Local cameraY:Float = Y - (cameraDistance * -Sin(Rotation))
		
		DrawMode7(cameraX,cameraY,Rotation)
		
		'Draw Mario statically on the screen.
		DrawImage ImgMario,XRes*0.5,YRes*0.75,0,2,2
		
		
	End
	
	Method DrawMode7(CameraX:Float,CameraY:float,CameraDir:Float)
		
		'Precalculate the cosine and sine angles for the camera direction
		Local cosine:Float = Cos(CameraDir)
		Local sine:Float = -Sin(CameraDir)
	
		DrawImage ImgSky,0,0,0,Float(XRes)/640.0,Float(YRes)/480.0
		
		For Local a = 8 to YLines-1 step 1
			
			'Detect the X and Y location in the 3D world where the ray hit
			Local XHit:Float = CameraX + (cosine*VDist[a])
			Local YHit:Float = CameraY + (sine*VDist[a])
			
			Local xpos = XHit mod ImgTrack.Width()
			Local ypos = YHit mod ImgTrack.Height()
			if(XHit&lt;0) xpos = 1024-xpos
			if(YHit&lt;0) ypos = 1024-ypos
			
			'Draw only this single line
			SetScissor(0,YRes/2+a,XRes,1)
			
			'Position, scale and rotate the image to draw on screen
			ImgTrack.SetHandle(xpos,ypos)
			
			
						
			'DrawImage ImgTrack,XRes/2,240+a,-(CameraDir-90),VScale[a],VScale[a]
			
			PushMatrix()
			
			Translate XRes/2,240+a
			Rotate -(CameraDir-90)
			Scale VScale[a],VScale[a]
			
			TileImage ImgTrack,0,0,0
			
			PopMatrix()
			
			
		Next
	
		SetScissor(0,0,XRes,YRes)
		
	End

End

Function Modf:Float( a:Float, n:Float )
  Local ret:Float = a - n * Floor( a / n )
  Return ret
End Function

Function Main ()
	New Mode7
End
EndRem

</textarea> <br><br></td></tr></table><br>
<a name="1294554"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is how the Nintendo did it in hardware. Changing offset, rotation and scaling per scanline, it also matches nicely <br>what is good practice with modern GPU's. It's the perfect match and, It's simple.<br><br>Not bugfree yet though, not that simple. <br><br></td></tr></table><br>
<a name="1294565"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> You definitely got something going on there, Casaber. I'll mention this in the hopes it helps. Not trying to promote another programming language. There is however one called B4GL or as some people call it BAGEL. It is geared very heavily for 3D but misses a lot of the good and powerful functions BlitzMAX has (otherwise I would be there instead of here).<br><br>I'll post one of its demos and source for you.<br><br><a href="https://www.mediafire.com/?7a1dds7d8rjszup" target="_blank">https://www.mediafire.com/?7a1dds7d8rjszup</a> <br><br></td></tr></table><br>
<a name="1294587"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> @dw817 what features do you miss from the other BASIC's you´ve used? is there some certain things that are important? What do you find BMax lacks?<br><br>About the Mode7 and graphics-wwise me tell you graphics is about covered since few last days. This is just for fun and learning Bmax and Monkey mainly, I thought Mode7 would be fun. It's one of those things I´ve always wanted to do myself from the ground up. I´ve seen numrous implementations. But this one is the best think, It's very close to yours actually as you might noticed. You did it very SNES like. <br><br></td></tr></table><br>
<a name="1294590"></a>

<a name="1294591"></a>

<a name="1294592"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> It's the other way around, Casaber. BlitzMAX has just about everything I need. Almost. There are a few things that are pretty advanced I could do in GFA that I don't think you can do in BlitzMAX. Not easily anyways.<br><br>No, I was saying that B4GL has some serious limitations that make it unusable for my code.<br><br>The first of which is the ability to have controls like you can do in MaxGUI. No, you can only make graphic screens. No ability to INCBIN any data, you must use a DLL just to have any audio, and it definitely has no ability to access the Internet or load any files from the Internet either.<br><br>It truly is a game programming language - and not much more.<br><br>BlitzMAX on the other hand has been shining through many interesting types of ways to express itself. No, it is with BlitzMAX I will make my home.<br><br>As for Mode 7, I think the best example you will see of this is Nintendo's shining and epic 3D racer, "F-Zero."<br><br><a href="https://www.youtube.com/watch?v=BIe4AvKLSa4" target="_blank">https://www.youtube.com/watch?v=BIe4AvKLSa4</a> <br><br></td></tr></table><br>
<a name="1294593"></a>

<a name="1294595"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> I tried to convert that Mode7 bc it looked good what I saw and it even had that simple Quad that I did at first And yet it was perspectiv correctly, I was half right. 3D is not my area, and this is the perfect entrance now. Just starting touching it abit.<br><br>I failed to convert everything so it won´t even run, it was close though. I think I know what's missing, the knowledge of matrixes. I should not even try to grasp that just yet.<br>It was interesting to see that old quad there though in all its glory.<br><br><br><pre class=code>
Local camera:Float[3*3] , temp:Float[3] , x:Float , y:Float , xaxis:Float , yxais:Float , speed:Float = 0.02 
camera = MatrixTranslate 0,5,0

Repeat
    glClear GL_DEPTH_BUFFER_BIT + GL_COLOR_BUFFER_BIT
    glLoadMatrixf RTInvert(camera)

    For x = -10 To 10
        For y = -10 To 10
            glPushMatrix
            glTranslatef x*3,0,y*3
            glBegin GL_QUADS
                glColor3f 1,0,0) ; glVertex2f  1,3
                glColor3f 0,1,0) ; glVertex2f -1,3
                glColor3f 0,0,1) ; glVertex2f -1,0
                glColor3f 1,1,1) ; glVertex2f  1,0
            glEnd
            glPopMatrix
        Next
    Next

    Flip  
    
    While SyncTimer(10)
        camera(3) = camera(3) + -camera(2) * speed
        xaxis = -MouseX() * 30
        yaxis =  MouseY() * 30
        If KeyDown(KEY_LEFT)  Then xaxis =  1
        If KeyDown(KEY_RIGHT) Then xaxis = -1
        If KeyDown(KEY_UP)    Then yaxis = -1
        If KeyDown(KEY_DOWN)  Then yaxis =  1


        camera = camera * MatrixRotateZ (xaxis) * MatrixRotateX (yaxis)
        temp = camera(3)
        camera(3) = vec4 (0,0,0,1)
        camera = MatrixRotateY (camera# (0)(1)) * camera
        camera(3) = temp
        camera = Orthonormalize (camera)

    Wend
Forever
</pre> <br><br></td></tr></table><br>
<a name="1294594"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ya F-zero is really nice, also Zelda I intenesly remember seeing those for the first time, it was.. just magic. I adds something special to the games. I hope the upcoming bug fix will make a really nice implementation of MODE 7.<br><br>The next step would to be throw a CRT shader ontop of it. And you got that true retro look. <br><br></td></tr></table><br>
<a name="1294598"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ah now you're pushing it, Casaber. What I really like is a filter called 2xSal (Kreed). As it is there are only 2 filters BlitzMAX has for cleaning up graphics, dithered and not.<br><br>But with an emulator like ZSNES and other game emulators, you have quite a few selections available.<br><br><img src="http://www.writerscafe.org/uploads/rte/bb7422264a4470b9b7e757ce9a119350.png"><br><br><a href="https://en.wikipedia.org/wiki/Image_scaling" target="_blank">https://en.wikipedia.org/wiki/Image_scaling</a> <br><br></td></tr></table><br>
<a name="1294601"></a>

<a name="1294602"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> I must tell you in before hand, I got the most amazing speed out of those old pixel code, actually you could do probably it all using CPU (at least some of those). And still have time.<br><br>I got 25 320x240 writes, 25 reads of 320x240 screens so far, with few shaders ontop and offlinebuffers with static pixels, and pushing everything on opengl single (non double buffered)  screen .<br><br>Double buffered works equally well but I seem to push 30% more power when single buffering.<br>Alpha rotation and scale seem to work when you want to throw your offline canvases on the screen (no cost essentially).<br><br>So you could stretch low resolutions. And you could draw using any image and any primtive and read it back as pixels (all gpu and with alpha rotation blending), do something with the cpu.<br>I only need to setup  a few standard shaders now, and add stencil/depth support (I really want that I´m not sure for what yet but it will do much good).<br><br><br>But this time I  want to give it time to mature and give out something with quality.<br><br>(I´m often to eager and throw out my code too fast) <br><br></td></tr></table><br>
<a name="1294603"></a>

<a name="1294607"></a>

<a name="1294608"></a>

<a name="1294609"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> For example.. If you use just a single of all your offline buffer as a screen-sized (or bigger) then you have a backbuffer for doublebufferin on your very own, one that you may clear only when you like it. <br><br>And it won't be a misseehving backbuffer that you hope works on all machines, but a true buffer that does its job on each and every machine quick and easy.<br><br>About that CRT shader it will actually be a color mask where you could use those older style palettes (I will reuse that mask for a GLOW/BLOOM shader which uses that palette remapper to pick out lighter colors that you would want to glow). So  it will actually be CRT/GLOW/Palette shader. Multipurpose :) <br><br>I forgot !! one of  my favorite shaders I'm thinking is something like this (not the bending though, don´t like that so much , but the style otherwise, imagine having a crispness setting and the like you know? ya.. Really nice). It got big, you should view it from about a mile to appriciate it.<br><img src="http://www.superretro16.com/Userfiles/Blog/crt-example-01.png"><br><br>But I have big hopes for this, it makes BMax a fun language to use.<br><br>I really start to enjoy programming again, and I guess that's my little baby haha.<br>It´s a shame it takes abit of time to unwind and get into the mood. I need a few good hours each time to get something sensible done.<br><br>Anyways hope your weekend treated you good ! :) I'll be signing off <br><br></td></tr></table><br>
<a name="1294610"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> Casaber, I can do that, the old-style CRT look ? Notta problem.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' old style CRT look
Strict
Graphics 512,448
Local img1:TImage=CreateImage(512,448)
Local img2:TImage=LoadImage(LoadBank("http::images.rapgenius.com/eaevuwz8k91gnuwlwgrdri629.256x224x1.png"))
Local c,i,j,f
SetScale 2,2
DrawImage img2,0,0
Flip
WaitKey
SetScale 1,1
img2=CreateImage(512,448)
GrabImage img2,0,0
For i=0 Until 448
  c=(i Mod 3*64)+128
  SetColor c,c,c
  DrawLine 0,i,511,i
Next
GrabImage img1,0,0
SetColor 255,255,255
For i=-512 Until 512
  Cls
  SetBlend maskblend
  DrawImage img2,i,0
  SetBlend shadeblend
  DrawImage img1,0,f Mod 2
  f:+1
  If i=0 And KeyDown(32)=0 Then i=-1
  Flip
Next
</textarea><br><br>Bedtime, c-ya on the morrow. <br><br></td></tr></table><br>
<a name="1294660"></a>

<a name="1294661"></a>

<a name="1294662"></a>

<a name="1294663"></a>

<a name="1294665"></a>

<a name="1294666"></a>

<a name="1294708"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> Rememeber that font you liked? I do that with it already. I do  a harsch scanline (black) I really enjoy that. Glow is better than anliasing I think So I rather have it harsch and/or glowing.<br><br>Wanna see? This is also a good example I think what you can to do without ANY hardware, just pixels all the way by hand.<br>EDIT About the inlined function, it's nothing, just move it if you want to, it won't mind. I was doing something. Also notice it's not optimised or anything (i even left some MOD's in there). Still runs smooth. <br><br>This is part of my little baby so be good to it ;)<br><br><pre class=code>
Global buffer:Int[128*128]
Local img2:TPixmap=LoadPixmap(LoadBank("http::s14.postimg.org/xotmro9vh/128x1282.png"))
For y=0 To 127 ; For x=0 To 127 ; buffer(x+y*128) = ReadPixel(img2,x,y) ; Next ; Next

AddHook FlipHook,irq,Null

Global fps:Int , fpstotal:Int , msstart:Float , ms:Float = MilliSecs()
Global map[4096,4096] ; For y=0 To 316 ; For x=0 To 475; map[x,y]=Rnd(127) ; Next ; Next
For temp=0 To 255 ; map[temp,0]=temp ; Next
Global cmap[4096,4096] ; For y=0 To 316 ; For x=0 To 475; cmap[x,y]=Rnd(15) ; Next ; Next
Global wx:Int , wy:Int , cx:Int , c:Int = buffer[0] , cols:Int[16]
RestoreData colors ; For temp=0 To 15 ; ReadData cols[temp] ; Next
writetomap "                                        ",0,0
writetomap "    **** COMMODORE 64 BASIC V2 ****     ",0,1
writetomap "                                        ",0,2
writetomap " 64K RAM SYSTEM  38911 BASIC BYTES FREE ",0,3
writetomap "                                        ",0,4
writetomap "READY.                                  ",0,5
writetomap "                                        ",0,4
Global xres:Int = 1280 , yres:Int = 800 , pixels:Int[xres*yres] , s:Int = 2
GLGraphics xres,yres,0,60,GRAPHICS_BACKBUFFER | GRAPHICS_DEPTHBUFFER ' Fullscreen, change 32 into 0 for windowed.
glViewport 0,0,xres,yres ; glMatrixMode GL_PROJECTION ; glLoadIdentity ; glOrtho 0,xres,yres,0,0,1 ; glPixelZoom 1,-1 ; glRasterPos2i 0,0

Repeat
For y = 0 To yres-1 Step 1 ; For x = 0 To xres-1 Step 1 ; pixels[y*xres+x] = 0 ; Next ; Next

Function readinputs()
wx=wx-s*KeyDown(KEY_LEFT)+s*KeyDown(KEY_RIGHT) ; wy=wy-s*KeyDown(KEY_UP)+s*KeyDown(KEY_DOWN) ; wx=Max(0,Min(10000,wx)) ; wy=Max(0,Min(10000,wy))
mx = MouseX() ; my = MouseY() ; xxx = (wx+mx) Sar 4 ; yyy = (wy+my) Sar 4 ; If MouseDown(1) Then map(xxx,yyy) = 42 ; cmap(xxx,yyy) = 7
End Function

readinputs ; wx=wx-s*KeyDown(KEY_LEFT)+s*KeyDown(KEY_RIGHT) ; wy=wy-s*KeyDown(KEY_UP)+s*KeyDown(KEY_DOWN) ; wx=Max(0,Min(10000,wx)) ; wy=Max(0,Min(10000,wy))
alive ' Animate tiles, colortiles, and atlas
display wx,wy,0,0,1280,800 ' Create buffer
glDrawPixels xres,yres,GL_BGRA,GL_UNSIGNED_BYTE,Pixels ' Render buffer

Delay 1 ; Flip 1
 
Until KeyHit(KEY_ESCAPE) Or AppTerminate()
End

Function alive()
For temp=1 To 16 ; buffer[Int(Rand(0,15))+Int((Rand(0,15))*128)]=$ffffffff * Int(Rand(0,1)) ; Next
cx=(cx+1) Mod 128 ; For tempy=0 To 15 ; For temp=0 To 15+32 ; buffer[16+temp+((0+tempy)*128)]=buffer[0+temp+cx+(16+tempy)*128] ; Next ; Next ; For temp=1 To 1600 ; cmap[Rnd(400),Rnd(250)]=Rnd(16) ; Next
End Function

Function display(wx,wy,ofx=0,ofy=0,sx=640,sy=400) 
scrx = wx &amp; 15 ; scry = wy &amp; 15 ; mapx = wx Shr 4 ; mapy = wy Shr 4
cnty = 0 ; For y = mapy To mapy+(sy Shr 4+1)
cntx = 0 ; For x = mapx To mapx+(sx Shr 4+1)
tilex = map(x,y) &amp; 15 ; tiley = map(x,y) Shr 4
colour = cols(cmap(x,y)) ; xx = cntx - scrx + ofx ; yy=cnty - scry + ofy
For ty = 0 To 7 ; For tx = 0 To 7
If (xx+tx+tx &gt;= ofx) And (yy+ty+ty &gt;= ofy) And (xx+tx+tx &lt; ofx+sx) And (yy+ty+ty &lt; ofy+sy).. ' Mind the steps
 And buffer[tilex Shl 3 + tx + (tiley Shl 3 + ty)*128] &lt;&gt; c Then pixels[xx+tx+tx+(yy+ty+ty)*xres] = colour 
Next ; Next
cntx = cntx+16 ; Next
cnty = cnty+16 ; Next
End Function

Function writetomap(t$,x,y)
	For tempx = 0 To Len(t$)-1 ; temp = Asc(Mid$(t$,1+tempx,1)) ; map[tempx+x,y] = temp ; cmap[tempx+x,y] = 14 ; Next
End Function

#colors
DefData $000000,$FFFFFF,$68372B,$70A4B2,$6F3D86,$588D43,$352879,$B8C76F,$6F4F25,$433900,$9A6759,$444444,$6C6C6C,$9AD284,$6C5EB5,$959595

Function irq:Object(id,data:Object,context:Object)	
	Return data
End Function
</pre> <br><br></td></tr></table><br>
<a name="1294687"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Chalky</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> That is one cool piece of code! It would make a great screensaver. <br><br></td></tr></table><br>
<a name="1294692"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> Wow, that's a crazy looking thing, Casaber. Reminds me of some screens I've seen when the APPLE used to crash when I was working on zealous machine-code. <br><br></td></tr></table><br>
<a name="1294693"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks Chalky and Dw817. You can scroll and paint in it too. It's a 16 Megabyte world. Perfect for making some platformer or shootem up :) or anything you want. <br><br></td></tr></table><br>
<a name="1294704"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#40">[#40]</a></td></tr></table></td></tr><tr ><td class="posttext"> My thumb hurts from coding today, I think it's time to rest. I´m glad that you enjoyed that piece of code.<br><br>The Mode 7 though is only halfdebugged, on the good side that means that only turns are wrong now.<br><br><pre class=code>
' Simple Mode 7 (buggy conversion from Monkey)

Local XRes:Float = 640 , YRes:Float = 480 , YLines:Float = 240 , X:Float = 930 , Y:Float = 700 , Height:Float = 32 , r:Float = 90-45 , HFOV:Float = 60 , VFOV:Float = 45
Local vas:Float[Ylines] , vd:Float[Ylines] , VScale:Float[Ylines] , VDelta:Float = VFOV / YLines , va:Float = VDelta , hl:Float
Local camd:Float , camx:Float , camy:Float , cosine:Float , sine:Float , xhit:Float , yhit:Float , xpos:Float , ypos:Float

For a = 0 To YLines-1 ; vas[a] = va ; vd[a] = Height / Tan(vas[a]) ; hl = (vd[a]*Tan(HFOV)) * 2 ; VScale[a] = (1024/hl) * (1024/XRes) ; va = va + VDelta ; Next

SetGraphicsDriver GLMax2DDriver(),0 ; Graphics xres,yres,0,60,GRAPHICS_BACKBUFFER + GRAPHICS_DEPTHBUFFER ; glewinit ; AutoImageFlags MASKEDIMAGE 

Local map:TImage = LoadImage(LoadBank("http::epicwallpapers.com/file/154/600x338/16:9/the-world-map-from-legend-of-zelda-links-awakening_8743972.png"))
mapw = ImageWidth(map) ; maph = ImageHeight(map)

Repeat
If MouseDown(1) Then x = x + Cos(r) * 2 ; y = y + -Sin(r) * 2 ; r = r- ((MouseX() - (xres/2.0)) / xres)*2
x = x + (KeyDown(KEY_UP)-KeyDown(KEY_DOWN)) * Cos(r) * 4
y = y + (KeyDown(KEY_UP)-KeyDown(KEY_DOWN)) * -Sin(r) * 4
r = r - (KeyDown(KEY_RIGHT) - KeyDown(KEY_LEFT)) * 2
			
camd = Tan(22.5) * Height * 5 ; camX = X - (camd * Cos(r)) ; camY = Y - (camd * -Sin(r)) ; camDir = r ; cosine = Cos(camDir) ; sine = -Sin(camDir) ' Cam pos

For a = 8 To YLines-1 Step 1
	XHit = camX + (Cosine*vd[a]) ; yhit = camY + (Sine*vd[a]) ; xpos = XHit Mod mapw ; ypos = YHit Mod maph
	If XHit &lt; 0 Then xpos = 1024-xpos
	If YHit &lt; 0 Then ypos = 1024-ypos
	
    ' Clip, rotate, scale, translate before drawing
 	  SetViewport 0,yres/2+a,xres,1
      SetImageHandle map,xpos,ypos
      SetRotation -(camDir-90)
      SetScale VScale[a],VScale[a] 
	  TileImage map,xres/2,240+a
Next

SetViewport 0,0,xres,yres
Flip
Until MouseDown(2)

' Replacement for the inbuilt TILEIMAGE which otherwise ignores current SCALE and ROTATION settings.
Function TileImage(image:TImage, x:Float=0# ,y:Float=0#, frame:Int=0)
    Local scale_x#, scale_y#
    GetScale(scale_x#, scale_y#)
    Local viewport_x%, viewport_y%, viewport_w%, viewport_h%
    GetViewport(viewport_x, viewport_y, viewport_w, viewport_h)
    Local origin_x#, origin_y#
    GetOrigin(origin_x, origin_y)
    Local handle_X#, handle_y#
    GetHandle(handle_X#, handle_y#)
    Local image_h# = ImageHeight(image)
    Local image_w# = ImageWidth(image)
    Local w#=image_w * Abs(scale_x#)
    Local h#=image_h * Abs(scale_y#)
    Local ox#=viewport_x-w+1
    Local oy#=viewport_y-h+1
    origin_X = origin_X Mod w
    origin_Y = origin_Y Mod h
    Local px#=x+origin_x - handle_x
    Local py#=y+origin_y - handle_y
    Local fx#=px-Floor(px)
    Local fy#=py-Floor(py)
    Local tx#=Floor(px)-ox
    Local ty#=Floor(py)-oy
    If tx&gt;=0 tx=tx Mod w + ox Else tx = w - -tx Mod w + ox
    If ty&gt;=0 ty=ty Mod h + oy Else ty = h - -ty Mod h + oy
    Local vr#= viewport_x + viewport_w, vb# = viewport_y + viewport_h
    SetOrigin 0,0
    Local iy#=ty
    While iy&lt;vb + h
        Local ix#=tx
        While ix&lt;vr + w
            DrawImage(image, ix+fx,iy+fy, frame)
            ix=ix+w
        Wend
        iy=iy+h
    Wend
    SetOrigin origin_x, origin_y
End Function
</pre> <br><br></td></tr></table><br>
<a name="1294710"></a>

<a name="1294711"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#41">[#41]</a></td></tr></table></td></tr><tr ><td class="posttext"> Reminds me of this thread:<br><a href="http://www.blitzbasic.com/Community/posts.php?topic=99346" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=99346</a><br><br>Some of the images are down. There's a few additional images in the archived page:<br>http://web.archive.org/web/20130728075410/http://blitzbasic.com/Community/posts.php?topic=99346<br><br>But the images in the first post of that thread are definitely gone. <br><br></td></tr></table><br>
<a name="1294714"></a>

<a name="1294715"></a>

<a name="1294716"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#42">[#42]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Kryzon that one looked really nice, hills and valleys where bloody sexy.<br><br>Back over inflatland I had a last second debug moment here before leaving, I tried away with the - in rotation and BAM, working. Who'd guess.<br>It needs some polishing and understanding now. But I feel really good about this.<br><br><pre class=code>
' Simple Mode 7 (Conversion from Monkey)

Local XRes:Float = 640 , YRes:Float = 480 , YLines:Float = 240 , X:Float = 930 , Y:Float = 700 , Height:Float = 32 , r:Float = 90-45 , HFOV:Float = 60 , VFOV:Float = 45
Local vas:Float[Ylines] , vd:Float[Ylines] , VScale:Float[Ylines] , VDelta:Float = VFOV / YLines , va:Float = VDelta , hl:Float
Local camd:Float , camx:Float , camy:Float , cosine:Float , sine:Float , xhit:Float , yhit:Float , xpos:Float , ypos:Float

For a = 0 To YLines-1 ; vas[a] = va ; vd[a] = Height / Tan(vas[a]) ; hl = (vd[a]*Tan(HFOV)) * 2 ; VScale[a] = (1024/hl) * (1024/XRes) ; va = va + VDelta ; Next

SetGraphicsDriver GLMax2DDriver(),0 ; Graphics xres,yres,0,60,GRAPHICS_BACKBUFFER + GRAPHICS_DEPTHBUFFER ; glewinit ; AutoImageFlags MASKEDIMAGE 

Local map:TImage = LoadImage(LoadBank("http::epicwallpapers.com/file/154/600x338/16:9/the-world-map-from-legend-of-zelda-links-awakening_8743972.png"))
mapw = ImageWidth(map) ; maph = ImageHeight(map)

Repeat
Cls
If MouseDown(1) Then x = x + Cos(r) * 2 ; y = y + -Sin(r) * 2 ; r = r- ((MouseX() - (xres/2.0)) / xres)*2
x = x + (KeyDown(KEY_UP)-KeyDown(KEY_DOWN)) * Cos(r) * 4
y = y + (KeyDown(KEY_UP)-KeyDown(KEY_DOWN)) * -Sin(r) * 4
r = r - (KeyDown(KEY_RIGHT) - KeyDown(KEY_LEFT)) * 2
			
camd = Tan(22.5) * Height * 5 ; camX = X - (camd * Cos(r)) ; camY = Y - (camd * -Sin(r)) ; camDir = r ; cosine = Cos(camDir) ; sine = -Sin(camDir) ' Cam pos

For a = 8 To YLines-1 Step 1
	XHit = camX + (Cosine*vd[a]) ; yhit = camY + (Sine*vd[a]) ; xpos = XHit Mod mapw ; ypos = YHit Mod maph
	If XHit &lt; 0 Then xpos = 1024-xpos
	If YHit &lt; 0 Then ypos = 1024-ypos
	
     ' Clip, rotate, scale, translate before drawing.
      SetViewport 0,yres/2+a,xres,1
      SetImageHandle map,xpos,ypos
      SetRotation (camDir-90)
      SetScale VScale[a],VScale[a] 
      DrawImage map,xres/2,240+a 
      'TileImage map,xres/2,240+a
Next

SetViewport 0,0,xres,yres
Flip
Until MouseDown(2)

' Replacement for the inbuilt TILEIMAGE which otherwise ignores current SCALE and ROTATION settings.
Function TileImage(image:TImage, x:Float=0# ,y:Float=0#, frame:Int=0)
    Local scale_x#, scale_y#
    GetScale(scale_x#, scale_y#)
    Local viewport_x%, viewport_y%, viewport_w%, viewport_h%
    GetViewport(viewport_x, viewport_y, viewport_w, viewport_h)
    Local origin_x#, origin_y#
    GetOrigin(origin_x, origin_y)
    Local handle_X#, handle_y#
    GetHandle(handle_X#, handle_y#)
    Local image_h# = ImageHeight(image)
    Local image_w# = ImageWidth(image)
    Local w#=image_w * Abs(scale_x#)
    Local h#=image_h * Abs(scale_y#)
    Local ox#=viewport_x-w+1
    Local oy#=viewport_y-h+1
    origin_X = origin_X Mod w
    origin_Y = origin_Y Mod h
    Local px#=x+origin_x - handle_x
    Local py#=y+origin_y - handle_y
    Local fx#=px-Floor(px)
    Local fy#=py-Floor(py)
    Local tx#=Floor(px)-ox
    Local ty#=Floor(py)-oy
    If tx&gt;=0 tx=tx Mod w + ox Else tx = w - -tx Mod w + ox
    If ty&gt;=0 ty=ty Mod h + oy Else ty = h - -ty Mod h + oy
    Local vr#= viewport_x + viewport_w, vb# = viewport_y + viewport_h
    SetOrigin 0,0
    Local iy#=ty
    While iy&lt;vb + h
        Local ix#=tx
        While ix&lt;vr + w
            DrawImage(image, ix+fx,iy+fy, frame)
            ix=ix+w
        Wend
        iy=iy+h
    Wend
    SetOrigin origin_x, origin_y
End Function

</pre> <br><br></td></tr></table><br>
<a name="1294720"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#43">[#43]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's a bit better, Casaber. Here are a few lines to change. As you can see, you will need to use REAL # numbers in order to slow down the movements to normal.<pre class=code>x = x + (KeyDown(KEY_UP)-KeyDown(KEY_DOWN)) * Cos(r/10.0)
y = y + (KeyDown(KEY_UP)-KeyDown(KEY_DOWN)) * -Sin(r/1000.0)
r = r - (KeyDown(KEY_RIGHT) - KeyDown(KEY_LEFT))/10.0</pre><br><br>Looking forward to seeing your next installment soon ! <br><br></td></tr></table><br>
<a name="1294721"></a>

<a name="1294730"></a>

<a name="1294741"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#44">[#44]</a></td></tr></table></td></tr><tr ><td class="posttext"> another debugged one<br>this one does not behave like the original, but to me looks more stable, the controls are off though.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

' Simple Mode 7 (Conversion from Monkey)

Local XRes:Float = 640 , YRes:Float = 480 , YLines:Float = 240 , X:Float = 930 , Y:Float = 700 , Height:Float = 32 , r:Float = 90-45 , HFOV:Float = 60 , VFOV:Float = 45
Local vas:Float[Ylines] , vd:Float[Ylines] , VScale:Float[Ylines] , VDelta:Float = VFOV / YLines , va:Float = VDelta
Local camd:Float , camx:Float , camy:Float , cosine:Float , sine:Float , xhit:Float , yhit:Float , xpos:Float , ypos:Float

For a = 0 To YLines-1 ; vas[a] = va ; vd[a] = Height / Tan(vas[a]) ; VScale[a] = (1024.0/ ((vd[a]*Tan(HFOV)) * 2)) * (1024.0/XRes) ; va = va + VDelta ; Next

SetGraphicsDriver GLMax2DDriver(),0 ; Graphics xres,yres,0,60,GRAPHICS_BACKBUFFER + GRAPHICS_DEPTHBUFFER ; glewinit ; AutoImageFlags MASKEDIMAGE 
Local map:TImage = LoadImage(LoadBank("http::epicwallpapers.com/file/154/600x338/16:9/the-world-map-from-legend-of-zelda-links-awakening_8743972.png"))
mapw = ImageWidth(map) ; maph = ImageHeight(map)
	
Repeat
Cls
' DIFFERENT True IN KEYS IS BUG?
If MouseDown(1) Then x = x + Cos(r) * 2 ; y = y + -Sin(r) * 2 ; r = r- ((MouseX() - (xres/2.0)) / xres)*2
x = x + (KeyDown(KEY_UP)-KeyDown(KEY_DOWN)) * Cos(r) * 4
y = y + (KeyDown(KEY_UP)-KeyDown(KEY_DOWN)) * -Sin(r) * 4
r = r - (KeyDown(KEY_RIGHT) - KeyDown(KEY_LEFT)) * 2
			
camd = Tan(22.5) * Height * 5 
camX = X - (camd * Cos(r)) ; camY = Y - (camd * -Sin(r)) ' THIS LINE BUG RELATED (negation)

'camDir = r ' THIS LINE BUG RELATED
	
	 cosine = -Cos(camDir) ; sine = Sin(camDir) ' Cam pos
' DRAWIMAGE
For a = 8 To YLines-1 Step 1
	XHit = camX + (Cosine*vd[a]) ; yhit = camY + (Sine*vd[a]) ; xpos = XHit Mod mapw ; ypos = YHit Mod maph
	If XHit &lt; 0 Then xpos = 1024-xpos
	If YHit &lt; 0 Then ypos = 1024-ypos

     ' Clip, rotate, scale, translate before drawing.
      SetViewport 0,yres/2+a,xres,1
      SetImageHandle map,xpos,ypos
      SetRotation -(camDir-90) ' THIS LINE BUG RELATED (negation)
      SetScale VScale[a],VScale[a] 
      DrawImage map,xres/2,240+a
      'TileImage map,xres/2,240+a
Next
SetViewport 0,0,xres,yres
Flip
Until MouseDown(2)

' Replacement for the inbuilt TILEIMAGE which otherwise ignores current SCALE and ROTATION settings.
Function TileImage(image:TImage, x:Float=0# ,y:Float=0#, frame:Int=0)
    Local scale_x#, scale_y#
    GetScale(scale_x#, scale_y#)
    Local viewport_x%, viewport_y%, viewport_w%, viewport_h%
    GetViewport(viewport_x, viewport_y, viewport_w, viewport_h)
    Local origin_x#, origin_y#
    GetOrigin(origin_x, origin_y)
    Local handle_X#, handle_y#
    GetHandle(handle_X#, handle_y#)
    Local image_h# = ImageHeight(image)
    Local image_w# = ImageWidth(image)
    Local w#=image_w * Abs(scale_x#)
    Local h#=image_h * Abs(scale_y#)
    Local ox#=viewport_x-w+1
    Local oy#=viewport_y-h+1
    origin_X = origin_X Mod w
    origin_Y = origin_Y Mod h
    Local px#=x+origin_x - handle_x
    Local py#=y+origin_y - handle_y
    Local fx#=px-Floor(px)
    Local fy#=py-Floor(py)
    Local tx#=Floor(px)-ox
    Local ty#=Floor(py)-oy
    If tx&gt;=0 tx=tx Mod w + ox Else tx = w - -tx Mod w + ox
    If ty&gt;=0 ty=ty Mod h + oy Else ty = h - -ty Mod h + oy
    Local vr#= viewport_x + viewport_w, vb# = viewport_y + viewport_h
    SetOrigin 0,0
    Local iy#=ty
    While iy&lt;vb + h
        Local ix#=tx
        While ix&lt;vr + w
            DrawImage(image, ix+fx,iy+fy, frame)
            ix=ix+w
        Wend
        iy=iy+h
    Wend
    SetOrigin origin_x, origin_y
End Function
</textarea> <br><br></td></tr></table><br>
<a name="1294722"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#45">[#45]</a></td></tr></table></td></tr><tr ><td class="posttext"> @DW817 those lines only adds slow hickups to my movement? I defined all as floats already? How do you mean real numbers they should be already? <br><br></td></tr></table><br>
<a name="1294724"></a>

<a name="1294725"></a>

<a name="1294726"></a>

<a name="1294727"></a>

<a name="1294728"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#46">[#46]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey in the new one, the hickups does not appear when I throw in those lines. I think that's a good sign. But this is not how the original behave, and I did a one on one comparison? <br><br>I must have dreamt it. I run the Monkey original code beside the Bmax, and i get the 1st  version, not the 2nd one. <br><br>Could there have been a bug in the original Monkey code? <br>I'm abit lost 1st I thought that it was all about truth values being different in Monkey and BMax (1 vs -1).<br><br>But then this 2nd (which I got by trying negating the trigonometry directly) made me.. confused. I´m not sure what was the original bug now. <br><br></td></tr></table><br>
<a name="1294731"></a>

<a name="1294735"></a>

<a name="1294736"></a>

<a name="1294737"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#47">[#47]</a></td></tr></table></td></tr><tr ><td class="posttext"> hah add in an x=x+1 or y=y+1 and enjoy your ride :)<br><br>Seem to work alright, now it's the controls only left to do. Happy as can be.<br>It can endless tile fine aswell. <br><br>But not with that png it get black areas for some reason.<br><br>EDIT I think it wants square pictures, the original SNES had 128x128 tiles with 8x8 tiles, making a 1024x1024).<br>That's the hardcoded 1024 I'll bet changing those to width and height of the image would be half the fix,<br>and having square image would be the other half I have the feeling. <br><br></td></tr></table><br>
<a name="1294732"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#48">[#48]</a></td></tr></table></td></tr><tr ><td class="posttext"> r I think is still buggy, you cant do r=r+1, it circles instead of swirling the camera <br><br></td></tr></table><br>
<a name="1294734"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#49">[#49]</a></td></tr></table></td></tr><tr ><td class="posttext"> The original Monkey code Swirls with r=r+1 but.. it has a buggy horizon instead (it can´t tile forever it gives alot of graphic errors at the horizon), <br>which the latest post here fixes (not intended but it happened). Maybe the original had an bug, I´m not the one to ask, but it looks like it might.<br><br>But the camera rotation are circling in this one. That's the only thing left to fix now. <br><br></td></tr></table><br>
<a name="1294738"></a>

<a name="1294740"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#50">[#50]</a></td></tr></table></td></tr><tr ><td class="posttext"> this is just a retouched one, where I will contine with later<br>fixed the small things I´ve said above in it.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' Simple Mode 7 (Conversion from Monkey)

Local XRes:Float = 640 , YRes:Float = 480 , X:Float = 930 , Y:Float = 700 , r:Float = 90-45 , YLines:Float = 240 
Local vas:Float[Ylines] , vd:Float[Ylines] , VScale:Float[Ylines] 
Local camd:Float , camx:Float , camy:Float , cosine:Float , sine:Float , xhit:Float , yhit:Float , xpos:Float , ypos:Float

' Calculate
Local Height:Float = 32 , HFOV:Float = 60 , VFOV:Float = 45 , VDelta:Float = VFOV / YLines , va:Float = VDelta
For a = 0 To YLines-1 ; vas[a] = va ; vd[a] = Height / Tan(vas[a]) ; VScale[a] = (1024.0/ ((vd[a]*Tan(HFOV)) * 2)) * (1024.0/XRes) ; va = va + VDelta ; Next

SetGraphicsDriver GLMax2DDriver(),0 ; Graphics xres,yres,0,60,GRAPHICS_BACKBUFFER + GRAPHICS_DEPTHBUFFER ; glewinit ; AutoImageFlags MASKEDIMAGE 
Local map:TImage = LoadImage(LoadBank("http::d13yacurqjgara.cloudfront.net/users/7564/screenshots/734550/attachments/70292/1024x1024.png"))
mapw = ImageWidth(map) ; maph = ImageHeight(map)

Repeat
Cls
' DIFFERENT True IN KEYS IS BUG?
'If MouseDown(1) Then x = x + Cos(r) * 2 ; y = y + -Sin(r) * 2 ; r = r- ((MouseX() - (xres/2.0)) / xres)*2
'x = x + (KeyDown(KEY_UP)-KeyDown(KEY_DOWN)) ' * Cos(r) * 4
'y = y + (KeyDown(KEY_UP)-KeyDown(KEY_DOWN)) ' * -Sin(r) * 4
'r = r - (KeyDown(KEY_RIGHT) - KeyDown(KEY_LEFT)) * 2
x=x-10
camd = Tan(22.5) * Height * 5 
camX = X - (camd * Cos(r)) ; camY = Y - (camd * -Sin(r)) ' THIS LINE BUG RELATED (negation)

'camDir = r ' THIS LINE BUG RELATED
	
	 cosine = -Cos(camDir) ; sine = Sin(camDir) ' Cam pos
' DRAWIMAGE
For a = 8 To YLines-1 Step 1
	XHit = camX + (Cosine*vd[a]) ; yhit = camY + (Sine*vd[a]) ; xpos = XHit Mod mapw ; ypos = YHit Mod maph
	If XHit &lt; 0 Then xpos = mapw-xpos
	If YHit &lt; 0 Then ypos = maph-ypos

     ' Clip, rotate, scale, translate before drawing.
      SetViewport 0,yres/2+a,xres,1
      SetImageHandle map,xpos,ypos
      SetRotation -(camDir-90) ' THIS LINE BUG RELATED (negation)
      SetScale VScale[a],VScale[a] 
     ' DrawImage map,xres/2,240+a
      TileImage map,xres/2,240+a
Next
SetViewport 0,0,xres,yres
Flip
Until MouseDown(2)

' Replacement for the inbuilt TILEIMAGE which otherwise ignores current SCALE and ROTATION settings.
Function TileImage(image:TImage, x:Float=0# ,y:Float=0#, frame:Int=0)
    Local scale_x#, scale_y#
    GetScale(scale_x#, scale_y#)
    Local viewport_x%, viewport_y%, viewport_w%, viewport_h%
    GetViewport(viewport_x, viewport_y, viewport_w, viewport_h)
    Local origin_x#, origin_y#
    GetOrigin(origin_x, origin_y)
    Local handle_X#, handle_y#
    GetHandle(handle_X#, handle_y#)
    Local image_h# = ImageHeight(image)
    Local image_w# = ImageWidth(image)
    Local w#=image_w * Abs(scale_x#)
    Local h#=image_h * Abs(scale_y#)
    Local ox#=viewport_x-w+1
    Local oy#=viewport_y-h+1
    origin_X = origin_X Mod w
    origin_Y = origin_Y Mod h
    Local px#=x+origin_x - handle_x
    Local py#=y+origin_y - handle_y
    Local fx#=px-Floor(px)
    Local fy#=py-Floor(py)
    Local tx#=Floor(px)-ox
    Local ty#=Floor(py)-oy
    If tx&gt;=0 tx=tx Mod w + ox Else tx = w - -tx Mod w + ox
    If ty&gt;=0 ty=ty Mod h + oy Else ty = h - -ty Mod h + oy
    Local vr#= viewport_x + viewport_w, vb# = viewport_y + viewport_h
    SetOrigin 0,0
    Local iy#=ty
    While iy&lt;vb + h
        Local ix#=tx
        While ix&lt;vr + w
            DrawImage(image, ix+fx,iy+fy, frame)
            ix=ix+w
        Wend
        iy=iy+h
    Wend
    SetOrigin origin_x, origin_y
End Function

</textarea> <br><br></td></tr></table><br>
<a name="1294739"></a>

<a name="1294742"></a>

<a name="1294744"></a>

<a name="1294746"></a>

<a name="1294750"></a>

<a name="1294751"></a>

<a name="1294753"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#51">[#51]</a></td></tr></table></td></tr><tr ><td class="posttext"> Testing height (it was fixed in Monkey version but actually it's real nice to use it dynamically. Okay, time to leave I´m hooked on this. <br><br>It still has areas inbetween them if you look carefully you see it at those great heights..  okay the bug level might best be unsaid now. But it's something visually comprehensible at least now, I like that.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' Simple Mode 7 (Conversion from Monkey)

Local XRes:Float = 640 , YRes:Float = 480 , X:Float = 930 , Y:Float = 700 , r:Float = 90-45 , YLines:Float = 240 
Local vas:Float[Ylines] , vd:Float[Ylines] , VScale:Float[Ylines] 
Local camd:Float , camx:Float , camy:Float , cosine:Float , sine:Float , xhit:Float , yhit:Float , xpos:Float , ypos:Float
Local Height:Float , HFOV:Float , VFOV:Float , VDelta:Float , va:Float 

SetGraphicsDriver GLMax2DDriver(),0 ; Graphics xres,yres,0,60,GRAPHICS_BACKBUFFER + GRAPHICS_DEPTHBUFFER ; glewinit ; AutoImageFlags MASKEDIMAGE 
Local map:TImage = LoadImage(LoadBank("http::d13yacurqjgara.cloudfront.net/users/7564/screenshots/734550/attachments/70292/1024x1024.png"))
mapw = ImageWidth(map) ; maph = ImageHeight(map)

Repeat


' Calculate
'Height = 32 ; HFOV = 60 ; VFOV= 45 ; VDelta = VFOV / YLines ; va = VDelta
'For a = 0 To YLines-1 ; vas[a] = va ; vd[a] = Height / Tan(vas[a]) ; VScale[a] = (1024.0/ ((vd[a]*Tan(HFOV)) * 2)) * (1024.0/XRes) ; va = va + VDelta ; Next

' Test height
height = 1+ Abs(Sin(temp))*1000 ; temp = temp+2 Mod 360

 HFOV = 60 ; VFOV= 45 ; VDelta = VFOV / YLines ; va = VDelta
For a = 0 To YLines-1 ; vas[a] = va ; vd[a] = Height / Tan(vas[a]) ; VScale[a] = (1024.0/ ((vd[a]*Tan(HFOV)) * 2)) * (1024.0/XRes) ; va = va + VDelta ; Next

Cls
'If MouseDown(1) Then x = x + Cos(r) * 2 ; y = y + -Sin(r) * 2 ; r = r- ((MouseX() - (xres/2.0)) / xres)*2
'x = x + (KeyDown(KEY_UP)-KeyDown(KEY_DOWN)) ' * Cos(r) * 4
'y = y + (KeyDown(KEY_UP)-KeyDown(KEY_DOWN)) ' * -Sin(r) * 4
'r = r - (KeyDown(KEY_RIGHT) - KeyDown(KEY_LEFT)) * 2
x=x-100
camd = Tan(22.5) * Height * 5 
camX = X - (camd * Cos(r)) ; camY = Y - (camd * -Sin(r)) ' THIS LINE BUG RELATED (negation)

'camDir = r ' THIS LINE BUG RELATED
	
	 cosine = -Cos(camDir) ; sine = Sin(camDir) ' Cam pos
' DRAWIMAGE
For a = 8 To YLines-1 Step 1
	XHit = camX + (Cosine*vd[a]) ; yhit = camY + (Sine*vd[a]) ; xpos = XHit Mod mapw ; ypos = YHit Mod maph
	If XHit &lt; 0 Then xpos = mapw-xpos
	If YHit &lt; 0 Then ypos = maph-ypos

     ' Clip, rotate, scale, translate before drawing.
      SetViewport 0,yres/2+a,xres,1
      SetImageHandle map,xpos,ypos
      SetRotation -(camDir-90) ' THIS LINE BUG RELATED (negation)
      SetScale VScale[a],VScale[a] 
     ' DrawImage map,xres/2,240+a
      TileImage map,xres/2,240+a
Next
SetViewport 0,0,xres,yres
Flip
Until MouseDown(2)

' Replacement for the inbuilt TILEIMAGE which otherwise ignores current SCALE and ROTATION settings.
Function TileImage(image:TImage, x:Float=0# ,y:Float=0#, frame:Int=0)
    Local scale_x#, scale_y#
    GetScale(scale_x#, scale_y#)
    Local viewport_x%, viewport_y%, viewport_w%, viewport_h%
    GetViewport(viewport_x, viewport_y, viewport_w, viewport_h)
    Local origin_x#, origin_y#
    GetOrigin(origin_x, origin_y)
    Local handle_X#, handle_y#
    GetHandle(handle_X#, handle_y#)
    Local image_h# = ImageHeight(image)
    Local image_w# = ImageWidth(image)
    Local w#=image_w * Abs(scale_x#)
    Local h#=image_h * Abs(scale_y#)
    Local ox#=viewport_x-w+1
    Local oy#=viewport_y-h+1
    origin_X = origin_X Mod w
    origin_Y = origin_Y Mod h
    Local px#=x+origin_x - handle_x
    Local py#=y+origin_y - handle_y
    Local fx#=px-Floor(px)
    Local fy#=py-Floor(py)
    Local tx#=Floor(px)-ox
    Local ty#=Floor(py)-oy
    If tx&gt;=0 tx=tx Mod w + ox Else tx = w - -tx Mod w + ox
    If ty&gt;=0 ty=ty Mod h + oy Else ty = h - -ty Mod h + oy
    Local vr#= viewport_x + viewport_w, vb# = viewport_y + viewport_h
    SetOrigin 0,0
    Local iy#=ty
    While iy&lt;vb + h
        Local ix#=tx
        While ix&lt;vr + w
            DrawImage(image, ix+fx,iy+fy, frame)
            ix=ix+w
        Wend
        iy=iy+h
    Wend
    SetOrigin origin_x, origin_y
End Function

</textarea><br><br>Also trying this, it might be correctly tiling, the dark areas i saw might have been just the gray shadings of the pic I´m currently using. I need more time to test.<br>But right now it looks okay. It has some kind of bendyness to it though. The world belongs to bugs..<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

' Simple Mode 7 (Conversion from Monkey)

Local XRes:Float = 640 , YRes:Float = 480 , X:Float = 930 , Y:Float = 700 , YLines:Float = 240 , r:Float = 0 ' 90-45
Local vas:Float[Ylines] , vd:Float[Ylines] , VScale:Float[Ylines] , Height:Float , HFOV:Float , VFOV:Float , VDelta:Float , va:Float 
Local camd:Float , camx:Float , camy:Float , cosine:Float , sine:Float , xhit:Float , yhit:Float , xpos:Float , ypos:Float

SetGraphicsDriver GLMax2DDriver(),0 ; Graphics xres,yres,0,60,GRAPHICS_BACKBUFFER + GRAPHICS_DEPTHBUFFER ; glewinit ; AutoImageFlags MASKEDIMAGE 
Local map:TImage = LoadImage(LoadBank("http::d13yacurqjgara.cloudfront.net/users/7564/screenshots/734550/attachments/70292/1024x1024.png"))
Local mapw:Float = ImageWidth(map) , maph:Float = ImageHeight(map)

Height = 32*5 ; HFOV = 60 ; VFOV= 45 ; VDelta = VFOV / YLines ; va = VDelta
For a = 0 To YLines-1 ; vas[a] = va ; vd[a] = Height / Tan(vas[a]) ; VScale[a] = (maph/ ((vd[a]*Tan(HFOV)) * 2)) * (mapw/XRes) ; va = va + VDelta ; Next

Repeat
Cls
If MouseDown(1) Then x = x + Cos(r) * 2 ; y = y + -Sin(r) * 2 ; r = r- ((MouseX() - (xres/2.0)) / xres)*2
x = x + (KeyDown(KEY_UP)-KeyDown(KEY_DOWN)) * 4 * Cos(r)
y = y + (KeyDown(KEY_UP)-KeyDown(KEY_DOWN)) * 4 * -Sin(r)
r = r - (KeyDown(KEY_RIGHT) - KeyDown(KEY_LEFT)) * 2
x = x - 2

camd = Tan(22.5) * height * 5 ; camX = x - (camd * Cos(r)) ; camy = y - (camd * -Sin(r))
cosine = -Cos(r) ; sine = Sin(r) ' Signs swapped

For a = 0 To YLines-1
	  xhit = camx + (cosine*vd[a]) ; yhit = camy + (sine*vd[a]) ; xpos = Abs(xhit) Mod mapw ; ypos = Abs(yhit) Mod maph
      SetViewport 0,yres/2+a,xres,1
      SetImageHandle map,xpos,ypos
      SetRotation -(r-90)
      SetScale vscale[a],vscale[a] 
      TileImage map,xres/2,240+a
Next
SetViewport 0,0,xres,yres
Flip
Until MouseDown(2)

' Replacement for the inbuilt TILEIMAGE which otherwise ignores current SCALE and ROTATION settings.
Function TileImage(image:TImage, x:Float=0# ,y:Float=0#, frame:Int=0)
    Local scale_x#, scale_y#
    GetScale(scale_x#, scale_y#)
    Local viewport_x%, viewport_y%, viewport_w%, viewport_h%
    GetViewport(viewport_x, viewport_y, viewport_w, viewport_h)
    Local origin_x#, origin_y#
    GetOrigin(origin_x, origin_y)
    Local handle_X#, handle_y#
    GetHandle(handle_X#, handle_y#)
    Local image_h# = ImageHeight(image)
    Local image_w# = ImageWidth(image)
    Local w#=image_w * Abs(scale_x#)
    Local h#=image_h * Abs(scale_y#)
    Local ox#=viewport_x-w+1
    Local oy#=viewport_y-h+1
    origin_X = origin_X Mod w
    origin_Y = origin_Y Mod h
    Local px#=x+origin_x - handle_x
    Local py#=y+origin_y - handle_y
    Local fx#=px-Floor(px)
    Local fy#=py-Floor(py)
    Local tx#=Floor(px)-ox
    Local ty#=Floor(py)-oy
    If tx&gt;=0 tx=tx Mod w + ox Else tx = w - -tx Mod w + ox
    If ty&gt;=0 ty=ty Mod h + oy Else ty = h - -ty Mod h + oy
    Local vr#= viewport_x + viewport_w, vb# = viewport_y + viewport_h
    SetOrigin 0,0
    Local iy#=ty
    While iy&lt;vb + h
        Local ix#=tx
        While ix&lt;vr + w
            DrawImage(image, ix+fx,iy+fy, frame)
            ix=ix+w
        Wend
        iy=iy+h
    Wend
    SetOrigin origin_x, origin_y
End Function
</textarea> <br><br></td></tr></table><br>
<a name="1294804"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#52">[#52]</a></td></tr></table></td></tr><tr ><td class="posttext"> <b>GOOD JOB ON THAT LAST ONE !!</b> You are definitely getting there. Get the rotation down and I think you'll have the whole thing, Casaber ! <br><br></td></tr></table><br>
<a name="1294805"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#53">[#53]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks, but this was HARD. <br><br>Any rotation expert in the house?<br>I´m exhausted here.<br><br>I would really like to get this specific implementation working, It's the one that's true to the SNES how it did it too. <br><br></td></tr></table><br>
<a name="1294806"></a>

<a name="1294807"></a>

<a name="1294808"></a>

<a name="1294810"></a>

<a name="1294828"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#54">[#54]</a></td></tr></table></td></tr><tr ><td class="posttext"> So I did this instead, which is based on a tutorial I found on the web for MODE 7. I think the previous MODE7 on this forum was based on the same tutorial. (It has a bug btw in it's rotation AND  ffffff should be MOD 360 in it)<br><br>But here I went for another simple approach (the only thing I skimped on was the X scale and Y Scale, i mashed them together because I don´t need to scale x and y differently.<br>So there's just "scale", which is nice.<br><br>It's a simple (but complete) MODE 7 which uses pixelling, based on a great tutorial. I'm very pleased to have a software too. It's FAST.<br>I'm just intrigued by the concept of the previous version though so any help would be appreciated.<br><br><br><pre class=code>

' Simple Mode 7 using software rendering (quick, 60 fps+)

Local a:Float = 0 , x:Float = 0 , y:Float = 0 , dx:Float = 0 , dy:Float = 0 , speed:Float = 0
Global space_z:Float = 50 , horizon:Int = 20, scale:Float = 1000 , obj_scale:Float = 50 ' Set view and scale here.
Global map:Int[1024*1024] ; Global img:TPixmap = LoadPixmap(LoadBank("http::static.monstermmorpg.com/images/maps/Meteor-Falls.png"))
For y=0 To 1023 ; For x=0 To 1024 ; map(x+y*1024) = ReadPixel(img,x,y) ; Next ; Next ' Load png 1024 x 1024

Global xres:Int = 1024 , yres:Int = 768 , pixels:Int[xres*yres]
GLGraphics xres,yres,0,60,GRAPHICS_BACKBUFFER | GRAPHICS_DEPTHBUFFER ; glViewport 0,0,xres,yres
glMatrixMode GL_PROJECTION ; glLoadIdentity ; glOrtho 0,xres,yres,0,0,1 ; glPixelZoom 1,-1 ; glRasterPos2i 0,0

x=0 ; y = 0 ; a= 0
Repeat
	speed = speed + KeyDown(KEY_UP)*0.1-KeyDown(KEY_DOWN)*0.1 ; speed=Max(-5,Min(5,speed))
    a = a         - KeyDown(KEY_LEFT)+KeyDown(KEY_RIGHT) ; a = a Mod 360
	dx = speed * Cos (a) ; dy =  speed * Sin (a) ; x :+ dx ; y :+ dy
	drawplane a,x,y
	Delay 1 ; Flip 1
Until KeyHit(KEY_ESCAPE) Or AppTerminate()
End

Function drawplane(a:Float,cx:Float,cy:Float)
	Local sx:Int , sy:Int , d:Float , hs:Float , maskx:Int = 1023 , masky:Int = 1023 
	Local dx:Float , dy:Float , spx:Float,spy:Float 
	For sy = 0 Until yres-1
		d = space_z*scale / Float(sy + horizon) ; hs = d / scale ; dx = -Sin(a) * hs ; dy = Cos(a) * hs
		spx = cx + d*Cos(a) - Float(xres) / 2 * dx ; spy = cy + d*Sin(a) - Float(xres) / 2 * dy
		For sx = 0 Until xres-1 ; pixels[sx+sy*xres] = map[  (Int(spx) &amp; maskx) + ( (Int(spy) &amp; masky)*1024)]
		spx :+ dx ; spy :+ dy ; Next
	Next
	glDrawPixels xres,yres,GL_BGRA,GL_UNSIGNED_BYTE,pixels
End Function

</pre><br><br>Everything is presentation so if you want to see it in action fullscreen with some style I personally adore. Here you go.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' Simple Mode 7 using software rendering (quick, 60 fps+)

Local a:Float = 0 , x:Float = 0 , y:Float = 0 , dx:Float = 0 , dy:Float = 0 , speed:Float = 0
Global space_z:Float = 50 , horizon:Int = 20, scale:Float = 1000 , obj_scale:Float = 50 ' Set view and scale here.
Global map:Int[1024*1024] ; Global img:TPixmap = LoadPixmap(LoadBank("http::static.monstermmorpg.com/images/maps/Meteor-Falls.png"))
For y=0 To 1023 ; For x=0 To 1024 ; map(x+y*1024) = ReadPixel(img,x,y) ; Next ; Next ' Load png 1024 x 1024

Global xres:Int = DesktopWidth() , yres:Int = DesktopHeight() , pixels:Int[xres*yres]
GLGraphics xres,yres,32,60,GRAPHICS_BACKBUFFER | GRAPHICS_DEPTHBUFFER ; glViewport 0,0,xres,yres ; HideMouse
glMatrixMode GL_PROJECTION ; glLoadIdentity ; glOrtho 0,xres,yres,0,0,1 ; glPixelZoom 1,-1 ; glRasterPos2i 0,0

x=0 ; y = 0 ; a= 0
Repeat
	speed = speed + KeyDown(KEY_UP)*0.1-KeyDown(KEY_DOWN)*0.1 ; speed=Max(-5,Min(5,speed))
    a = a         - KeyDown(KEY_LEFT)+KeyDown(KEY_RIGHT) ; a = a Mod 360
	dx = speed * Cos (a) ; dy =  speed * Sin (a) ; x :+ dx ; y :+ dy
	
drawplane a,x,y,0,1920/2
drawplane a2,x2,y2,1920/2,1920/2 ; x2=x2+10 ; a2=a2+1 Mod 360

glDrawPixels xres,yres,GL_BGRA,GL_UNSIGNED_BYTE,pixels
	
Delay 1 ; Flip 1
Until KeyHit(KEY_ESCAPE) Or AppTerminate()
End

Function drawplane(a:Float,cx:Float,cy:Float,offset:Int,www:Int)
	Local sx:Int , sy:Int , d:Float , hs:Float , maskx:Int = 1023 , masky:Int = 1023 
	Local dx:Float , dy:Float , spx:Float,spy:Float 
	For sy = 0 Until yres-1 Step 2
		d = space_z*scale / Float(sy + horizon) ; hs = d / scale ; dx = -Sin(a) * hs ; dy = Cos(a) * hs
		spx = cx + d*Cos(a) - Float(xres) / 2 * dx ; spy = cy + d*Sin(a) - Float(xres) / 2 * dy
		For sx = offset Until www-1+offset Step 2 ; pixels[sx+sy*xres] = map[(Int(spx) &amp; maskx) + ( (Int(spy) &amp; masky)*1024)]
		spx :+ dx ; spy :+ dy ; Next
	Next
End Function

</textarea> <br><br></td></tr></table><br>
<a name="1294832"></a>

<a name="1294833"></a>

<a name="1294834"></a>

<a name="1294835"></a>

<a name="1294836"></a>

<a name="1294837"></a>

<a name="1294838"></a>

<a name="1294840"></a>

<a name="1294845"></a>

<a name="1294846"></a>

<a name="1294847"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#55">[#55]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is pushing it but (this COULD and SHOULD drop below 60fps on weak machines ..1st draft, heavy optimization is next step. It doesnot have to drop below 60 fps on weak machines , that's the important bit.<br><br>EDIT If you put this in singlebuffering mode, and fullscreen mode, it will probably push it well above 60 fps wo. optimzation, asis.<br><br>The point is, these are LIVE tiles, pixel level and tile levelled animated per frame, and colorised live aswell (1 color per tile), could be used for animating ocean tiles for instance.<br>Don´t mind about my retro text, I', using it for a few things,  so ya.. it's there<br><br>Just place youreself somewhere on the map, and stand still for a moment, and look upon the horizon full of ..STUFF.. it looks like waves. Very soothing.<br><br><br><pre class=code>
Global buffer:Int[128*128]
Local img2:TPixmap=LoadPixmap(LoadBank("http::s14.postimg.org/xotmro9vh/128x1282.png"))
For yy=0 To 127 ; For xx=0 To 127 ; buffer(xx+yy*128) = ReadPixel(img2,xx,yy) ; Next ; Next
AddHook FlipHook,irq,Null ; Global fps:Int , fpstotal:Int , msstart:Float , ms:Float = MilliSecs()

Global map[4096,4096] ; For yy=0 To 316 ; For xx=0 To 475; map[xx,yy]=Rnd(127) ; Next ; Next
For temp=0 To 255 ; map[temp,0]=temp ; Next
Global cmap[4096,4096] ; For yy=0 To 316 ; For xx=0 To 475; cmap[xx,yy]=Rnd(15) ; Next ; Next
Global wx:Int , wy:Int , cx:Int , c:Int = buffer[0] , cols:Int[16]
RestoreData colors ; For temp=0 To 15 ; ReadData cols[temp] ; Next
writetomap "                                        ",0,0
writetomap "    **** COMMODORE 64 BASIC V2 ****     ",0,1
writetomap "                                        ",0,2
writetomap " 64K RAM SYSTEM  38911 BASIC BYTES FREE ",0,3
writetomap "                                        ",0,4
writetomap "READY.                                  ",0,5
writetomap "                                        ",0,4

Global xres:Int = 1024 , yres:Int = 768 ' Set resolution here.

Local a:Float = 0 , x:Float = 0 , y:Float = 0 , dx:Float = 0 , dy:Float = 0 , speed:Float = 0
Global space_z:Float = 50 , horizon:Int = 20, scale:Float = 1000 , obj_scale:Float = 50 ' Set view and scale here.
Global pmap:Int[1024*1024] ; Global img:TPixmap = LoadPixmap(LoadBank("http::static.monstermmorpg.com/images/maps/Meteor-Falls.png"))
For y=0 To 1023 ; For x=0 To 1024 ; pmap(x+y*1024) = ReadPixel(img,x,y) ; Next ; Next ' Load png 1024 x 1024
Global pixels:Int[xres*yres] ' 1024 x 1024

GLGraphics xres,yres,0,60,GRAPHICS_BACKBUFFER | GRAPHICS_DEPTHBUFFER ; glViewport 0,0,xres,yres ' Set 0 for Windowed, 32 for Fullscreen here.
glMatrixMode GL_PROJECTION ; glLoadIdentity ; glOrtho 0,xres,yres,0,0,1 ; glPixelZoom 1,-1 ; glRasterPos2i 0,0 ; HideMouse

Repeat

Function readinputs()
	wx=wx-s*KeyDown(KEY_LEFT)+s*KeyDown(KEY_RIGHT) ; wy=wy-s*KeyDown(KEY_UP)+s*KeyDown(KEY_DOWN) ; wx=Max(0,Min(10000,wx)) ; wy=Max(0,Min(10000,wy))
	mx = MouseX() ; my = MouseY() ; xxx = (wx+mx) Sar 4 ; yyy = (wy+my) Sar 4 ; If MouseDown(1) Then map(xxx,yyy) = 42 ; cmap(xxx,yyy) = 7
End Function

	alive
        For yy = 0 To 1023 ; For xx = 0 To 1023 ; pmap[yy*1024+xx] = 0 ; Next ; Next ' Clear
        display wx,wy,0,0,1024,1024 ' Render tiles
	
	speed = speed + KeyDown(KEY_UP)*0.1-KeyDown(KEY_DOWN)*0.1 ; speed=Max(-5,Min(5,speed))
        a = a               - KeyDown(KEY_LEFT)+KeyDown(KEY_RIGHT) ; a = a Mod 360
	dx = speed * Cos (a) ; dy =  speed * Sin (a) ; x :+ dx ; y :+ dy
	drawplane a,x,y
	glDrawPixels xres,yres,GL_BGRA,GL_UNSIGNED_BYTE,pixels

	 Delay 1 ; Flip 1
Until KeyHit(KEY_ESCAPE) Or AppTerminate()
End

Function drawplane(a:Float,cx:Float,cy:Float)
	Local sx:Int , sy:Int , d:Float , hs:Float , maskx:Int = 1023 , masky:Int = 1023 
	Local dx:Float , dy:Float , spx:Float,spy:Float 
	For sy = 0 Until yres-1 Step 2
		d = space_z*scale / Float(sy + horizon) ; hs = d / scale ; dx = -Sin(a) * hs ; dy = Cos(a) * hs
		spx = cx + d*Cos(a) - Float(xres) / 2 * dx ; spy = cy + d*Sin(a) - Float(xres) / 2 * dy
		For sx = 0 Until xres-1 ; pixels[sx+sy*xres] = pmap[(Int(spx) &amp; maskx) + ( (Int(spy) &amp; masky)*1024)]
		spx :+ dx ; spy :+ dy ; Next
	Next
End Function

Function alive()
	For temp=1 To 16 ; buffer[Int(Rand(0,15))+Int((Rand(0,15))*128)]=$ffffffff * Int(Rand(0,1)) ; Next
	cx=(cx+1) Mod 128 ; For tempy=0 To 15 ; For temp=0 To 15+32 ; buffer[16+temp+((0+tempy)*128)]=buffer[0+temp+cx+(16+tempy)*128] ; Next ; Next ; For temp=1 To 1600 ; cmap[Rnd(400),Rnd(250)]=Rnd(16) ; Next
End Function

Function display(wx,wy,ofx=0,ofy=0,sx=640,sy=400) 
	scrx = wx &amp; 15 ; scry = wy &amp; 15 ; mapx = wx Shr 4 ; mapy = wy Shr 4
	cnty = 0 ; For y = mapy To mapy+(sy Shr 4+1)
	cntx = 0 ; For x = mapx To mapx+(sx Shr 4+1)
	tilex = map(x,y) &amp; 15 ; tiley = map(x,y) Shr 4
	colour = cols(cmap(x,y)) ; xx = cntx - scrx + ofx ; yy=cnty - scry + ofy
	For ty = 0 To 7 ; For tx = 0 To 7
	If (xx+tx+tx &gt;= ofx) And (yy+ty+ty &gt;= ofy) And (xx+tx+tx &lt; ofx+sx) And (yy+ty+ty &lt; ofy+sy).. ' Mind the steps
 	 And buffer[tilex Shl 3 + tx + (tiley Shl 3 + ty)*128] &lt;&gt; c Then pmap[xx+tx+tx+(yy+ty+ty)*1024] = colour 
	Next ; Next
	cntx = cntx+16 ; Next
	cnty = cnty+16 ; Next
End Function

Function writetomap(t$,x,y)
	For tempx = 0 To Len(t$)-1 ; temp = Asc(Mid$(t$,1+tempx,1)) ; map[tempx+x,y] = temp ; cmap[tempx+x,y] = 14 ; Next
End Function

Function irq:Object(id,data:Object,context:Object)	
	Return data
End Function

#colors
DefData $000000,$FFFFFF,$68372B,$70A4B2,$6F3D86,$588D43,$352879,$B8C76F,$6F4F25,$433900,$9A6759,$444444,$6C6C6C,$9AD284,$6C5EB5,$959595
</pre> <br><br></td></tr></table><br>
<a name="1294867"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Chalky</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#56">[#56]</a></td></tr></table></td></tr><tr ><td class="posttext"> There's a bug in that code:<br><pre class=code>For y=0 To 1023 ; For x=0 To 1024 ; pmap(x+y*1024) = ReadPixel(img,x,y) ; Next ; Next ' Load png 1024 x 1024</pre>should be:<br><pre class=code>For y=0 To 1023 ; For x=0 To 1023 ; pmap(x+y*1024) = ReadPixel(img,x,y) ; Next ; Next ' Load png 1024 x 1024</pre>Very nice effect though. <br><br></td></tr></table><br>
<a name="1294868"></a>

<a name="1294869"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#57">[#57]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ya I've been buzy with alot of versions, it slipped in., there was a  few more, I fixed them all here.<br><br><pre class=code>
Rem ------------------------------------------
 ___     ____  _____  _____   ______   ______  
|    \  /    |/     \|     \ |   ___| |___   | 
|     \/     ||     ||      \|   ___|   /   /  
|__/\__/|____|\_____/|______/|______|  |___|   

EndRem

Global buffer:Int[128*128]
Local img2:TPixmap=LoadPixmap(LoadBank("http::s14.postimg.org/xotmro9vh/128x1282.png"))
For yy=0 To 127 ; For xx=0 To 127 ; buffer(xx+yy*128) = ReadPixel(img2,xx,yy) ; Next ; Next
AddHook FlipHook,irq,Null ; Global fps:Int , fpstotal:Int , msstart:Float , ms:Float = MilliSecs()

Global map[4096,4096] ; For yy=0 To 316 ; For xx=0 To 475; map[xx,yy]=Rnd(127) ; Next ; Next
For temp=0 To 255 ; map[temp,0]=temp ; Next
Global cmap[4096,4096] ; For yy=0 To 316 ; For xx=0 To 475; cmap[xx,yy]=Rnd(15) ; Next ; Next
Global wx:Int , wy:Int , cx:Int , c:Int = buffer[0] , cols:Int[16] , s:Int = 2
RestoreData colors ; For temp=0 To 15 ; ReadData cols[temp] ; Next
writetomap "                                        ",0,0
writetomap "    **** COMMODORE 64 BASIC V2 ****     ",0,1
writetomap "                                        ",0,2
writetomap " 64K RAM SYSTEM  38911 BASIC BYTES FREE ",0,3
writetomap "                                        ",0,4
writetomap "READY.                                  ",0,5
writetomap "                                        ",0,4

Global xres:Int = 1024 , yres:Int = 768 , pixels:Int[xres*yres] ' Set resolution here.
Local a:Float = 0 , x:Float = 0 , y:Float = 0 , dx:Float = 0 , dy:Float = 0 , speed:Float = 0
Global space_z:Float = 50 , horizon:Int = 20, scale:Float = 1000 , obj_scale:Float = 50 ' Set view and scale here.
Global pmap:Int[1024*1024] ; Global img:TPixmap = LoadPixmap(LoadBank("http::static.monstermmorpg.com/images/maps/Meteor-Falls.png"))
For y=0 To 1023 ; For x=0 To 1023 ; pmap(x+y*1024) = ReadPixel(img,x,y) ; Next ; Next ' Load png 1024 x 1024

GLGraphics xres,yres,0,60,GRAPHICS_BACKBUFFER | GRAPHICS_DEPTHBUFFER ; glViewport 0,0,xres,yres ' Set 0 for Windowed, 32 for Fullscreen here.
glMatrixMode GL_PROJECTION ; glLoadIdentity ; glOrtho 0,xres,yres,0,0,1 ; glPixelZoom 1,-1 ; glRasterPos2i 0,0 '; HideMouse

Repeat

Function readinputs()
	wx=wx-s*KeyDown(KEY_LEFT)+s*KeyDown(KEY_RIGHT) ; wy=wy-s*KeyDown(KEY_UP)+s*KeyDown(KEY_DOWN) ; wx=Max(0,Min(10000,wx)) ; wy=Max(0,Min(10000,wy))
	mx = MouseX() ; my = MouseY() ; xxx = (wx+mx) Sar 4 ; yyy = (wy+my) Sar 4 ; If MouseDown(1) Then map(xxx,yyy) = 42 ; cmap(xxx,yyy) = 7
End Function
   
	' Comment if you want static landscape, uncomment for live tile landscape
	For yy = 0 To 1023 ; For xx = 0 To 1023 ; pmap[yy*1024+xx] = 0 ; Next ; Next ; alive ; display wx,wy,0,0,1024,1024 ' Render tiles

	speed = speed + KeyDown(KEY_UP)*0.1-KeyDown(KEY_DOWN)*0.1 ; speed=Max(-5,Min(5,speed))
        a = a               - KeyDown(KEY_LEFT)+KeyDown(KEY_RIGHT) ; a = a Mod 360
	dx = speed * Cos (a) ; dy =  speed * Sin (a) ; x :+ dx ; y :+ dy
	drawplane a,x,y
       ' readinputs ; for yy = 0 To yres ; For xx = 0 To 1023 ; pixels[yy*xres+xx] = pmap[yy*1024+xx]  ; Next ; Next
	glDrawPixels xres,yres,GL_BGRA,GL_UNSIGNED_BYTE,pixels
	Delay 1 ; Flip 1
Until KeyHit(KEY_ESCAPE) Or AppTerminate()
End

Function drawplane(a:Float,cx:Float,cy:Float)
	Local sx:Int , sy:Int , d:Float , hs:Float , maskx:Int = 1023 , masky:Int = 1023 
	Local dx:Float , dy:Float , spx:Float,spy:Float 
	For sy = 0 Until yres-1 Step 2
		d = space_z*scale / Float(sy + horizon) ; hs = d / scale ; dx = -Sin(a) * hs ; dy = Cos(a) * hs
		spx = cx + d*Cos(a) - Float(xres) / 2 * dx ; spy = cy + d*Sin(a) - Float(xres) / 2 * dy
		For sx = 0 Until xres-1 ; pixels[sx+sy*xres] = pmap[(Int(spx) &amp; maskx) + ( (Int(spy) &amp; masky)*1024)] ; spx :+ dx ; spy :+ dy ; Next
	Next
End Function

Function alive()
	For temp=1 To 16 ; buffer[Int(Rand(0,15))+Int((Rand(0,15))*128)]=$ffffffff * Int(Rand(0,1)) ; Next
	cx=(cx+1) Mod 128 ; For tempy=0 To 15 ; For temp=0 To 15+32 ; buffer[16+temp+((0+tempy)*128)]=buffer[0+temp+cx+(16+tempy)*128] ; Next ; Next ; For temp=1 To 1600 ; cmap[Rnd(400),Rnd(250)]=Rnd(16) ; Next
End Function

Function display(wx,wy,ofx=0,ofy=0,sx=640,sy=400) 
	scrx = wx &amp; 15 ; scry = wy &amp; 15 ; mapx = wx Shr 4 ; mapy = wy Shr 4
	cnty = 0 ; For y = mapy To mapy+(sy Shr 4+1)
	cntx = 0 ; For x = mapx To mapx+(sx Shr 4+1)
	tilex = map(x,y) &amp; 15 ; tiley = map(x,y) Shr 4
	colour = cols(cmap(x,y)) ; xx = cntx - scrx + ofx ; yy=cnty - scry + ofy
	For ty = 0 To 7 ; For tx = 0 To 7
	If (xx+tx+tx &gt;= ofx) And (yy+ty+ty &gt;= ofy) And (xx+tx+tx &lt; ofx+sx) And (yy+ty+ty &lt; ofy+sy).. ' Mind the steps
 	 And buffer[tilex Shl 3 + tx + (tiley Shl 3 + ty)*128] &lt;&gt; c Then pmap[xx+tx+tx+(yy+ty+ty)*1024] = colour 
	Next ; Next
	cntx = cntx+16 ; Next
	cnty = cnty+16 ; Next
End Function

Function writetomap(t$,x,y)
	For tempx = 0 To Len(t$)-1 ; temp = Asc(Mid$(t$,1+tempx,1)) ; map[tempx+x,y] = temp ; cmap[tempx+x,y] = 14 ; Next
End Function

Function irq:Object(id,data:Object,context:Object)	
	Return data
End Function

#colors
DefData $000000,$FFFFFF,$68372B,$70A4B2,$6F3D86,$588D43,$352879,$B8C76F,$6F4F25,$433900,$9A6759,$444444,$6C6C6C,$9AD284,$6C5EB5,$959595
</pre> <br><br></td></tr></table><br>
<a name="1294870"></a>

<a name="1294873"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#58">[#58]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ya I've been buzy with alot of versions, it slipped in., there was a  few more, I fixed them all here.<br><br><pre class=code>
Rem ------------------------------------------
 ___     ____  _____  _____   ______   ______  
|    \  /    |/     \|     \ |   ___| |___   | 
|     \/     ||     ||      \|   ___|   /   /  
|__/\__/|____|\_____/|______/|______|  |___|   

EndRem

Global buffer:Int[128*128]
Local img2:TPixmap=LoadPixmap(LoadBank("http::s14.postimg.org/xotmro9vh/128x1282.png"))
For yy=0 To 127 ; For xx=0 To 127 ; buffer(xx+yy*128) = ReadPixel(img2,xx,yy) ; Next ; Next
AddHook FlipHook,irq,Null ; Global fps:Int , fpstotal:Int , msstart:Float , ms:Float = MilliSecs()

Global map[4096,4096] ; For yy=0 To 316 ; For xx=0 To 475; map[xx,yy]=Rnd(127) ; Next ; Next
For temp=0 To 255 ; map[temp,0]=temp ; Next
Global cmap[4096,4096] ; For yy=0 To 316 ; For xx=0 To 475; cmap[xx,yy]=Rnd(15) ; Next ; Next
Global wx:Int , wy:Int , cx:Int , c:Int = buffer[0] , cols:Int[16] , s:Int = 2
RestoreData colors ; For temp=0 To 15 ; ReadData cols[temp] ; Next
writetomap "                                        ",0,0
writetomap "    **** COMMODORE 64 BASIC V2 ****     ",0,1
writetomap "                                        ",0,2
writetomap " 64K RAM SYSTEM  38911 BASIC BYTES FREE ",0,3
writetomap "                                        ",0,4
writetomap "READY.                                  ",0,5
writetomap "                                        ",0,4

Global xres:Int = 1024 , yres:Int = 768 , pixels:Int[xres*yres] ' Set resolution here.
Local a:Float = 0 , x:Float = 0 , y:Float = 0 , dx:Float = 0 , dy:Float = 0 , speed:Float = 0
Global space_z:Float = 50 , horizon:Int = 20, scale:Float = 1000 , obj_scale:Float = 50 ' Set view and scale here.
Global pmap:Int[1024*1024] ; Global img:TPixmap = LoadPixmap(LoadBank("http::static.monstermmorpg.com/images/maps/Meteor-Falls.png"))
For y=0 To 1023 ; For x=0 To 1023 ; pmap(x+y*1024) = ReadPixel(img,x,y) ; Next ; Next ' Load png 1024 x 1024

GLGraphics xres,yres,0,60,GRAPHICS_BACKBUFFER | GRAPHICS_DEPTHBUFFER ; glViewport 0,0,xres,yres ' Set 0 for Windowed, 32 for Fullscreen here.
glMatrixMode GL_PROJECTION ; glLoadIdentity ; glOrtho 0,xres,yres,0,0,1 ; glPixelZoom 1,-1 ; glRasterPos2i 0,0 '; HideMouse

Repeat

Function readinputs()
	wx=wx-s*KeyDown(KEY_LEFT)+s*KeyDown(KEY_RIGHT) ; wy=wy-s*KeyDown(KEY_UP)+s*KeyDown(KEY_DOWN) ; wx=Max(0,Min(10000,wx)) ; wy=Max(0,Min(10000,wy))
	mx = MouseX() ; my = MouseY() ; xxx = (wx+mx) Sar 4 ; yyy = (wy+my) Sar 4 ; If MouseDown(1) Then map(xxx,yyy) = 42 ; cmap(xxx,yyy) = 7
End Function
   
	' Comment if you want static landscape, uncomment for live tile landscape
	For yy = 0 To 1023 ; For xx = 0 To 1023 ; pmap[yy*1024+xx] = 0 ; Next ; Next ; alive ; display wx,wy,0,0,1024,1024 ' Render tiles

	speed = speed + KeyDown(KEY_UP)*0.1-KeyDown(KEY_DOWN)*0.1 ; speed=Max(-5,Min(5,speed))
        a = a               - KeyDown(KEY_LEFT)+KeyDown(KEY_RIGHT) ; a = a Mod 360
	dx = speed * Cos (a) ; dy =  speed * Sin (a) ; x :+ dx ; y :+ dy
	drawplane a,x,y
       ' readinputs ; for yy = 0 To yres ; For xx = 0 To 1023 ; pixels[yy*xres+xx] = pmap[yy*1024+xx]  ; Next ; Next
	glDrawPixels xres,yres,GL_BGRA,GL_UNSIGNED_BYTE,pixels
	Delay 1 ; Flip 1
Until KeyHit(KEY_ESCAPE) Or AppTerminate()
End

Function drawplane(a:Float,cx:Float,cy:Float)
	Local sx:Int , sy:Int , d:Float , hs:Float , maskx:Int = 1023 , masky:Int = 1023 
	Local dx:Float , dy:Float , spx:Float,spy:Float 
	For sy = 0 Until yres-1 Step 2
		d = space_z*scale / Float(sy + horizon) ; hs = d / scale ; dx = -Sin(a) * hs ; dy = Cos(a) * hs
		spx = cx + d*Cos(a) - Float(xres) / 2 * dx ; spy = cy + d*Sin(a) - Float(xres) / 2 * dy
		For sx = 0 Until xres-1 ; pixels[sx+sy*xres] = pmap[(Int(spx) &amp; maskx) + ( (Int(spy) &amp; masky)*1024)] ; spx :+ dx ; spy :+ dy ; Next
	Next
End Function

Function alive()
	For temp=1 To 16 ; buffer[Int(Rand(0,15))+Int((Rand(0,15))*128)]=$ffffffff * Int(Rand(0,1)) ; Next
	cx=(cx+1) Mod 128 ; For tempy=0 To 15 ; For temp=0 To 15+32 ; buffer[16+temp+((0+tempy)*128)]=buffer[0+temp+cx+(16+tempy)*128] ; Next ; Next ; For temp=1 To 1600 ; cmap[Rnd(400),Rnd(250)]=Rnd(16) ; Next
End Function

Function display(wx,wy,ofx=0,ofy=0,sx=640,sy=400) 
	scrx = wx &amp; 15 ; scry = wy &amp; 15 ; mapx = wx Shr 4 ; mapy = wy Shr 4
	cnty = 0 ; For y = mapy To mapy+(sy Shr 4+1)
	cntx = 0 ; For x = mapx To mapx+(sx Shr 4+1)
	tilex = map(x,y) &amp; 15 ; tiley = map(x,y) Shr 4
	colour = cols(cmap(x,y)) ; xx = cntx - scrx + ofx ; yy=cnty - scry + ofy
	For ty = 0 To 7 ; For tx = 0 To 7
	If (xx+tx+tx &gt;= ofx) And (yy+ty+ty &gt;= ofy) And (xx+tx+tx &lt; ofx+sx) And (yy+ty+ty &lt; ofy+sy).. ' Mind the steps
 	 And buffer[tilex Shl 3 + tx + (tiley Shl 3 + ty)*128] &lt;&gt; c Then pmap[xx+tx+tx+(yy+ty+ty)*1024] = colour 
	Next ; Next
	cntx = cntx+16 ; Next
	cnty = cnty+16 ; Next
End Function

Function writetomap(t$,x,y)
	For tempx = 0 To Len(t$)-1 ; temp = Asc(Mid$(t$,1+tempx,1)) ; map[tempx+x,y] = temp ; cmap[tempx+x,y] = 14 ; Next
End Function

Function irq:Object(id,data:Object,context:Object)	
	Return data
End Function

#colors
DefData $000000,$FFFFFF,$68372B,$70A4B2,$6F3D86,$588D43,$352879,$B8C76F,$6F4F25,$433900,$9A6759,$444444,$6C6C6C,$9AD284,$6C5EB5,$959595
</pre><br><br><br>Here's the Mode7, which is much simpler on its own, static only. It might be useful for people when learning. (This is normal MODE7 without any bells and whistles).<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' Simple Mode 7 using software rendering (quick, 60 fps+)

Local a:Float = 0 , x:Float = 0 , y:Float = 0 , dx:Float = 0 , dy:Float = 0 , speed:Float = 0
Global space_z:Float = 50 , horizon:Int = 20, scale:Float = 1000 , obj_scale:Float = 50 ' Set view and scale here.
Global map:Int[1024*1024] ; Global img:TPixmap = LoadPixmap(LoadBank("http::static.monstermmorpg.com/images/maps/Meteor-Falls.png"))
For y=0 To 1023 ; For x=0 To 1024 ; map(x+y*1024) = ReadPixel(img,x,y) ; Next ; Next ' Load png 1024 x 1024

Global xres:Int = 1024 , yres:Int = 768 , pixels:Int[xres*yres]
GLGraphics xres,yres,0,60,GRAPHICS_BACKBUFFER | GRAPHICS_DEPTHBUFFER ; glViewport 0,0,xres,yres
glMatrixMode GL_PROJECTION ; glLoadIdentity ; glOrtho 0,xres,yres,0,0,1 ; glPixelZoom 1,-1 ; glRasterPos2i 0,0

x=0 ; y = 0 ; a= 0
Repeat
	speed = speed + KeyDown(KEY_UP)*0.1-KeyDown(KEY_DOWN)*0.1 ; speed=Max(-5,Min(5,speed))
    a = a         - KeyDown(KEY_LEFT)+KeyDown(KEY_RIGHT) ; a = a Mod 360
	dx = speed * Cos (a) ; dy =  speed * Sin (a) ; x :+ dx ; y :+ dy
	drawplane a,x,y
	Delay 1 ; Flip 1
Until KeyHit(KEY_ESCAPE) Or AppTerminate()
End

Function drawplane(a:Float,cx:Float,cy:Float)
	Local sx:Int , sy:Int , d:Float , hs:Float , maskx:Int = 1023 , masky:Int = 1023 
	Local dx:Float , dy:Float , spx:Float,spy:Float 
	For sy = 0 Until yres-1
		d = space_z*scale / Float(sy + horizon) ; hs = d / scale ; dx = -Sin(a) * hs ; dy = Cos(a) * hs
		spx = cx + d*Cos(a) - Float(xres) / 2 * dx ; spy = cy + d*Sin(a) - Float(xres) / 2 * dy
		For sx = 0 Until xres-1 ; pixels[sx+sy*xres] = map[  (Int(spx) &amp; maskx) + ( (Int(spy) &amp; masky)*1024)]
		spx :+ dx ; spy :+ dy ; Next
	Next
	glDrawPixels xres,yres,GL_BGRA,GL_UNSIGNED_BYTE,pixels
End Function
</textarea> <br><br></td></tr></table><br>
<a name="1294871"></a>

<a name="1294872"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#59">[#59]</a></td></tr></table></td></tr><tr ><td class="posttext"> Congratulations, Casaber ! You do realize you are likely the <u>only</u> programmer that has solved mode 7 <b>=AND=</b> posted the source code to show how it's done !<br><br>When you're up to it, next challenge. Take a good look at F-Zero. See how they have a static background (not 3D) above the horizon (vertical 3rd of screen), and that everything below is true and lovely 3D.<br><br><img src="http://wiiudaily.com/wp-content/uploads/2013/02/f-zero_gameplay.jpeg"> <br><br></td></tr></table><br>
<a name="1294874"></a>

<a name="1294875"></a>

<a name="1294876"></a>

<a name="1294877"></a>

<a name="1294878"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#60">[#60]</a></td></tr></table></td></tr><tr ><td class="posttext"> dw817 :) Well there was a previous post here, I learned alot from that. Or, at least I got the idea roughly, I didn't learn from it becuase it was very complex source. <br>But I found the blog behind it, and got the ideas clearly from there. I had to look around quiet a few nights before finding a good simple solution.<br><br>Still, I want that HW solution that reminds me of SNES concepts (and yours too actually). You use the same mindset as they did with setting scale (and they also use rotation) and set it once differently per scanline.<br><br>It's a real headscratcher to get it working (and the Monkey original has it's flaw so I cannot rely 100% on it either). It's a rare solution The SNES engineers knew what they did. <br>They kind of started the whole thing and made 3d more readily available.. MODE7..inspired into Raycasting DOOM I guess etc and  before we know it we ended up have amazing <br>3d games in 2016, and get all nostagic about 1980's again. That's how it works ;)<br><br>If anyone wants to try check it out and help, I would be most grateful and sleep better at night.<br><br>PS the TileiImage is robust and perfect condition. So it's not much code to look through actually, I guess good matrix knowledge and a clear mind is what's sought after, I have neither ;)<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' Simple Mode 7 (Conversion from Monkey)

Local XRes:Float = 640 , YRes:Float = 480 , X:Float = 930 , Y:Float = 700 , YLines:Float = 240 , r:Float = 0 ' 90-45
Local vas:Float[Ylines] , vd:Float[Ylines] , VScale:Float[Ylines] , Height:Float , HFOV:Float , VFOV:Float , VDelta:Float , va:Float 
Local camd:Float , camx:Float , camy:Float , cosine:Float , sine:Float , xhit:Float , yhit:Float , xpos:Float , ypos:Float

SetGraphicsDriver GLMax2DDriver(),0 ; Graphics xres,yres,0,60,GRAPHICS_BACKBUFFER + GRAPHICS_DEPTHBUFFER ; glewinit ; AutoImageFlags MASKEDIMAGE 
Local map:TImage = LoadImage(LoadBank("http::d13yacurqjgara.cloudfront.net/users/7564/screenshots/734550/attachments/70292/1024x1024.png"))
Local mapw:Float = ImageWidth(map) , maph:Float = ImageHeight(map)

Height = 32*5 ; HFOV = 60 ; VFOV= 45 ; VDelta = VFOV / YLines ; va = VDelta
For a = 0 To YLines-1 ; vas[a] = va ; vd[a] = Height / Tan(vas[a]) ; VScale[a] = (maph/ ((vd[a]*Tan(HFOV)) * 2)) * (mapw/XRes) ; va = va + VDelta ; Next

Repeat
Cls
If MouseDown(1) Then x = x + Cos(r) * 2 ; y = y + -Sin(r) * 2 ; r = r- ((MouseX() - (xres/2.0)) / xres)*2
x = x + (KeyDown(KEY_UP)-KeyDown(KEY_DOWN)) * 4 * Cos(r)
y = y + (KeyDown(KEY_UP)-KeyDown(KEY_DOWN)) * 4 * -Sin(r)
r = r - (KeyDown(KEY_RIGHT) - KeyDown(KEY_LEFT)) * 2
x = x - 2

camd = Tan(22.5) * height * 5 ; camX = x - (camd * Cos(r)) ; camy = y - (camd * -Sin(r))
cosine = -Cos(r) ; sine = Sin(r) ' Signs swapped

For a = 0 To YLines-1
	  xhit = camx + (cosine*vd[a]) ; yhit = camy + (sine*vd[a]) ; xpos = Abs(xhit) Mod mapw ; ypos = Abs(yhit) Mod maph
      SetViewport 0,yres/2+a,xres,1
      SetImageHandle map,xpos,ypos
      SetRotation -(r-90)
      SetScale vscale[a],vscale[a] 
      TileImage map,xres/2,240+a
Next
SetViewport 0,0,xres,yres
Flip
Until MouseDown(2)

' Replacement for the inbuilt TILEIMAGE which otherwise ignores current SCALE and ROTATION settings.
Function TileImage(image:TImage, x:Float=0# ,y:Float=0#, frame:Int=0)
    Local scale_x#, scale_y#
    GetScale(scale_x#, scale_y#)
    Local viewport_x%, viewport_y%, viewport_w%, viewport_h%
    GetViewport(viewport_x, viewport_y, viewport_w, viewport_h)
    Local origin_x#, origin_y#
    GetOrigin(origin_x, origin_y)
    Local handle_X#, handle_y#
    GetHandle(handle_X#, handle_y#)
    Local image_h# = ImageHeight(image)
    Local image_w# = ImageWidth(image)
    Local w#=image_w * Abs(scale_x#)
    Local h#=image_h * Abs(scale_y#)
    Local ox#=viewport_x-w+1
    Local oy#=viewport_y-h+1
    origin_X = origin_X Mod w
    origin_Y = origin_Y Mod h
    Local px#=x+origin_x - handle_x
    Local py#=y+origin_y - handle_y
    Local fx#=px-Floor(px)
    Local fy#=py-Floor(py)
    Local tx#=Floor(px)-ox
    Local ty#=Floor(py)-oy
    If tx&gt;=0 tx=tx Mod w + ox Else tx = w - -tx Mod w + ox
    If ty&gt;=0 ty=ty Mod h + oy Else ty = h - -ty Mod h + oy
    Local vr#= viewport_x + viewport_w, vb# = viewport_y + viewport_h
    SetOrigin 0,0
    Local iy#=ty
    While iy&lt;vb + h
        Local ix#=tx
        While ix&lt;vr + w
            DrawImage(image, ix+fx,iy+fy, frame)
            ix=ix+w
        Wend
        iy=iy+h
    Wend
    SetOrigin origin_x, origin_y
End Function
</textarea> <br><br></td></tr></table><br>
<a name="1294885"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#61">[#61]</a></td></tr></table></td></tr><tr ><td class="posttext"> So far the best code I've seen of the bunch you've done so far, Casaber, is this one. Perfect acceleration and rotation. Works great here !<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' Simple Mode 7 using software rendering (quick, 60 fps+)

Local a:Float = 0 , x:Float = 0 , y:Float = 0 , dx:Float = 0 , dy:Float = 0 , speed:Float = 0
Global space_z:Float = 50 , horizon:Int = 20, scale:Float = 1000 , obj_scale:Float = 50 ' Set view and scale here.
Global map:Int[1024*1024] ; Global img:TPixmap = LoadPixmap(LoadBank("http::static.monstermmorpg.com/images/maps/Meteor-Falls.png"))
For y=0 To 1023 ; For x=0 To 1023 ; map(x+y*1024) = ReadPixel(img,x,y) ; Next ; Next ' Load png 1024 x 1024

Global xres:Int = 1024 , yres:Int = 768 , pixels:Int[xres*yres]
GLGraphics xres,yres,0,0,GRAPHICS_BACKBUFFER | GRAPHICS_DEPTHBUFFER ; glViewport 0,0,xres,yres
glMatrixMode GL_PROJECTION ; glLoadIdentity ; glOrtho 0,xres,yres,0,0,1 ; glPixelZoom 1,-1 ; glRasterPos2i 0,0

x=0 ; y = 0 ; a= 0
Repeat
	speed = speed + KeyDown(KEY_UP)*0.1-KeyDown(KEY_DOWN)*0.1 ; speed=Max(-5,Min(5,speed))
    a = a         - KeyDown(KEY_LEFT)+KeyDown(KEY_RIGHT) ; a = a Mod 360
	dx = speed * Cos (a) ; dy =  speed * Sin (a) ; x :+ dx ; y :+ dy
	drawplane a,x,y
	Delay 1 ; Flip 1
Until KeyHit(KEY_ESCAPE) Or AppTerminate()
End

Function drawplane(a:Float,cx:Float,cy:Float)
	Local sx:Int , sy:Int , d:Float , hs:Float , maskx:Int = 1023 , masky:Int = 1023 
	Local dx:Float , dy:Float , spx:Float,spy:Float 
	For sy = 0 Until yres-1
		d = space_z*scale / Float(sy + horizon) ; hs = d / scale ; dx = -Sin(a) * hs ; dy = Cos(a) * hs
		spx = cx + d*Cos(a) - Float(xres) / 2 * dx ; spy = cy + d*Sin(a) - Float(xres) / 2 * dy
		For sx = 0 Until xres-1 ; pixels[sx+sy*xres] = map[  (Int(spx) &amp; maskx) + ( (Int(spy) &amp; masky)*1024)]
		spx :+ dx ; spy :+ dy ; Next
	Next
	glDrawPixels xres,yres,GL_BGRA,GL_UNSIGNED_BYTE,pixels
End Function
</textarea><br><br>What really astounds me about this code is you can choose any vector to rotate, start accelerating, and it is flawless and seamless tiling despite the angle chosen. <br><br></td></tr></table><br>
<a name="1294890"></a>

<a name="1294891"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#62">[#62]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks, I like that too, havn't seen any simpler mode7 example so far so I am abit proud of that one. Terseness important for clearity.<br><br>There are parallals in this to the hardware of course, so I could fix the hw later when  the math feels like home. Which would take a few years ;) <br><br></td></tr></table><br>
<a name="1294892"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#63">[#63]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'll bet someone will take this and make an even shorter now ;)<br><br>That's how things work haha.<br><br>I only wanted to have a good demo for my little project.. you know, I made this into a a few sleepless nights instead :s<br><br>You're planning to use this kind of graphics in you RPG project? <br><br></td></tr></table><br>
<a name="1294909"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#64">[#64]</a></td></tr></table></td></tr><tr ><td class="posttext"> Perhaps, Casaber. It depends. As I am ultimately working on a new RPG Maker, I would use it to tilt the screen for when you travel by Airship, just like Final Fantasy.<br><br>Yet ... your code could also yield a great racing game with a bit of work involved. Might be interesting to see. :) <br><br></td></tr></table><br>
<a name="1294928"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#65">[#65]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nice !! if you need help later with something just shout :) keep in touch!!  <br><br>Over here things are quickly getting more and more into being normal so I won´t have as much time to spend on coding.  I learnt alot about Bmax this week I  feel. <br><br>A very descent platform to do stuff on, and I hope Monkey2 will only improve on it ! <br><br></td></tr></table><br>
<a name="1294933"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#66">[#66]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've changed my public email my old died, it's CassandrawCastell@...<br>This is my new trash mail but I check it at times. <br><br></td></tr></table><br>
<a name="1294934"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#67">[#67]</a></td></tr></table></td></tr><tr ><td class="posttext"> Urrf ... Notta good idea to post your Email in the forum,Casaber. I know you can publicly list it in your account but SPAM 'bots often do cull through the Internet for any stray Emails to add to the collective.<br><br>And is it Cassandra ? That's fine. :) Once again some very fine coding you've done up there. I spent about an hour last night looking it over - trying to understand it. It's all very advanced to me. <br><br></td></tr></table><br>
<a name="1294936"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#68">[#68]</a></td></tr></table></td></tr><tr ><td class="posttext"> Awesome demos here! <br><br></td></tr></table><br>
<a name="1294963"></a>

<a name="1294965"></a>

<a name="1294967"></a>

<a name="1294980"></a>

<a name="1294981"></a>

<a name="1295002"></a>

<a name="1295003"></a>

<a name="1295009"></a>

<a name="1295010"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#69">[#69]</a></td></tr></table></td></tr><tr ><td class="posttext"> Want to show one last thing how I did (halfway I´m in the middle of things) optimize the slow IF..THEN and show the difference.<br><br><br>This is only true for emmense loops, "inner" loops, "long" loops, you know those times when extreme amounts of things just needs to get done within a timeframe. <br>It's easy too look at modern machine as gods of infinite speed. Or rather they *are* extremely fast but what we throw at them (invisibly sometimes in the code) makes them very sad, and<br> it's hard to know sometimes as the rules are complex and hidden , you just have to  test/measure and be surprised.  Some things got learned with exprience sure. But not all.<br><br>They use every kind of odd thing to try speed them up.. caches, predictions, aligments, parallal instructions (SSE/NEON) which very nice actually but have so <br>very mechanical rules in what order registers should be used to get best speed. Everything  gets very unhumane and these things are left best to the compilers to handle, but when the compiler fails it really bites your tail.<br><br>This is the original code with not too much thought into (well actually there are much thought gone into details in this one and that hit it with the ugly bat. you can's see every intention in <br>the code. Which I hate, but it was needed to bring things up to speed. And it didn't quiet make even then. It can't keep up with 60 fps. If it does you have a strong machine. Exremely strong. I get almost 60fps with loads of dropouts on my 3Ghz Mac. <br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Global buffer:Int[256*256] ; Local img2:TPixmap=LoadPixmap(LoadBank("http::www.foxhack.net/files/blog/2008/01-09-charadata.png"))  ' Load a 256x256 Atlas with 8x8 tiles
For yy=0 To 255 ; For xx=0 To 255 ; buffer(xx+yy*256) = ReadPixel(img2,xx,yy) ; Next ; Next
Global map[4096,4096] , wx:Int , wy:Int , cx:Int , c:Int = buffer[0] , s:Int = 2 , xres:Int = 1024 , yres:Int = 768 , pixels:Int[xres*yres]
Local a:Float = 0 , x:Float = 0 , y:Float = 0 , dx:Float = 0 , dy:Float = 0 , speed:Float = 0
Global space_z:Float = 50 , horizon:Int = 20, scale:Float = 1000 , obj_scale:Float = 50 , pmap:Int[1024*1024] 

' Fill world with atlas 1:1 side by side
For worldy=0 To 4095 Step 32 ; For worldx=0 To 4095 Step 32 ; For temp2=0 To 31 ; For temp=0 To 31 ;	map(temp+worldx,temp2+worldy)=temp+temp2*32 ; Next ; Next ; Next ; Next
GLGraphics xres,yres,0,60,GRAPHICS_BACKBUFFER | GRAPHICS_DEPTHBUFFER ; glViewport 0,0,xres,yres
glMatrixMode GL_PROJECTION ; glLoadIdentity ; glOrtho 0,xres,yres,0,0,1 ; glPixelZoom 1,-1 ; glRasterPos2i 0,0 

Repeat
	For yy = 0 To 1023 ; For xx = 0 To 1023 ; pmap[yy*1024+xx] = 0 ; Next ; Next
	display wx,wy,0,0,1024,1024
	speed = speed + KeyDown(KEY_UP)*0.1-KeyDown(KEY_DOWN)*0.1 ; speed=Max(-5,Min(5,speed))
	a = a - KeyDown(KEY_LEFT)+KeyDown(KEY_RIGHT) ; a = a Mod 360
	dx = speed * Cos (a) ; dy =  speed * Sin (a) ; x :+ dx ; y :+ dy
	drawplane a,x,y
	alive
	'readinputs ; For yy = 0 To yres ; For xx = 0 To 1023 ; pixels[yy*xres+xx] = pmap[yy*1024+xx]  ; Next ; Next ' Show 2D
	glDrawPixels xres,yres,GL_BGRA,GL_UNSIGNED_BYTE,pixels
	Delay 1 ; Flip 1
Until KeyHit(KEY_ESCAPE) Or AppTerminate()
End

Function readinputs()
	wx=wx-s*KeyDown(KEY_LEFT)+s*KeyDown(KEY_RIGHT) ; wy=wy-s*KeyDown(KEY_UP)+s*KeyDown(KEY_DOWN) ; wx=Max(0,Min(10000,wx)) ; wy=Max(0,Min(10000,wy))
	mx = MouseX() ; my = MouseY() ; xxx = (wx+mx) Sar 3 ; yyy = (wy+my) Sar 3; If MouseDown(1) Then map(xxx,yyy) = 42
End Function

Function alive()
	For temp=1 To 16 ; buffer[Int(Rand(0,15))+Int((Rand(0,15))*256)]=$ffffffff * Int(Rand(0,1)) ; Next
	cx=cx+1 Mod 256 ; For tempy=0 To 15 ; For temp=0 To 15+32 ; buffer[16+temp+((0+tempy)*256)]=buffer[0+temp+cx+(16+tempy)*256] ; Next ; Next
	'For temp=1 To 100 ; map[Rnd(1023),Rnd(1023)]=Rnd(1023) ; Next ' Change few tiles each frame (this could be thousands no problem, mind the rnd when it gets large though.)
End Function

Function drawplane(a:Float,cx:Float,cy:Float) ' This might need optimzation too but it has not as intens loops so actually it does not need at all as much as display() does.
	Local sx:Int , sy:Int , d:Float , hs:Float , maskx:Int = 1023 , masky:Int = 1023 
	Local dx:Float , dy:Float , spx:Float,spy:Float 
	For sy = 0 Until yres-1 Step 2
		d = space_z*scale / Float(sy + horizon) ; hs = d / scale ; dx = -Sin(a) * hs ; dy = Cos(a) * hs
		spx = cx + d*Cos(a) - Float(xres) / 2 * dx ; spy = cy + d*Sin(a) - Float(xres) / 2 * dy
		For sx = 0 Until xres-1 ; pixels[sx+sy*xres] = pmap[(Int(spx) &amp; maskx) + ( (Int(spy) &amp; masky)*1024)] ; spx :+ dx ; spy :+ dy ; Next
	Next
End Function

Function display(wx,wy,ofx=0,ofy=0,sx=640,sy=400) ' Here's where most optimization is needed (as it is it can't keep up with steady 60 fps on average machines, every teeny fraction of Bmax knowledge should be put in here. Unrolling helps, less conditions helps.
	scrx = wx &amp; 7 ; scry = wy &amp; 7 ; mapx = wx Shr 3 ; mapy = wy Shr 3
	cnty = 0 ; For y = mapy To mapy+(sy Shr 3+1)
	cntx = 0 ; For x = mapx To mapx+(sx Shr 3+1)
	tilex = map(x,y) &amp; 31 ; tiley = map(x,y) Shr 5 ' 32 tiles per line in atlas
	xx = cntx - scrx + ofx ; yy=cnty - scry + ofy
	For ty = 0 To 7 ; For tx = 0 To 7
	If xx+tx &gt;= ofx And yy+ty &gt;= ofy And xx+tx &lt; ofx+sx And yy+ty &lt; ofy+sy ..
 	 Then pmap[xx+tx+(yy+ty)Shl 10] = buffer[tilex Shl 3 + tx + (tiley Shl 3 + ty) Shl 8]
	Next ; Next
	cntx = cntx+8 ; Next
	cnty = cnty+8 ; Next
End Function
</textarea><br><br>This though, which I leave unravelled to be read.. This is the horror that happened when I wanted to get ONE IF .. THEN out of a very very intense loop. In the above.<br>This is what slowed it down (the major cause at least, there lots left you could do, but as you see in other place you could even have trigonometry without problem). <br>We're talking scale of<br>about 300.000 x 8 x 8 times that an IF..THEN happens. that was the slowdown. This one below should run fine. Even if it's in the middle of the optimizing process. <br>Don't even try to grasp that code. I need to code this within few days or I will forget what I was doing forever.<br><br>So ya, just wanted to show, that optimizing is needed when it really counts. <br>This brought this code up to speed.<br><br>60 fps here we come.<br><pre class=code>

Global buffer:Int[256*256] ; Local img2:TPixmap=LoadPixmap(LoadBank("http::www.foxhack.net/files/blog/2008/01-09-charadata.png"))  ' Load a 256x256 Atlas with 8x8 tiles
For yy=0 To 255 ; For xx=0 To 255 ; buffer(xx+yy*256) = ReadPixel(img2,xx,yy) ; Next ; Next
Global map[4096,4096] , wx:Int , wy:Int , cx:Int , c:Int = buffer[0] , s:Int = 2 , xres:Int = 1024 , yres:Int = 768 , pixels:Int[xres*yres]
Local a:Float = 0 , x:Float = 0 , y:Float = 0 , dx:Float = 0 , dy:Float = 0 , speed:Float = 0
Global space_z:Float = 50 , horizon:Int = 20, scale:Float = 1000 , obj_scale:Float = 50 , pmap:Int[1024*1024] 

' Fill world with atlas 1:1 side by side
For worldy=0 To 4095 Step 32 ; For worldx=0 To 4095 Step 32 ; For temp2=0 To 31 ; For temp=0 To 31 ;	map(temp+worldx,temp2+worldy)=temp+temp2*32 ; Next ; Next ; Next ; Next
GLGraphics xres,yres,0,60,GRAPHICS_BACKBUFFER | GRAPHICS_DEPTHBUFFER ; glViewport 0,0,xres,yres
glMatrixMode GL_PROJECTION ; glLoadIdentity ; glOrtho 0,xres,yres,0,0,1 ; glPixelZoom 1,-1 ; glRasterPos2i 0,0 

Repeat
	For yy = 0 To 1023 ; For xx = 0 To 1023 ; pmap[yy*1024+xx] = 0 ; Next ; Next
	display wx,wy,    0,0,1024,1024 ' DRAW INTO AN NON-TILE ALIGNED RECTANGLE TO VIEW BUG
	speed = speed + KeyDown(KEY_UP)*0.1-KeyDown(KEY_DOWN)*0.1 ; speed=Max(-5,Min(5,speed))
	a = a - KeyDown(KEY_LEFT)+KeyDown(KEY_RIGHT) ; a = a Mod 360
	dx = speed * Cos (a) ; dy =  speed * Sin (a) ; x :+ dx ; y :+ dy
	drawplane a,x,y
	alive
	' readinputs ; For yy = 0 To yres ; For xx = 0 To 1023 ; pixels[yy*xres+xx] = pmap[yy*1024+xx]  ; Next ; Next ' Show 2D
	glDrawPixels xres,yres,GL_BGRA,GL_UNSIGNED_BYTE,pixels
	Delay 1 ; Flip 1
Until KeyHit(KEY_ESCAPE) Or AppTerminate()
End

Function readinputs()
	wx=wx-s*KeyDown(KEY_LEFT)+s*KeyDown(KEY_RIGHT) ; wy=wy-s*KeyDown(KEY_UP)+s*KeyDown(KEY_DOWN) ; wx=Max(0,Min(10000,wx)) ; wy=Max(0,Min(10000,wy))
	mx = MouseX() ; my = MouseY() ; xxx = (wx+mx) Sar 3 ; yyy = (wy+my) Sar 3; If MouseDown(1) Then map(xxx,yyy) = 42
End Function

Function alive()
	For temp=1 To 16 ; buffer[Int(Rand(0,15))+Int((Rand(0,15))*256)]=$ffffffff * Int(Rand(0,1)) ; Next
	cx=cx+1 Mod 256 ; For tempy=0 To 15 ; For temp=0 To 15+32 ; buffer[16+temp+((0+tempy)*256)]=buffer[0+temp+cx+(16+tempy)*256] ; Next ; Next
	'For temp=1 To 100 ; map[Rnd(1023),Rnd(1023)]=Rnd(1023) ; Next ' Change few tiles each frame (this could be thousands no problem, mind the rnd when it gets large though.)
End Function

Function drawplane(a:Float,cx:Float,cy:Float) ' This might need optimzation too but it has not as intens loops so actually it does not need at all as much as display() does.
	Local sx:Int , sy:Int , d:Float , hs:Float , maskx:Int = 1023 , masky:Int = 1023 
	Local dx:Float , dy:Float , spx:Float,spy:Float 
	For sy = 0 Until yres-1 Step 2
		d = space_z*scale / Float(sy + horizon) ; hs = d / scale ; dx = -Sin(a) * hs ; dy = Cos(a) * hs
		spx = cx + d*Cos(a) - Float(xres) / 2 * dx ; spy = cy + d*Sin(a) - Float(xres) / 2 * dy
		For sx = 0 Until xres-1 ; pixels[sx+sy*xres] = pmap[(Int(spx) &amp; maskx) + ( (Int(spy) &amp; masky)*1024)] ; spx :+ dx ; spy :+ dy ; Next
	Next
End Function

Function display(wx,wy,ofx=0,ofy=0,sx=640,sy=400) ' Here's where most optimization is needed (as it is it can't keep up with steady 60 fps on average machines, 
' every teeny fraction of Bmax knowledge should be put in here. Unrolling helps, less conditions helps.
	scrx = wx &amp; 7 ; scry = wy &amp; 7 ; mapx = wx Shr 3 ; mapy = wy Shr 3
	
	' Draw 99% of the tiles, inside the frame so we don´t need any conditions
	cnty = 8 ; For y = mapy+1 To mapy+(sy Shr 3-1)
	cntx = 8 ; For x = mapx+1 To mapx+(sx Shr 3-1)
	tilex = map(x,y) &amp; 31 ; tiley = map(x,y) Shr 5 ' 32 tiles per line in atlas
	xx = cntx - scrx + ofx ; yy=cnty - scry + ofy



' IN THE MIDDLE OF THE OPTIMIZATION PROCESS..

' Doing many tiles and the horror below is half-simplified and unrolled (partly improved) of what the CPU does.
' What was before an invisible mess that the CPU had To go through.
' What slowed everything down mostly was         300.000 x 8 x 8 IF THEN, nothing else mostly.

' 2 Inner most loops of code have been partly unrolled here, and here we see something in the middle of the optimizing process, and its' towards the end actually.
' Very messy and the need to do these kind of thought processes are intense, and might even hide the intention of code (not always though), but often. Sometimes they actually clear things up. But we're are in the middle of things now. So, very messy.

' 99 % of the tiiles need no clipping, meaning no expansive IF THEN.

For ty = 0 To 7
a = (tiley Shl 3 + ty) Shl 8 ; a = a + tilex Shl 3 ; b = xx+(yy+ty) Shl 10
pmap[b] = buffer[a] ; pmap[b+1] = buffer[a+1] ; pmap[b+2] = buffer[a+2] ; pmap[b+3] = buffer[a+3]
pmap[b+4] = buffer[a+4] ; pmap[b+5] = buffer[a+5] ; pmap[b+6] = buffer[a+6] ; pmap[b+7] = buffer[a+7]
Next
cntx = cntx+8 ; Next
cnty = cnty+8 ; Next

' Now most is draw, we still have the outer "frame" of tiles, th edges, the top, bottom, left and right and these needs clipping. 

' Let's get saucy.

' TOP FRAME OF TILES W. CLIPPING
cnty = 0 ; For y = mapy To mapy '  Nothing here to loop, but middle of work so KEEP loops while working to see symmetry of code. This is messy enough already.
cntx = 0 ; For x = mapx To mapx+ sx Shr 3 + 0
tilex = map(x,y) &amp; 31 ; tiley = map(x,y) Shr 5 ; xx = cntx- scrx + ofx ; yy=cnty - scry + ofy
For ty = 0 To 7
a = (tiley Shl 3 + ty) Shl 8 ; a = a + tilex Shl 3 ; b = xx+(yy+ty) Shl 10
If   xx &gt;= ofx And yy+ty &gt;= ofy And   xx &lt; ofx+sx And yy+ty &lt; ofy+sy   Then pmap[b] =  buffer[a]
If xx+1 &gt;= ofx And yy+ty &gt;= ofy And xx+1 &lt; ofx+sx And yy+ty &lt; ofy+sy	 Then pmap[b+1] = buffer[a+1]
If xx+2 &gt;= ofx And yy+ty &gt;= ofy And xx+2 &lt; ofx+sx And yy+ty &lt; ofy+sy	 Then pmap[b+2] = buffer[a+2]
If xx+3 &gt;= ofx And yy+ty &gt;= ofy And xx+3 &lt; ofx+sx And yy+ty &lt; ofy+sy	 Then pmap[b+3] = buffer[a+3]
If xx+4 &gt;= ofx And yy+ty &gt;= ofy And xx+4 &lt; ofx+sx And yy+ty &lt; ofy+sy	 Then pmap[b+4] = buffer[a+4]
If xx+5 &gt;= ofx And yy+ty &gt;= ofy And xx+5 &lt; ofx+sx And yy+ty &lt; ofy+sy	 Then pmap[b+5] = buffer[a+5]
If xx+6 &gt;= ofx And yy+ty &gt;= ofy And xx+6 &lt; ofx+sx And yy+ty &lt; ofy+sy	 Then pmap[b+6] = buffer[a+6]
If xx+7 &gt;= ofx And yy+ty &gt;= ofy And xx+7 &lt; ofx+sx And yy+ty &lt; ofy+sy	 Then pmap[b+7] = buffer[a+7]
Next
cntx = cntx+8 ; Next
cnty = cnty+8 ; Next

' BOTTOM FRAME OF TILES W. CLIPPING
cnty = sy ; For y = mapy+sy Shr 3 + 0 To mapy + sy Shr 3 + 0
cntx = 0 ; For x = mapx To mapx+ sx Shr 3 + 0
tilex = map(x,y) &amp; 31 ; tiley = map(x,y) Shr 5 ; xx = cntx- scrx + ofx ; yy=cnty - scry + ofy
For ty = 0 To 7
a = (tiley Shl 3 + ty) Shl 8 ; a = a + tilex Shl 3 ; b = xx+(yy+ty) Shl 10
If   xx &gt;= ofx And yy+ty &gt;= ofy And   xx &lt; ofx+sx And yy+ty &lt; ofy+sy   Then pmap[b] =  buffer[a]
If xx+1 &gt;= ofx And yy+ty &gt;= ofy And xx+1 &lt; ofx+sx And yy+ty &lt; ofy+sy	 Then pmap[b+1] = buffer[a+1]
If xx+2 &gt;= ofx And yy+ty &gt;= ofy And xx+2 &lt; ofx+sx And yy+ty &lt; ofy+sy	 Then pmap[b+2] = buffer[a+2]
If xx+3 &gt;= ofx And yy+ty &gt;= ofy And xx+3 &lt; ofx+sx And yy+ty &lt; ofy+sy	 Then pmap[b+3] = buffer[a+3]
If xx+4 &gt;= ofx And yy+ty &gt;= ofy And xx+4 &lt; ofx+sx And yy+ty &lt; ofy+sy	 Then pmap[b+4] = buffer[a+4]
If xx+5 &gt;= ofx And yy+ty &gt;= ofy And xx+5 &lt; ofx+sx And yy+ty &lt; ofy+sy	 Then pmap[b+5] = buffer[a+5]
If xx+6 &gt;= ofx And yy+ty &gt;= ofy And xx+6 &lt; ofx+sx And yy+ty &lt; ofy+sy	 Then pmap[b+6] = buffer[a+6]
If xx+7 &gt;= ofx And yy+ty &gt;= ofy And xx+7 &lt; ofx+sx And yy+ty &lt; ofy+sy	 Then pmap[b+7] = buffer[a+7]
Next
cntx = cntx+8 ; Next
cnty = cnty+8 ; Next

' LEFT FRAME OF TILES W. CLIPPING
cnty = 0 ; For y = mapy To mapy+sy Shr 3 + 0
cntx = 0 ; For x = mapx+0 To mapx+0
tilex = map(x,y) &amp; 31 ; tiley = map(x,y) Shr 5 ; xx = cntx - scrx + ofx ; yy=cnty - scry + ofy
For ty = 0 To 7
a = (tiley Shl 3 + ty) Shl 8 ; a = a + tilex Shl 3 ; b = xx+(yy+ty) Shl 10
If   xx &gt;= ofx And yy+ty &gt;= ofy And   xx &lt; ofx+sx And yy+ty &lt; ofy+sy   Then pmap[b] =  buffer[a]
If xx+1 &gt;= ofx And yy+ty &gt;= ofy And xx+1 &lt; ofx+sx And yy+ty &lt; ofy+sy	 Then pmap[b+1] = buffer[a+1]
If xx+2 &gt;= ofx And yy+ty &gt;= ofy And xx+2 &lt; ofx+sx And yy+ty &lt; ofy+sy	 Then pmap[b+2] = buffer[a+2]
If xx+3 &gt;= ofx And yy+ty &gt;= ofy And xx+3 &lt; ofx+sx And yy+ty &lt; ofy+sy	 Then pmap[b+3] = buffer[a+3]
If xx+4 &gt;= ofx And yy+ty &gt;= ofy And xx+4 &lt; ofx+sx And yy+ty &lt; ofy+sy	 Then pmap[b+4] = buffer[a+4]
If xx+5 &gt;= ofx And yy+ty &gt;= ofy And xx+5 &lt; ofx+sx And yy+ty &lt; ofy+sy	 Then pmap[b+5] = buffer[a+5]
If xx+6 &gt;= ofx And yy+ty &gt;= ofy And xx+6 &lt; ofx+sx And yy+ty &lt; ofy+sy	 Then pmap[b+6] = buffer[a+6]
If xx+7 &gt;= ofx And yy+ty &gt;= ofy And xx+7 &lt; ofx+sx And yy+ty &lt; ofy+sy	 Then pmap[b+7] = buffer[a+7]
Next
cntx = cntx+8 ; Next
cnty = cnty+8 ; Next

' RIGHT FRAME OF TILES W. CLIPPING
cnty = 0 ; For y = mapy To mapy + sy Shr 3 + 0
cntx = sx ; For x = mapx+ sx Shr 3 + 0 To mapx + sx Shr 3 + 0 
tilex = map(x,y) &amp; 31 ; tiley = map(x,y) Shr 5 ; xx = cntx - scrx + ofx ; yy=cnty- scry + ofy
For ty = 0 To 7
a = (tiley Shl 3 + ty) Shl 8 ; a = a + tilex Shl 3 ; b = xx+(yy+ty) Shl 10
If   xx &gt;= ofx And yy+ty &gt;= ofy And   xx &lt; ofx+sx And yy+ty &lt; ofy+sy   Then pmap[b] =  buffer[a]
If xx+1 &gt;= ofx And yy+ty &gt;= ofy And xx+1 &lt; ofx+sx And yy+ty &lt; ofy+sy	 Then pmap[b+1] = buffer[a+1]
If xx+2 &gt;= ofx And yy+ty &gt;= ofy And xx+2 &lt; ofx+sx And yy+ty &lt; ofy+sy	 Then pmap[b+2] = buffer[a+2]
If xx+3 &gt;= ofx And yy+ty &gt;= ofy And xx+3 &lt; ofx+sx And yy+ty &lt; ofy+sy	 Then pmap[b+3] = buffer[a+3]
If xx+4 &gt;= ofx And yy+ty &gt;= ofy And xx+4 &lt; ofx+sx And yy+ty &lt; ofy+sy	 Then pmap[b+4] = buffer[a+4]
If xx+5 &gt;= ofx And yy+ty &gt;= ofy And xx+5 &lt; ofx+sx And yy+ty &lt; ofy+sy	 Then pmap[b+5] = buffer[a+5]
If xx+6 &gt;= ofx And yy+ty &gt;= ofy And xx+6 &lt; ofx+sx And yy+ty &lt; ofy+sy	 Then pmap[b+6] = buffer[a+6]
If xx+7 &gt;= ofx And yy+ty &gt;= ofy And xx+7 &lt; ofx+sx And yy+ty &lt; ofy+sy	 Then pmap[b+7] = buffer[a+7]
Next 
cntx = cntx+8 ; Next
cnty = cnty+8 ; Next

End Function
</pre> <br><br></td></tr></table><br>
<a name="1294964"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#70">[#70]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just wanted to share that optimizing experience and thoughts, hope that's okay and interesting for some. <br><br></td></tr></table><br>
<a name="1294976"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#71">[#71]</a></td></tr></table></td></tr><tr ><td class="posttext"> I reliased (afterwards of course what else) that you could made another approach here, and that would been to have a larger array with an<br> extra unusued space around it, and just go wild on it, and only draw the middle. Becuase it's far cheaper to do more pixels and no conditions.<br><br>I'm not gonna try implement that now as Im all sick of optimizing for today. But that it might have been a better idea.<br>Or worse I don´t know. I wanted a perfect sized array solution, but it would have kept the code size down. <br><br>If you could have just used hw clipping then I would have died. actually I really needed to use arrays internally before actually throwing anything on the screen so neat handling was needed before the actual screen. Otherwise HW clipping is practically free today I guess. You could clip all day long. <br><br></td></tr></table><br>
<a name="1294979"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#72">[#72]</a></td></tr></table></td></tr><tr ><td class="posttext"> But this one single IF..THEN, killed the performance. <br><br></td></tr></table><br>
<a name="1295040"></a>

<a name="1295041"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#73">[#73]</a></td></tr></table></td></tr><tr ><td class="posttext"> You're peaking out at 24%, Casaber, on that last entry. Turned off DEBUG to run it. My that thing really flies ! :D<br><br>I know you don't want to fight this right now, but at some point you might consider seeing how difficult it is to plot a sprite in the middle, like a sprite facing up (we see its back, not the front) and to circumnavigate the 3D terrain acknowledging obstacle tiles when touched.<br><br>Also I changed your STEP 2 back to STEP 1 to see how much slower it is to draw the entire screen without skipping every other line. It's not very slow at all, the CPU here only increased by 4% and maintained the same speed. <br><br></td></tr></table><br>
<a name="1295095"></a>

<a name="1295096"></a>

<a name="1295097"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#74">[#74]</a></td></tr></table></td></tr><tr ><td class="posttext"> without pseudo3d you could EASLY plot 128 128x128 sprites with pixelwrite ontop. no problem<br>with this added mode7..  Im not sure, i might woik the same, i would not like to try without optimizing further.<br>But you know.. still not in the optimizing mood today, haha.<br><br>If you want to know why, I have other plans to use other graphics (using my little project) so that would allow mixing HW and software.<br><br>Not this week though.. but it's planned.I even named the project now<br><br>Graphene (one of the strongest materials in the world, and lightest too)<br>I´m focus on readable simple power code.<br><br>I think you're one of the ppl who KNOWS the strength of short terse code. <br>When you know all the other rules by heart. This is the one most true rule of them all.<br><br>K.I.S.S. <br><br></td></tr></table><br>
<a name="1295098"></a>

<a name="1295099"></a>

<a name="1295100"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#75">[#75]</a></td></tr></table></td></tr><tr ><td class="posttext"> The way to KISS is often messy in the middle. And most ppl leave the stage before even trying.<br><br>It needs a pro to get through the mess haha.<br><br>Coding is the perfect life analogy ;) <br><br></td></tr></table><br>
<a name="1295127"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#76">[#76]</a></td></tr></table></td></tr><tr ><td class="posttext"> <b>I think you're one of the ppl who KNOWS the strength of short terse code. </b><br><br>Well thank you Casaber, I try. :) But yes, I am a bit of a lazy SOB and I REALLY hate to write long code, whether it's mine or a routine I am making use of. That's one reason I have such short solutions often.<br><br>I may be able to cull that code of yours down very succinctly, and you may lose rotation but not the scrolling up down left right - and that's fine for what I might try with it. <br><br></td></tr></table><br>
<a name="1295131"></a>

<a name="1295132"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#77">[#77]</a></td></tr></table></td></tr><tr ><td class="posttext"> There's a very nasty floating point bug in that mode7. It shows up only after awhile, so that's a clue in itself. Keep it going for some time and you'll see it. And oh you'll see it.. haha.<br>Things gets sawtooth shaped all over the place. That's one for later, I want to grasp the 3D fully first.<br><br>I didn't expect me wanting to learn 3D ever in life, but you know It's not that weird and strange to me anymore. It feels abit closer now, more within the range of possiblities so to speak. <br><br></td></tr></table><br>
<a name="1295141"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#78">[#78]</a></td></tr></table></td></tr><tr ><td class="posttext"> Can you send a screenshot of it please, Casaber ? The Floating Point bug you are running into. <br><br></td></tr></table><br>
<a name="1295142"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#79">[#79]</a></td></tr></table></td></tr><tr ><td class="posttext"> sure , haha now I'm having hard time to lure it. I'm not sure if its pure time, or if you need to move around alot, or if it's about changing window forth and back.<br><br>One or a combination of those 3, and it comes in several flavors;<br>minor, which just has abit odd edges, almost "okay looking"<br>and a severe version which makes the whole  screen look sawtoothed, like if you had broken glass shards ontop of the screen. And theres inbetween aswell.<br><br>Right now I couldn't get none of those. The hour before I had all of them.<br><br>No wait I think I just had one now, the minor one..<br><br><br><img src="http://s14.postimg.org/f6zcqftbl/minor.png"> <br><br></td></tr></table><br>
<a name="1295143"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#80">[#80]</a></td></tr></table></td></tr><tr ><td class="posttext"> Looks good here, Casaber. BTW be aware that REAL and DOUBLE numbers in BlitzMAX are far from accurate. Try out this simple code:<pre class=code>Strict
Local i!
For i!=0! To 1! Step .01!
  Print i!
Next</pre>Now if it was working correctly, you would have a simple display of:<br><b>0<br>0.01<br>0.02<br>0.03<br>etc.</b><br><br>But as you can see, you do not. There is no 0.03, 0.15, or even just "1" at all. This then is something to consider when using your REAL or DOUBLE math variables. <br><br></td></tr></table><br>
<a name="1295147"></a>

<a name="1295148"></a>

<a name="1295149"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#81">[#81]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ya i Know, it's tricky sometimes.<br><br>Have you used fixedpoint ever? Those seemed to have vanished though, I guess they have uses and they're still there hidden behind types like INT and 64bit versions of INT so they are possible. But they are not actually used much. They're abit counter intuitive, I guess in how they are presented and used. <br>But same goes with floats/doubles with those "hidden" incorrectness lurking inside them despite all cleverness.<br><br>But this must be some ackumulating bug so float should suffice I'm thinking. Float would be great not even doubles would be needed, and throwing doubles on the mix would only make it better when it's bugfree.<br><br>I think it's some kind of ackumulation problem here. <br><br></td></tr></table><br>
<a name="1295151"></a>

<a name="1295152"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BlitzSupport</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#82">[#82]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>BTW be aware that REAL and DOUBLE numbers [...] are far from accurate.<br> <br></div><br><br>This is the same for any language using floating point numbers -- they are inaccurate, and that's how they work within only 32/64 bits.<br><br><div class="quote"> <br>Now if it was working correctly, you would have a simple display of:<br>0<br>0.01<br>0.02<br>0.03<br>etc.<br> <br></div><br>It is working correctly: <a href="https://en.wikipedia.org/wiki/Floating_point" target="_blank">In computing, floating point is the formulaic representation that approximates a real number so as to support a trade-off between range and precision</a>.<br><br>You would need a software-based 'bignum'-type library for this kind of accuracy, not hardware-based floating-point numbers. <br><br></td></tr></table><br>
<a name="1295158"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#83">[#83]</a></td></tr></table></td></tr><tr ><td class="posttext"> I shall look into that when I´m clear in the head, I had too many sleepless nights at the hospital recently. Th waiting kills me.<br>Coding really helps you from keeping worrying about things.<br><br>But i would nevver had the energy to focus and make things like this otherwise.<br><br>bignum is powerful, noone would ever trust floats for handling currencies and the like.<br>I don´t even hink there have been a better idea yet since 1986 how to store numbers efficiently.<br>But I do hate my floats. Oh yes. Did I tell you that I´m starting doing alot of DSP recently and need to become friends with them. *Shivering*<br><br>But floats has speeds nowadays, so I just put my hat on and pretend they work. <br><br></td></tr></table><br>
<a name="1295163"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#84">[#84]</a></td></tr></table></td></tr><tr ><td class="posttext"> But there's precision in them when you know what you do I've noticed. I was so suprised.<br><br>I´m not the one to know those rules, but I´ve seen it in action enough to believe it.<br>Those floats knew what they did. Nothing escaped them.<br><br>But that's not how they are used by most ppl and I would never expect ppl to learn them. That would be to ask for too much anyway.<br><br>I don´t even think there's much literature on that kind of aspect of floats. How to USE THEM. If those books exist they are proably using big academic words and a boring language, making sure that noone ever EVER actually learn from them. <br><br></td></tr></table><br>
<a name="1295168"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#85">[#85]</a></td></tr></table></td></tr><tr ><td class="posttext"> global cx, i think thats the bug. <br><br></td></tr></table><br>
<a name="1295169"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#86">[#86]</a></td></tr></table></td></tr><tr ><td class="posttext"> Stupid bug, so very human of me. <br><br></td></tr></table><br>
<a name="1295171"></a>

<a name="1295172"></a>

<a name="1295173"></a>

<a name="1295174"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#87">[#87]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well now Blitz, I have heard this in the past, and I might believe it if it weren't for the fact that GFA gives flawless results. And no, there was no way I could prove it - until now.<br><br>Watch out because I finally have GFA working in Windows 8 so I can prove its flawless execution and handing of real variables.<br><br><img src="http://www.writerscafe.org/uploads/rte/44221a18b6f00e82d1eb3d99c915f131.png"><br><br>Here is the text file pasted:<br><b>0<br>0.01<br>0.02<br>0.03<br>0.04<br>0.05<br>0.06<br>0.07<br>0.08<br>0.09<br>0.1<br>0.11<br>0.12<br>0.13<br>0.14<br>0.15<br>0.16<br>0.17<br>0.18<br>0.19<br>0.2<br>0.21<br>0.22<br>0.23<br>0.24<br>0.25<br>0.26<br>0.27<br>0.28<br>0.29<br>0.3<br>0.31<br>0.32<br>0.33<br>0.34<br>0.35<br>0.36<br>0.37<br>0.38<br>0.39<br>0.4<br>0.41<br>0.42<br>0.43<br>0.44<br>0.45<br>0.46<br>0.47<br>0.48<br>0.49<br>0.5<br>0.51<br>0.52<br>0.53<br>0.54<br>0.55<br>0.56<br>0.57<br>0.58<br>0.59<br>0.6<br>0.61<br>0.62<br>0.63<br>0.64<br>0.65<br>0.66<br>0.67<br>0.68<br>0.69<br>0.7<br>0.71<br>0.72<br>0.73<br>0.74<br>0.75<br>0.76<br>0.77<br>0.78<br>0.79<br>0.8<br>0.81<br>0.82<br>0.83<br>0.84<br>0.85<br>0.86<br>0.87<br>0.88<br>0.89<br>0.9<br>0.91<br>0.92<br>0.93<br>0.94<br>0.95<br>0.96<br>0.97<br>0.98<br>0.99<br>1</b><br><br>This is the part where you tell me now that BlitzMAX still isn't flawed in real variables and that GFA is the one with the problem. :) <br><br></td></tr></table><br>
<a name="1295175"></a>

<a name="1295176"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#88">[#88]</a></td></tr></table></td></tr><tr ><td class="posttext"> dw817 Nice, actually that's the kind of precision you want as a stable base for doing  math.<br><br>I looked around quickliy on the surface and it loosk like GFA solved it using some clever storage of their own?<br><br>If I understood this right. <br><a href="http://forum.purebasic.com/english/viewtopic.php?p=236491" target="_blank">http://forum.purebasic.com/english/viewtopic.php?p=236491</a><br><br>This will become a nice reading later. I put it here.<br><a href="https://randomascii.wordpress.com/2012/03/08/float-precisionfrom-zero-to-100-digits-2/" target="_blank">https://randomascii.wordpress.com/2012/03/08/float-precisionfrom-zero-to-100-digits-2/</a><br><br>If I got it right. Bmax uses the standard float/double nothing special, and GFA made an extra effort behind the scenes. I wonder if that slowed things down much if it where so. <br><br></td></tr></table><br>
<a name="1295177"></a>

<a name="1295178"></a>

<a name="1295179"></a>

<a name="1295180"></a>

<a name="1295182"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#89">[#89]</a></td></tr></table></td></tr><tr ><td class="posttext"> No kidding, Casaber ! All this talk of 'it's my fault I don't like BlitzMAX's real numbers.'<br><br>Well I guess it got me off my duff to install GFA to show if any programming language is doing it correctly, THEY are. :D<br><br>And that's a good thing. I have available ATM a little over 700 programs I wrote in GFA and now I can finally examine, modify, and run them and in time transfer their code to BlitzMAX.<br><br>Also, as for GFA being slow. NO. It is not. It has (or had ?) really REALLY fast execution. <br><br></td></tr></table><br>
<a name="1295181"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#90">[#90]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sounds fun :) 700 programs haha, take a deep dive. <br><br></td></tr></table><br>
<a name="1295183"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#91">[#91]</a></td></tr></table></td></tr><tr ><td class="posttext"> Instead of blaming BlitzMax (or any other langage for that matter) for "not having accurate floating point numbers" you should instead blame your CPU, as that is what BlitzMax uses to implement floats. IE It uses hardware floating point for speed. Just like C, C++ or any other systems langauge.<br><br>And about GFA, they are probably doing it all in software. IE its not very fast.<br>And if you really need accurate floats, YOU can do it in software too ;) <br><br></td></tr></table><br>
<a name="1295184"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#92">[#92]</a></td></tr></table></td></tr><tr ><td class="posttext"> Aaand we come back to it again. Can ANYONE take up the challenge, take up the mantle and write a program in BlitzMAX (a page of length or less) that can reproduce the results GFA just gave ?<br><br>That is, count from 0 to 1 by decimal 01. Count from 0 (zero) percent to 100 percent, with no weird or stray numbers interfering the output. <br><br></td></tr></table><br>
<a name="1295185"></a>

<a name="1295186"></a>

<a name="1295187"></a>

<a name="1295188"></a>

<a name="1295189"></a>

<a name="1295190"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#93">[#93]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> All this talk of 'it's my fault I don't like BlitzMAX's real numbers.' <br></div><br><br><i>so very tired of this</i><br><br>That's because it is. You are wilfully ignoring the facts of how real numbers work. BlitzMax's math works <b>correctly</b>. Your expectations of it are wrong. This has been explained to you at length in another thread, there's no excuse for spreading misinformation further. BlitzMax is giving the <b>correct</b> results for what you asked it to do.<br><br>If you want perfect decimal math, use a number format that supports decimal representation, rather than complaining that a number type <i>neither designed nor intended for what you want</i> doesn't do what you want! To specifically count from 0 to 100 (or any range in perfect fixed steps), use integers, that's exactly what they're for.<br><br>GFA BASIC is an interpreter. It will be hiding more involved, slower, operations underneath those operators. You can replicate the results in software, but because BlitzMax's math operators are mapped to hardware operations, it will <i>look</i> like math implemented in software. This is also what has already been pointed out. <br><br></td></tr></table><br>
<a name="1295191"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#94">[#94]</a></td></tr></table></td></tr><tr ><td class="posttext"> I might become slow dq817..  would speed be an issue? <br><br>GFA might have done a pure software solution or something like using the hw in some other fashion (which is hard to imagein bc its very hardwired how CPU's wants their math done but nonetheless) <br><br>And if it did things fast using harware it would have gone more famous bc that would have been amazing. SO I´m thinking. it was probably software and not using IEEE/HW much at all.<br><br>More like something like a bigint with decimalpoint? <br><br></td></tr></table><br>
<a name="1295192"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#95">[#95]</a></td></tr></table></td></tr><tr ><td class="posttext"> There have been som many amazing minds trying to bend IEEE to do its best, so I´m not that positive its possible to use HW and get perfect results.<br><br>They kinda of decided that years and years ago, that its' "okay". <br><br></td></tr></table><br>
<a name="1295193"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#96">[#96]</a></td></tr></table></td></tr><tr ><td class="posttext"> GFA being a learners tool (and a professional tool at once) I think they reliased that they needed somthing that showed numbers very truthfully and not infuse confusion. <br><br></td></tr></table><br>
<a name="1295194"></a>

<a name="1295195"></a>

<a name="1295196"></a>

<a name="1295198"></a>

<a name="1295199"></a>

<a name="1295205"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#97">[#97]</a></td></tr></table></td></tr><tr ><td class="posttext"> GFABasic has a compiler I purchased, Yasha, so no, you cannot say that it is only an interpreter. I know this because I have compiled code in it that runs differently from interpreted. And the compiler wasn't cheap. It was American currency converted to Deutsche marks.<br><br>To do the total pixel demo, Grable ? Where you fill the screen completely w random colors, I got about 15 frames-per-second, minju, this was on a 500mhz computer so that is pretty good. That was with compilation though, not interpreted.<br><br>GFA also could run so fast it would tie up the entire CPU which is why you needed the command <b>PEEKEVENT</b> to give some CPU back to the rest of the OS.<br><br>I wrote S2 with it, so it's no slouch for programming.<br><br><img src="http://www.writerscafe.org/uploads/rte/67c34f4041311531f4ab39b7c510f994.png"><br><br>Also understand that I've been using GFA for nearly 18-years and not once, not once did it give me 'correct' floating point numbers as BlitzMAX delivers them. And I am glad for that.<br><br>Now if SOMEONE will write a small bit of code to achieve the same results as BlitzMAX, then it can be written off, just as with BlitzMAX you have no native ability to go frameless - but a solution was found.<br><br>Yasha, can you post a code example that reproduces the same results as GFA ? Using 'decimal number format' if that so helps you ?<br><br>But =IF= this simple task of counting from zero to 1 by 1% is so immensely difficult for BlitzMAX to accomplish correctly - then you can spout all you want, there is a PROBLEM and I know I'm not alone in this belief.<pre class=code>a!=1
b!=3

If a!/b!&lt;&gt;1!/3! Then Print"flawed"</pre> <br><br></td></tr></table><br>
<a name="1295200"></a>

<a name="1295203"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#98">[#98]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes. It's a serious problem of IEEE, and it should be solved.<br><br>These kind of problems pop up everywhere, and libraries such as BIGINT and so on comes along. What does Bmax use for correct roundings? <br><br></td></tr></table><br>
<a name="1295201"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Henri</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#99">[#99]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hmmm...It seems to work ?<br><pre class=code>Local a:Double = 1, b:Double = 3

If String(a/b) &lt;&gt; String(1.0!/3.0!) Then Print "Oh no!"</pre><br><br>-Henri <br><br></td></tr></table><br>
<a name="1295204"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#100">[#100]</a></td></tr></table></td></tr><tr ><td class="posttext"> I tried the<br><br>for i=0 to 100<br>print i/100<br>next<br><br>It's the more interesting problem for me, to be able to show at least 2 decimals correctly. <br><br></td></tr></table><br>
<a name="1295207"></a>

<a name="1295208"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#101">[#101]</a></td></tr></table></td></tr><tr ><td class="posttext"> You have something good there, Henri. I am trying this though:<pre class=code>Local i!

For i!=0 To 1 Step .01
  Print String(i!)
Next</pre>And still getting the same results. Hmm ... Let's try this using your String method:<pre class=code>Local i!,a$

For i!=0.0! To 1.0! Step .01!
  a$=String(i!+.01!)
  Print Left$(a$,Instr(a$,".")+2)
Next
</pre>Almost perfect. <br><br></td></tr></table><br>
<a name="1295209"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#102">[#102]</a></td></tr></table></td></tr><tr ><td class="posttext"> dw817 I just got the same results indpendely searching the forum<br><br>Local i2:Float' = 10.3<br>For i2=0 To 100<br>Print Left(i2/100,Instr(i2,".")+2)<br>Next <br><br>WaitKey<br><br><br>Which is interresing I guess.. on a string conversion level <br><br></td></tr></table><br>
<a name="1295212"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#103">[#103]</a></td></tr></table></td></tr><tr ><td class="posttext"> I need to go now, but this was interesting actually. This thread has approved to discuss this matter, it's very MODE 7 related. The IEEE enigma continues. <br><br>But I'm SO fond of integers right now, you wouldn´t believe it. <br><br></td></tr></table><br>
<a name="1295213"></a>

<a name="1295224"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#104">[#104]</a></td></tr></table></td></tr><tr ><td class="posttext"> <pre class=code>Local i!,a$,c
For i!=0.0! To 1.0+.01! Step .01!
  a$=String(i!+.01)
  Print c+" "+Left$(a$,Instr(a$,".")+2)
  c:+1
Next
</pre>Awright, I got it. But yeah, whatta way to fudge the numbers. :/ <br><br></td></tr></table><br>
<a name="1295214"></a>

<a name="1295218"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#105">[#105]</a></td></tr></table></td></tr><tr ><td class="posttext"> Casaber, when I was working on the early TRS 80, there were no float values. I remember writing a program to emulate it. And yes, you are on the right track, I used INTEGER variables to emulate the float.<br><br>How did I do it ? It was all a matter of using a$ and b$ (the only two strings available in the language), and putting a visual decimal point between the two of them.<br><br>The same method of building a float might be done in BlitzMAX but perhaps not so easily.<br><br>Integers can act as FLOAT if treated properly. It is a blessing that BlitzMAX has integers that count past 999999999.<br><br>Have a good rest, I think I need one too. :) <br><br></td></tr></table><br>
<a name="1295215"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#106">[#106]</a></td></tr></table></td></tr><tr ><td class="posttext"> I hope we find an elegant solution, Personally I have'nt tried libraries yet on Bmax, I figure that will help but I hope there's also a more direct solution.<br><br>Btw the funny thing is.. the bug was not even floating point error, don't global CX and its' gone. Well.. I hope. haven't throughly tested it yet ;)<br><br>Have a good weekend everyone. <br><br></td></tr></table><br>
<a name="1295216"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Casaber</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#107">[#107]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ya have a good rest dw817 :) We'll talk later about those 700 golden tresures of yours muHAHAAH. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
