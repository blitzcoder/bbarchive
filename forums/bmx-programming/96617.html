<!DOCTYPE html><html lang="en" ><head ><title >Gfx modes always listed from smallest to largest?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Gfx modes always listed from smallest to largest?</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Gfx modes always listed from smallest to largest?</a><br><br>
<a name="1118655"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Russell</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> When using GraphicsModes(), are the returned elements in the TGraphicsMode array always from smallest to largest, regardless of OS and/or gfx card driver? I know on some older graphics cards, certain modes are only available in, say 16 bit depth or at a lower refresh rate. I guess because of this, it's probably a good idea to go through the whole list, eh?<br><br>Russell <br><br></td></tr></table><br>
<a name="1118679"></a>

<a name="1118690"></a>

<a name="1118691"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hiya.<br>They are added to the array depending on how the hardware gives them to bmax, however it is generally from smallest to largest but I wouldn't rely on it. So yes, its best to check the whole array.<br><br>Edit:- I'm not sure if its still the case ( away from pc at the mo ) but bmax used to just check for 32 bit modes only. There are some minor modifications that have posted in the past to include 16 bits modes if BRL still haven't included them yet.<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1118716"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Russell</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Another question/problem: Is there a way to figure out which modes are supported by the user's monitor? If I use GraphicsModes() to get an array of all of the available modes, I get just that: every single mode that the graphics card can display. But if I go into the display settings through Windows it only displays the modes that are displayable on my monitor (via the monitor driver), which for my laptop is only 1600 x 900, 1280 x 720 and 800 x 600 (I guess this is the fallback mode that they all support, even if it will be a stretched display).<br><br>How can I get just those three modes to be returned?<br><br>Russell<br><br>p.s. Is there a cross-platform way to get the information, perhaps via a tweaked BRL module? <br><br></td></tr></table><br>
<a name="1118719"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Russell</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> I did find some info on this here: <a href="http://www.winvistatips.com/read-monitors-edid-information-t181727.html" target="_blank">http://www.winvistatips.com/read-monitors-edid-information-t181727.html</a> but it is windows only and is still not quite what I need (The information is totally raw, unformatted data).<br><br>Anyway, maybe I'll just stick with using the user's desktop mode, although this would be pretty limiting... There must be a better way!<br><br>Apparently, modern monitors send EDID information to the computer which includes information about what it can display (among other things). This freeware program can get exactly the information I need from EDID, but AFAIK the source code is not available: <a href="http://www.nirsoft.net/utils/monitor_info_view.html" target="_blank">http://www.nirsoft.net/utils/monitor_info_view.html</a><br><br>Anyway, I'll bet this sort of module could be pretty useful to some people?<br><br>Russell <br><br></td></tr></table><br>
<a name="1118730"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hmm.<br><br>I understand what you mean. MS have a timeout fallback when you set the desktop and monitor modes manually, just in case something plays up. You could easily do something similar. <br><br></td></tr></table><br>
<a name="1118825"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Russell</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> One big problem (and I'm really surprised this was overlooked by the graphics card &amp; monitor industries), is that there doesn't seem to be any widescreen "minimum" standards like there are in the 4:3 world. <br>For example, before widescreen (16:9) or pseudo-widescreen (16:10 and the like), you could pretty much guarantee that a user's system could handle 640 x 480 without even checking. Even 800 x 600 is probably supported by 99.9% of the systems out there that are less than 20 years old. But since the widescreen came on the scene, it seems like there are no widescreen modes that ALL of the monitors cab handle (especially laptops, which tend to support fewer overall display choices).<br><br>If there was a BMax module that could read the EDID information, that would be VERY helpful, as we could cross-check its capabilities with the capabilities of the video card (returned by GraphicsModes()) and find a mode that suits our needs. I guess you're right, though: I'll have to let the user decide and timeout after 10 or 15 seconds if they don't click 'Ok' or something similar, in case they select a mode that their monitor can not actually display. EDID method would look more professional, though.<br><br>Anyway, would someone like to have a look at the example code from the winvistatips.com website (see link above) and see if they can make heads or tales out of it? Since the information is sent through the VGA port (or DVI) I would imagine that it should be platform neutral. I didn't know you could even receive non-raster information from the VGA port!<br><br>Russell <br><br></td></tr></table><br>
<a name="1118826"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Russell</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here's the actual EDID structure: <a href="http://en.wikipedia.org/wiki/Extended_display_identification_data#EDID_1.3_data_format" target="_blank">http://en.wikipedia.org/wiki/Extended_display_identification_data#EDID_1.3_data_format</a><br><br>Russell <br><br></td></tr></table><br>
<a name="1118835"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> I had a quick stab at porting that program to BMax last night, but it got too late to finish it :-)<br>I need to change some of the logic because if there is an error returned from one of the funtions then it exits too early. I'm not really sure how good it will be as I'm on a 16:9 laptop display and it just uses a 'Generic PnP Monitor' driver, which doesnt actually show result. However I can get it to list all drivers and also get the registry info for those drivers.<br><br>I have this code so far which will output ALL devices that has a driver.<br>On line 103:63 if you change DIGF_ALLCLASSES to DIGF_PRESENT it will list all monitor only drivers. On my system it doesnt return any value when using DIGF_PRESENT ( maybe because it uses a generic driver, I'm too early into it at this stage ). See what result you get...<br><br>This is of course Windows only so far, tested on Win7 and Vista, same results.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict

Const SPDRP_DEVICEDESC                  =$00000000  ' DeviceDesc (R/W)
Const SPDRP_HARDWAREID                  =$00000001  ' HardwareID (R/W)
Const SPDRP_COMPATIBLEIDS               =$00000002  ' CompatibleIDs (R/W)
Const SPDRP_NTDEVICEPATHS               =$00000003  ' Unsupported, DO Not USE
Const SPDRP_SERVICE                     =$00000004  ' Service (R/W)
Const SPDRP_CONFIGURATION               =$00000005  ' Configuration (R)
Const SPDRP_CONFIGURATIONVECTOR         =$00000006  ' ConfigurationVector (R)
Const SPDRP_CLASS                       =$00000007  ' Class (R--tied To ClassGUID)
Const SPDRP_CLASSGUID                   =$00000008  ' ClassGUID (R/W)
Const SPDRP_DRIVER                      =$00000009  ' Driver (R/W)
Const SPDRP_CONFIGFLAGS                 =$0000000A  ' ConfigFlags (R/W)
Const SPDRP_MFG                         =$0000000B  ' Mfg (R/W)
Const SPDRP_FRIENDLYNAME                =$0000000C  ' FriendlyName (R/W)
Const SPDRP_LOCATION_INFORMATION        =$0000000D  ' LocationInformation (R/W)
Const SPDRP_PHYSICAL_DEVICE_OBJECT_NAME =$0000000E  ' PhysicalDeviceObjectName (R)
Const SPDRP_CAPABILITIES                =$0000000F  ' Capabilities (R)
Const SPDRP_UI_NUMBER                   =$00000010  ' UiNumber (R)
Const SPDRP_UPPERFILTERS                =$00000011  ' UpperFilters (R/W)
Const SPDRP_LOWERFILTERS                =$00000012  ' LowerFilters (R/W)
Const SPDRP_MAXIMUM_PROPERTY            =$00000013  ' Upper bound on ordinals

Const DIGCF_DEFAULT           =$00000001
Const DIGCF_PRESENT           =$00000002
Const DIGCF_ALLCLASSES        =$00000004
Const DIGCF_PROFILE           =$00000008
Const DIGCF_DEVICEINTERFACE   =$00000010

Const CM_DEVCAP_LOCKSUPPORTED            =$00000001
Const CM_DEVCAP_EJECTSUPPORTED           =$00000002
Const CM_DEVCAP_REMOVABLE                =$00000004
Const CM_DEVCAP_DOCKDEVICE               =$00000008
Const CM_DEVCAP_UNIQUEID                 =$00000010
Const CM_DEVCAP_SILENTINSTALL            =$00000020
Const CM_DEVCAP_RAWDEVICEOK              =$00000040
Const CM_DEVCAP_SURPRISEREMOVALOK        =$00000080
Const CM_DEVCAP_HARDWAREDISABLED         =$00000100
Const CM_DEVCAP_NONDYNAMIC               =$00000200

Const DICS_FLAG_GLOBAL         =$0000001 
Const DIREG_DEV       =$00000001

Const KEY_READ = $20019
Const KEY_ALL_ACCESS  =$F003F

Const ERROR_NO_MORE_ITEMS = 259

Type SP_DEVINFO_DATA
	Field cbSize = SizeOf(SP_DEVINFO_DATA)
	Field ClassGuid0,ClassGuid1,ClassGuid2:Short,ClassGuid3:Short,ClassGuid4:Short
	Field DevInst
	Field Reserved
EndType

Type SP_DEVINFO_LIST_DETAIL_DATA
	Field cbSize = SizeOf(SP_DEVINFO_LIST_DETAIL_DATA)
	Field ClassGuid:Byte Ptr
	Field RemoteMachineHandle
	Field RemoteMachineName0:Long,RemoteMachineName1:Long,RemoteMachineName2:Long,RemoteMachineName3:Long
	Field RemoteMachineName4:Long,RemoteMachineName5:Long,RemoteMachineName6:Long,RemoteMachineName7:Long
	Field RemoteMachineName8:Long,RemoteMachineName9:Long,RemoteMachineName10:Long,RemoteMachineName11:Long
	Field RemoteMachineName12:Long,RemoteMachineName13:Long,RemoteMachineName14:Long,RemoteMachineName15:Long
	Field RemoteMachineName16:Long,RemoteMachineName17:Long,RemoteMachineName18:Long,RemoteMachineName19:Long
	Field RemoteMachineName20:Long,RemoteMachineName21:Long,RemoteMachineName22:Long,RemoteMachineName23:Long
	Field RemoteMachineName24:Long,RemoteMachineName25:Long,RemoteMachineName26:Long,RemoteMachineName27:Long
	Field RemoteMachineName28:Long,RemoteMachineName29:Long,RemoteMachineName30:Long,RemoteMachineName31:Long
	Field RemoteMachineName32:Int,RemoteMachineName33:Short,RemoteMachineName34:Byte
EndType


''''''''''
Global GUID_CLASS_MONITOR[] = [$4d36e963,$11cee325,$0008c1bf,$1803e12b]


''''''''''
Global Kernel32DLL = LoadLibraryA("kernel32")
Global GetLastError()"win32" = GetProcAddress(Kernel32DLL,"GetLastError")


''''''''''
Global AdvApi32DLL = LoadLibraryA("advapi32")
Global RegCloseKey(hKey:Byte Ptr)"win32" = GetProcAddress(AdvApi32DLL,"RegCloseKey")
Global RegEnumValue(hKey:Byte Ptr,dwIndex,lpValueName:Byte Ptr,lpcchValueName:Byte Ptr,lpReserved,lpType:Byte Ptr,lpData:Byte Ptr,..
								lpcData:Byte Ptr)"win32" = GetProcAddress(AdvApi32DLL,"RegEnumValue")
								
								
''''''''''
Global SetupApiDLL = LoadLibraryA("setupapi")
Global SetupDiGetDeviceRegistryProperty(DeviceInfoSet:Byte Ptr,DeviceInfoData:Byte Ptr,Property,PropertyRegDataType:Int Ptr,..
								PropertyBuffer:Byte Ptr,PropertyBufferSize,RequiredSize:Int Ptr)"win32" = GetProcAddress(SetupApiDLL,"SetupDiGetDeviceRegistryPropertyA")
Global SetupDiGetClassDevsEx:Byte Ptr(ClassGuid:Byte Ptr,Enumerator:Byte Ptr,hwndParent,Flags,DeviceInfoSet:Byte Ptr,MachineName:Byte Ptr,..
								Reserved:Byte Ptr)"win32" = GetProcAddress(SetupApiDLL,"SetupDiGetClassDevsExA")
Global SetupDiEnumDeviceInfo(DeviceInfoSet:Byte Ptr,MemberIndex,DeviceInfoData:Byte Ptr)"win32" = GetProcAddress(SetupApiDLL,"SetupDiEnumDeviceInfo")
Global SetupDiOpenDevRegKey:Byte Ptr(DeviceInfoSet:Byte Ptr,DeviceInfoData:Byte Ptr,Scope,HwProfile,KeyType,samDesired)"win32" = GetProcAddress(SetupApiDLL,"SetupDiOpenDevRegKey")


''''''''''
Function EnumDevices()
	Local devInfo:Byte Ptr
	Local devInfoData:SP_DEVINFO_DATA = New SP_DEVINFO_DATA
	
	devinfo = SetupDiGetClassDevsEx(GUID_CLASS_MONITOR,Null,Null,DIGCF_ALLCLASSES,Null,Null,Null)
	
	If devInfo = Null
		Notify "Error :-  SetupDiGetClassDevsEx",True
		End
	EndIf
	
	Local i
	Repeat
		If SetupDiEnumDeviceInfo(devInfo,i,devInfoData)
			PlayWithDeviceInfo(devInfo,devInfoData)
		EndIf
		i :+ 1
	Until GetLastError() &lt;&gt; 0
EndFunction

Function PlayWithDeviceInfo(devInfo:Byte Ptr,devInfoData:SP_DEVINFO_DATA)
	Type TuniID
		Field uniID0:Long,uniID1:Long,uniID2:Long,uniID3:Long,uniID4:Long
		Field uniID5:Long,uniID6:Long,uniID7:Long,uniID8:Long,uniID9:Long
		Field uniID10:Long,uniID11:Long,uniID12:Long,uniID13:Long,uniID14:Long
		Field uniID15:Short,uniID16:Byte
		
		Method GetuniID$()
			Return String.FromCString(Varptr uniID0)
		EndMethod
	EndType
	
	Type TName
		Field Name0:Long,Name1:Long,Name2:Long,Name3:Long,Name4:Long
		Field Name5:Long,Name6:Long,Name7:Long,Name8:Long,Name9:Long
		Field Name10:Long,Name11:Long,Name12:Long,Name13:Long,Name14:Long
		Field Name15:Long
		
		Method GetName$()
			Return String.FromCString(Varptr Name0)
		EndMethod
	EndType
	
	Local uniID:TuniID = New TuniID
	
	If SetupDiGetDeviceRegistryProperty(devInfo,devInfoData,SPDRP_DEVICEDESC,Null,uniID,SizeOf(uniID),Null)
		Print uniID.GetuniID()
	EndIf
	
	'DebugStop
	Local hDevRegKey:Byte Ptr
	'hDevRegKey = SetupDiOpenDevRegKey(devInfo,devInfoData,DICS_FLAG_GLOBAL,0,DIREG_DEV,KEY_READ)
	'DebugStop
	'If hDevRegKey
	'	Local Name:TName = New TName
	'	Print "Here"
		
	'	RegCloseKey(hDevRegKey)
	'Else
	'	GetLastError()
	'EndIf
EndFunction

''''''''''
EnumDevices()
</textarea> <br><br></td></tr></table><br>
<a name="1118894"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Russell</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks, I'll give this a shot! I am also on a laptop primarily, so I may have a similar result. I guess since a laptop's display is already known for certain (unless it has an external monitor attached through an external port) there's no need for it to return any EDID information.<br><br>I did some digging last night and discovered that a lot of monitor makers apparently either don't return correct EDID values, or they are incomplete (It is not a requirement, although Plug-n-play is not possible otherwise), so the usefulness of the EDID information may be questionable, unfortunately.<br><br>Still, if there was at least ONE widescreen mode that was pretty much guaranteed to be available, that would be very helpful. I can't imagine why they didn't think of this!<br><br>I thought of just using the SetVirtualResolution(), but that can sometimes lead to other issues, such as a not as crisp display.<br><br>Anyway, I'm going to try your code right now, and thanks!<br>Russell <br><br></td></tr></table><br>
<a name="1118897"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Russell</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yep, I made the change to line 103 and it returned nothing (although it's actually DIGCF_xxx, not DIGF_xxx). So there seems to be an issue with laptop displays. :(<br><br>Thanks, Dave, for getting this to work. <br><br>What is everyone else doing to determine the correct fullscreen display dimensions? Are you using a standard 800 x 600 with pillar boxing on widescreens? Letting the user choose from a list that you provide?<br><br>Russell <br><br></td></tr></table><br>
<a name="1118902"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >xlsior</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> One fairly foolproof way of obtaining at least one most-likely-to-be-desirable resolution that is also supported by the hardware, would be to look at the resolution used by the actual OS desktop itself.<br><br>Although a catch there is that if it is a high resolution, there is a chance that low-end videocards may not have enough memory to open a second screen with the same specs. <br><br></td></tr></table><br>
<a name="1118904"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >xlsior</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oh, one more thought about EDID (I did some playing around with this myself in the past) is that it's possible to make an educated guess about whether or not the user is using LCD or CRT: if the EDID info has an overscan value declared, it's most likely a CRT. If the overscan value is zero, it's most likely an LCD.<br><br>It's really too bad that so many devices flat out LIE about their capabilities, though -- why on earth would the manufacturer want to set themselves up for failure? <br><br></td></tr></table><br>
<a name="1118914"></a>

<a name="1118916"></a>

<a name="1119003"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm making more progress on the code with getting EDID info from the 'Generic PnP Monitor' registry entry. How useful will it be? we won't know until it's put out for trials. But it's interesting anyway :D<br><br>I also read about false EDID return results, kind of pointless returning a result if the data isn't accurate, but there you go. However, the source I read from was primarily referring to HDMI TVs.<br><br>I read an article on gamedev.net recently regarding resolutions etc but I'll be damned as I can't find it.<br><br>*DIGCFxxx typo. my apologies, as a way of an excuse :- late night coding :/<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1118920"></a>

<a name="1118958"></a>

<a name="1118959"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for the EDID format :P<br>I can get this to output the data into human readable form. Maybe knock up a GUI for looks.<br><br>EDIT - Thanks for the heads up there xlsior. I'm in the middle of making the gui output now to make things readable.<br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1118996"></a>

<a name="1118998"></a>

<a name="1118999"></a>

<a name="1119000"></a>

<a name="1119001"></a>

<a name="1119002"></a>

<a name="1119004"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> I didn't bother putting it together into a GUI, but here is the code that will put all monitors that have EDID data into an array of TMonitors which contains a monitor name and all resolutions the monitor can support. Again as we've discussed this may or may be erroneous data anyway :P<br><br>This could do with some more testing as I've left some validation checks, for eg it assumes the EDID data is in EDID1.3 format. If its worth updating this code and maybe putting into a module then I'd do all the sanity checks, but it is how it is just for now.<br><br>The data gets stored in these Types<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Type TMonitorResolution
	Field width,height,hz
EndType

Type TMonitor
	Field Name$
	Field NumOfResolutions
	Field Resolution:TMonitorResolution[]
EndType

Global Monitors:TMonitor[]            'Global array of TMonitors
</textarea><br><br>To use in your own code you call:<br><br><b>EnumMonitors(CheckAllMonitors = False)</b><br><br>The default is to check just the monitors connected but if you pass in a value of True as the optional parameter then it will spit out all monitors listed that have EDID data along with all resolutions supported ( or I should say reported ) :-<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
EnumMonitors(True) '&lt;--- Or leave the parameter empty as EnumMonitors()

For Local Mon:TMonitor = EachIn Monitors
	Print "Monitor Name: "+Mon.Name
	For Local Res:TMonitorResolution = EachIn Mon.Resolution
'EDIT :- The forum screwed this next line up!!!! so I had to space it out. lol.
		Print  Chr( 9 )+Chr( 9 ) + Res.Width + "x" + Res.Height + "@" + Res.Hz +"Hz"         
	Next
Next
</textarea><br><br>The complete code including the example code :-<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict

Const SPDRP_DEVICEDESC                  =$00000000  ' DeviceDesc (R/W)
Const SPDRP_HARDWAREID                  =$00000001  ' HardwareID (R/W)
Const SPDRP_COMPATIBLEIDS               =$00000002  ' CompatibleIDs (R/W)
Const SPDRP_NTDEVICEPATHS               =$00000003  ' Unsupported, DO Not USE
Const SPDRP_SERVICE                     =$00000004  ' Service (R/W)
Const SPDRP_CONFIGURATION               =$00000005  ' Configuration (R)
Const SPDRP_CONFIGURATIONVECTOR         =$00000006  ' ConfigurationVector (R)
Const SPDRP_CLASS                       =$00000007  ' Class (R--tied To ClassGUID)
Const SPDRP_CLASSGUID                   =$00000008  ' ClassGUID (R/W)
Const SPDRP_DRIVER                      =$00000009  ' Driver (R/W)
Const SPDRP_CONFIGFLAGS                 =$0000000A  ' ConfigFlags (R/W)
Const SPDRP_MFG                         =$0000000B  ' Mfg (R/W)
Const SPDRP_FRIENDLYNAME                =$0000000C  ' FriendlyName (R/W)
Const SPDRP_LOCATION_INFORMATION        =$0000000D  ' LocationInformation (R/W)
Const SPDRP_PHYSICAL_DEVICE_OBJECT_NAME =$0000000E  ' PhysicalDeviceObjectName (R)
Const SPDRP_CAPABILITIES                =$0000000F  ' Capabilities (R)
Const SPDRP_UI_NUMBER                   =$00000010  ' UiNumber (R)
Const SPDRP_UPPERFILTERS                =$00000011  ' UpperFilters (R/W)
Const SPDRP_LOWERFILTERS                =$00000012  ' LowerFilters (R/W)
Const SPDRP_MAXIMUM_PROPERTY            =$00000013  ' Upper bound on ordinals

Const DIGCF_DEFAULT           =$00000001
Const DIGCF_PRESENT           =$00000002
Const DIGCF_ALLCLASSES        =$00000004
Const DIGCF_PROFILE           =$00000008
Const DIGCF_DEVICEINTERFACE   =$00000010

Const CM_DEVCAP_LOCKSUPPORTED            =$00000001
Const CM_DEVCAP_EJECTSUPPORTED           =$00000002
Const CM_DEVCAP_REMOVABLE                =$00000004
Const CM_DEVCAP_DOCKDEVICE               =$00000008
Const CM_DEVCAP_UNIQUEID                 =$00000010
Const CM_DEVCAP_SILENTINSTALL            =$00000020
Const CM_DEVCAP_RAWDEVICEOK              =$00000040
Const CM_DEVCAP_SURPRISEREMOVALOK        =$00000080
Const CM_DEVCAP_HARDWAREDISABLED         =$00000100
Const CM_DEVCAP_NONDYNAMIC               =$00000200

Const DICS_FLAG_GLOBAL         =$0000001 
Const DIREG_DEV       =$00000001

Const KEY_READ = $20019
Const KEY_ALL_ACCESS  =$F003F

Const ERROR_SUCCESS				= 0
Const ERROR_NO_MORE_ITEMS 		= 259

Type SP_DEVINFO_DATA
	Field cbSize = SizeOf(SP_DEVINFO_DATA)
	Field ClassGuid0,ClassGuid1,ClassGuid2,ClassGuid3:Short
	Field DevInst
	Field Reserved
EndType

Type SP_DEVINFO_LIST_DETAIL_DATA
	Field cbSize = SizeOf(SP_DEVINFO_LIST_DETAIL_DATA)
	Field ClassGuid:Byte Ptr
	Field RemoteMachineName0:Long,RemoteMachineName1:Long,RemoteMachineName2:Long,RemoteMachineName3:Long
	Field RemoteMachineName4:Long,RemoteMachineName5:Long,RemoteMachineName6:Long,RemoteMachineName7:Long
	Field RemoteMachineName8:Long,RemoteMachineName9:Long,RemoteMachineName10:Long,RemoteMachineName11:Long
	Field RemoteMachineName12:Long,RemoteMachineName13:Long,RemoteMachineName14:Long,RemoteMachineName15:Long
	Field RemoteMachineName16:Long,RemoteMachineName17:Long,RemoteMachineName18:Long,RemoteMachineName19:Long
	Field RemoteMachineName20:Long,RemoteMachineName21:Long,RemoteMachineName22:Long,RemoteMachineName23:Long
	Field RemoteMachineName24:Long,RemoteMachineName25:Long,RemoteMachineName26:Long,RemoteMachineName27:Long
	Field RemoteMachineName28:Long,RemoteMachineName29:Long,RemoteMachineName30:Long,RemoteMachineName31:Long
	Field RemoteMachineName32:Int,RemoteMachineName33:Short,RemoteMachineName34:Byte
EndType


''''''''''
Global GUID_CLASS_MONITOR[] = [$4d36e963,$11cee325,$0008c1bf,$1803e12b]


''''''''''
Global Kernel32DLL = LoadLibraryA("kernel32")
Global GetLastError()"win32" = GetProcAddress(Kernel32DLL,"GetLastError")


''''''''''
Global AdvApi32DLL = LoadLibraryA("advapi32")
Global RegCloseKey(hKey:Byte Ptr)"win32" = GetProcAddress(AdvApi32DLL,"RegCloseKey")
Global RegEnumValue(hKey:Byte Ptr,dwIndex,lpValueName:Byte Ptr,lpcchValueName:Int Var,lpReserved,lpType:Int Var,lpData:Byte Ptr,..
								lpcData:Int Var)"win32" = GetProcAddress(AdvApi32DLL,"RegEnumValueA")
								
''''''''''
Global SetupApiDLL = LoadLibraryA("setupapi")
Global SetupDiGetDeviceRegistryProperty(DeviceInfoSet:Byte Ptr,DeviceInfoData:Byte Ptr,Property,PropertyRegDataType:Int Ptr,..
								PropertyBuffer:Byte Ptr,PropertyBufferSize,RequiredSize:Int Ptr)"win32" = GetProcAddress(SetupApiDLL,"SetupDiGetDeviceRegistryPropertyA")
Global SetupDiGetClassDevsEx:Byte Ptr(ClassGuid:Byte Ptr,Enumerator:Byte Ptr,hwndParent,Flags,DeviceInfoSet:Byte Ptr,MachineName:Byte Ptr,..
								Reserved:Byte Ptr)"win32" = GetProcAddress(SetupApiDLL,"SetupDiGetClassDevsExA")
Global SetupDiEnumDeviceInfo(DeviceInfoSet:Byte Ptr,MemberIndex,DeviceInfoData:Byte Ptr)"win32" = GetProcAddress(SetupApiDLL,"SetupDiEnumDeviceInfo")
Global SetupDiOpenDevRegKey:Byte Ptr(DeviceInfoSet:Byte Ptr,DeviceInfoData:Byte Ptr,Scope,HwProfile,KeyType,samDesired)"win32" = GetProcAddress(SetupApiDLL,"SetupDiOpenDevRegKey")
Global SetupDiDestroyDeviceInfoList(DeviceInfoSet:Byte Ptr)"win32" = GetProcAddress(SetupApiDLL,"SetupDiDestroyDeviceInfoList")


'''''''''
Type TMonitorResolution
	Field width,height,hz
EndType

Type TMonitor
	Field Name$
	Field NumOfResolutions
	Field Resolution:TMonitorResolution[]
EndType

Global Monitors:TMonitor[]

''''''''''
Function EnumMonitors(CheckAllMonitors = False)
	Function AddResolution(Mon:TMonitor,Width,Height,Hz)
		'See if the resolution alreadys exists
		Local Exists = False
		
		For Local Res:TMonitorResolution = EachIn Mon.Resolution
			If Res.Width = Width
				If Res.Height = Height
					If Res.Hz = Hz
						Exists = True
					EndIf
				EndIf
			EndIf
		Next
		
		If Not Exists
			Local NumRes = Mon.NumOfResolutions
			Mon.Resolution = Mon.Resolution[..NumRes+1]
			Mon.Resolution[NumRes] = New TMonitorResolution
						
			Mon.Resolution[NumRes].Width = Width
			Mon.Resolution[NumRes].Height = Height
			Mon.Resolution[NumRes].Hz = Hz
						
			Mon.NumOfResolutions :+ 1
		EndIf
	EndFunction
	
	Function PlayWithDeviceInfo(devInfo:Byte Ptr,devInfoData:SP_DEVINFO_DATA)
		Type TuniID
			Field uniID0:Long,uniID1:Long,uniID2:Long,uniID3:Long,uniID4:Long
			Field uniID5:Long,uniID6:Long,uniID7:Long,uniID8:Long,uniID9:Long
			Field uniID10:Long,uniID11:Long,uniID12:Long,uniID13:Long,uniID14:Long
			Field uniID15:Short,uniID16:Byte
		
			Method GetuniID$()
				Return String.FromCString(Varptr uniID0)
			EndMethod
		EndType
	
		Type TName
			Field Name0:Long,Name1:Long,Name2:Long,Name3:Long
			Field Name4:Long,Name5:Long,Name6:Long,Name7:Long
			Field Name8:Long,Name9:Long,Name10:Long,Name11:Long
			Field Name12:Long,Name13:Long,Name14:Long,Name15:Long
		
			Field NameLength = 128
		
			Method GetName$()
				Return String.FromCString(Varptr Name0)
			EndMethod
		EndType
	
		Type TEDIDData
			Field Data0:Long,Data1:Long,Data2:Long,Data3:Long,Data4:Long,Data5:Long,Data6:Long,Data7:Long
			Field Data8:Long,Data9:Long,Data10:Long,Data11:Long,Data12:Long,Data13:Long,Data14:Long,Data15:Long
			Field Data16:Long,Data17:Long,Data18:Long,Data19:Long,Data20:Long,Data21:Long,Data22:Long,Data23:Long
			Field Data24:Long,Data25:Long,Data26:Long,Data27:Long,Data28:Long,Data29:Long,Data30:Long,Data31:Long
			Field Data32:Long,Data33:Long,Data34:Long,Data35:Long,Data36:Long,Data37:Long,Data38:Long,Data39:Long
			Field Data40:Long,Data41:Long,Data42:Long,Data43:Long,Data44:Long,Data45:Long,Data46:Long,Data47:Long
			Field Data48:Long,Data49:Long,Data50:Long,Data51:Long,Data52:Long,Data53:Long,Data54:Long,Data55:Long
			Field Data56:Long,Data57:Long,Data58:Long,Data59:Long,Data60:Long,Data61:Long,Data62:Long,Data63:Long
			Field Data64:Long,Data65:Long,Data66:Long,Data67:Long,Data68:Long,Data69:Long,Data70:Long,Data71:Long
			Field Data72:Long,Data73:Long,Data74:Long,Data75:Long,Data76:Long,Data77:Long,Data78:Long,Data79:Long
			Field Data80:Long,Data81:Long,Data82:Long,Data83:Long,Data84:Long,Data85:Long,Data86:Long,Data87:Long
			Field Data88:Long,Data89:Long,Data90:Long,Data91:Long,Data92:Long,Data93:Long,Data94:Long,Data95:Long
			Field Data96:Long,Data97:Long,Data98:Long,Data99:Long,Data100:Long,Data101:Long,Data102:Long,Data103:Long
			Field Data104:Long,Data105:Long,Data106:Long,Data107:Long,Data108:Long,Data109:Long,Data110:Long,Data111:Long
			Field Data112:Long,Data113:Long,Data114:Long,Data115:Long,Data116:Long,Data117:Long,Data118:Long,Data119:Long
			Field Data120:Long,Data121:Long,Data122:Long,Data123:Long,Data124:Long,Data125:Long,Data126:Long,Data127:Long
			
			Field Data:Byte Ptr = Byte Ptr(Varptr Data0)
		EndType
	
		Local uniID:TuniID = New TuniID
		Local hDevRegKey:Byte Ptr

		SetupDiGetDeviceRegistryProperty(devInfo,devInfoData,SPDRP_DEVICEDESC,Null,uniID,SizeOf(uniID),Null)
		hDevRegKey = SetupDiOpenDevRegKey(devInfo,devInfoData,DICS_FLAG_GLOBAL,0,DIREG_DEV,KEY_READ)

		If hDevRegKey
			Local valueName:TName = New TName
			Local EDIDSize = SizeOf(TEDIDData)
			Local i,retValue
			Local dwType:Int
			
			Repeat
				Local EDIDData:TEDIDData = New TEDIDData
			
				retValue = RegEnumValue(hDevRegKey,i,valueName,valueName.NameLength,Null,dwType,EDIDData,EDIDSize)

				If retValue = ERROR_SUCCESS
					If valueName.GetName() = "EDID"
						Local Mon:TMonitor
						Local NumMonitors = Len(Monitors)
						Monitors = Monitors[..NumMonitors+1]
						Monitors[NumMonitors] = New TMonitor
						Mon = Monitors[NumMonitors]

						'Get monitor name
						'Possible choice of three places!
						Local index
						
						If EDIDData.Data[57] = $FC index = 59
						If EDIDData.Data[75] = $FC index = 77
						If EDIDData.Data[93] = $FC index = 95
						
						Local name$
						If index
							For Local n = index Until index + 12
								Local char = EDIDData.Data[n]
								If char = 10 Exit
				
								name :+ Chr(char)
							Next
						EndIf
					
						Mon.Name = name
					
						'Evaulate Standard Resolutions
						If EDIDData.Data[35] &amp; 128 AddResolution(Mon,720,400,70)
						If EDIDData.Data[35] &amp; 64 AddResolution(Mon,720,400,88)
						If EDIDData.Data[35] &amp; 32 AddResolution(Mon,640,480,60)
						If EDIDData.Data[35] &amp; 16 AddResolution(Mon,640,480,67)
						If EDIDData.Data[35] &amp; 8 AddResolution(Mon,640,480,72)
						If EDIDData.Data[35] &amp; 4 AddResolution(Mon,640,480,75)
						If EDIDData.Data[35] &amp; 2 AddResolution(Mon,800,600,56)
						If EDIDData.Data[35] &amp; 1 AddResolution(Mon,800,600,60)
						If EDIDData.Data[36] &amp; 128 AddResolution(Mon,800,600,72)
						If EDIDData.Data[36] &amp; 64 AddResolution(Mon,800,600,75)
						If EDIDData.Data[36] &amp; 32 AddResolution(Mon,832,624,75)
						If EDIDData.Data[36] &amp; 16 AddResolution(Mon,1024,768,87)
						If EDIDData.Data[36] &amp; 8 AddResolution(Mon,1024,768,60)
						If EDIDData.Data[36] &amp; 4 AddResolution(Mon,1024,768,72)
						If EDIDData.Data[36] &amp; 2 AddResolution(Mon,1024,768,75)
						If EDIDData.Data[36] &amp; 1 AddResolution(Mon,1280,1024,75)
						'Apple Mac :-
						If EDIDData.Data[37] &amp; 128 AddResolution(Mon,1152,870,75)
						
						'Get any extra non standard resolutions
						For Local j = 38 To 53 Step 2
							Local Width = (EDIDData.Data[j] + 31) * 8
							Local Height
							
							Local Ratio = EDIDData.Data[j+1] &amp; 192
						
							Select Ratio
								Case 0
									Height = Width * 10 / 16
								Case 64
									Height = Width * 3 / 4
								Case 128
									Height = Width * 4 / 5
								Case 192
									Height = Width * 9 / 16
							EndSelect
						
							Local Hz = (EDIDData.Data[j+1] &amp; 31) + 60
						
							'Validate
							If EDIDData.Data[j] = 0 Or EDIDData.Data[j] = 1
								Continue
							Else
								AddResolution(Mon,Width,Height,Hz)
							EndIf
						Next
					EndIf
				EndIf
			
				EDIDData = Null 'Just to make sure
			
			Until retValue = ERROR_NO_MORE_ITEMS Or retValue &lt;&gt; ERROR_SUCCESS
	
		Else
			Print "Error :- "+GetLastError()
		EndIf
	
		RegCloseKey(hDevRegKey)
	EndFunction

	Local Scope
	If CheckAllMonitors
		Scope = DIGCF_ALLCLASSES
	Else
		Scope = DIGCF_PRESENT
	EndIf

	Local devInfo:Byte Ptr
	Local devInfoData:SP_DEVINFO_DATA = New SP_DEVINFO_DATA
	
	devinfo = SetupDiGetClassDevsEx(GUID_CLASS_MONITOR,Null,Null,Scope,Null,Null,Null)
	
	If devInfo = Null
		Notify "Error :-  SetupDiGetClassDevsEx",True
		End
	EndIf
	
	Local i
	Repeat
		If SetupDiEnumDeviceInfo(devInfo,i,devInfoData)
			PlayWithDeviceInfo(devInfo,devInfoData)
		EndIf
		i :+ 1
	Until GetLastError() = ERROR_NO_MORE_ITEMS
	
	SetupDiDestroyDeviceInfoList(devInfo)
EndFunction



'''''''''' EXAMPLE USE
'You could just use EnumMonitors() to get only the attached monitor
'but it doesnt seem To work on laptops?
EnumMonitors(True)

For Local Mon:TMonitor = EachIn Monitors
	Print "Monitor Name: "+Mon.Name
	For Local Res:TMonitorResolution = EachIn Mon.Resolution
		Print  Chr( 9 )+Chr( 9 ) + Res.Width + "x" + Res.Height + "@" + Res.Hz +"Hz"
	Next
Next
</textarea><br><br><font class="tiny">Last edited 2011</font> <br><br></td></tr></table><br>
<a name="1119007"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Russell</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks again, Dave! Now this is really getting somewhere! Looks good!<br><br>@xlsior: Another problem with using the user's desktop resolution is that it's pretty likely that it is one of the gfx cards higher resolutions, say 1920 x 1080 or such, and if your game is considerably lower then there might be issues. But, that being said, I just did some tests, and even though my Windows 'set resolution' dialog only lists 3 resolutions (800 x 600, 1280 x 720 and 1600 x 900) it had no problems with any resolution I threw at it that was returned by GraphicsModes(). And the neat thing is, none of the resolutions were visibly stretched: They were automatically pillar-boxed! Even 640 x 480, to my surprise, looked fine. Interestingly, none of the modes were letter-boxed, not even the ones with lower vertical resolutions: All of them took up the entire screen vertically without any apparent stretching.<br><br>Is this the case with anyone else's laptop? Mine has integrated Intel Extreme 3000 HD graphics. This would be great news if this is standard behavior for laptops (a growing segment of the PC world)!<br><br>Russell <br><br></td></tr></table><br>
<a name="1119009"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think that could be a driver issue, as mine also defaults to a pillar/letter box mode when needed. When I installed Win7 and using the Dx11 driver I made up, in full screen it definitely wasn't right, for eg the screen would be at max resolution with a smaller centred square representing a smaller resolution that I requested. When I installed the correct driver, the problem was gone.<br><br>However there are a couple of 'letterbox/pillarbox' adjustment functions in the 'Archives Section', so there has been some issues in the past.<br><br>Shall I build out the code some more or just leave it as it is? :P <br><br></td></tr></table><br>
<a name="1119010"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Russell</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>When I installed the correct driver, the problem was gone<br> <br></div><br>So even that behavior is inconsistent from driver to driver...Geez!<br><br><div class="quote"> <br>Shall I build out the code some more or just leave it as it is? :P <br> <br></div><br>I think as-is it provides more than enough information to be useful. Thanks for knocking that together so fast! But, of course the problem is that there is a huge amount of inconsistency between various display manufacturers and the quality of the information they return through EDID (not to mention the problem with slightly older displays using an older version of EDID...). It's a royal pain!<br><br>Russell <br><br></td></tr></table><br>
<a name="1119017"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just to add to the pain........<br><br>In Dx11 ( I've worked extensively with this in these past 6 months or so ), the full screen will display any resolution you want it too!! Even obscure ones that 'should' only be available in a 'window' mode, something like 850x650!! This will still work giving a pillar/letter box style. But.... and the next part is the real crunch! The displays backbuffer is only copied to the front screen buffer by the gpu instead of using a hardware swap!! This then causes it to run a lot slower in full screen modes, and then only evidence of the problem is the speed issue. Of course checking for the correct modes and setting things up properly from the start removes these issues and its not possible to set an incorrect mode in BMax as the checks are taken care of, but it is food for thought :P<br><br>I'm not sure on the other APIs that PCs can use as I've not dived so deep into the previous Dx APIs or OpenGL as I have into Dx11.<br><br>BTW. Its easy to make the code compatible with older versions of EDID if its really needed. Its just a case of using the correct data format. There is tons of information in the EDID data, as long as its provided - which is the whole dilemma really :( I guess there must a 'minimum' amount provided to allow PnP to function correctly. <br><br></td></tr></table><br>
<a name="1119020"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>and its not possible to set an incorrect mode in BMax as the checks are taken care of<br> <br></div><br><br>I'm sure they are :D *scurries off to check* <br><br></td></tr></table><br>
<a name="1119133"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Russell</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Do you mean with your DX11 driver it's not possible to set an incorrect mode in BMax, or just with Bmax in general? That's great if that's true, as we can just check to make sure Graphics() returns a non-Null object.<br><br>Every single mode that I tried on my laptop, except totally weird ones like 300 x 300, etc, worked. The ones I tried were like 320 x 200, 320 x 240, 640 x 400, 640 x 480... In other words, VESA modes. One strange thing about this is that the lowest mode that gets listed either from "list all modes" via the set-resolution dialog or from modes returned by GraphicsMode() is 800 x 600, yet those lower resolution modes worked anyway. I guess the driver does the best it can if it's a "standard" VESA type mode. Otherwise Graphics() returns a null object and the execution terminates. DX11, it seems, is going to make it better in some ways but worse in others...<br><br>I'm gonna have to give this a think and figure out what the best way to handle it is that works on various drivers and DX versions. :(<br><br>Russell <br><br></td></tr></table><br>
<a name="1119137"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >xlsior</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> The pillarbox / letterbox feature has three places it can be introduced:<br>1) The application<br>2) The windows video driver <br>1) The display itself<br><br>I know that on my Samsung 24" LCD there is an option in the on-screen settings to keep the aspect ratio, and it will automatically pillar/letterbox it.<br><br>If I disable that setting, I can also go into the ATI Catalyst program and enable the feature there<br><br>If the aspect ratio setting is disabled both in the driver AND in the monitor, it will stretch the screen to try to fill the entire display.<br><br>On a laptop you don't have the on-screen navigation buttons for the display, but there may (or may not) be some configuration options regarding the display in the computer BIOS settings. <br><br></td></tr></table><br>
<a name="1119138"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Russell</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ack! When will it end! LOL<br><br>In a perfect world:<br>- the EDID information would always be reliable,<br>- All widescreen monitors would support the same resolutions (and be 16:9, not 16:10, etc),<br>- Bmax would read this EDID information and only return values that are compatible with the users monitor,<br>- I would be married to Beyonce' ;)<br><br>Until then, I'll let the user choose a full screen mode (from a list returned by GraphicsModes()) and time out in 10 seconds if they don't click 'Ok'....and I'll keep Beyonce' in my dreams...<br><br>Russell <br><br></td></tr></table><br>
<a name="1119144"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >skidracer</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> IMHO this is only relevant for CRT monitors.<br><br>For LCD you should always use the native resolution of the panel and use virtual resolutions to fit your games requirements. <br><br></td></tr></table><br>
<a name="1119167"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2011)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> Try setting a full screen of 800x700x32 and it will return as Null :-<br><br><b><br>Local gc:TGraphics = Graphics(800,700,32)<br>If Not gc End<br><br>Print "Graphics succeeded"<br></b><br><br>I need to fix this in the D3D11 driver :-) as it will create a full screen of 800x700 :P This SHOULD NOT be happening :P Although its in the Max2D drivers that it takes place, its a general BMax feature that it returns a Null object for non standard full screen displays. So I need to fix this :-)<br><br><br>Anyway.... Yes, I'd let the user choose what looks ok for them. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
