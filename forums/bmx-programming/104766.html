<!DOCTYPE html><html lang="en" ><head ><title >BMX wrapper for Lame_enc.dll?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >BMX wrapper for Lame_enc.dll?</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >BMX wrapper for Lame_enc.dll?</a><br><br>
<a name="1271310"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi guys,<br><br>I'd like to use Lame (http://lame.sourceforge.net/) in my app to convert wav-files to mp3.<br><br>Has anyone written a simple wrapper for it yet?<br><br>Thanks<br>Grisu <br><br></td></tr></table><br>
<a name="1271324"></a>

<a name="1271325"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >skidracer</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> In theory you should be able to use CreateProcess "ffmpeg" with ffmpeg and lame binary files bundled with your own app. Talking to lame codec directly seems like an awful lot of work for little gain. <br><br></td></tr></table><br>
<a name="1271326"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >skidracer</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sox is another light weight command line tool that will recognise lame dll. <br><br></td></tr></table><br>
<a name="1271331"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for the help. <br><br>I'm probably better of creating a batch file and the users can compress the wav files themself.<br><br>Also, I'm not sure if using this stuff would cause license fees. <br><br></td></tr></table><br>
<a name="1271379"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >xlsior</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Also, I'm not sure if using this stuff would cause license fees.  <br></div><br><br>More than likely it would -- for comparison, even Audacity (one of the most popular free audio editing programs) doesn't bundle lame_enc.dll with the program itself but allows the end user to drop it on their system to add support for MP3 export:<br><br><a href="http://wiki.audacityteam.org/wiki/Lame_Installation" target="_blank">http://wiki.audacityteam.org/wiki/Lame_Installation</a><br><br><div class="quote"> Because of patent considerations, Audacity cannot ship with a built-in encoder to export MP3 files, but is able to use the third-party LAME encoder. This page explains how to download and install the correct LAME encoder for your system, and outlines the legal issues surrounding LAME encoding patents. <br></div><br><br>Apparently MP3 patents won't expire until 2017 in the USA. <br><br></td></tr></table><br>
<a name="1271381"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> I could add a batch file / command line creator for lame. <br>So users that have the dll installed on their system, can use it. <br><br></td></tr></table><br>
<a name="1271384"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I could add a batch file / command line creator for lame. <br>So users that have the dll installed on their system, can use it.  <br></div><br>If you aren't going to provide anything directly in your program, it seems a little pointless generating a batch file to do something. Certainly not something you would expect an "average" user to have much confidence (competence?) using.<br><br>If someone really wants to make an mp3 for the wav data you've ripped off the radio stream, I'm sure they will already have some software on their machine to do it? (or at least something more useful than a batch file)<br>Usefully, you could perhaps just open the folder for them in explorer, where you've just dumped the .wav file. Then they can choose to compress it in whatever way they might usually do so.<br><br>Just a thought, or few :-) <br><br></td></tr></table><br>
<a name="1271413"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >skidracer</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> I always get a dirty feeling having to download lame.<br><br>Using an ogg encoder would not leave the user with that feeling and is trivial from BlitzMax. <br><br></td></tr></table><br>
<a name="1271465"></a>

<a name="1271466"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> The "folder switch" looks like a good option.<br><br>For the ogg encoder (http://www.vorbis.com/faq/):<br><br>Is there an encoding function in the code archives? <br>I only found the "brl.oggloader.mod" and an "ogg to wav converter" on the forums. <br><br></td></tr></table><br>
<a name="1271474"></a>

<a name="1271476"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >skidracer</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oops, sorry to not link. <br><br>If I had, I would have found the relevant module abandoned on googlecode out of public reach.<br><br>Back momentarily...<br><br><br>relevant files are still available here:<br><br><a href="http://max-edit.googlecode.com/svn/trunk/mod/axe.mod/oggsaver.mod/" target="_blank">http://max-edit.googlecode.com/svn/trunk/mod/axe.mod/oggsaver.mod/</a><br><br>Google is currently exporting the entire kaboodle to github where I will test soon to make sure it works. <br><br></td></tr></table><br>
<a name="1271555"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> If you really do want to venture into mp3 land then the <a href="https://code.google.com/p/blademp3/downloads/list" target="_blank">Blade mp3 dll</a> wraps the lameenc library to give a simple interface to encode wav to mp3. <br><br></td></tr></table><br>
<a name="1271572"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Skid:<br>I needed to make some changes to the module code in order to make work.<br>Therefore I replaced the header with the ogg files present in the pub.mod (Brucey Edition).<br><br>Btw: There are some updates available on the official site (put as comment below).<br><br><pre class=code>
Import "../../pub.mod/oggvorbis.mod/libogg-1.3.1/include/*.h" ' Latest version: 1.3.2
Import "../../pub.mod/oggvorbis.mod/libvorbis-1.3.4/include/*.h" ' Latest version: 1.3.5 
Import "../../pub.mod/oggvorbis.mod/libvorbis-1.3.4/lib/*.h"     ' Latest version: 1.3.5
Import "../../pub.mod/oggvorbis.mod/libvorbis-1.3.4/lib/vorbisenc.c" ' Latest version: 1.3.5
</pre><br><br>Modules rebuilt fine and the exampe works too.<br><br>But the given functions don't seem to work, if I throw a WAV at them? I'm only getting "blank" data file.<br><br><pre class=code>
	Local filename:String = RECORDINGS_DIR+station_name
	Local ogg_sample:TAudioSample

	filename.ToUTF8String() ' Setting the basic filename of the last recording.

    Print "Loading wav..." 
    ogg_sample=LoadAudioSample:TAudioSample(filename+".wav" ) ' Loading original wav-file

    Print "OGGing sample..."
    Print SaveOGG(ogg_sample, filename+".ogg") ' Encoding...
</pre><br><br>@col:<br>I love adventures, but porting the blade code over to bmx is beyond my coding skills.<br><br>The FLAC format might be an additonal free alternative. But again, there's no bmx-module for it. <br><br></td></tr></table><br>
<a name="1274414"></a>

<a name="1274415"></a>

<a name="1274419"></a>

<a name="1274420"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Grisu<br>Oops. I forgot about this thread, my apologies.<br><br><div class="quote"> <br>I love adventures, but porting the blade code over to bmx is beyond my coding skills.<br> <br></div><br><br>I love them too :-)<br><br>Here's a simple wrapper, if you can call it that. Just stick the BladeMp3Enc.dll file in the same folder as the .exe produced by the following code and you should be able to choose a wav file to encode to an mp3 in the same folder as the wav file. I did start to put the encoding function in a thread but then I got sleepy... and I'm sure that you wouldn't want me have all of the fun by doing ALL of the work now eh ;O)<br><br>Do read the source though as I've put some hints in there for you...<br>Also it may be a good idea for you to read the BladeMp3EncDll.h file for some acceptable parameter values so that your users can change the encoding bitrate etc<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict

Import MaxGui.Drivers
Import MaxGui.XpManifest

' BladeMP3EncDll

' config
Type BE_CONFIG
	Field dwConfig:Int

	Field dwSampleRate:Int
	Field byMode:Byte
	Field wBitrate:Short
	Field bPrivate:Int
	Field bCRC:Int
	Field bCopyright:Int
	Field bOriginal:Int
EndType

' dll 
Global hBladeDll = loadlibrarya("BladeMp3Enc.dll")
If Not hBladeDll
	Notify("You need to use BladeMp3Enc.dll with this software",True)
	End
EndIf

Global beInitStream:Int(pbeConfig:Byte Ptr,pdwSamples: Int Ptr,pdwBufferSize:Int Ptr,phbeStream:Int Ptr)"Win32" = GetProcAddress(hBladeDll,"beInitStream")
Global beEncodeChunk:Int(hbeSream:Int,nSamples:Int,pSamples:Short Ptr,pOutput:Byte Ptr,pdwOutput:Int Ptr)"Win32" = GetProcAddress(hBladeDll,"beEncodeChunk")
Global beDeInitStream:Int(hbeStream:Int,pOutput:Byte Ptr,pdwOutput:Int Ptr)"Win32" = GetProcAddress(hBladeDll,"beDeinitStream")
Global beCloseStream:Int(hbeStream:Int)"Win32" = GetProcAddress(hBladeDll,"beCloseStream")



' main application
Global winMain:TGadget = CreateWindow("BladeMp3 encoding",0,0,600,200,Null,WINDOW_DEFAULT|WINDOW_CENTER ~ WINDOW_MENU)

' in file
Global butSelectInFile:TGadget = CreateButton("Select input file:",20,20,100,25,winMain)
Global butInFilename:TGadget = CreateTextArea(120,20,300,25,winMain,TEXTAREA_READONLY)
SetGadgetText(butInFilename,"&lt;not selected&gt;")

' encode 
Global butEncode:TGadget = CreateButton("Encode now",420,20,100,25,winMain)

' progress
Global prgProgress:TGadget = CreateProgBar(20,50,500,30,winMain)

' mainloop
Repeat
	WaitEvent
	
	Select EventID()
		Case EVENT_GADGETACTION
			Select EventSource()
				Case butSelectInFile
					Local file$ = RequestFile("Select WAV file","WAV files:wav")
					If file &lt;&gt; ""
						SetGadgetText(butInFilename,file)
					EndIf
					
				Case butEncode
					Encode(GadgetText(butInFilename))

			EndSelect
		
			
		Case EVENT_WINDOWCLOSE
			End

	EndSelect
Forever

Function Encode:Object(Data:Object)
	Local dwSamples = 0
	Local dwBufferSize = 0
	Local hbeStream = 0
	
	' open the input wav file and get some data from it
	Local wavFile:TStream = LittleEndianStream(OpenStream(Data,True,False))
	If Not wavFile Notify "error - cannot open file: "+String Data
	
	' load in the header - we dont want to encode the WAV header anyway - only the audio data itself
	Local RIFF:Int = ReadInt(wavFile)			' RIFF tag
	Local filelength:Int = ReadInt(wavFile)		' file length - 8
	Local WAVE:Int = ReadInt(wavFile)			' WAVE tag
	Local fmt_:Int = ReadInt(wavFile)			' fmt tag
	Local length:Int = ReadInt(wavFile) 		' should be 16 for the previous 4 int reads
	Local pcm:Short = ReadShort(wavFile)		' should be 1 for PCM format
	Local channels:Short = ReadShort(wavFile)	' mono or stereo
	Local samplerate:Int = ReadInt(wavFile)		' sample rate
	Local bitrate:Int = ReadInt(wavFile)		' bitrate
	Local align:Short = ReadShort(wavFile)		' alignment
	Local bps:Short = ReadShort(wavFile)		' bits per sample
	Local DATA_:Int = ReadInt(wavFile)			' data tag
	Local datasize:Int = ReadInt(wavFile)		' chunk size
	
	' make sure the WAV data is valid for the encoder
	If RIFF &lt;&gt; 1179011410 Or WAVE &lt;&gt; 1163280727 Or fmt_ &lt;&gt; 544501094 Or pcm &lt;&gt; 1 Or bps &lt;&gt; 16 Notify "Unsupported WAV file"

	' configure a couple of settings for the encoder
	Local config:BE_CONFIG = New BE_CONFIG
	config.dwSampleRate = samplerate	' keep the output sample rate the same as the input sample rate
	config.wbitRate = 128				' choose an output bitrate here

	' create an instance of the lame encoder via the blade dll
	If beInitStream(config,Varptr dwSamples,Varptr dwBufferSize,Varptr hbeStream) &lt;&gt; 0 Notify "Error - setting config"; Return
	
	' make sure the instance is valid
	If Not hbestream Notify "error - handle is invalid"; End

	' create a new mp3 file to save into
	Local mp3$ = StripExt(String Data) + ".mp3"
	Local mp3File:TStream = OpenStream(mp3,False,True)
	
	' create some counters
	Local wavSamplesLeft:Int =  datasize / 2	' the divide 2 is for reading 16bit shorts
	Local wavBufferSize:Int = dwSamples			' given from initialising the encoder
	Local wavChunksize = wavBufferSize			' current number of samples to send to the encoder
	Local iBytesEncoded:Int						' no of bytes of mp3 data returned from the encoder
	
	' create a buffer for the wav and mp3 data
	Local pWAVBuffer:Short[wavBufferSize]
	Local pMp3Buffer:Byte[dwBufferSize]			' dwBufferSize was given from the encoder
	
	' loop by loading in the wav data, encoding it to mp3 and saving out the mp3 data
	While wavSamplesLeft &gt; 0
		' less than wavBufferSize to load in?
		If wavSamplesLeft &lt; wavChunkSize wavChunkSize = wavSamplesLeft
		
		' load data into the wav buffer
		For Local i:Int = 0 Until wavChunkSize
			pWAVBuffer[i] = ReadShort(wavFile)
		Next
		
		' encode the wav data to mp3 data
		Local enc:Int = beEncodeChunk(hbeStream,wavChunkSize,pWAVBuffer,pMp3Buffer,Varptr iBytesEncoded)
		If enc &lt;&gt; 0 Notify "error - encoding chunk failed!";End
		
		' save out the mp3 data
		For Local i:Int = 0 Until iBytesEncoded
			WriteByte(mp3File,pMp3Buffer[i])
		Next

		' simple update for user feedback
		Local update# = 1.0 - (Float(wavSamplesLeft) / Float(datasize/2) )
		UpdateProgBar(prgProgress,update)
		
		' reduce how much encoding is left to do
		wavSamplesLeft :- wavChunkSize
	Wend
	
	' squeeze out any last drops of data from the encoder
	beDeInitStream(hbeStream,pMp3Buffer,Varptr iBytesEncoded)
	For Local i:Int = 0 Until iBytesEncoded
		WriteByte(mp3File,pMp3Buffer[i])
	Next

	Notify "Encoding of "+ StripExt(StripDir(String Data)) + ".mp3 is finished"
	UpdateProgBar(prgProgress,0)

	' clean up a little
	beCloseStream(hbeStream)
	CloseStream(wavFile)
	CloseStream(mp3File)
EndFunction
</textarea> <br><br></td></tr></table><br>
<a name="1274418"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi Dave,<br>thanks a lot for the simple code! ;) <br>Now I have enough bits to tinker with for the next months. <br><br>I'm currently adding ogg support to my recoder (see other thread). Mp3 may follow later. The licensing unclairity bugs me though. Thus I probably won't be able to include the dll in my releases. <br><br></td></tr></table><br>
<a name="1275861"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi Dave,<br>I tried your example code from above. It compiles fine but produces 768 Byte large empty MP3 files?! <br><br>No error message. It just states: Encoding of ... is finished.<br><br>P.S.: I'm using the latest BladeEnc.dll, i.e. 1.3.2. <br><br></td></tr></table><br>
<a name="1275883"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi Grisu,<br><br>That's the same version I used :-)<br>How big is the .wav file? Could it be over 2Gb? the size of a signed 32 bit integer? <br><br></td></tr></table><br>
<a name="1275916"></a>

<a name="1275918"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> For testing I used .wav files that were created via the FMOD_OUTPUTTYPE_WAVWRITER. <br><br><div class="quote"> <br>Const FMOD_OUTPUTTYPE_WAVWRITER:Int <br>Description All - Writes output to fmodoutput.wav by default. <br>Information Use the 'extradriverdata' parameter in System::init, by simply passing the filename as a string, to set the wav filename. <br> <br></div><br><br>My guess is that this might cause the issue. Though I can't change any settings for this via FMOD.<br><br>All test files were &lt;500 MB. You could record a station with PRP and see for yourself.<br> <br>Sorry to bother you. :( <br><br></td></tr></table><br>
<a name="1275924"></a>

<a name="1275925"></a>

<a name="1275927"></a>

<a name="1275928"></a>

<a name="1275929"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey Grisu,<br><br><div class="quote"> My guess is that this might cause the issue. <br></div><br><br>Naaah... it was bug in the header reader.<br>Here's a fixed version - there's only one extra line, line 96.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict

Import MaxGui.Drivers
Import MaxGui.XpManifest

' BladeMP3EncDll

' config
Type BE_CONFIG
	Field dwConfig:Int

	Field dwSampleRate:Int
	Field byMode:Byte
	Field wBitrate:Short
	Field bPrivate:Int
	Field bCRC:Int
	Field bCopyright:Int
	Field bOriginal:Int
EndType

' dll 
Global hBladeDll = loadlibrarya("BladeMp3Enc.dll")
If Not hBladeDll
	Notify("You need to use BladeMp3Enc.dll with this software",True)
	End
EndIf

Global beInitStream:Int(pbeConfig:Byte Ptr,pdwSamples: Int Ptr,pdwBufferSize:Int Ptr,phbeStream:Int Ptr)"Win32" = GetProcAddress(hBladeDll,"beInitStream")
Global beEncodeChunk:Int(hbeSream:Int,nSamples:Int,pSamples:Short Ptr,pOutput:Byte Ptr,pdwOutput:Int Ptr)"Win32" = GetProcAddress(hBladeDll,"beEncodeChunk")
Global beDeInitStream:Int(hbeStream:Int,pOutput:Byte Ptr,pdwOutput:Int Ptr)"Win32" = GetProcAddress(hBladeDll,"beDeinitStream")
Global beCloseStream:Int(hbeStream:Int)"Win32" = GetProcAddress(hBladeDll,"beCloseStream")



' main application
Global winMain:TGadget = CreateWindow("BladeMp3 encoding",0,0,600,200,Null,WINDOW_DEFAULT|WINDOW_CENTER ~ WINDOW_MENU)

' in file
Global butSelectInFile:TGadget = CreateButton("Select input file:",20,20,100,25,winMain)
Global butInFilename:TGadget = CreateTextArea(120,20,300,25,winMain,TEXTAREA_READONLY)
SetGadgetText(butInFilename,"&lt;not selected&gt;")

' encode 
Global butEncode:TGadget = CreateButton("Encode now",420,20,100,25,winMain)

' progress
Global prgProgress:TGadget = CreateProgBar(20,50,500,30,winMain)

' mainloop
Repeat
	WaitEvent
	
	Select EventID()
		Case EVENT_GADGETACTION
			Select EventSource()
				Case butSelectInFile
					Local file$ = RequestFile("Select WAV file","WAV files:wav")
					If file &lt;&gt; ""
						SetGadgetText(butInFilename,file)
					EndIf
					
				Case butEncode
					Encode(GadgetText(butInFilename))

			EndSelect
		
			
		Case EVENT_WINDOWCLOSE
			End

	EndSelect
Forever

Function Encode:Object(Data:Object)
	Local dwSamples = 0
	Local dwBufferSize = 0
	Local hbeStream = 0
	
	' open the input wav file and get some data from it
	Local wavFile:TStream = LittleEndianStream(OpenStream(Data,True,False))
	If Not wavFile Notify "error - cannot open file: "+String Data
	
	' load in the header - we dont want to encode the WAV header anyway - only the audio data itself
	Local RIFF:Int = ReadInt(wavFile)			' RIFF tag
	Local filelength:Int = ReadInt(wavFile)		' file length - 8
	Local WAVE:Int = ReadInt(wavFile)			' WAVE tag
	Local fmt_:Int = ReadInt(wavFile)			' fmt tag
	Local length:Int = ReadInt(wavFile) 		' variable length header
	Local pcm:Short = ReadShort(wavFile)		' should be 1 for PCM format
	Local channels:Short = ReadShort(wavFile)	' mono or stereo
	Local samplerate:Int = ReadInt(wavFile)		' sample rate
	Local bitrate:Int = ReadInt(wavFile)		' bitrate
	Local align:Short = ReadShort(wavFile)		' alignment
	Local bps:Short = ReadShort(wavFile)		' bits per sample
	
	' go to end of header
	SeekStream(wavFile,20+length)
	
	Local DATA_:Int = ReadInt(wavFile)			' data tag
	Local datasize:Int = ReadInt(wavFile)		' chunk size
		
	' make sure the WAV data is valid for the encoder
	If RIFF &lt;&gt; 1179011410 Or WAVE &lt;&gt; 1163280727 Or fmt_ &lt;&gt; 544501094 Or pcm &lt;&gt; 1 Or bps &lt;&gt; 16 Notify "Unsupported WAV file"

	' configure a couple of settings for the encoder
	Local config:BE_CONFIG = New BE_CONFIG
	config.dwSampleRate = samplerate	' keep the output sample rate the same as the input sample rate
	config.wbitRate = 128				' choose an output bitrate here

	' create an instance of the lame encoder via the blade dll
	If beInitStream(config,Varptr dwSamples,Varptr dwBufferSize,Varptr hbeStream) &lt;&gt; 0 Notify "Error - setting config"; Return
	
	' make sure the instance is valid
	If Not hbestream Notify "error - handle is invalid"; End

	' create a new mp3 file to save into
	Local mp3$ = StripExt(String Data) + ".mp3"
	Local mp3File:TStream = OpenStream(mp3,False,True)
	
	' create some counters
	Local wavSamplesLeft:Int =  datasize / 2	' the divide 2 is for reading 16bit shorts
	Local wavBufferSize:Int = dwSamples			' given from initialising the encoder
	Local wavChunksize = wavBufferSize			' current number of samples to send to the encoder
	Local iBytesEncoded:Int						' no of bytes of mp3 data returned from the encoder
	
	' create a buffer for the wav and mp3 data
	Local pWAVBuffer:Short[wavBufferSize]
	Local pMp3Buffer:Byte[dwBufferSize]			' dwBufferSize was given from the encoder
	
	' loop by loading in the wav data, encoding it to mp3 and saving out the mp3 data
	While wavSamplesLeft &gt; 0
		' less than wavBufferSize to load in?
		If wavSamplesLeft &lt; wavChunkSize wavChunkSize = wavSamplesLeft
		
		' load data into the wav buffer
		For Local i:Int = 0 Until wavChunkSize
			pWAVBuffer[i] = ReadShort(wavFile)
		Next
		
		' encode the wav data to mp3 data
		Local enc:Int = beEncodeChunk(hbeStream,wavChunkSize,pWAVBuffer,pMp3Buffer,Varptr iBytesEncoded)
		If enc &lt;&gt; 0 Notify "error - encoding chunk failed!";End
		
		' save out the mp3 data
		For Local i:Int = 0 Until iBytesEncoded
			WriteByte(mp3File,pMp3Buffer[i])
		Next

		' simple update for user feedback
		Local update# = 1.0 - (Float(wavSamplesLeft) / Float(datasize/2) )
		UpdateProgBar(prgProgress,update)
		
		' reduce how much encoding is left to do
		wavSamplesLeft :- wavChunkSize
	Wend
	
	' squeeze out any last drops of data from the encoder
	beDeInitStream(hbeStream,pMp3Buffer,Varptr iBytesEncoded)
	For Local i:Int = 0 Until iBytesEncoded
		WriteByte(mp3File,pMp3Buffer[i])
	Next

	Notify "Encoding of "+ StripExt(StripDir(String Data)) + ".mp3 is finished"
	UpdateProgBar(prgProgress,0)

	' clean up a little
	beCloseStream(hbeStream)
	CloseStream(wavFile)
	CloseStream(mp3File)
EndFunction
</textarea> <br><br></td></tr></table><br>
<a name="1275964"></a>

<a name="1275965"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Awesome! Works fine now and I can set a custom bitrate.<br><br>I like you progress bar a lot. Do you know how I could encode the ogg files in chunks as well to create a progress bar? From the oggsaver.mod the external command doesn't seem to allow this. <br><br><div class="quote"> <br>Encode_Ogg(outputstream:Object,callback:Byte Ptr,freq,channels,samples:Float Ptr,length,compression:Float)<br> <br></div><br><br>This way I could offer the same functionality / gui for mp3 and ogg saving. <br><br></td></tr></table><br>
<a name="1275976"></a>

<a name="1275978"></a>

<a name="1275979"></a>

<a name="1275980"></a>

<a name="1275981"></a>

<a name="1276218"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Did more digging this morning.<br><br>The Lame website states: BladeEnc One of the first free encoders for Linux. Development has stopped at version 0.94.2. Quality is not satisfactory. <br><br>As I tried, you can also use the lame_enc.dll directly with the construct.<br><br>Global hBladeDll = loadlibrarya("lame_enc.dll")<br><br>Works nicely. And should be faster / better than the blade.dll. <br><br></td></tr></table><br>
<a name="1275995"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thats cool!<br><br>It looks as though they've incorporated the BladeEnc api into the LameEnc.dll. That's a pretty smart thing to do as I think BladeEnc was used in a fairly large amount of software in days gone by.<br><br>The progress update is a bit of an illusion really. Ideally you'd have the encoder running in a separate thread. That way the user can cancel halfway through encoding should they choose to. As it is the main app thread is doing the encoding with no way to exit - you could check for user input I suppose in the encoding loop and exit early I guess.<br><br>I'll have a play with the vorbis encoder later to get some encoding feedback going. It looks as though only a minor tweak would be needed. <br><br></td></tr></table><br>
<a name="1276038"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> I made a small modification to the axe.oggsaver module ( hope you don't mind skidracer?!? ) that adds an optional extra parameter to allow a callback function to be called during encoding. This modification is also 100% backwards compatible will any code that already uses the original axe.oggsaver module and should suit as a drop in replacement.<br><br>Also here's the same app as above with the option to choose ogg or mp3 output. The app now expects the lame_enc.dll as you noted above and of course the modified axe.oggsaver module...<br><br>SampleApplication.bmx:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Strict

Import MaxGui.Drivers
Import MaxGui.XpManifest
Import Axe.OggSaver

' config
Type BE_CONFIG
	Field dwConfig:Int

	Field dwSampleRate:Int
	Field byMode:Byte
	Field wBitrate:Short
	Field bPrivate:Int
	Field bCRC:Int
	Field bCopyright:Int
	Field bOriginal:Int
EndType

' dlls
Global hLameEncDll = loadlibrarya("lame_enc.dll")
If Not hLameEncDll
	Notify("You need to use lame_enc.dll with this software",True)
	End
EndIf

Global beInitStream:Int(pbeConfig:Byte Ptr,pdwSamples: Int Ptr,pdwBufferSize:Int Ptr,phbeStream:Int Ptr)"Win32" = GetProcAddress(hLameEncDll,"beInitStream")
Global beEncodeChunk:Int(hbeSream:Int,nSamples:Int,pSamples:Short Ptr,pOutput:Byte Ptr,pdwOutput:Int Ptr)"Win32" = GetProcAddress(hLameEncDll,"beEncodeChunk")
Global beDeInitStream:Int(hbeStream:Int,pOutput:Byte Ptr,pdwOutput:Int Ptr)"Win32" = GetProcAddress(hLameEncDll,"beDeinitStream")
Global beCloseStream:Int(hbeStream:Int)"Win32" = GetProcAddress(hLameEncDll,"beCloseStream")





' main application
Global winMain:TGadget = CreateWindow("Basic audio encoder",0,0,600,200,Null,WINDOW_DEFAULT|WINDOW_CENTER ~ WINDOW_MENU)

' in file
Global butSelectInFile:TGadget = CreateButton("Select input file:",20,20,100,25,winMain)
Global butInFilename:TGadget = CreateTextArea(120,20,300,25,winMain,TEXTAREA_READONLY)
Global butOgg:TGadget = CreateButton("Ogg",530,20,50,25,winMain,BUTTON_RADIO)
Global butMp3:TGadget = CreateButton("Mp3",530,50,50,25,winMain,BUTTON_RADIO)

SetButtonState(butOgg,True)
SetGadgetText(butInFilename,"&lt;not selected&gt;")

' encode 
Global butEncode:TGadget = CreateButton("Encode now",420,20,100,25,winMain)

' progress
Global prgProgress:TGadget = CreateProgBar(20,50,500,30,winMain)

' mainloop
Repeat
	WaitEvent
	
	Select EventID()
		Case EVENT_GADGETACTION
			Select EventSource()
				Case butSelectInFile
					Local file$ = RequestFile("Select WAV file","WAV files:wav")
					If file &lt;&gt; ""
						SetGadgetText(butInFilename,file)
					EndIf
					
				Case butEncode
					If ButtonState(butMp3) Encode_Mp3(GadgetText(butInFilename),ProgressUpdate)
					If ButtonState(butOgg) Encode_Ogg(GadgetText(butInFilename),ProgressUpdate)

			EndSelect
			
		Case EVENT_WINDOWCLOSE
			End

	EndSelect
Forever




Function ProgressUpdate(AmountDone:Float)
	UpdateProgBar(prgProgress,AmountDone)
EndFunction




Function Encode_Ogg(Filename:String,ProgressCallback(AmountDone:Float))
	Local wavFile:TAudioSample = LoadAudioSample(Filename)
	If Not wavFile Return

	SaveOgg(wavFile,StripExt(Filename)+".ogg",,ProgressCallback)
	
	Notify "Encoding of "+ StripExt(StripDir(String Filename)) + ".ogg is finished"
	UpdateProgBar(prgProgress,0)
EndFunction




Function Encode_Mp3:Object(Data:Object,ProgressCallback(AmountDone:Float))
	Local dwSamples = 0
	Local dwBufferSize = 0
	Local hbeStream = 0
	
	' open the input wav file and get some data from it
	Local wavFile:TStream = LittleEndianStream(OpenStream(Data,True,False))
	If Not wavFile Notify "error - cannot open file: "+String Data
	
	' load in the header - we dont want to encode the WAV header anyway - only the audio data itself
	Local RIFF:Int = ReadInt(wavFile)			' RIFF tag
	Local filelength:Int = ReadInt(wavFile)		' file length - 8
	Local WAVE:Int = ReadInt(wavFile)			' WAVE tag
	Local fmt_:Int = ReadInt(wavFile)			' fmt tag
	Local length:Int = ReadInt(wavFile) 		' variable length header
	Local pcm:Short = ReadShort(wavFile)		' should be 1 for PCM format
	Local channels:Short = ReadShort(wavFile)	' mono or stereo
	Local samplerate:Int = ReadInt(wavFile)		' sample rate
	Local bitrate:Int = ReadInt(wavFile)		' bitrate
	Local align:Short = ReadShort(wavFile)		' alignment
	Local bps:Short = ReadShort(wavFile)		' bits per sample
	
	' go to end of header
	SeekStream(wavFile,20+length)
	
	Local DATA_:Int = ReadInt(wavFile)			' data tag
	Local datasize:Int = ReadInt(wavFile)		' chunk size
		
	' make sure the WAV data is valid for the encoder
	If RIFF &lt;&gt; 1179011410 Or WAVE &lt;&gt; 1163280727 Or fmt_ &lt;&gt; 544501094 Or pcm &lt;&gt; 1 Or bps &lt;&gt; 16 Notify "Unsupported WAV file"

	' configure a couple of settings for the encoder
	Local config:BE_CONFIG = New BE_CONFIG
	config.dwSampleRate = samplerate	' keep the output sample rate the same as the input sample rate
	config.wbitRate = 128				' choose an output bitrate here

	' create an instance of the lame encoder via the blade dll
	If beInitStream(config,Varptr dwSamples,Varptr dwBufferSize,Varptr hbeStream) &lt;&gt; 0 Notify "Error - setting config"; Return
	
	' make sure the instance is valid
	If Not hbestream Notify "error - handle is invalid"; End

	' create a new mp3 file to save into
	Local mp3$ = StripExt(String Data) + ".mp3"
	Local mp3File:TStream = OpenStream(mp3,False,True)
	
	' create some counters
	Local wavSamplesLeft:Int =  datasize / 2	' the divide 2 is for reading 16bit shorts
	Local wavBufferSize:Int = dwSamples			' given from initialising the encoder
	Local wavChunksize = wavBufferSize			' current number of samples to send to the encoder
	Local iBytesEncoded:Int						' no of bytes of mp3 data returned from the encoder
	
	' create a buffer for the wav and mp3 data
	Local pWAVBuffer:Short[wavBufferSize]
	Local pMp3Buffer:Byte[dwBufferSize]			' dwBufferSize was given from the encoder
	
	' loop by loading in the wav data, encoding it to mp3 and saving out the mp3 data
	While wavSamplesLeft &gt; 0
		' less than wavBufferSize to load in?
		If wavSamplesLeft &lt; wavChunkSize wavChunkSize = wavSamplesLeft
		
		' load data into the wav buffer
		For Local i:Int = 0 Until wavChunkSize
			pWAVBuffer[i] = ReadShort(wavFile)
		Next
		
		' encode the wav data to mp3 data
		Local enc:Int = beEncodeChunk(hbeStream,wavChunkSize,pWAVBuffer,pMp3Buffer,Varptr iBytesEncoded)
		If enc &lt;&gt; 0 Notify "error - encoding chunk failed!";End
		
		' save out the mp3 data
		For Local i:Int = 0 Until iBytesEncoded
			WriteByte(mp3File,pMp3Buffer[i])
		Next

		' simple callback for user feedback
		ProgressCallback(1.0 - (Float(wavSamplesLeft) / Float(datasize/2) ))
		
		
		' reduce how much encoding is left to do
		wavSamplesLeft :- wavChunkSize
	Wend
	
	' squeeze out any last drops of data from the encoder
	beDeInitStream(hbeStream,pMp3Buffer,Varptr iBytesEncoded)
	For Local i:Int = 0 Until iBytesEncoded
		WriteByte(mp3File,pMp3Buffer[i])
	Next

	Notify "Encoding of "+ StripExt(StripDir(String Data)) + ".mp3 is finished"
	UpdateProgBar(prgProgress,0)

	' clean up a little
	beCloseStream(hbeStream)
	CloseStream(wavFile)
	CloseStream(mp3File)
EndFunction
</textarea><br><br>oggencoder.c [axe.mod/oggsaver.mod/oggencoder.c]<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
//oggencoder.c

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

#include &lt;time.h&gt;
#include &lt;math.h&gt;

#include &lt;vorbis/vorbisenc.h&gt;
//#include &lt;vorbisenc.h&gt;

#define READ 1024

typedef struct oggwriter oggwriter;

struct oggwriter{
	ogg_stream_state os; //take physical pages, weld into a logical stream of packets 
	ogg_page         og; //one Ogg bitstream page.  Vorbis packets are inside 
	ogg_packet       op; //one raw packet of data for decode 
	
	vorbis_info      vi; //struct that stores all the static vorbis bitstream settings 
	vorbis_comment   vc; //struct that stores all the user comments 
	
	vorbis_dsp_state vd; //central working state for the packet-&gt;PCM decoder 
	vorbis_block     vb; //local working space for packet-&gt;PCM decode 
};

int Encode_Ogg(void *stream,void(*writefunc)(void *bytes,int count,void *stream),int freq,int channels,float *samples,int length,float compression,void(*progressfunc)(float)){
	oggwriter *ogg;	
	int eos;
	int result;

	ogg=(oggwriter*)malloc(sizeof(oggwriter));

	vorbis_info_init(&amp;ogg-&gt;vi);
	
	result=vorbis_encode_init_vbr(&amp;ogg-&gt;vi,channels,freq,compression);	

	if(result) return -1;	//error format not supported...

// add a comment 

	vorbis_comment_init(&amp;ogg-&gt;vc);
	vorbis_comment_add_tag(&amp;ogg-&gt;vc,"ENCODER","encoder_example.c");
	
// set up the analysis state and auxiliary encoding storage 

	vorbis_analysis_init(&amp;ogg-&gt;vd,&amp;ogg-&gt;vi);

	vorbis_block_init(&amp;ogg-&gt;vd,&amp;ogg-&gt;vb);
	
	srand(time(NULL));
	ogg_stream_init(&amp;ogg-&gt;os,rand());
		
	ogg_packet header;
	ogg_packet header_comm;
	ogg_packet header_code;
	
	vorbis_analysis_headerout(&amp;ogg-&gt;vd,&amp;ogg-&gt;vc,&amp;header,&amp;header_comm,&amp;header_code);
	ogg_stream_packetin(&amp;ogg-&gt;os,&amp;header); //automatically placed in its own page 
	ogg_stream_packetin(&amp;ogg-&gt;os,&amp;header_comm);
	ogg_stream_packetin(&amp;ogg-&gt;os,&amp;header_code);

//This ensures the actual audio data will start on a new page, as per spec
	while(1){
		result=ogg_stream_flush(&amp;ogg-&gt;os,&amp;ogg-&gt;og);
		if(result==0)break;
		writefunc(ogg-&gt;og.header,ogg-&gt;og.header_len,stream);
		writefunc(ogg-&gt;og.body,ogg-&gt;og.body_len,stream);
	}

	int i,c,n,totallength = length;
	eos=0;
	
	while(!eos){
		if (length&gt;0){
			float **buffer=vorbis_analysis_buffer(&amp;ogg-&gt;vd,READ);
			n=length;if (n&gt;READ) n=READ;			
//uninterleave samples
			for (i=0;i&lt;n;i++){
				for (c=0;c&lt;channels;c++){
					buffer[c][i]=*samples++;
				}
			}	
			length=length-n;
//tell the library how much we actually submitted
			vorbis_analysis_wrote(&amp;ogg-&gt;vd,i);
		}else{
			vorbis_analysis_wrote(&amp;ogg-&gt;vd,0);
		}
		
// progress update
		if(progressfunc) progressfunc(1.0f - (float)length / (float)totallength);

		while(vorbis_analysis_blockout(&amp;ogg-&gt;vd,&amp;ogg-&gt;vb)==1){
//analysis, assume we want to use bitrate management
			vorbis_analysis(&amp;ogg-&gt;vb,NULL);
			vorbis_bitrate_addblock(&amp;ogg-&gt;vb);		
			while(vorbis_bitrate_flushpacket(&amp;ogg-&gt;vd,&amp;ogg-&gt;op)){
//weld the packet into the bitstream
				ogg_stream_packetin(&amp;ogg-&gt;os,&amp;ogg-&gt;op);
//write out pages (if any)
				while(!eos){
					result=ogg_stream_pageout(&amp;ogg-&gt;os,&amp;ogg-&gt;og);
					if(result==0)break;
					writefunc(ogg-&gt;og.header,ogg-&gt;og.header_len,stream);
					writefunc(ogg-&gt;og.body,ogg-&gt;og.body_len,stream);
					if (ogg_page_eos(&amp;ogg-&gt;og)) eos=1;
				}
			}
		}
	}		
//clean up and exit.  vorbis_info_clear() must be called last 
	ogg_stream_clear(&amp;ogg-&gt;os);
	vorbis_block_clear(&amp;ogg-&gt;vb);
	vorbis_dsp_clear(&amp;ogg-&gt;vd);
	vorbis_comment_clear(&amp;ogg-&gt;vc);
	vorbis_info_clear(&amp;ogg-&gt;vi);
	
	free(ogg);

	return 0;	
}
</textarea><br><br>oggsaver.bmx  [axe.mod/oggsaver.mod/oggsaver.bmx]<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Strict

Rem
bbdoc: OGG saver
about:
The axe.oggsaver module provides the ability to save OGG format #brl.audiosample.AudioSamples.
End Rem
Module axe.oggsaver

ModuleInfo "Version: 1.01"
ModuleInfo "Author: Simon Armstrong"
ModuleInfo "License: Public Domain"
ModuleInfo "Copyright: Blitz Research Ltd"
ModuleInfo "Modserver: BRL"

ModuleInfo "History: 1.01 Release"
ModuleInfo "History: axe.saveogg module created due to growth restrictions on brl.oggloader"

Import Pub.OggVorbis
Import BRL.AudioSample

Import "../../pub.mod/oggvorbis.mod/libogg-1.1.3/include/*.h"
Import "../../pub.mod/oggvorbis.mod/libvorbis-1.1.2/include/*.h"
Import "../../pub.mod/oggvorbis.mod/libvorbis-1.1.2/lib/*.h"
Import "../../pub.mod/oggvorbis.mod/libvorbis-1.1.2/lib/vorbisenc.c"

Import "oggencoder.c"

Extern
Function Encode_Ogg(outputstream:Object,callback:Byte Ptr,freq,channels,samples:Float Ptr,length,compression:Float,progresscallback:Byte Ptr)
End Extern

Private

Function writefunc(bytes:Byte Ptr,count,stream:TStream) NODEBUG
	stream.WriteBytes bytes,count
End Function	

Public

Rem
bbdoc: Save an Audio Sample in OGG format
about:
#SaveOGG saves @sample to @url in OGG format. If successful, #SaveOGG returns
True, otherwise False.&lt;br&gt;
&lt;br&gt;
The optional @compression parameter should be in the range -0.1 to 1.0,
where -0.1 indicates maximum compression and 1.0 indicates best quality.
End Rem
Function SaveOGG(sample:TAudioSample,URL:Object,compression#=0.1,funcprogress:Int(done:Float)=Null)
	Local output:TStream
	Local samples:Float[],channels,rate,count,i,res,w
	Select sample.format
		Case SF_MONO8
			channels=1
		Case SF_MONO16LE
			channels=1			
		Case SF_MONO16BE
			channels=1
		Case SF_STEREO8
			channels=2
		Case SF_STEREO16LE
			channels=2
		Case SF_STEREO16BE
			channels=2
	End Select
	rate=sample.hertz
	count=channels*sample.length
	samples=New Float[count]
	Local s:Byte Ptr=sample.samples
	Select sample.format
		Case SF_MONO8,SF_STEREO8
			For i=0 Until count
				samples[i]=(s[i]-127.5)/127.5
			Next
		Case SF_MONO16LE,SF_STEREO16LE
			For i=0 Until count
				w=(s[1] Shl 8)|(s[0])
				If (w&amp;$8000) w=w|$ffff0000	'sign extend
				samples[i]=w/32768.0				
				s=s+2
			Next	
		Case SF_MONO16BE,SF_STEREO16BE
			For i=0 Until count
				w=(s[0] Shl 8)|(s[1])
				If (w&amp;$8000) w=w|$ffff0000	'sign extend
				samples[i]=w/32768.0				
				s=s+2
			Next	
	End Select		
	output=WriteStream(url)
	If Not output Return -1
	
	If funcprogress
		res=Encode_Ogg(output,writefunc,rate,channels,samples,sample.length,compression,funcprogress)
	Else
		res=Encode_Ogg(output,writefunc,rate,channels,samples,sample.length,compression,Null)
	EndIf
	
	CloseStream(output)
	Return res
End Function



Rem
bbdoc: Save an Audio Sample in WAV format
about:
#SaveWAV saves @sample to @url in WAV format. If successful, #SaveWAV returns
True, otherwise False.&lt;br&gt;
End Rem
Function SaveWAV(sample:TAudioSample,URL:Object)
	Local output:TStream
	Local channels
	
	Select sample.format
		Case SF_MONO8
			channels=1
		Case SF_MONO16LE
			channels=1			
		Case SF_MONO16BE
			channels=1
		Case SF_STEREO8
			channels=2
		Case SF_STEREO16LE
			channels=2
		Case SF_STEREO16BE
			channels=2
	End Select

	Local bitrate=8
	
	Local block = channels * bitrate / 8

	Local count=block*sample.length


	output=WriteStream(url)
	If Not output Return -1
	
	'write wav header info
	output.WriteString("RIFF")						'"RIFF" file description header (4 bytes)
	output.WriteInt(count + 40)						'file size - 8 (4 bytes)
	output.WriteString("WAVE")						'"WAVE" description header (4 bytes)
	output.WriteString("fmt ")						'"fmt " description header (4 bytes)
	output.WriteInt(16)								'size of WAVE section chunk (4 bytes)
	output.WriteShort(1)							'WAVE type format (2 bytes)
	output.WriteShort(channels)						'mono/stereo (2 bytes)
	output.WriteInt(sample.hertz)					'sample rate (4 bytes)
	output.WriteInt(sample.hertz * block)			'avg bytes/sec (4 bytes)
	output.WriteShort(block)						'Block alignment (2 bytes)
	output.WriteShort(bitrate)						'Bits/sample (2 bytes)
	output.WriteString("data")						'"data" description header (4 bytes)
	output.WriteInt(count)							'size of data chunk (4 bytes)
	
	For Local i=0 Until count
		output.WriteByte sample.samples[i]
	Next

	CloseStream(output)
	
	Return True

End Function
</textarea> <br><br></td></tr></table><br>
<a name="1276042"></a>

<a name="1276043"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Skid: <br>If you update your module, could please also include the latest oggvorbis codecs?<br><br><pre class=code>
Import "../../pub.mod/oggvorbis.mod/libogg-1.3.2/include/*.h" ' Latest version: 1.3.2
Import "../../pub.mod/oggvorbis.mod/libvorbis-1.3.5/include/*.h" ' Latest version: 1.3.5 
Import "../../pub.mod/oggvorbis.mod/libvorbis-1.3.5/lib/*.h"     ' Latest version: 1.3.5
Import "../../pub.mod/oggvorbis.mod/libvorbis-1.3.5/lib/vorbisenc.c" ' Latest version: 1.3.5
</pre><br><br>@col:<br>Thanks a lot for your help Dave.<br><br>I'm still coding on my app's framework, will report back asap. I also made your "old" example "SuperStrict". Will change your new one as welll.<br><br>Stefan <br><br></td></tr></table><br>
<a name="1276215"></a>

<a name="1276216"></a>

<a name="1276217"></a>

<a name="1276224"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> After spending my weekend on this. I got it up and running. I posted some images and a test build in the PRP thread. <br><br>Below is an updated example code:<br><br>1. It checks if one of the dlls is present at startup. If both are present the app uses Blade &gt; Lame.<br>2. You can close the Window while encoding.<br>3. Sets custom bitrates via a new drop down.<br>4. SuperStrict code.<br>5. Additional status messages.<br><br><b>Example:</b><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' Fancy Example by Col &amp; Grisu :D

SuperStrict

Import MaxGui.Drivers
Import MaxGui.XpManifest
Import Axe.OggSaver

' main application
Global winMain:TGadget = CreateWindow("Basic Audio Encoder",0,0,600,200,Null,WINDOW_DEFAULT|WINDOW_CENTER ~ WINDOW_MENU)

' config
Type BE_CONFIG
	Field dwConfig:Int

	Field dwSampleRate:Int
	Field byMode:Byte
	Field wBitrate:Short
	Field bPrivate:Int
	Field bCRC:Int
	Field bCopyright:Int
	Field bOriginal:Int
EndType

Global Encoder_Qualitybox:TGadget=CreateComboBox(150,50,70,25,winMain)
SetGadgetLayout Encoder_Qualitybox, Null, Null, EDGE_ALIGNED, Null

AddGadgetItem Encoder_Qualitybox,"  64 kb", GADGETITEM_NORMAL
AddGadgetItem Encoder_Qualitybox,"  80 kb", GADGETITEM_NORMAL
AddGadgetItem Encoder_Qualitybox,"  96 kb", GADGETITEM_NORMAL
AddGadgetItem Encoder_Qualitybox," 112 kb", GADGETITEM_NORMAL
AddGadgetItem Encoder_Qualitybox," 128 kb", GADGETITEM_NORMAL
AddGadgetItem Encoder_Qualitybox," 160 kb", GADGETITEM_NORMAL
AddGadgetItem Encoder_Qualitybox," 192 kb", GADGETITEM_NORMAL
AddGadgetItem Encoder_Qualitybox," 224 kb", GADGETITEM_NORMAL
AddGadgetItem Encoder_Qualitybox," 256 kb", GADGETITEM_NORMAL
AddGadgetItem Encoder_Qualitybox," 320 kb", GADGETITEM_NORMAL

' dlls
Global hLameEncDll:Int'
Global Enc_used:Int=0 ' 1 = Blade, 2 = Lame

If FileType("BladeMP3Enc.dll")=1 Then 
	hLameEncDll:Int = loadlibrarya("BladeMP3Enc.dll") 
    Enc_used=1
    SetStatusText ( WinMain, "Mp3-Encoding via BladeMP3Enc.dll." )
Else 
    If FileType("lame_enc.dll")=1 Then 
      hLameEncDll:Int = loadlibrarya("lame_enc.dll")
      Enc_used=2
      SetStatusText ( WinMain, "Mp3-Encoding via Lame_enc.dll." )
    EndIf
EndIf 

Global beInitStream:Int(pbeConfig:Byte Ptr,pdwSamples: Int Ptr,pdwBufferSize:Int Ptr,phbeStream:Int Ptr)"Win32" = GetProcAddress(hLameEncDll,"beInitStream")
Global beEncodeChunk:Int(hbeSream:Int,nSamples:Int,pSamples:Short Ptr,pOutput:Byte Ptr,pdwOutput:Int Ptr)"Win32" = GetProcAddress(hLameEncDll,"beEncodeChunk")
Global beDeInitStream:Int(hbeStream:Int,pOutput:Byte Ptr,pdwOutput:Int Ptr)"Win32" = GetProcAddress(hLameEncDll,"beDeinitStream")
Global beCloseStream:Int(hbeStream:Int)"Win32" = GetProcAddress(hLameEncDll,"beCloseStream")


' in file
Global butSelectInFile:TGadget = CreateButton("Select input file:",20,20,100,25,winMain)
Global butInFilename:TGadget = CreateTextArea(120,20,440,25,winMain,TEXTAREA_READONLY)
Global butEncode:TGadget = CreateButton("Encode now",460,50,100,25,winMain)

Global butOgg:TGadget = CreateButton("Ogg",20,50,50,25,winMain,BUTTON_RADIO)
Global butMp3:TGadget = CreateButton("Mp3",90,50,50,25,winMain,BUTTON_RADIO)

Global Enc_Progbar:TGadget = CreateProgBar(20,90,540,25,winMain)


If Not hLameEncDll Then 

	SetButtonState(butOgg,True)
	DisableGadget butmp3
    SelectGadgetItem Encoder_Qualitybox, 4  

    SetStatusText ( WinMain, "Only Ogg-Encoding. Mp3 Library not found!" )

Else 

	SetButtonState(butmp3,True)

	If Enc_used = 2 Then 
	   ' Lame Codec = restricted to 320 kb/s
	   SelectGadgetItem Encoder_Qualitybox, 9 
	Else 
	   SelectGadgetItem Encoder_Qualitybox, 4  
	EndIf 

EndIf 

SetGadgetText(butInFilename,"&lt;Not selected&gt;")


' mainloop
Repeat
	WaitEvent
	
	Select EventID()
		Case EVENT_GADGETACTION
			Select EventSource()
				Case butSelectInFile
					Local file$ = RequestFile("Select WAV file","WAV files:wav")
					If file &lt;&gt; ""
						SetGadgetText(butInFilename,file)
   						SetStatusText ( WinMain, "Loaded &amp; Ready for some action! :o)" )
					EndIf
					
				Case butEncode

Print Trim(GadgetText(butInFilename))
					
					If ButtonState(butMp3) And Trim(GadgetText(butInFilename)) &lt;&gt; "&lt;Not selected&gt;" Then 

						Local compression:Int=128 
		
	  				    Select SelectedGadgetItem (Encoder_Qualitybox)
					      Case 9
							compression=320  '320 kbs
					      Case 8
							compression=256  '256 kbs
		    			  Case 7
							compression=224  '224 kbs
					      Case 6
							compression=192  '192 kbs
					      Case 5
							compression=160  '160 kbs
					      Case 4
							compression=128  '128 kbs
					      Case 3
							compression=112  '112 kbs
					      Case 2
							compression=96  '96 kbs
					      Case 1
							compression=80  '80 kbs
					      Case 0
							compression=64 '64 kbs
	
					    End Select 
					
  						SetStatusText ( WinMain, "MP3-Encoding @ "+compression+" kb/s... Please wait!" )
 					    Encode_Mp3(GadgetText(butInFilename),Compression,Enc_ProgressUpdate)
                    EndIf
 
					If ButtonState(butOgg) And Trim(GadgetText(butInFilename)) &lt;&gt; "&lt;Not selected&gt;" Then

						Local compression:Int=0.4 
	
				  	    Select SelectedGadgetItem (Encoder_Qualitybox)
		    			  Case 9
							compression=0.9  '320 kbs
					      Case 8
							compression=0.8  '256 kbs
					      Case 7
							compression=0.7  '224 kbs
					      Case 6
							compression=0.6  '192 kbs
					      Case 5
							compression=0.5  '160 kbs
					      Case 4
							compression=0.4  '128 kbs
					      Case 3
							compression=0.3  '112 kbs
					      Case 2
						compression=0.2  '96 kbs
					      Case 1
						compression=0.1  '80 kbs
					      Case 0
						compression=0.005 '64 kbs

					    End Select 

   						SetStatusText ( WinMain, "Ogg-Encoding @ "+compression+" kb/s... Please wait!" )
 					    Encode_Ogg(GadgetText(butInFilename),Compression,Enc_ProgressUpdate)
                    EndIf 

			EndSelect
			
		Case EVENT_WINDOWCLOSE
			End

	EndSelect
Forever

Function Encode_Ogg(enc_filename:String,compression:Float,ProgressCallback(AmountDone:Float))
	Local wavFile:TAudioSample = LoadAudioSample(StripExt(enc_filename)+".wav")
	If Not wavFile Return

	SaveOGG(wavFile, StripExt(enc_filename)+".ogg", compression, ProgressCallback) ' Do the magic!

	UpdateProgBar(enc_progbar,0)
    SetStatusText ( WinMain, "Encoding of "+StripExt(StripDir(enc_filename))+".ogg is finished!" )

End Function

Function Encode_Mp3:Object(Data:Object, compression:Int, ProgressCallback(AmountDone:Float))
'Function Encode_Mp3:Object(Data:Object, compression:Int)', ProgressCallback(Enc_AmountDone:Float))
	Local dwSamples:Int = 0
	Local dwBufferSize:Int = 0
	Local hbeStream:Int = 0
	
	' open the input wav file and get some data from it
	Local wavFile:TStream = LittleEndianStream(OpenStream(Data,True,False))
	If Not wavFile Then 
	  Notify "Error: Cannot open file: "+String Data
      Return data 
	EndIf 
	
	' load in the header - we dont want to encode the WAV header anyway - only the audio data itself
	Local RIFF:Int = ReadInt(wavFile)			' RIFF tag
	Local filelength:Int = ReadInt(wavFile)		' file length - 8
	Local WAVE:Int = ReadInt(wavFile)			' WAVE tag
	Local fmt_:Int = ReadInt(wavFile)			' fmt tag
	Local length:Int = ReadInt(wavFile) 		' variable length header
	Local pcm:Short = ReadShort(wavFile)		' should be 1 for PCM format
	Local channels:Short = ReadShort(wavFile)	' mono or stereo
	Local samplerate:Int = ReadInt(wavFile)		' sample rate
	Local bitrate:Int = ReadInt(wavFile)		' bitrate
	Local align:Short = ReadShort(wavFile)		' alignment
	Local bps:Short = ReadShort(wavFile)		' bits per sample
	
	' go to end of header
	SeekStream(wavFile,20+length)
	
	Local DATA_:Int = ReadInt(wavFile)			' data tag
	Local datasize:Int = ReadInt(wavFile)		' chunk size
		
	' make sure the WAV data is valid for the encoder
	If RIFF &lt;&gt; 1179011410 Or WAVE &lt;&gt; 1163280727 Or fmt_ &lt;&gt; 544501094 Or pcm &lt;&gt; 1 Or bps &lt;&gt; 16 Then 
	 Notify "Error: Unsupported WAV file!"
	 Return data
    EndIf

	' configure a couple of settings for the encoder
	Local config:BE_CONFIG = New BE_CONFIG
	config.dwSampleRate = samplerate	' keep the output sample rate the same as the input sample rate
	config.wbitRate = compression		' choose an output bitrate here

'    Print "MP3 Compress: "+config.wbitRate

	' create an instance of the lame encoder via the blade dll
	If beInitStream(config,Varptr dwSamples,Varptr dwBufferSize,Varptr hbeStream) &lt;&gt; 0 Then
       Notify "Error: Setting config!"
	   Return data
	End If 
	
	' make sure the instance is valid
	If Not hbestream Then 
	   Notify "Error: Handle is invalid!"
       End
	EndIf

	' create a new mp3 file to save into
	Local mp3$ = StripExt(String Data) + ".mp3"
	Local mp3File:TStream = OpenStream(mp3,False,True)
	
	' create some counters
	Local wavSamplesLeft:Int =  datasize / 2	' the divide 2 is for reading 16bit shorts
	Local wavBufferSize:Int = dwSamples			' given from initialising the encoder
	Local wavChunksize:Int = wavBufferSize		' current number of samples to send to the encoder
	Local iBytesEncoded:Int						' no of bytes of mp3 data returned from the encoder
	
	' create a buffer for the wav and mp3 data
	Local pWAVBuffer:Short[wavBufferSize]
	Local pMp3Buffer:Byte[dwBufferSize]			' dwBufferSize was given from the encoder
	
	' loop by loading in the wav data, encoding it to mp3 and saving out the mp3 data
	While wavSamplesLeft &gt; 0
		' less than wavBufferSize to load in?
		If wavSamplesLeft &lt; wavChunkSize wavChunkSize = wavSamplesLeft
		
		' load data into the wav buffer
		For Local i:Int = 0 Until wavChunkSize
			pWAVBuffer[i] = ReadShort(wavFile)
		Next
		
		' encode the wav data to mp3 data
		Local enc:Int = beEncodeChunk(hbeStream,wavChunkSize,pWAVBuffer,pMp3Buffer,Varptr iBytesEncoded)
		If enc &lt;&gt; 0 Then 
		  Notify "Error: Encoding chunk failed!"
		  End
		EndIf
		
		' save out the mp3 data
		For Local i:Int = 0 Until iBytesEncoded
			WriteByte(mp3File,pMp3Buffer[i])
		Next

		' simple callback for user feedback
		ProgressCallback(1.0 - (Float(wavSamplesLeft) / Float(datasize/2) ))		
'		Local update# = 1.0 - (Float(wavSamplesLeft) / Float(datasize/2) )
'		UpdateProgBar(enc_progbar,update)
	
		' reduce how much encoding is left to do
		wavSamplesLeft :- wavChunkSize

		PollEvent() ' Check for user clicking "x"
		Select EventSource()
		Case WinMain
			Select EventID()
 	    		 Case EVENT_WINDOWCLOSE
					End 
		    End Select 

		End Select 	


	Wend
	
	' squeeze out any last drops of data from the encoder
	beDeInitStream(hbeStream,pMp3Buffer,Varptr iBytesEncoded)
	For Local i:Int = 0 Until iBytesEncoded
		WriteByte(mp3File,pMp3Buffer[i])
	Next

	UpdateProgBar(enc_progbar,100)

	' clean up a little
	beCloseStream(hbeStream)
	CloseStream(wavFile)
	CloseStream(mp3File)

	wavFile=Null
	Mp3File=Null
   	
    SetStatusText ( WinMain, "Encoding of "+ StripExt(StripDir(String Data)) + ".mp3 is finished!" )
	UpdateProgBar(enc_progbar,0)
	
End Function

Function Enc_ProgressUpdate(Enc_AmountDone:Float)
	UpdateProgBar(enc_progbar,Enc_AmountDone)
EndFunction
</textarea><br><br>The issue that I have is that the different bitrates are only supported by the blade_enc.dll, if you use the lame_enc.dll, it'll always compresses at 320 kb/s. - Do you know a workaround for this? Must have something to do with the &lt;h1&gt; construct. But I'm not sure how to set this up. <br><br></td></tr></table><br>
<a name="1276280"></a>

<a name="1276281"></a>

<a name="1276283"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nice one!<br><br>To get the compression parameter working as you're expecting with the lame_enc.dll I think it's best to now use the BE_CONFIG_LAME struct.<br><br>Here's a modified version that uses that more fine grained struct.<br>Also, I hope you don't mind but I got rid of the 2 large Select statements and put the values into arrays - personally I think it keeps the code easier to read on the eyes, and it is purely my personal flavour on keeping code tidy. You can change it back if you prefer Selects :D<br><br>edit:- Tested with lame_enc.dll 3.99.5, and BladeMp3Enc.dll 1.3.2<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' Fancy Example by Col &amp; Grisu :D

SuperStrict

Import MaxGui.Drivers
Import MaxGui.XpManifest
Import Axe.OggSaver

' main application
Global winMain:TGadget = CreateWindow("Basic Audio Encoder",0,0,600,200,Null,WINDOW_DEFAULT|WINDOW_CENTER ~ WINDOW_MENU)

' config
Type BE_CONFIG_LAME
	Field dwConfig:Int
	
	Field dwStructVersion:Int
	Field dwStructSize:Int
	
	Field dwSampleRate:Int
	Field dwResampleRate:Int
	Field nMode:Int
	Field dwBitrate:Int
	Field dwMaxBitrate:Int
	Field nPreset:Int
	Field dwMpegVersion:Int
	Field dwEmpahasis:Int
	
	Field bPrivate:Int
	Field bCRC:Int
	Field bCopyright:Int
	Field bOriginal:Int
	
	Field bWriteVBRHeader:Int
	Field bEnableVBR:Int
	Field nVBRQuality:Int
	Field dwVBRAbr_bps:Int
	Field nVbrMethod:Int
	Field bNoRes:Int
	
	Field bStrictIso:Int
	Field nQuality:Int
	
	Field btReservered0:Long,btReservered1:Long,btReservered2:Long,btReservered3:Long
	Field btReservered4:Long,btReservered5:Long,btReservered6:Long,btReservered7:Long
	Field btReservered8:Long,btReservered9:Long,btReservered10:Long,btReservered11:Long
	Field btReservered12:Long,btReservered13:Long,btReservered14:Long,btReservered15:Long
	Field btReservered16:Long,btReservered17:Long,btReservered18:Long,btReservered19:Long
	Field btReservered20:Long,btReservered21:Long,btReservered22:Long,btReservered23:Long
	Field btReservered24:Long,btReservered25:Long,btReservered26:Long,btReservered27:Long
	Field btReservered28:Long,btReservered29:Short,btReserved30:Byte
EndType

Global Mp3_Compressions:Int[] = [64, 80, 96, 112, 128, 160, 192, 224, 256, 320]
Global Ogg_Compressions:Float[] = [0.005, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]

Global Encoder_Qualitybox:TGadget=CreateComboBox(150,50,70,25,winMain)
SetGadgetLayout Encoder_Qualitybox, Null, Null, EDGE_ALIGNED, Null

For Local i:Int = 0 Until 10
	Local bitrate:String = RSet(String(Mp3_Compressions[i])+" kb",7)
	AddGadgetItem Encoder_Qualitybox,bitrate, GADGETITEM_NORMAL
Next

' dlls
Global hLameEncDll:Int'
Global Enc_used:Int=0 ' 1 = Blade, 2 = Lame

If FileType("BladeMP3Enc.dll")=1 Then 
	hLameEncDll:Int = loadlibrarya("BladeMP3Enc.dll") 
    Enc_used=1
    SetStatusText ( WinMain, "Mp3-Encoding via BladeMP3Enc.dll." )
Else 
    If FileType("lame_enc.dll")=1 Then 
      hLameEncDll:Int = loadlibrarya("lame_enc.dll")
      Enc_used=2
      SetStatusText ( WinMain, "Mp3-Encoding via Lame_enc.dll." )
    EndIf
EndIf 

Global beInitStream:Int(pbeConfig:Byte Ptr,pdwSamples: Int Ptr,pdwBufferSize:Int Ptr,phbeStream:Int Ptr)"Win32" = GetProcAddress(hLameEncDll,"beInitStream")
Global beEncodeChunk:Int(hbeSream:Int,nSamples:Int,pSamples:Short Ptr,pOutput:Byte Ptr,pdwOutput:Int Ptr)"Win32" = GetProcAddress(hLameEncDll,"beEncodeChunk")
Global beDeInitStream:Int(hbeStream:Int,pOutput:Byte Ptr,pdwOutput:Int Ptr)"Win32" = GetProcAddress(hLameEncDll,"beDeinitStream")
Global beCloseStream:Int(hbeStream:Int)"Win32" = GetProcAddress(hLameEncDll,"beCloseStream")


' in file
Global butSelectInFile:TGadget = CreateButton("Select input file:",20,20,100,25,winMain)
Global butInFilename:TGadget = CreateTextArea(120,20,440,25,winMain,TEXTAREA_READONLY)
Global butEncode:TGadget = CreateButton("Encode now",460,50,100,25,winMain)

Global butOgg:TGadget = CreateButton("Ogg",20,50,50,25,winMain,BUTTON_RADIO)
Global butMp3:TGadget = CreateButton("Mp3",90,50,50,25,winMain,BUTTON_RADIO)

Global Enc_Progbar:TGadget = CreateProgBar(20,90,540,25,winMain)


If Not hLameEncDll Then 

	SetButtonState(butOgg,True)
	DisableGadget butmp3
    SelectGadgetItem Encoder_Qualitybox, 4  

    SetStatusText ( WinMain, "Only Ogg-Encoding. Mp3 Library not found!" )

Else 

	SetButtonState(butmp3,True)

	If Enc_used = 2 Then 
	   ' Lame Codec = restricted to 320 kb/s
	   SelectGadgetItem Encoder_Qualitybox, 9 
	Else 
	   SelectGadgetItem Encoder_Qualitybox, 4  
	EndIf 

EndIf 

SetGadgetText(butInFilename,"&lt;Not selected&gt;")


' mainloop
Repeat
	WaitEvent
	
	Select EventID()
		Case EVENT_GADGETACTION
			Select EventSource()
				Case butSelectInFile
					Local file$ = RequestFile("Select WAV file","WAV files:wav")
					If file &lt;&gt; ""
						SetGadgetText(butInFilename,file)
   						SetStatusText ( WinMain, "Loaded &amp; Ready for some action! :o)" )
					EndIf
					
				Case butEncode

Print Trim(GadgetText(butInFilename))
					
					If ButtonState(butMp3) And Trim(GadgetText(butInFilename)) &lt;&gt; "&lt;Not selected&gt;" Then 
						Local compression:Int = Mp3_Compressions[SelectedGadgetItem (Encoder_Qualitybox)]
				
  						SetStatusText ( WinMain, "MP3-Encoding @ "+compression+" kb/s... Please wait!" )
 					    Encode_Mp3(GadgetText(butInFilename),Compression,Enc_ProgressUpdate)
                    EndIf
 
					If ButtonState(butOgg) And Trim(GadgetText(butInFilename)) &lt;&gt; "&lt;Not selected&gt;" Then

						Local compression:Float =  Ogg_Compressions[SelectedGadgetItem (Encoder_Qualitybox)]
   						SetStatusText ( WinMain, "Ogg-Encoding @ "+compression+" kb/s... Please wait!" )
 					    Encode_Ogg(GadgetText(butInFilename),Compression,Enc_ProgressUpdate)
                    EndIf 

			EndSelect
			
		Case EVENT_WINDOWCLOSE
			End

	EndSelect
Forever

Function Encode_Ogg(enc_filename:String,compression:Float,ProgressCallback(AmountDone:Float))
	Local wavFile:TAudioSample = LoadAudioSample(StripExt(enc_filename)+".wav")
	If Not wavFile Return

	SaveOGG(wavFile, StripExt(enc_filename)+".ogg", compression, ProgressCallback) ' Do the magic!

	UpdateProgBar(enc_progbar,0)
    SetStatusText ( WinMain, "Encoding of "+StripExt(StripDir(enc_filename))+".ogg is finished!" )

End Function

Function Encode_Mp3:Object(Data:Object, compression:Int, ProgressCallback(AmountDone:Float))
'Function Encode_Mp3:Object(Data:Object, compression:Int)', ProgressCallback(Enc_AmountDone:Float))
	Local dwSamples:Int = 0
	Local dwBufferSize:Int = 0
	Local hbeStream:Int = 0
	
	' open the input wav file and get some data from it
	Local wavFile:TStream = LittleEndianStream(OpenStream(Data,True,False))
	If Not wavFile Then 
	  Notify "Error: Cannot open file: "+String Data
      Return data 
	EndIf 
	
	' load in the header - we dont want to encode the WAV header anyway - only the audio data itself
	Local RIFF:Int = ReadInt(wavFile)			' RIFF tag
	Local filelength:Int = ReadInt(wavFile)		' file length - 8
	Local WAVE:Int = ReadInt(wavFile)			' WAVE tag
	Local fmt_:Int = ReadInt(wavFile)			' fmt tag
	Local length:Int = ReadInt(wavFile) 		' variable length header
	Local pcm:Short = ReadShort(wavFile)		' should be 1 for PCM format
	Local channels:Short = ReadShort(wavFile)	' mono or stereo
	Local samplerate:Int = ReadInt(wavFile)		' sample rate
	Local bitrate:Int = ReadInt(wavFile)		' bitrate
	Local align:Short = ReadShort(wavFile)		' alignment
	Local bps:Short = ReadShort(wavFile)		' bits per sample
	
	' go to end of header
	SeekStream(wavFile,20+length)
	
	Local DATA_:Int = ReadInt(wavFile)			' data tag
	Local datasize:Int = ReadInt(wavFile)		' chunk size
		
	' make sure the WAV data is valid for the encoder
	If RIFF &lt;&gt; 1179011410 Or WAVE &lt;&gt; 1163280727 Or fmt_ &lt;&gt; 544501094 Or pcm &lt;&gt; 1 Or bps &lt;&gt; 16 Then 
	 Notify "Error: Unsupported WAV file!"
	 Return data
    EndIf

	' configure a couple of settings for the encoder
	Local config:BE_CONFIG_LAME = New BE_CONFIG_LAME
	config.dwConfig = 256
	config.dwStructVersion = 1
	config.dwStructSize = SizeOf(BE_CONFIG_LAME)
	config.dwSampleRate = samplerate
	config.dwBitrate = compression
	config.dwMaxBitrate = compression
	config.nPreset = 4
	config.dwMpegVersion = 1
	config.bWriteVBRHeader = True
	config.bNoRes = True

    'Print "MP3 Compress: "+config.wbitRate

	' create an instance of the lame encoder via the blade dll
	If beInitStream(config,Varptr dwSamples,Varptr dwBufferSize,Varptr hbeStream) &lt;&gt; 0 Then
       Notify "Error: Setting config!"
	   Return data
	End If 
	
	' make sure the instance is valid
	If Not hbestream Then 
	   Notify "Error: Handle is invalid!"
       End
	EndIf

	' create a new mp3 file to save into
	Local mp3$ = StripExt(String Data) + ".mp3"
	Local mp3File:TStream = OpenStream(mp3,False,True)
	
	' create some counters
	Local wavSamplesLeft:Int =  datasize / 2	' the divide 2 is for reading 16bit shorts
	Local wavBufferSize:Int = dwSamples			' given from initialising the encoder
	Local wavChunksize:Int = wavBufferSize		' current number of samples to send to the encoder
	Local iBytesEncoded:Int						' no of bytes of mp3 data returned from the encoder
	
	' create a buffer for the wav and mp3 data
	Local pWAVBuffer:Short[wavBufferSize]
	Local pMp3Buffer:Byte[dwBufferSize]			' dwBufferSize was given from the encoder
	
	' loop by loading in the wav data, encoding it to mp3 and saving out the mp3 data
	While wavSamplesLeft &gt; 0
		' less than wavBufferSize to load in?
		If wavSamplesLeft &lt; wavChunkSize wavChunkSize = wavSamplesLeft
		
		' load data into the wav buffer
		For Local i:Int = 0 Until wavChunkSize
			pWAVBuffer[i] = ReadShort(wavFile)
		Next
		
		' encode the wav data to mp3 data
		Local enc:Int = beEncodeChunk(hbeStream,wavChunkSize,pWAVBuffer,pMp3Buffer,Varptr iBytesEncoded)
		If enc &lt;&gt; 0 Then 
		  Notify "Error: Encoding chunk failed!"
		  End
		EndIf
		
		' save out the mp3 data
		For Local i:Int = 0 Until iBytesEncoded
			WriteByte(mp3File,pMp3Buffer[i])
		Next

		' simple callback for user feedback
		ProgressCallback(1.0 - (Float(wavSamplesLeft) / Float(datasize/2) ))		
'		Local update# = 1.0 - (Float(wavSamplesLeft) / Float(datasize/2) )
'		UpdateProgBar(enc_progbar,update)
	
		' reduce how much encoding is left to do
		wavSamplesLeft :- wavChunkSize

		PollEvent() ' Check for user clicking "x"
		Select EventSource()
		Case WinMain
			Select EventID()
 	    		 Case EVENT_WINDOWCLOSE
					End 
		    End Select 

		End Select 	


	Wend
	
	' squeeze out any last drops of data from the encoder
	beDeInitStream(hbeStream,pMp3Buffer,Varptr iBytesEncoded)
	For Local i:Int = 0 Until iBytesEncoded
		WriteByte(mp3File,pMp3Buffer[i])
	Next

	UpdateProgBar(enc_progbar,100)

	' clean up a little
	beCloseStream(hbeStream)
	CloseStream(wavFile)
	CloseStream(mp3File)

	wavFile=Null
	Mp3File=Null
   	
    SetStatusText ( WinMain, "Encoding of "+ StripExt(StripDir(String Data)) + ".mp3 is finished!" )
	UpdateProgBar(enc_progbar,0)
	
End Function

Function Enc_ProgressUpdate(Enc_AmountDone:Float)
	UpdateProgBar(enc_progbar,Enc_AmountDone)
EndFunction
</textarea> <br><br></td></tr></table><br>
<a name="1276368"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> Strange, from my testings the files created are now always at 32 kb/s rate?<br><br>I checked the results via the VLC player:<br><img src="http://s4.postimg.org/44g8pyv4t/32kbs.png"><br><br>Both codecs don't work anymore for me. As usual used PRP recordings as example files. <br><br></td></tr></table><br>
<a name="1276370"></a>

<a name="1276375"></a>

<a name="1276376"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> Omg, sorry about that!<br><br>Try changing line 218 to <br><b>config.nPreset = 9000</b> or <b> = 10000</b><br>and all should be good! <br><br></td></tr></table><br>
<a name="1276474"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> From my tests it looks ok now!<br><br>Now to threadding mp3 chunks... *rides into the dawn* <br><br></td></tr></table><br>
<a name="1276477"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >*</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> Looking good :D <br><br></td></tr></table><br>
<a name="1276486"></a>

<a name="1276487"></a>

<a name="1276488"></a>

<a name="1276508"></a>

<a name="1276510"></a>

<a name="1276511"></a>

<a name="1276521"></a>

<a name="1276523"></a>

<a name="1276524"></a>

<a name="1276575"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> oh ok theeeennn :D<br><br>Encoding of mp3 is now done in a different thread. The 'Encode now' button toggles between 'Encode now and 'Cancel encoding' depending on if its encoding or not. Hmm... maybe threaded Ogg later too?<br><br>Remember to build the axe.oggsaver module in threaded mode too otherwise you'll get errors during compilation.<br><br>It seems ok for a little example application :^)<br><br>EDIT:- It turns out that the app would crash when threaded during encoding in release build. It happens that upon closer inspection of the dll that the functions are being exported as standard c calling convention functions and not using the stdcall convention. This will cause the stack to be corrupted. Strange how this only showed up when threaded in release build. Oh well, fixed again :D<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' Fancy Example by Col &amp; Grisu :D

SuperStrict

Import MaxGui.Drivers
Import MaxGui.XpManifest
Import Axe.OggSaver

Type TThreadObject
	Field wavFilename:String
	Field compression:Int
	Field ProgressCallback(AmountDone:Float)
	Field semThreadStarted:TSemaphore
EndType


' config
Type BE_CONFIG_LAME
	Field dwConfig:Int
	
	Field dwStructVersion:Int
	Field dwStructSize:Int
	
	Field dwSampleRate:Int
	Field dwResampleRate:Int
	Field nMode:Int
	Field dwBitrate:Int
	Field dwMaxBitrate:Int
	Field nPreset:Int
	Field dwMpegVersion:Int
	Field dwEmpahasis:Int
	
	Field bPrivate:Int
	Field bCRC:Int
	Field bCopyright:Int
	Field bOriginal:Int
	
	Field bWriteVBRHeader:Int
	Field bEnableVBR:Int
	Field nVBRQuality:Int
	Field dwVBRAbr_bps:Int
	Field nVbrMethod:Int
	Field bNoRes:Int
	
	Field bStrictIso:Int
	Field nQuality:Int
	
	Field btReservered0:Long,btReservered1:Long,btReservered2:Long,btReservered3:Long
	Field btReservered4:Long,btReservered5:Long,btReservered6:Long,btReservered7:Long
	Field btReservered8:Long,btReservered9:Long,btReservered10:Long,btReservered11:Long
	Field btReservered12:Long,btReservered13:Long,btReservered14:Long,btReservered15:Long
	Field btReservered16:Long,btReservered17:Long,btReservered18:Long,btReservered19:Long
	Field btReservered20:Long,btReservered21:Long,btReservered22:Long,btReservered23:Long
	Field btReservered24:Long,btReservered25:Long,btReservered26:Long,btReservered27:Long
	Field btReservered28:Long,btReservered29:Short,btReserved30:Byte
EndType

' compressions
Global Mp3_Compressions:Int[] = [64, 80, 96, 112, 128, 160, 192, 224, 256, 320]
Global Ogg_Compressions:Float[] = [0.005, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]

' main application
Global winMain:TGadget = CreateWindow("Basic Audio Encoder",0,0,600,200,Null,WINDOW_DEFAULT|WINDOW_CENTER ~ WINDOW_MENU)
Global Encoder_Qualitybox:TGadget=CreateComboBox(150,50,70,25,winMain)
SetGadgetLayout Encoder_Qualitybox, Null, Null, EDGE_ALIGNED, Null

For Local i:Int = 0 Until 10
	Local bitrate:String = RSet(String(Mp3_Compressions[i])+" kb",7)
	AddGadgetItem Encoder_Qualitybox,bitrate, GADGETITEM_NORMAL
Next

' dlls
Global hLameEncDll:Int'
Global Enc_used:Int=0 ' 1 = Blade, 2 = Lame

If FileType("BladeMP3Enc.dll")=1 Then 
	hLameEncDll:Int = loadlibrarya("BladeMP3Enc.dll") 
    Enc_used=1
    SetStatusText ( WinMain, "Mp3-Encoding via BladeMP3Enc.dll." )
Else 
    If FileType("lame_enc.dll")=1 Then 
      hLameEncDll:Int = loadlibrarya("lame_enc.dll")
      Enc_used=2
      SetStatusText ( WinMain, "Mp3-Encoding via Lame_enc.dll." )
    EndIf
EndIf 

Global beInitStream:Int(pbeConfig:Byte Ptr,pdwSamples: Int Ptr,pdwBufferSize:Int Ptr,phbeStream:Int Ptr) = GetProcAddress(hLameEncDll,"beInitStream")
Global beEncodeChunk:Int(hbeSream:Int,nSamples:Int,pSamples:Short Ptr,pOutput:Byte Ptr,pdwOutput:Int Ptr) = GetProcAddress(hLameEncDll,"beEncodeChunk")
Global beDeInitStream:Int(hbeStream:Int,pOutput:Byte Ptr,pdwOutput:Int Ptr) = GetProcAddress(hLameEncDll,"beDeinitStream")
Global beCloseStream:Int(hbeStream:Int) = GetProcAddress(hLameEncDll,"beCloseStream")


' in file
Global butSelectInFile:TGadget = CreateButton("Select input file:",20,20,100,25,winMain)
Global butInFilename:TGadget = CreateTextArea(120,20,440,25,winMain,TEXTAREA_READONLY)
Global butEncode:TGadget = CreateButton("Encode now",460,50,100,25,winMain)

Global butOgg:TGadget = CreateButton("Ogg",20,50,50,25,winMain,BUTTON_RADIO)
Global butMp3:TGadget = CreateButton("Mp3",90,50,50,25,winMain,BUTTON_RADIO)
Global Enc_Progbar:TGadget = CreateProgBar(20,90,540,25,winMain)

Global mtxCancel:TMutex = CreateMutex()
Global bCancelPressed:Int = False

Global mtxEncoding:TMutex = CreateMutex()
Global bIsEncoding:Int = False

If Not hLameEncDll Then 
	SetButtonState(butOgg,True)
	DisableGadget butmp3
    SelectGadgetItem Encoder_Qualitybox, 4  

    SetStatusText ( WinMain, "Only Ogg-Encoding. Mp3 Library not found!" )

Else 

	SetButtonState(butmp3,True)
	SelectGadgetItem Encoder_Qualitybox, 4  

EndIf 

SetGadgetText(butInFilename,"&lt;Not selected&gt;")

' multithread guards
Function SetUserCancel(bState:Int)
	LockMutex(mtxCancel)
	bCancelPressed = bState
	UnlockMutex(mtxCancel)
EndFunction

Function GetUserCancelled:Int()
	LockMutex(mtxCancel)
	Local bCancelState:Int = bCancelPressed 
	UnlockMutex(mtxCancel)
	
	Return bCancelState
EndFunction

Function SetIsEncoding(bState:Int)
	LockMutex(mtxEncoding)
	bIsEncoding = bState
	UnlockMutex(mtxEncoding)
EndFunction

Function GetIsEncoding:Int()
	LockMutex(mtxEncoding)
	Local bIsEncodingState:Int = bIsEncoding
	UnlockMutex(mtxEncoding)
	
	Return bIsEncodingState
EndFunction

' mainloop
Repeat
	WaitEvent
	Local ev:TEvent = CurrentEvent
	
	Select ev.id
		Case EVENT_GADGETACTION
			Select ev.source
				Case butSelectInFile
					Local file$ = RequestFile("Select WAV file","WAV files:wav")
					If file &lt;&gt; ""
						SetGadgetText(butInFilename,file)
   						SetStatusText ( WinMain, "Loaded &amp; Ready for some action! :o)" )
					EndIf
					
				Case butEncode
					If GetIsEncoding() = False
						OnEncodePressed()
					Else
						OnCancelEncodingPressed()
					EndIf

			EndSelect
			
		Case EVENT_WINDOWCLOSE
			CloseMutex(mtxEncoding)
			CloseMutex(mtxCancel)
			End

	EndSelect
Forever

Function OnEncodePressed()
	If ButtonState(butMp3) And Trim(GadgetText(butInFilename)) &lt;&gt; "&lt;Not selected&gt;" Then 

		Local compression:Int = Mp3_Compressions[SelectedGadgetItem (Encoder_Qualitybox)]

		SetStatusText ( WinMain, "MP3-Encoding @ "+compression+" kb/s... Please wait!" )
		SetGadgetText ( butEncode, "Cancel encoding")
		
		SetUserCancel(False)
		Local Data:TThreadObject = New TThreadObject
		Data.wavFilename = GadgetText(butInFilename)
		Data.Compression = Compression
		Data.ProgressCallback = Enc_ProgressUpdate
		Data.semThreadStarted = CreateSemaphore(0)
		
	    DetachThread(CreateThread (Encode_Mp3,Data) )
		WaitSemaphore(Data.semThreadStarted)
		CloseSemaphore(Data.semThreadStarted)
		SetIsEncoding(True)

   ElseIf ButtonState(butOgg) And Trim(GadgetText(butInFilename)) &lt;&gt; "&lt;Not selected&gt;" Then
		SetUserCancel(False)
		SetIsEncoding(True)
		
		Local selected:Int = SelectedGadgetItem (Encoder_Qualitybox)
		Local compression:Float =  Ogg_Compressions[selected]
		
		' show correct kbps text - using mp3 kbps values
   		SetStatusText ( WinMain, "Ogg-Encoding @ "+ String(Mp3_compressions[selected]) + " kb/s... Please wait!" )
		SetGadgetText ( butEncode, "Please wait")
		
		Encode_Ogg(GadgetText(butInFilename),Compression,Enc_ProgressUpdate)
		
		SetIsEncoding(False)
		SetGadgetText( butEncode, "Encode now")
	EndIf 
EndFunction

Function OnCancelEncodingPressed()
	SetUserCancel(True)
EndFunction

' Encode to Ogg
Function Encode_Ogg:Object(enc_filename:String,compression:Float,ProgressCallback(AmountDone:Float))
	Local wavFile:TAudioSample = LoadAudioSample(StripExt(enc_filename)+".wav")
	If Not wavFile Return Null

	SaveOGG(wavFile, StripExt(enc_filename)+".ogg", compression, ProgressCallback) ' Do the magic!

	UpdateProgBar(enc_progbar,0)
    SetStatusText ( WinMain, "Encoding of "+StripExt(StripDir(enc_filename))+".ogg is finished!" )
End Function

' encode to mp3 thread
Function Encode_Mp3:Object(ThreadData:Object)
	Local Data:TThreadObject = TThreadObject(ThreadData)
	Local wavFilename:String = Data.wavFilename
	Local Compression:Int = Data.compression
	Local ProgressCallback(AmountDone:Float) = Data.ProgressCallback
	
	PostSemaphore(Data.semThreadStarted)

	Local dwSamples:Int = 0
	Local dwBufferSize:Int = 0
	Local hbeStream:Int = 0
	
	' open the input wav file and get some data from it
	Local wavFile:TStream = LittleEndianStream(OpenStream(wavFilename,True,False))
	If Not wavFile Then 
		Notify "Error: Cannot open file: "+String wavFilename
		ExitEncoding()
		Return Null
	EndIf 
	
	' load in the header - we dont want to encode the WAV header anyway - only the audio data itself
	Local RIFF:Int = ReadInt(wavFile)			' RIFF tag
	Local filelength:Int = ReadInt(wavFile)		' file length - 8
	Local WAVE:Int = ReadInt(wavFile)			' WAVE tag
	Local fmt_:Int = ReadInt(wavFile)			' fmt tag
	Local length:Int = ReadInt(wavFile) 		' variable length header
	Local pcm:Short = ReadShort(wavFile)		' should be 1 for PCM format
	Local channels:Short = ReadShort(wavFile)	' mono or stereo
	Local samplerate:Int = ReadInt(wavFile)		' sample rate
	Local bitrate:Int = ReadInt(wavFile)		' bitrate
	Local align:Short = ReadShort(wavFile)		' alignment
	Local bps:Short = ReadShort(wavFile)		' bits per sample
	
	' go to end of header
	SeekStream(wavFile,20+length)
	
	Local DATA_:Int = ReadInt(wavFile)			' data tag
	Local datasize:Int = ReadInt(wavFile)		' chunk size
		
	' make sure the WAV data is valid for the encoder
	If RIFF &lt;&gt; 1179011410 Or WAVE &lt;&gt; 1163280727 Or fmt_ &lt;&gt; 544501094 Or pcm &lt;&gt; 1 Or bps &lt;&gt; 16 Then 
		Notify "Error: Unsupported WAV file!"
		ExitEncoding()
		Return Null
    EndIf

	' configure a couple of settings for the encoder
	Local config:BE_CONFIG_LAME = New BE_CONFIG_LAME
	config.dwConfig = 256
	config.dwStructVersion = 1
	config.dwStructSize = SizeOf(BE_CONFIG_LAME)
	config.dwSampleRate = samplerate
	config.dwBitrate = compression
	config.dwMaxBitrate = compression
	config.nPreset = 9000
	config.dwMpegVersion = 1
	config.bWriteVBRHeader = True
	config.bNoRes = True

  	' create an instance of the lame encoder via the blade dll
	If beInitStream(config,Varptr dwSamples,Varptr dwBufferSize,Varptr hbeStream) &lt;&gt; 0 Then
    	Notify "Error: Setting config!"
		ExitEncoding()
	   	Return Null
	End If 
	
	' make sure the instance is valid
	If Not hbestream Then 
		Notify "Error: Handle is invalid!"
   		ExitEncoding()
	   	Return Null
	EndIf

	' create a new mp3 file to save into
	Local mp3$ = StripExt(String wavFilename) + ".mp3"
	Local mp3File:TStream = OpenStream(mp3,False,True)
	
	' create some counters
	Local wavSamplesLeft:Int =  datasize / 2	' the divide 2 is for reading 16bit shorts
	Local wavBufferSize:Int = dwSamples			' given from initialising the encoder
	Local wavChunksize:Int = wavBufferSize		' current number of samples to send to the encoder
	Local iBytesEncoded:Int						' no of bytes of mp3 data returned from the encoder
	
	' create a buffer for the wav and mp3 data
	Local pWAVBuffer:Short[wavBufferSize]
	Local pMp3Buffer:Byte[dwBufferSize]			' dwBufferSize was given from the encoder
	
	' loop by loading in the wav data, encoding it to mp3 and saving out the mp3 data
	While wavSamplesLeft &gt; 0
		' did user press cancel?
		If GetUserCancelled() = True Exit
		
		' less than wavBufferSize to load in?
		If wavSamplesLeft &lt; wavChunkSize wavChunkSize = wavSamplesLeft
		
		' load data into the wav buffer
		For Local i:Int = 0 Until wavChunkSize
			pWAVBuffer[i] = ReadShort(wavFile)
		Next
		
		' encode the wav data to mp3 data
		Local enc:Int = beEncodeChunk(hbeStream,wavChunkSize,pWAVBuffer,pMp3Buffer,Varptr iBytesEncoded)
		If enc &lt;&gt; 0 Then 
			Notify "Error: Encoding chunk failed!"
			End
		EndIf
		
		' save out the mp3 data
		For Local i:Int = 0 Until iBytesEncoded
			WriteByte(mp3File,pMp3Buffer[i])
		Next

		' simple callback for user feedback
		ProgressCallback(1.0 - (Float(wavSamplesLeft) / Float(datasize/2) ))		
	
		' reduce how much encoding is left to do
		wavSamplesLeft :- wavChunkSize
	Wend

	' squeeze out any last drops of data from the encoder
	beDeInitStream(hbeStream,pMp3Buffer,Varptr iBytesEncoded)
	For Local i:Int = 0 Until iBytesEncoded
		WriteByte(mp3File,pMp3Buffer[i])
	Next

	ProgressCallback(1.0)

	' clean up a little
	beCloseStream(hbeStream)
	CloseStream(wavFile)
	CloseStream(mp3File)

	wavFile=Null
	Mp3File=Null

	If GetUserCancelled()
		SetStatusText ( WinMain, "Encoding of "+ StripExt(StripDir(wavFilename)) + ".mp3 was cancelled!" )
		DeleteFile(StripExt(wavFilename)+".mp3")
	Else
	    SetStatusText ( WinMain, "Encoding of "+ StripExt(StripDir(wavFilename)) + ".mp3 is finished!" )
	EndIf
	
	ExitEncoding()
	Return Null
End Function

Function ExitEncoding()
	Enc_ProgressUpdate(0)
	
	' reset the Encode gadget text
	SetGadgetText(butEncode,"Encode now")

	SetUserCancel(False)
	SetIsEncoding(False)
EndFunction

Function Enc_ProgressUpdate(Enc_AmountDone:Float)
	UpdateProgBar(enc_progbar,Enc_AmountDone)
EndFunction
</textarea> <br><br></td></tr></table><br>
<a name="1276574"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> I can't compile the code in threaded or unthreaded mode: "Identifier ProgressCallback not found" or "TSemaphore not found"? <br><br>I did rebuild all modules in threaded mode beforehand. <br><br></td></tr></table><br>
<a name="1276576"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey,<br><br>Try again with the same code as I've just made a change. I can copy/paste the code into the standard editor, switch on threaded build, gui build, with or without debug and it runs ok.<br><br>TSemaphore... that's strange as it's a BMax multithread Type that's recognised when threaded build is switched on - it's a part of the standard Max installation. <br><br></td></tr></table><br>
<a name="1276652"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> Compiles now. <br><br>Can I put the ogg encoding into the same thread construct as well or is it not thread-safe?<br><br>Will need to find some time over the weekend to implement and test it. <br><br></td></tr></table><br>
<a name="1276743"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey Grisu,<br><br>I was a little bored last night so I had a play with this little app and finished it off this morning.<br><br>Keeping in mind that you mentioned FLAC encoding in a previous post above I changed the complete structure so that now, with correct planning, any future encoders can extend from a base encoder and the app can use it without too much fuss - its just doing things a little more towards the OO way. The base encoder is still heavily tied to this application but its just a start in the OO direction.<br><br>There's another little tweak required to the axe.oggsaver module to allow cancelling in the middle of encoding. The tweak should still be 100% compatible with existing sources etc.<br><br>The app will require your robust testing ;-)<br>Have Fun!!<br><br><b>Application.bmx</b><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' Fancy Example by Col &amp; Grisu :D

SuperStrict

Import MaxGui.Drivers
Import MaxGui.XpManifest
Import Axe.OggSaver

Type TThreadObject
	Field objEncoder:Object
	Field sWavFilename:String
	Field iCompression:Int, fCompression:Float
	Field fnProgressCallback:Int(AmountDone:Float,Encoder:Object)
	Field semThreadStarted:TSemaphore
EndType

Type TEncoder
' public

' Abstract methods to be implemented by each derived encoder
	Method Init:Int() Abstract
	Method EncodingBegin(WavFilename:String,EncoderQuality:Int) Abstract
	Method EncodingComplete(Filename:String) Abstract
	Method EncodingCancelled(Filename:String) Abstract
	Method ToString:String() Abstract
	
' Common methods
	Method EncodingEnd()
		EnableGadget(butMp3)
		EnableGadget(butOgg)
		EnableGadget(Encoder_Qualitybox)
		EnableGadget(butSelectWavFile)		
		SetGadgetText(butEncode,"Encode now")

		SetIsEncoding(False)
		SetCancel(False)
	EndMethod

	Method SetCancel(bCancel:Int)
		LockMutex(_mtxCancel)
		_bCancelPressed = bCancel
		UnlockMutex(_mtxCancel)
	EndMethod
	
	Method GetCancel:Int()
		LockMutex(_mtxCancel)
		Local bCancel:Int = _bCancelPressed
		UnlockMutex(_mtxCancel)
		Return bCancel
	EndMethod
	
' private
	Function ProgressCallback:Int(AmountDone:Float,EncoderObj:Object)
		UpdateProgBar(enc_progbar,AmountDone)
		Local Encoder:TEncoder = TEncoder(EncoderObj)
		Return Encoder.GetCancel()
	EndFunction

	Field _mtxCancel:TMutex = CreateMutex()
	Field _bCancelPressed:Int = False
EndType

Type TOggEncoder Extends TEncoder
	Method Init:Int()
		SetStatusText(WinMain,"Ogg Vorbis codec selected")
		Return True
	EndMethod
	
	Method EncodingBegin(WavFilename:String,EncodingQuality:Int)
		Local EncodingBitrate:Float = OggRates[EncodingQuality]	
		Local Data:TThreadObject = New TThreadObject
		Data.objEncoder = Self
		Data.sWavFilename = WavFilename
		Data.fCompression = EncodingBitrate
		Data.fnProgressCallback = ProgressCallback
		Data.semThreadStarted = CreateSemaphore(0)

		DetachThread(CreateThread(Self.EncodeThread,Data))
		WaitSemaphore(Data.semThreadStarted)
		CloseSemaphore(Data.semThreadStarted)
		SetIsEncoding(True)
	EndMethod
	
	Method EncodingComplete(Filename:String)
		UpdateProgBar(enc_progbar,0)
	    SetStatusText ( WinMain, "Encoding of "+StripExt(StripDir(Filename))+".ogg is finished!" )
	EndMethod
	
	Method EncodingCancelled(Filename:String)
		UpdateProgBar(enc_progbar,0)
		SetStatusText ( WinMain, "Encoding of "+ StripExt(StripDir(Filename)) + ".ogg was cancelled!" )
		DeleteFile(StripExt(Filename)+".ogg")
	EndMethod
	
	Method ToString:String()
		Return "Ogg Vorbis"
	EndMethod
	
'private
	Function EncodeThread:Object(ThreadData:Object)
		Local Data:TThreadObject = TThreadObject(ThreadData)
		Local WavFilename:String = Data.sWavFilename
		Local Compression:Float = Data.fCompression
		Local ProgressCallback(AmountDone:Float,EncoderObj:Object) = Data.fnProgressCallback
		Local Encoder:TOggEncoder = TOggEncoder(Data.objEncoder)

		PostSemaphore(Data.semThreadStarted)

		Local WavSample:TAudioSample = LoadAudioSample(WavFilename)
		If Not FileType(WavFilename) = 1 Then 
			Notify "Error: Cannot open file: "+String wavFilename
			Return Null
		EndIf 

		Local UserCancelled:Int = SaveOGG(WavSample, StripExt(WavFilename)+".ogg", Compression, ProgressCallback,Encoder)
		If UserCancelled
			Encoder.EncodingCancelled(WavFilename)
		Else
			Encoder.EncodingComplete(WavFilename)
		EndIf
		Encoder.EncodingEnd()

		Return Null
	EndFunction
	
	Field OggRates:Float[] = [0.005, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]
EndType


Type TMp3Encoder Extends TEncoder
' public
	Method New()
		If FileType("BladeMP3Enc.dll")=1 Then 
			hLameEncDll:Int = loadlibrarya("BladeMP3Enc.dll")
			sUsingDll = "Mp3-Encoding via BladeMP3Enc.dll."
		ElseIf FileType("lame_enc.dll")=1 Then 
      		hLameEncDll:Int = loadlibrarya("lame_enc.dll")
      		sUsingDll = "Mp3-Encoding via Lame_enc.dll."
		EndIf
		
		If Not hLameEncDll Return

		beInitStream = GetProcAddress(hLameEncDll,"beInitStream")
		beEncodeChunk = GetProcAddress(hLameEncDll,"beEncodeChunk")
		beDeInitStream = GetProcAddress(hLameEncDll,"beDeinitStream")
		beCloseStream = GetProcAddress(hLameEncDll,"beCloseStream")
	EndMethod
	
	Method Init:Int()
		If Not hLameEncDll Return False

		SetStatusText(WinMain,sUsingDll)
		Return True
	EndMethod
	
	Method EncodingBegin:Int(WavFilename:String,EncoderQuality:Int)
		If Not hLameEncDll Return 0
		
		Local EncodingBitrate:Int = Mp3Rates[EncoderQuality]	
		Local Data:TThreadObject = New TThreadObject
		Data.objEncoder = Self
		Data.sWavFilename = WavFilename
		Data.iCompression = EncodingBitrate
		Data.fnProgressCallback = ProgressCallback
		Data.semThreadStarted = CreateSemaphore(0)
		
		DetachThread(CreateThread(Self.EncodeThread,Data))
		WaitSemaphore(Data.semThreadStarted)
		CloseSemaphore(Data.semThreadStarted)
		SetIsEncoding(True)
	EndMethod
	
	Method EncodingComplete(Filename:String)
		UpdateProgBar(enc_progbar,0)
		SetStatusText ( WinMain, "Encoding of "+ StripExt(StripDir(Filename)) + ".mp3 complete!" )
	EndMethod
	
	Method EncodingCancelled(Filename:String)
		UpdateProgBar(enc_progbar,0)
		SetStatusText ( WinMain, "Encoding of "+ StripExt(StripDir(Filename)) + ".mp3 was cancelled!" )
		DeleteFile(StripExt(Filename)+".mp3")
	EndMethod
	
	Method ToString:String()
		Return "Mp3-Lame_Enc"
	EndMethod
	
' private
	Function EncodeThread:Object(ThreadData:Object)
		Local Data:TThreadObject = TThreadObject(ThreadData)
		Local WavFilename:String = Data.sWavFilename
		Local Compression:Int = Data.iCompression
		Local ProgressCallback(AmountDone:Float,EncoderObj:Object) = Data.fnProgressCallback
		Local Encoder:TMp3Encoder = TMp3Encoder(Data.objEncoder)

		PostSemaphore(Data.semThreadStarted)

		Local dwSamples:Int = 0
		Local dwBufferSize:Int = 0
		Local hbeStream:Int = 0
		
		' open the input wav file and get some data from it
		Local wavFile:TStream = LittleEndianStream(OpenStream(wavFilename,True,False))
		If Not wavFile Then 
			Notify "Error: Cannot open file: "+String wavFilename
			Return Null
		EndIf 
	
		' load in the header - we dont want to encode the WAV header anyway - only the audio data itself
		Local RIFF:Int = ReadInt(wavFile)			' RIFF tag
		Local filelength:Int = ReadInt(wavFile)		' file length - 8
		Local WAVE:Int = ReadInt(wavFile)			' WAVE tag
		Local fmt_:Int = ReadInt(wavFile)			' fmt tag
		Local length:Int = ReadInt(wavFile) 		' variable length header
		Local pcm:Short = ReadShort(wavFile)		' should be 1 for PCM format
		Local channels:Short = ReadShort(wavFile)	' mono or stereo
		Local samplerate:Int = ReadInt(wavFile)		' sample rate
		Local bitrate:Int = ReadInt(wavFile)		' bitrate
		Local align:Short = ReadShort(wavFile)		' alignment
		Local bps:Short = ReadShort(wavFile)		' bits per sample
		
		' go to end of header
		SeekStream(wavFile,20+length)
		
		Local DATA_:Int = ReadInt(wavFile)			' data tag
		Local datasize:Int = ReadInt(wavFile)		' chunk size
			
		' make sure the WAV data is valid for the encoder
		If RIFF &lt;&gt; 1179011410 Or WAVE &lt;&gt; 1163280727 Or fmt_ &lt;&gt; 544501094 Or pcm &lt;&gt; 1 Or bps &lt;&gt; 16 Then 
			Notify "Error: Unsupported WAV file!"
			Return Null
	    EndIf
	
		' configure a couple of settings for the encoder
		Local config:BE_CONFIG_LAME = New BE_CONFIG_LAME
		config.dwConfig = 256
		config.dwStructVersion = 1
		config.dwStructSize = SizeOf(BE_CONFIG_LAME)
		config.dwSampleRate = samplerate
		config.dwBitrate = compression
		config.dwMaxBitrate = compression
		config.nPreset = 9000
		config.dwMpegVersion = 1
		config.bWriteVBRHeader = True
		config.bNoRes = True

	  	' create an instance of the lame encoder via the blade dll
		If Encoder.beInitStream(config,Varptr dwSamples,Varptr dwBufferSize,Varptr hbeStream) &lt;&gt; 0 Then
	    	Notify "Error: Setting config!"
		   	Return Null
		End If 
		
		' make sure the instance is valid
		If Not hbestream Then 
			Notify "Error: Handle is invalid!"
		   	Return Null
		EndIf
	
		' create a new mp3 file to save into
		Local mp3$ = StripExt(String wavFilename) + ".mp3"
		Local mp3File:TStream = OpenStream(mp3,False,True)
		If Not mp3FIle
			Notify "Error: Cannot create mp3 file!"
			Return Null
		EndIf
		
		' create some counters
		Local wavSamplesLeft:Int =  datasize / 2	' the divide 2 is for reading 16bit shorts
		Local wavBufferSize:Int = dwSamples			' given from initialising the encoder
		Local wavChunksize:Int = wavBufferSize		' current number of samples to send to the encoder
		Local iBytesEncoded:Int						' no of bytes of mp3 data returned from the encoder
		
		' create a buffer for the wav and mp3 data
		Local pWAVBuffer:Short[wavBufferSize]
		Local pMp3Buffer:Byte[dwBufferSize]			' dwBufferSize was given from the encoder
		Local bUserCancelled:Int = False			' did the user press cancel?
		
		' loop by loading in the wav data, encoding it to mp3 and saving out the mp3 data
		While wavSamplesLeft &gt; 0
			' less than wavBufferSize to load in?
			If wavSamplesLeft &lt; wavChunkSize wavChunkSize = wavSamplesLeft
			
			' load data into the wav buffer
			For Local i:Int = 0 Until wavChunkSize
				pWAVBuffer[i] = ReadShort(wavFile)
			Next
			
			' encode the wav data to mp3 data
			Local enc:Int = Encoder.beEncodeChunk(hbeStream,wavChunkSize,pWAVBuffer,pMp3Buffer,Varptr iBytesEncoded)
			If enc &lt;&gt; 0 Then 
				Notify "Error: Encoding chunk failed!"
				Exit
			EndIf
		
			' save out the mp3 data
			For Local i:Int = 0 Until iBytesEncoded
				WriteByte(mp3File,pMp3Buffer[i])
			Next

			' during the callback check if the user cancelled - returns true to cancel
			bUserCancelled = ProgressCallback(1.0 - (Float(wavSamplesLeft) / Float(datasize/2) ),Encoder)
			If bUserCancelled
				Exit
			EndIf
		
			' reduce how much encoding is left to do
			wavSamplesLeft :- wavChunkSize
		Wend
	
		' squeeze out any last drops of data from the encoder
		Encoder.beDeInitStream(hbeStream,pMp3Buffer,Varptr iBytesEncoded)
		For Local i:Int = 0 Until iBytesEncoded
			WriteByte(mp3File,pMp3Buffer[i])
		Next

		' clean up a little
		Encoder.beCloseStream(hbeStream)
		CloseStream(wavFile)
		CloseStream(mp3File)
	
		wavFile=Null
		Mp3File=Null
	
		If bUserCancelled
			Encoder.EncodingCancelled(WavFilename)
		Else
			Encoder.EncodingComplete(WavFIlename)
		EndIf
		Encoder.EncodingEnd()
		
		Return Null
	End Function

	Field sUsingDll:String
	Field hLameEncDll:Int
	
	Field beInitStream:Int(pbeConfig:Byte Ptr,pdwSamples: Int Ptr,pdwBufferSize:Int Ptr,phbeStream:Int Ptr) 
	Field beEncodeChunk:Int(hbeSream:Int,nSamples:Int,pSamples:Short Ptr,pOutput:Byte Ptr,pdwOutput:Int Ptr)
	Field beDeInitStream:Int(hbeStream:Int,pOutput:Byte Ptr,pdwOutput:Int Ptr)
	Field beCloseStream:Int(hbeStream:Int)

	Field Mp3Rates:Int[] = [64, 80, 96, 112, 128, 160, 192, 224, 256, 320]
EndType

' mp3 config
Type BE_CONFIG_LAME
	Field dwConfig:Int
	
	Field dwStructVersion:Int
	Field dwStructSize:Int
	
	Field dwSampleRate:Int
	Field dwResampleRate:Int
	Field nMode:Int
	Field dwBitrate:Int
	Field dwMaxBitrate:Int
	Field nPreset:Int
	Field dwMpegVersion:Int
	Field dwEmpahasis:Int
	
	Field bPrivate:Int
	Field bCRC:Int
	Field bCopyright:Int
	Field bOriginal:Int
	
	Field bWriteVBRHeader:Int
	Field bEnableVBR:Int
	Field nVBRQuality:Int
	Field dwVBRAbr_bps:Int
	Field nVbrMethod:Int
	Field bNoRes:Int
	
	Field bStrictIso:Int
	Field nQuality:Int
	
	Field btReservered0:Long,btReservered1:Long,btReservered2:Long,btReservered3:Long
	Field btReservered4:Long,btReservered5:Long,btReservered6:Long,btReservered7:Long
	Field btReservered8:Long,btReservered9:Long,btReservered10:Long,btReservered11:Long
	Field btReservered12:Long,btReservered13:Long,btReservered14:Long,btReservered15:Long
	Field btReservered16:Long,btReservered17:Long,btReservered18:Long,btReservered19:Long
	Field btReservered20:Long,btReservered21:Long,btReservered22:Long,btReservered23:Long
	Field btReservered24:Long,btReservered25:Long,btReservered26:Long,btReservered27:Long
	Field btReservered28:Long,btReservered29:Short,btReserved30:Byte
EndType






' main application
AppTitle = "Wav to Mp3 - Ogg Audio Encoder"
Global CompressionBitrates:Int[] = [64, 80, 96, 112, 128, 160, 192, 224, 256, 320]
Global winMain:TGadget = CreateWindow(AppTitle,0,0,600,200,Null,WINDOW_DEFAULT|WINDOW_CENTER ~ WINDOW_MENU)
Global Encoder_Qualitybox:TGadget=CreateComboBox(150,50,70,25,winMain)
SetGadgetLayout Encoder_Qualitybox, Null, Null, EDGE_ALIGNED, Null

For Local i:Int = 0 Until 10
	Local bitrate:String = RSet(String(CompressionBitrates[i])+" kb",7)
	AddGadgetItem Encoder_Qualitybox,bitrate, GADGETITEM_NORMAL
Next

' in wav file
Global butSelectWavFile:TGadget = CreateButton("Select input file:",20,20,100,25,winMain)
Global butWavFilename:TGadget = CreateTextArea(120,20,440,25,winMain,TEXTAREA_READONLY)
Global butEncode:TGadget = CreateButton("Encode now",460,50,100,25,winMain)

' encoders
Global butOgg:TGadget = CreateButton("Ogg",20,50,50,25,winMain,BUTTON_RADIO)
Global butMp3:TGadget = CreateButton("Mp3",90,50,50,25,winMain,BUTTON_RADIO)

' user feedback that something is happening
Global Enc_Progbar:TGadget = CreateProgBar(20,90,540,25,winMain)

' choice of encoders
Global Mp3Encoder:TMp3Encoder = New TMp3Encoder
Global OggEncoder:TOggEncoder = New TOggEncoder

' default to Mp3
SetButtonState(butMp3,True)
If Not Mp3Encoder.Init()
	DisableGadget butmp3
	
	SetButtonState(butOgg,True)
	SetStatusText ( WinMain, "Only Ogg-Encoding. Mp3 Library not found!" )
EndIf

' default to 128kbs
SelectGadgetItem Encoder_Qualitybox, 4

' no initial wav file
SetGadgetText(butWavFilename,"&lt;Not selected&gt;")

' mainloop
Global bIsEncoding:Int = False
Global mtxIsEncoding:TMutex = CreateMutex()

Repeat
	WaitEvent
	Local ev:TEvent = CurrentEvent
	
	Select ev.id
		Case EVENT_GADGETACTION
			Select ev.source
				Case butSelectWavFile
					Local file$ = RequestFile("Select WAV file","WAV files:wav")
					If file &lt;&gt; ""
						SetGadgetText(butWavFilename,file)
   						SetStatusText ( WinMain, "Loaded &amp; Ready for some action! :o)" )
					EndIf
				
				Case butMp3
					OnMp3Pressed()
					
				Case butOgg
					OnOggPressed()
					
				Case butEncode
					If Not GetIsEncoding()
						OnEncodePressed()
					Else
						OnCancelEncodingPressed()
					EndIf

			EndSelect
			
		Case EVENT_WINDOWCLOSE
			'Mp3Encoder.Close()
			'OggEncoder.Close()
			End

	EndSelect
Forever

Function OnMp3Pressed()
	' The mp3 button shouln't be active If the dll failed To Load - so To get here would be errornous If Mp3Encoder.Init() fails
	If Not Mp3Encoder.Init() SetStatusText(WinMain,"Error: loading mp3 lame codec dll")
EndFunction

Function OnOggPressed()
	OggEncoder.Init()
EndFunction

Function OnEncodePressed()
	Local Encoder:TEncoder
	Local BitrateIndex:Int = SelectedGadgetItem(Encoder_Qualitybox)
	
	If Trim(GadgetText(butWavFilename)) = "&lt;Not selected&gt;"
		Notify "Select a valid wav file!" 
		Return
	EndIf

	If ButtonState(butMp3) Then
		Encoder = Mp3Encoder
	
	Else If ButtonState(butOgg) Then
		Encoder = OggEncoder
	
	EndIf
	
 	SetStatusText ( WinMain, "Encoding using " + Encoder.ToString() + " @ "+ CompressionBitrates[BitrateIndex] +" kb/s... Please wait!" )
	SetGadgetText ( butEncode, "Cancel encoding")
	DisableGadget(butSelectWavFile)
	DisableGadget(butMp3)
	DisableGadget(butOgg)
	DisableGadget(Encoder_Qualitybox)

	Encoder.EncodingBegin(GadgetText(butWavFilename),BitrateIndex)
EndFunction

Function OnCancelEncodingPressed()
	Local Encoder:TEncoder
	
	If ButtonState(butMp3) Then
		Encoder = Mp3Encoder
	ElseIf ButtonState(butOgg) Then
		Encoder = OggEncoder
	EndIf

	Encoder.SetCancel(True)
EndFunction

Function SetIsEncoding(IsEncoding:Int)
	LockMutex(mtxIsEncoding)
	bIsEncoding = IsEncoding
	UnlockMutex(mtxIsEncoding)
EndFunction

Function GetIsEncoding:Int()
	LockMutex(mtxIsEncoding)
	Local IsEncoding:Int = bIsEncoding
	UnlockMutex(mtxIsEncoding)
	Return IsEncoding
EndFunction
</textarea><br><br><b>oggsaver.bmx [axe.mod/oggsaver.mod/oggsaver.bmx]</b><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Strict

Rem
bbdoc: OGG saver
about:
The axe.oggsaver module provides the ability to save OGG format #brl.audiosample.AudioSamples.
End Rem
Module axe.oggsaver

ModuleInfo "Version: 1.01"
ModuleInfo "Author: Simon Armstrong"
ModuleInfo "License: Public Domain"
ModuleInfo "Copyright: Blitz Research Ltd"
ModuleInfo "Modserver: BRL"

ModuleInfo "History: 1.01 Release"
ModuleInfo "History: axe.saveogg module created due to growth restrictions on brl.oggloader"

Import Pub.OggVorbis
Import BRL.AudioSample

Import "../../pub.mod/oggvorbis.mod/libogg-1.1.3/include/*.h"
Import "../../pub.mod/oggvorbis.mod/libvorbis-1.1.2/include/*.h"
Import "../../pub.mod/oggvorbis.mod/libvorbis-1.1.2/lib/*.h"
Import "../../pub.mod/oggvorbis.mod/libvorbis-1.1.2/lib/vorbisenc.c"

Import "oggencoder.c"

Extern
Function Encode_Ogg(outputstream:Object,callback:Byte Ptr,freq,channels,samples:Float Ptr,length,compression:Float,progresscallback:Byte Ptr,obj:Object)
End Extern

Private

Function writefunc(bytes:Byte Ptr,count,stream:TStream) NODEBUG
	stream.WriteBytes bytes,count
End Function	

Public

Rem
bbdoc: Save an Audio Sample in OGG format
about:
#SaveOGG saves @sample to @url in OGG format. If successful, #SaveOGG returns
True, otherwise False.&lt;br&gt;
&lt;br&gt;
The optional @compression parameter should be in the range -0.1 to 1.0,
where -0.1 indicates maximum compression and 1.0 indicates best quality.
End Rem
Function SaveOGG(sample:TAudioSample,URL:Object,compression#=0.1,funcprogress:Int(done:Float,obj:Object)=Null,obj:Object = Null)
	Local output:TStream
	Local samples:Float[],channels,rate,count,i,res,w
	Select sample.format
		Case SF_MONO8
			channels=1
		Case SF_MONO16LE
			channels=1			
		Case SF_MONO16BE
			channels=1
		Case SF_STEREO8
			channels=2
		Case SF_STEREO16LE
			channels=2
		Case SF_STEREO16BE
			channels=2
	End Select
	rate=sample.hertz
	count=channels*sample.length
	samples=New Float[count]
	Local s:Byte Ptr=sample.samples
	Select sample.format
		Case SF_MONO8,SF_STEREO8
			For i=0 Until count
				samples[i]=(s[i]-127.5)/127.5
			Next
		Case SF_MONO16LE,SF_STEREO16LE
			For i=0 Until count
				w=(s[1] Shl 8)|(s[0])
				If (w&amp;$8000) w=w|$ffff0000	'sign extend
				samples[i]=w/32768.0				
				s=s+2
			Next	
		Case SF_MONO16BE,SF_STEREO16BE
			For i=0 Until count
				w=(s[0] Shl 8)|(s[1])
				If (w&amp;$8000) w=w|$ffff0000	'sign extend
				samples[i]=w/32768.0				
				s=s+2
			Next	
	End Select		
	output=WriteStream(url)
	If Not output Return -1
	
	If funcprogress
		res=Encode_Ogg(output,writefunc,rate,channels,samples,sample.length,compression,funcprogress,obj)
	Else
		res=Encode_Ogg(output,writefunc,rate,channels,samples,sample.length,compression,Null,Null)
	EndIf
	
	CloseStream(output)
	Return res
End Function



Rem
bbdoc: Save an Audio Sample in WAV format
about:
#SaveWAV saves @sample to @url in WAV format. If successful, #SaveWAV returns
True, otherwise False.&lt;br&gt;
End Rem
Function SaveWAV(sample:TAudioSample,URL:Object)
	Local output:TStream
	Local channels
	
	Select sample.format
		Case SF_MONO8
			channels=1
		Case SF_MONO16LE
			channels=1			
		Case SF_MONO16BE
			channels=1
		Case SF_STEREO8
			channels=2
		Case SF_STEREO16LE
			channels=2
		Case SF_STEREO16BE
			channels=2
	End Select

	Local bitrate=8
	
	Local block = channels * bitrate / 8

	Local count=block*sample.length


	output=WriteStream(url)
	If Not output Return -1
	
	'write wav header info
	output.WriteString("RIFF")						'"RIFF" file description header (4 bytes)
	output.WriteInt(count + 40)						'file size - 8 (4 bytes)
	output.WriteString("WAVE")						'"WAVE" description header (4 bytes)
	output.WriteString("fmt ")						'"fmt " description header (4 bytes)
	output.WriteInt(16)								'size of WAVE section chunk (4 bytes)
	output.WriteShort(1)							'WAVE type format (2 bytes)
	output.WriteShort(channels)						'mono/stereo (2 bytes)
	output.WriteInt(sample.hertz)					'sample rate (4 bytes)
	output.WriteInt(sample.hertz * block)			'avg bytes/sec (4 bytes)
	output.WriteShort(block)						'Block alignment (2 bytes)
	output.WriteShort(bitrate)						'Bits/sample (2 bytes)
	output.WriteString("data")						'"data" description header (4 bytes)
	output.WriteInt(count)							'size of data chunk (4 bytes)
	
	For Local i=0 Until count
		output.WriteByte sample.samples[i]
	Next

	CloseStream(output)
	
	Return True

End Function
</textarea><br><br><b>oggencoder.c [axe.mod/oggsaver.mod/oggencoder.c]</b><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
//oggencoder.c

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

#include &lt;time.h&gt;
#include &lt;math.h&gt;

#include &lt;vorbis/vorbisenc.h&gt;
//#include &lt;vorbisenc.h&gt;

#define READ 1024

typedef struct oggwriter oggwriter;

struct oggwriter{
	ogg_stream_state os; //take physical pages, weld into a logical stream of packets 
	ogg_page         og; //one Ogg bitstream page.  Vorbis packets are inside 
	ogg_packet       op; //one raw packet of data for decode 
	
	vorbis_info      vi; //struct that stores all the static vorbis bitstream settings 
	vorbis_comment   vc; //struct that stores all the user comments 
	
	vorbis_dsp_state vd; //central working state for the packet-&gt;PCM decoder 
	vorbis_block     vb; //local working space for packet-&gt;PCM decode 
};

int Encode_Ogg(void *stream,void(*writefunc)(void *bytes,int count,void *stream),int freq,int channels,float *samples,int length,float compression,int(*progressfunc)(float,void *object),void *object){
	oggwriter *ogg;	
	int eos;
	int result;

	ogg=(oggwriter*)malloc(sizeof(oggwriter));

	vorbis_info_init(&amp;ogg-&gt;vi);
	
	result=vorbis_encode_init_vbr(&amp;ogg-&gt;vi,channels,freq,compression);	

	if(result) return -1;	//error format not supported...

// add a comment 

	vorbis_comment_init(&amp;ogg-&gt;vc);
	//vorbis_comment_add_tag(&amp;ogg-&gt;vc,"ENCODER","encoder_example.c");
	
// set up the analysis state and auxiliary encoding storage 

	vorbis_analysis_init(&amp;ogg-&gt;vd,&amp;ogg-&gt;vi);

	vorbis_block_init(&amp;ogg-&gt;vd,&amp;ogg-&gt;vb);
	
	srand(time(NULL));
	ogg_stream_init(&amp;ogg-&gt;os,rand());
		
	ogg_packet header;
	ogg_packet header_comm;
	ogg_packet header_code;
	
	vorbis_analysis_headerout(&amp;ogg-&gt;vd,&amp;ogg-&gt;vc,&amp;header,&amp;header_comm,&amp;header_code);
	ogg_stream_packetin(&amp;ogg-&gt;os,&amp;header); //automatically placed in its own page 
	ogg_stream_packetin(&amp;ogg-&gt;os,&amp;header_comm);
	ogg_stream_packetin(&amp;ogg-&gt;os,&amp;header_code);

//This ensures the actual audio data will start on a new page, as per spec
	while(1){
		result=ogg_stream_flush(&amp;ogg-&gt;os,&amp;ogg-&gt;og);
		if(result==0)break;
		writefunc(ogg-&gt;og.header,ogg-&gt;og.header_len,stream);
		writefunc(ogg-&gt;og.body,ogg-&gt;og.body_len,stream);
	}

	int i,c,n,totallength = length, usercancelled = 0;
	eos=0;
	
	while(!eos){
		if (length&gt;0){
			float **buffer=vorbis_analysis_buffer(&amp;ogg-&gt;vd,READ);
			n=length;if (n&gt;READ) n=READ;			
//uninterleave samples
			for (i=0;i&lt;n;i++){
				for (c=0;c&lt;channels;c++){
					buffer[c][i]=*samples++;
				}
			}	
			length=length-n;
//tell the library how much we actually submitted
			vorbis_analysis_wrote(&amp;ogg-&gt;vd,i);
		}else{
			vorbis_analysis_wrote(&amp;ogg-&gt;vd,0);
		}
		
// progress update
		if(progressfunc){
			usercancelled = progressfunc(1.0f - (float)length / (float)totallength,object);
			if(usercancelled) break;
		}

		while(vorbis_analysis_blockout(&amp;ogg-&gt;vd,&amp;ogg-&gt;vb)==1){
//analysis, assume we want to use bitrate management
			vorbis_analysis(&amp;ogg-&gt;vb,NULL);
			vorbis_bitrate_addblock(&amp;ogg-&gt;vb);		
			while(vorbis_bitrate_flushpacket(&amp;ogg-&gt;vd,&amp;ogg-&gt;op)){
//weld the packet into the bitstream
				ogg_stream_packetin(&amp;ogg-&gt;os,&amp;ogg-&gt;op);
//write out pages (if any)
				while(!eos){
					result=ogg_stream_pageout(&amp;ogg-&gt;os,&amp;ogg-&gt;og);
					if(result==0)break;
					writefunc(ogg-&gt;og.header,ogg-&gt;og.header_len,stream);
					writefunc(ogg-&gt;og.body,ogg-&gt;og.body_len,stream);
					if (ogg_page_eos(&amp;ogg-&gt;og)) eos=1;
				}
			}
		}
	}		
//clean up and exit.  vorbis_info_clear() must be called last 
	ogg_stream_clear(&amp;ogg-&gt;os);
	vorbis_block_clear(&amp;ogg-&gt;vb);
	vorbis_dsp_clear(&amp;ogg-&gt;vd);
	vorbis_comment_clear(&amp;ogg-&gt;vc);
	vorbis_info_clear(&amp;ogg-&gt;vi);
	
	free(ogg);

	return usercancelled;	
}
</textarea> <br><br></td></tr></table><br>
<a name="1276782"></a>

<a name="1276785"></a>

<a name="1276789"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> Will do my best. :o) Though I caught a cold and don't feel well.<br><br>Anyway, when I try to encode ogg with your latest stuff, the app crashes right at the start after I pressed encode. <br><br>Debug says MAV:<br><pre class=code>
	Function ProgressCallback:Int(AmountDone:Float,EncoderObj:Object)
		UpdateProgBar(enc_progbar,AmountDone)
		Local Encoder:TEncoder = TEncoder(EncoderObj) &lt;- MAV here!!!!
		Return Encoder.GetCancel()
	EndFunction
</pre><br><br>[Edit] Might have to do with my module. Seems to work now again. Testing goes on. The evening is still young. :)<br><br>[Edit2] More fun, the oo-structure completely truns my code upside down. This is Sparta! <br><br></td></tr></table><br>
<a name="1276788"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> The evening is still young. :) <br></div><br>Indeed :-)<br><br>Just to plant a seed of thought ;-) .... have you thought about encoding the live stream directly instead of saving to .wav first? <br><br></td></tr></table><br>
<a name="1276803"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's easy to answer:<br>- When I started my little app it was never intended to record streams.<br>- Recording is done internally via FModEx.<br>- Recording is done over the sound card, so it's compatible over all platforms.<br>- Wav-Recoding has a lesser CPU-footprint.<br>- Avoiding license issues.<br>- And I don't know how. :)<br><br>Sooo... after 2 hours I converted the code over and got rid of lots of bloated stuff.<br><br>The basic RAM usage went up from ~10 MB to ~20 MB due to threadded compiling which is dislike.<br><br>But more importantly the ogg (and mp3 saver?) have  memory leaks. The RAM usage goes up to 1 GB and isn't cleared after encoding. I also fear that big wav-files may crash my app due to that. <br><br></td></tr></table><br>
<a name="1276805"></a>

<a name="1276806"></a>

<a name="1276810"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> I like the fact that your player is very small and lightweight. Its really cool.<br>I'm not sure why the ram usage would double under threaded mode just yet.<br><br>And yes, I just monitored the memory foot print during encoding too ( 150Mb wav file  )....<br><br>The mp3 encoder doesn't appear to leak here, the memory usage went up about 1 mb during encoding, stayed rock solid while encoding and actually dropped ( using 3Mb less than it was using before it started ) when it was done. I encoded the same file 5 times during that test. The mp3 encoder is already set up for streaming, also encoding while streaming doesn't load up the cpu any where near as much either.<br><br>The Ogg encoder however is a different story and it is indeed leaking like a sieve under a waterfall. I'd think that the contribution to the high memory usage during encoding is because of loading the wav file completely into memory ( as a TAudioSample ) instead of streaming it in. But that doesn't explain why the memory isn't being freed after encoding. Streaming into the ogg encoder in the same way as the mp3 encoder is doing will resolve the memory leak and the high memory usage, I'm sure.<br><br>*rolls sleeves up*<br><br><div class="quote">  the oo-structure completely truns my code upside down <br></div><br><div class="quote"> Sooo... after 2 hours I converted the code over and got rid of lots of bloated stuff <br></div><br>any changes to this little app... shall I leave it oo ? or change it back to procedural? make it a module ? or are you going to drop the idea of the encoding?<br><br>Hold on... Doesn't FModEx already do encoding while streaming? <br><br></td></tr></table><br>
<a name="1276823"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Hold on... Doesn't FModEx already do encoding while streaming? <br></div><br><br>Not writing as MP3. The lib offers some Windows Media format, WIIU and XBox360 as output. Not sure what these formats do or look like.<br><br>I just rechecked your first module changes above. They aready have the memory leak for ogg.<br><br>Hard call. With 16 GB Ram I don't care much about that 10 MB extra. But we need to fix this leak first. <br><br></td></tr></table><br>
<a name="1276841"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#40">[#40]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ahh ok, we won't worry about using FModEx then :p<br><br>I'll write a new ogg module using ogg 1.3.2 and vorbis 1.3.5 to allow us to encode in the same way as we're encoding to mp3. <br><br></td></tr></table><br>
<a name="1276864"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#41">[#41]</a></td></tr></table></td></tr><tr ><td class="posttext"> The newer version works 1.3.x works fine for me.<br><br>But I find strange is that the loading of the WAV-file doesn't increase the memory usage for mp3-encoding during my tests. These files get large quite easily. <br><br></td></tr></table><br>
<a name="1276867"></a>

<a name="1276870"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#42">[#42]</a></td></tr></table></td></tr><tr ><td class="posttext"> Good isn't it :)<br>That's because its streaming the file into a small buffer ( uncompressed data ), encoding that small buffer into another smaller buffer ( mp3 data ) then writing to disk. At one any one time there's only a small amount of uncompressed wav data and a small amount of mp3 data in memory. As opposed to the oggsaver requiring the whole uncompressed data to be in memory before encoding ( as a TAudioSample ). To be fair the axe.oggsaver isn't designed to be used for the purpose we're currently using it, it's designed for smaller audio samples that fit comfortably in memory. No worries though as there's a streaming ogg saver on its way that will use very little memory too ;-). A thumbs up I'm sure :) <br><br></td></tr></table><br>
<a name="1276871"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#43">[#43]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sounds all too easy. ;)<br><br>I was thinking of ways to reduce the memory usage. So vars should only be added until the user presses "encode". So I can keep memory usage low until really needed. <br><br></td></tr></table><br>
<a name="1277320"></a>

<a name="1277326"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#44">[#44]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just a little update to let you know that I'll probably be able to get back to this over the weekend. I've not touched it all week, so I'm eager to get it done asap :-) <br><br></td></tr></table><br>
<a name="1277348"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#45">[#45]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks again for your assistance and feedback Dave.<br><br>Would be great to push out a new release over the weekend (aka sunday eve). :) <br><br></td></tr></table><br>
<a name="1277518"></a>

<a name="1277519"></a>

<a name="1277520"></a>

<a name="1277707"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#46">[#46]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hiya,<br><br>I managed to find a couple of hours this evening...<br><br>After your comment about the OO style I changed the code back to the original procedural style. I hope I haven't goofed up your code base again - you did make a backup of the original yes?  ;-)<br><br>There's a little issue in that I've put the extracted <a href="http://downloads.xiph.org/releases/ogg/libogg-1.3.2.zip" target="_blank"><b>1.3.2 ogg</b></a> and the <a href="http://downloads.xiph.org/releases/vorbis/libvorbis-1.3.5.zip" target="_blank"><b>1.3.5 vorbis</b></a> in the new module folder, instead of putting them in the pub.mod folder which would otherwise have the risk of being overwritten during official updates. However this then creates a clash of vorbis* functions which then means importing the module manually while not importing the pub.mod version of the ogg decoder. I'm not sure on the best way to resolve this at the moment - any thoughts? I noticed that you use the Framework command so maybe it's not a problem for you?<br><br>To get this little app to compile the module file structure should look like this:<br>/mod/srs.mod/oggencoder.mod/libogg-1.3.2/*all ogg files*<br>/mod/srs.mod/oggencoder.mod/libvorbis-1.3.5/*all vorbis files*<br>/mod/srs.mod/oggencoder.mod/oggencoder.bmx<br>/mod/srs.mod/oggencoder.mod/oggencoder.c<br><br><br><b>Application</b><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

' Fancy Example by Col &amp; Grisu :D

SuperStrict

Framework Brl.System

Import Brl.Threads
Import Brl.Retro
Import Brl.EventQueue

Import MaxGui.Drivers
Import MaxGui.XpManifest
Import Srs.OggEncoder

Const UseCodec_Mp3:Int = 1
Const UseCodec_Ogg:Int = 2

Type TThreadObject
	Field wavFilename:String
	Field compression:Float
	Field Codec:Int
	Field ProgressCallback(AmountDone:Float)
	Field semThreadStarted:TSemaphore
EndType


' config
Type BE_CONFIG_LAME
	Field dwConfig:Int
	
	Field dwStructVersion:Int
	Field dwStructSize:Int
	
	Field dwSampleRate:Int
	Field dwResampleRate:Int
	Field nMode:Int
	Field dwBitrate:Int
	Field dwMaxBitrate:Int
	Field nPreset:Int
	Field dwMpegVersion:Int
	Field dwEmpahasis:Int
	
	Field bPrivate:Int
	Field bCRC:Int
	Field bCopyright:Int
	Field bOriginal:Int
	
	Field bWriteVBRHeader:Int
	Field bEnableVBR:Int
	Field nVBRQuality:Int
	Field dwVBRAbr_bps:Int
	Field nVbrMethod:Int
	Field bNoRes:Int
	
	Field bStrictIso:Int
	Field nQuality:Int
	
	Field btReservered0:Long,btReservered1:Long,btReservered2:Long,btReservered3:Long
	Field btReservered4:Long,btReservered5:Long,btReservered6:Long,btReservered7:Long
	Field btReservered8:Long,btReservered9:Long,btReservered10:Long,btReservered11:Long
	Field btReservered12:Long,btReservered13:Long,btReservered14:Long,btReservered15:Long
	Field btReservered16:Long,btReservered17:Long,btReservered18:Long,btReservered19:Long
	Field btReservered20:Long,btReservered21:Long,btReservered22:Long,btReservered23:Long
	Field btReservered24:Long,btReservered25:Long,btReservered26:Long,btReservered27:Long
	Field btReservered28:Long,btReservered29:Short,btReserved30:Byte
EndType

' compressions
Global Mp3_Compressions:Int[] = [64, 80, 96, 112, 128, 160, 192, 224, 256, 320]
Global Ogg_Compressions:Float[] = [0.005, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]

' main application
Global winMain:TGadget = CreateWindow("Basic Audio Encoder",0,0,600,200,Null,WINDOW_DEFAULT|WINDOW_CENTER ~ WINDOW_MENU)
Global Encoder_Qualitybox:TGadget=CreateComboBox(150,50,70,25,winMain)
SetGadgetLayout Encoder_Qualitybox, Null, Null, EDGE_ALIGNED, Null

For Local i:Int = 0 Until 10
	Local bitrate:String = RSet(String(Mp3_Compressions[i])+" kb",7)
	AddGadgetItem Encoder_Qualitybox,bitrate, GADGETITEM_NORMAL
Next

' dlls
Global hLameEncDll:Int'
Global Enc_used:Int=0 ' 1 = Blade, 2 = Lame

If FileType("BladeMP3Enc.dll")=1 Then 
	hLameEncDll:Int = loadlibrarya("BladeMP3Enc.dll") 
    Enc_used=1
    SetStatusText ( WinMain, "Mp3-Encoding via BladeMP3Enc.dll." )
Else 
    If FileType("lame_enc.dll")=1 Then 
      hLameEncDll:Int = loadlibrarya("lame_enc.dll")
      Enc_used=2
      SetStatusText ( WinMain, "Mp3-Encoding via Lame_enc.dll." )
    EndIf
EndIf 

Global beInitStream:Int(pbeConfig:Byte Ptr,pdwSamples: Int Ptr,pdwBufferSize:Int Ptr,phbeStream:Byte Ptr) = GetProcAddress(hLameEncDll,"beInitStream")
Global beEncodeChunk:Int(hbeSream:Byte Ptr,nSamples:Int,pSamples:Short Ptr,pOutput:Byte Ptr,pdwOutput:Int Ptr) = GetProcAddress(hLameEncDll,"beEncodeChunk")
Global beDeInitStream:Int(hbeStream:Byte Ptr,pOutput:Byte Ptr,pdwOutput:Int Ptr) = GetProcAddress(hLameEncDll,"beDeinitStream")
Global beCloseStream:Int(hbeStream:Byte Ptr) = GetProcAddress(hLameEncDll,"beCloseStream")


' in file
Global butSelectInFile:TGadget = CreateButton("Select input file:",20,20,100,25,winMain)
Global butInFilename:TGadget = CreateTextArea(120,20,440,25,winMain,TEXTAREA_READONLY)
Global butEncode:TGadget = CreateButton("Encode now",460,50,100,25,winMain)

Global butOgg:TGadget = CreateButton("Ogg",20,50,50,25,winMain,BUTTON_RADIO)
Global butMp3:TGadget = CreateButton("Mp3",90,50,50,25,winMain,BUTTON_RADIO)
Global Enc_Progbar:TGadget = CreateProgBar(20,90,540,25,winMain)

Global mtxCancel:TMutex = CreateMutex()
Global bCancelPressed:Int = False

Global mtxEncoding:TMutex = CreateMutex()
Global bIsEncoding:Int = False

If Not hLameEncDll Then 
	SetButtonState(butOgg,True)
	DisableGadget butmp3
    SelectGadgetItem Encoder_Qualitybox, 4  

    SetStatusText ( WinMain, "Only Ogg-Encoding. Mp3 Library not found!" )

Else 

	SetButtonState(butmp3,True)
	SelectGadgetItem Encoder_Qualitybox, 4  

EndIf 

SetGadgetText(butInFilename,"&lt;Not selected&gt;")

' multithread guards
Function SetUserCancel(bState:Int)
	LockMutex(mtxCancel)
	bCancelPressed = bState
	UnlockMutex(mtxCancel)
EndFunction

Function GetUserCancelled:Int()
	LockMutex(mtxCancel)
	Local bCancelState:Int = bCancelPressed 
	UnlockMutex(mtxCancel)
	
	Return bCancelState
EndFunction

Function SetIsEncoding(bState:Int)
	LockMutex(mtxEncoding)
	bIsEncoding = bState
	UnlockMutex(mtxEncoding)
EndFunction

Function GetIsEncoding:Int()
	LockMutex(mtxEncoding)
	Local bIsEncodingState:Int = bIsEncoding
	UnlockMutex(mtxEncoding)
	
	Return bIsEncodingState
EndFunction

' mainloop
Repeat
	WaitEvent
	Local ev:TEvent = CurrentEvent
	
	Select ev.id
		Case EVENT_GADGETACTION
			Select ev.source
				Case butSelectInFile
					Local file$ = RequestFile("Select WAV file","WAV files:wav")
					If file &lt;&gt; ""
						SetGadgetText(butInFilename,file)
   						SetStatusText ( WinMain, "Loaded &amp; Ready for some action! :o)" )
					EndIf
					
				Case butEncode
					If GetIsEncoding() = False
						OnStartEncodingPressed()
					Else
						OnCancelEncodingPressed()
					EndIf

			EndSelect
			
		Case EVENT_WINDOWCLOSE
			CloseMutex(mtxEncoding)
			CloseMutex(mtxCancel)
			End

	EndSelect
Forever

Function OnStartEncodingPressed()
	If Trim(GadgetText(butInFilename)) = "&lt;Not selected&gt;"
		Notify "You must select a file to encode first!"
		Return
	EndIf
	
	Local Data:TThreadObject = New TThreadObject
	Data.wavFilename = GadgetText(butInFilename)
	Data.ProgressCallback = Enc_ProgressUpdate
	Data.semThreadStarted = CreateSemaphore(0)
	
	Local kbps:Int = Mp3_Compressions[SelectedGadgetItem (Encoder_Qualitybox)]

	If ButtonState(butMp3)
		Data.Codec = UseCodec_Mp3
		Data.Compression = kbps
		SetStatusText ( WinMain, "MP3-Encoding @ " + kbps + " kb/s... Please wait!" )

	ElseIf ButtonState(butOgg)
		Data.Codec = UseCodec_Ogg
		Data.Compression = Ogg_Compressions[SelectedGadgetItem (Encoder_Qualitybox)]
   		SetStatusText ( WinMain, "Ogg-Encoding @ " + kbps + " kb/s... Please wait!" )		
	EndIf 

	SetGadgetText ( butEncode, "Cancel encoding")
	
	DetachThread(CreateThread (EncodeFile,Data) )
	WaitSemaphore(Data.semThreadStarted)
	CloseSemaphore(Data.semThreadStarted)
	
	DisableGadget(butOgg)
	DisableGadget(butMp3)
	DisableGadget(Encoder_Qualitybox)
	DisableGadget(butInFilename)
	DisableGadget(butSelectInFile)
	
	SetUserCancel(False)
	SetIsEncoding(True)
EndFunction

Function OnCancelEncodingPressed()
	SetUserCancel(True)
EndFunction

' encoding thread
Function EncodeFile:Object(ThreadData:Object)
	Local Data:TThreadObject = TThreadObject(ThreadData)
	Local wavFilename:String = Data.wavFilename
	Local Compression:Float = Data.compression
	Local ProgressCallback(AmountDone:Float) = Data.ProgressCallback
	Local Codec:Int = Data.Codec
	PostSemaphore(Data.semThreadStarted)

	' open the input wav file and get some data from it
	Local wavStream:TStream = LittleEndianStream(OpenStream(wavFilename,True,False))
	If Not wavStream Then 
		Notify "Error: Cannot open file: "+String wavFilename
		ExitEncoding()
		Return Null
	EndIf 
	
	' load in the header - we dont want to encode the WAV header anyway - only the audio data itself
	Local RIFF:Int = ReadInt(wavStream)			' RIFF tag
	Local filelength:Int = ReadInt(wavStream)	' file length - 8
	Local WAVE:Int = ReadInt(wavStream)			' WAVE tag
	Local fmt_:Int = ReadInt(wavStream)			' fmt tag
	Local length:Int = ReadInt(wavStream) 		' variable length header
	Local pcm:Short = ReadShort(wavStream)		' should be 1 for PCM format
	Local channels:Short = ReadShort(wavStream)	' mono or stereo
	Local samplerate:Int = ReadInt(wavStream)	' sample rate
	Local bitrate:Int = ReadInt(wavStream)		' bitrate
	Local align:Short = ReadShort(wavStream)	' alignment
	Local bps:Short = ReadShort(wavStream)		' bits per sample
	
	' go to end of header
	SeekStream(wavStream,20+length)
	
	Local DATA_:Int = ReadInt(wavStream)		' data tag
	Local datasize:Int = ReadInt(wavStream)		' chunk size
		
	' make sure the WAV data is valid for the encoder
	If RIFF &lt;&gt; 1179011410 Or WAVE &lt;&gt; 1163280727 Or fmt_ &lt;&gt; 544501094 Or pcm &lt;&gt; 1 Or bps &lt;&gt; 16 Then 
		Notify "Error: Unsupported WAV file!"
		ExitEncoding()
		Return Null
    EndIf

	' the output stream
	Local OutputFilename$
	Local encStream:TStream

	' some working variables	
	Local wavChunksize:Int
	Local wavBuffersize:Int
	Local encBuffersize:Int
	Local encInstance:Byte Ptr
	Local iBytesEncoded:Int
	Local wavSamplesLeft:Int =  datasize / 2
	Local pWAVBuffer:Short[]
	Local pEncBuffer:Byte[]
	Local Progress:Float
	Local PrevProgress:Float

	If Codec = UseCodec_Mp3
		' configure a couple of settings for the encoder
		Local config:BE_CONFIG_LAME = New BE_CONFIG_LAME
		config.dwConfig = 256
		config.dwStructVersion = 1
		config.dwStructSize = SizeOf(BE_CONFIG_LAME)
		config.dwSampleRate = samplerate
		config.dwBitrate = compression
		config.dwMaxBitrate = compression
		config.nPreset = 9000
		config.dwMpegVersion = 1
		config.bWriteVBRHeader = True
		config.bNoRes = True
	
	  	' create an instance of the lame encoder via the blade dll
		If beInitStream(config,Varptr wavBufferSize,Varptr encBufferSize,Varptr encInstance) &lt;&gt; 0 Then
	    	Notify "Error: Setting config!"
			ExitEncoding()
		   	Return Null
		End If 
	
		' make sure the instance is valid
		If Not encInstance Then 
			Notify "Error: Handle is invalid!"
	   		ExitEncoding()
		   	Return Null
		EndIf

		wavChunksize = wavBufferSize		' current number of samples to send to the encoder
		
		pWavBuffer = New Short[wavBuffersize]
		pEncBuffer = New Byte[encBufferSize]
		
		' open the output stream
		OutputFilename = StripExt(wavFilename) + ".mp3"
		encStream = OpenStream(OutputFilename,False,True)

	ElseIf Codec = UseCodec_Ogg
		wavChunksize = 2048					' use 2Kb chunks
		wavBuffersize = wavChunkSize
		encBuffersize = 8096				' 8kb output buffer - usually uses around 4kb, we have some room for movement
		
		pWavBuffer = New Short[wavBuffersize]
		pEncBuffer = New Byte[encBuffersize]
		
		' open the output stream
		OutputFilename = StripExt(wavFilename) + ".ogg"
		encStream = OpenStream(OutputFilename,False,True)
		
		If oggInitStream(channels,samplerate,Compression, Varptr encInstance,pEncBuffer,Varptr iBytesEncoded) &lt;&gt; 0
			Notify "Error - invalid ogg handle"
			Return Null
		EndIf
		
		' save the header information
		For Local i:Int = 0 Until iBytesEncoded
			WriteByte(encStream,pEncBuffer[i])
		Next
	EndIf
	
	' loop by loading in the wav data, encoding it to mp3 and saving out the mp3 data
	While wavSamplesLeft &gt; 0
		' did user press cancel?
		If GetUserCancelled() = True Exit
		
		' less than wavBufferSize to load in?
		If wavSamplesLeft &lt; wavChunkSize wavChunkSize = wavSamplesLeft
		
		' load data into the wav buffer
		For Local i:Int = 0 Until wavChunkSize
			pWAVBuffer[i] = ReadShort(wavStream)
		Next
		
		Local EncoderStatus:Int
		If Codec = UseCodec_Mp3
			' encode the wav data to mp3 data
			EncoderStatus = beEncodeChunk(encInstance,wavChunkSize,pWAVBuffer,pEncBuffer,Varptr iBytesEncoded)
		
		Else If Codec = UseCodec_Ogg
			' encode the wav data to ogg data
			EncoderStatus = oggEncodeChunk(encInstance,pWavBuffer,wavChunkSize/2,pEncBuffer,Varptr iBytesEncoded)
			
		EndIf
		
		If EncoderStatus &lt;&gt; 0 Then 
			Notify "Error: Encoding chunk failed!"
			End
		EndIf
		
		' save out the encoded data
		For Local i:Int = 0 Until iBytesEncoded
			WriteByte(encStream,pEncBuffer[i])
		Next

		' simple callback for user feedback - only if its needed - prevent flooding the OS message queue
		Progress = 1.0 - (Float(wavSamplesLeft) / Float(datasize/2))
		If Progress &lt;&gt; PrevProgress
			ProgressCallback(Progress)
			PrevProgress = Progress
		EndIf
	
		' reduce how much encoding is left to do
		wavSamplesLeft :- wavChunkSize
	Wend

	' squeeze out any last drops of data from the encoder
	If Codec = UseCodec_Mp3 beDeInitStream(encInstance,pEncBuffer,Varptr iBytesEncoded)
	If Codec = UseCodec_Ogg oggDeinitStream(encInstance,pEncBuffer,Varptr iBytesEncoded)
	
	For Local i:Int = 0 Until iBytesEncoded
		WriteByte(encStream,pEncBuffer[i])
	Next

	ProgressCallback(1.0)

	' clean up a little
	If Codec = UseCodec_Mp3 beCloseStream(encInstance)
	If Codec = UseCodec_Ogg oggCloseStream(encInstance)
	
	CloseStream(wavStream)
	CloseStream(encStream)

	wavStream=Null
	encStream=Null

	' user status update
	If GetUserCancelled()
		SetStatusText ( WinMain, "Encoding of "+ StripDir(OutputFilename) + " was cancelled!" )
		DeleteFile(OutputFilename)
	Else
	    SetStatusText ( WinMain, "Encoding of "+ StripDir(OutputFilename) + " is finished!" )
	EndIf
	
	ExitEncoding()
	Return Null
End Function

Function ExitEncoding()
	Enc_ProgressUpdate(0)
	
	' reset the Encode gadget text
	SetGadgetText(butEncode,"Encode now")

	' reenable ui
	EnableGadget(butOgg)
	EnableGadget(butMp3)
	EnableGadget(Encoder_Qualitybox)
	EnableGadget(butInFilename)
	EnableGadget(butSelectInFile)

	SetUserCancel(False)
	SetIsEncoding(False)
EndFunction

Function Enc_ProgressUpdate(Enc_AmountDone:Float)
	UpdateProgBar(enc_progbar,Enc_AmountDone)
EndFunction
</textarea><br><br><b>srs.oggencoder [/mod/srs.mod/oggencoder.mod/oggencoder.bmx]</b><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

Module srs.oggencoder

Import "libogg-1.3.2/include/*.h"
Import "libogg-1.3.2/src/bitwise.c"
Import "libogg-1.3.2/src/framing.c"

Import "libvorbis-1.3.5/include/vorbis/*.h"

Import "libvorbis-1.3.5/include/*.h"
Import "libvorbis-1.3.5/lib/*.h"
Import "libvorbis-1.3.5/lib/bitrate.c"
Import "libvorbis-1.3.5/lib/block.c"
Import "libvorbis-1.3.5/lib/codebook.c"
Import "libvorbis-1.3.5/lib/envelope.c"
Import "libvorbis-1.3.5/lib/floor0.c" 
Import "libvorbis-1.3.5/lib/floor1.c"
Import "libvorbis-1.3.5/lib/info.c"
Import "libvorbis-1.3.5/lib/lpc.c"
Import "libvorbis-1.3.5/lib/lsp.c"
Import "libvorbis-1.3.5/lib/mapping0.c"
Import "libvorbis-1.3.5/lib/mdct.c"
Import "libvorbis-1.3.5/lib/psy.c"
Import "libvorbis-1.3.5/lib/registry.c"
Import "libvorbis-1.3.5/lib/res0.c"
Import "libvorbis-1.3.5/lib/sharedbook.c"
Import "libvorbis-1.3.5/lib/smallft.c"
Import "libvorbis-1.3.5/lib/synthesis.c"
Import "libvorbis-1.3.5/lib/vorbisfile.c"
Import "libvorbis-1.3.5/lib/window.c"
Import "libvorbis-1.3.5/lib/analysis.c"
Import "libvorbis-1.3.5/lib/vorbisenc.c"

Import "oggencoder.c"

Extern
Function oggInitStream:Int(iChannels:Int, iBitrate:Int, fQuality:Float, pOggStream:Byte Ptr,pOggData:Byte Ptr,iOggHeaderLength:Int Ptr)
Function oggEncodeChunk:Int(pOggStream:Byte Ptr,pWavSamples:Short Ptr,iCount:Int,pOggData:Byte Ptr,iOggDataLength:Int Ptr)
Function oggDeinitStream:Int(pOggStream:Byte Ptr,pOggData:Byte Ptr,iOggDataLength:Int Ptr)
Function oggCloseStream:Int(pOggStream:Byte Ptr)
EndExtern
</textarea><br><br><b>oggencoder.c [/mod/srs.mod/oggencoder.mod/oggencoder.c</b><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

#include &lt;time.h&gt;
#include &lt;math.h&gt;


#include "libvorbis-1.3.5/include/vorbis/vorbisenc.h"

typedef struct vorbis_object{
	vorbis_info			info;
	vorbis_dsp_state	state;
	vorbis_block		block;
	vorbis_comment		comment;
	ogg_stream_state	stream;
	ogg_page			page;
	ogg_packet			packet;
} vorbis_object;

int oggInitStream(int iChannels, int iBitrate, float fQuality, vorbis_object** object,char* pOggData,int* piDataLength){
	vorbis_object* vobject = (vorbis_object*)malloc(sizeof(vorbis_object));
	
	vorbis_info_init(&amp;vobject-&gt;info);
	if(vorbis_encode_init_vbr(&amp;vobject-&gt;info,iChannels,iBitrate,fQuality) != 0){
		return -1;
	}

	vorbis_comment_init(&amp;vobject-&gt;comment);

	if(vorbis_analysis_init(&amp;vobject-&gt;state,&amp;vobject-&gt;info) != 0) return -1;
	if(vorbis_block_init(&amp;vobject-&gt;state,&amp;vobject-&gt;block) != 0)	return -1;
	
	srand(time(NULL));
	ogg_stream_init(&amp;vobject-&gt;stream,rand());
		
	ogg_packet header;
	ogg_packet header_comm;
	ogg_packet header_code;
	
	vorbis_analysis_headerout(&amp;vobject-&gt;state,&amp;vobject-&gt;comment,&amp;header,&amp;header_comm,&amp;header_code);
	ogg_stream_packetin(&amp;vobject-&gt;stream,&amp;header); //automatically placed in its own page 
	ogg_stream_packetin(&amp;vobject-&gt;stream,&amp;header_comm);
	ogg_stream_packetin(&amp;vobject-&gt;stream,&amp;header_code);

	int iOffset = 0;
	while(ogg_stream_flush(&amp;vobject-&gt;stream,&amp;vobject-&gt;page)){
		memcpy(pOggData+iOffset,vobject-&gt;page.header,vobject-&gt;page.header_len);
		iOffset += vobject-&gt;page.header_len;

		memcpy(pOggData+iOffset,vobject-&gt;page.body,vobject-&gt;page.body_len);
		iOffset += vobject-&gt;page.body_len;
	}

	*piDataLength = iOffset;
	*object = vobject;

	return 0;
}

int EncodeChunk(vorbis_object* object,char* pOggData){
	int iEncodedBytes = 0;
	while(vorbis_analysis_blockout(&amp;object-&gt;state,&amp;object-&gt;block)==1){

		vorbis_analysis(&amp;object-&gt;block,NULL);
		vorbis_bitrate_addblock(&amp;object-&gt;block);
			
		while(vorbis_bitrate_flushpacket(&amp;object-&gt;state,&amp;object-&gt;packet)){
			ogg_stream_packetin(&amp;object-&gt;stream,&amp;object-&gt;packet);
			
			if(!ogg_stream_pageout(&amp;object-&gt;stream,&amp;object-&gt;page)) break;
			
			memcpy(pOggData+iEncodedBytes,object-&gt;page.header,object-&gt;page.header_len);
			iEncodedBytes += object-&gt;page.header_len;
			
			memcpy(pOggData+iEncodedBytes,object-&gt;page.body,object-&gt;page.body_len);
			iEncodedBytes += object-&gt;page.body_len;
		}
	}
	return iEncodedBytes;
}

int oggEncodeChunk(vorbis_object* object,short* samples, int incount,char* pOggData,int* piOutCount){
	float **buffer=vorbis_analysis_buffer(&amp;object-&gt;state,incount);
	
	int i;
	for(i=0;i&lt;incount;i++){
		buffer[0][i] = *samples++ / 32768.f;
		buffer[1][i] = *samples++ / 32768.f;
	}
	vorbis_analysis_wrote(&amp;object-&gt;state,incount);

	int iOutCount = EncodeChunk(object,pOggData);
	*piOutCount = iOutCount;
	
	return 0;
}

int oggDeinitStream(vorbis_object* object,char* pOggData,int* piOutCount){
	vorbis_analysis_wrote(&amp;object-&gt;state,0);
	
	int iOutCount = 0;
	while(!ogg_page_eos(&amp;object-&gt;page)){
		iOutCount += EncodeChunk(object,pOggData);
	}
	*piOutCount = iOutCount;

	return 0;
}

int oggCloseStream(vorbis_object* object){
	ogg_stream_clear(&amp;object-&gt;stream);
	vorbis_comment_clear(&amp;object-&gt;comment);
	vorbis_dsp_clear(&amp;object-&gt;state);
	vorbis_block_clear(&amp;object-&gt;block);
	vorbis_info_clear(&amp;object-&gt;info);
	free(object);
}
</textarea> <br><br></td></tr></table><br>
<a name="1277687"></a>

<a name="1277700"></a>

<a name="1277701"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#47">[#47]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>I think it's not a bad idea to split the module from the original one. And adding a Framework should be normal for many users.<br><br>I managed to convert your latest code into my main branch. Testings so far went well. No memory issue at all. Even when Playing + Recording + Encoding different test stations at the same time, the app remained stable. Not sure how well it will run on lower end machines though. ;)<br><br>Thanks again for all your help!<br><br><b>[Edit]</b> New release with a fancy name is up. :o)<br><br><img src="http://i.imgur.com/eYi2MXh.png"><br><br>Stefan <br><br></td></tr></table><br>
<a name="1277828"></a>

<a name="1277829"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#48">[#48]</a></td></tr></table></td></tr><tr ><td class="posttext"> Excellent release :-)<br><br>Works faultlessly here too and on my works pc.<br>It's a good simple example and practical use of threading which would otherwise make the application laggy. <br><br></td></tr></table><br>
<a name="1278102"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#49">[#49]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for the feedback Dave! <br><br>It's just a small app, but I hope it displayed some efforts, progress and time put into it. - It also might be the last release as bmx is now Abandonware. <br><br></td></tr></table><br>
<a name="1278171"></a>

<a name="1278172"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#50">[#50]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> It also might be the last release as bmx is now Abandonware. <br></div><br><br>Surely not? 'C' hasn't been updated for a loooong time and there's still plenty of applications that are written using it, including complete OSs. There's nothing wrong with BlitzMax at all as it is, who cares that it's gone open source? Your version still works yes? :^) <br><br></td></tr></table><br>
<a name="1292830"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#51">[#51]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sorry to bring up this necro-thread. :(<br><br>The code above doesn't seem to work with WAV files larger than 2 GB. Doesn't matter, if I use ogg or mp3-encoding. I don't get an error message. It just runs through 100% (within a second) and the created file is broken.<br><br>Is there a way to fix that? <br><br></td></tr></table><br>
<a name="1292832"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TomToad</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#52">[#52]</a></td></tr></table></td></tr><tr ><td class="posttext"> 2 GB?  A full audio CD is only about 650 MB.  Maybe break down your file into individual "tracks", then encode. <br><br> I'd imagine the 2GB limit has to do with using an Int pointer somewhere in the .dll instead of Long.  That was the reason why FAT32 was limited to only 2GB files. <br><br></td></tr></table><br>
<a name="1292840"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#53">[#53]</a></td></tr></table></td></tr><tr ><td class="posttext"> My app writes a raw WAV file to the hard drive. Some of my users record longer sessions. You reach the 2 GB wall after around 3 hours or so. For breaking down the file into tracks I would have to analyse the data which is even more complicated. In addition most tracks are faded into each other so cutting them is nearly useless. <br><br></td></tr></table><br>
<a name="1292869"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#54">[#54]</a></td></tr></table></td></tr><tr ><td class="posttext"> 2 GB ...isn't this a 32bit thing?<br><br>So if integers are used, you run into a barrier then.<br><br>Maybe "the ones" with knowlegde are able to shed some light.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1292886"></a>

<a name="1292907"></a>

<a name="1292908"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#55">[#55]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey all!<br><br>I'll get a test installation up and running tomorrow to see about the large file size encoding.<br><br>I'd tend to agree with everyone else regarding the 32bit limit and I think it'll be just the signed 32int integer maximum value being reached. My *initial* thoughts are that changing some Int variables to Long will give you 4GB support and better file size handling  should allow up to I think 16TB. <br><br></td></tr></table><br>
<a name="1292984"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#56">[#56]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yep, its the 32bit signed integer limit thats the problem. Also a .wav file larger than 4gb has its header size parameter set to -1 (32bit).<br><br>What makes things even more interesting is that the brl filesystem module is 32bit only too :D I know Brucey has a filesystemex module that depends on his boost module which obviously depends on the boost library - maybe a bit heavy weight just to know the file size? <br><br></td></tr></table><br>
<a name="1292989"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TomToad</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#57">[#57]</a></td></tr></table></td></tr><tr ><td class="posttext"> instead of saving as .wav, try saving as raw PCM data.  Seems LAME-Enc will accept raw data.  Also could try compressing the data as it streams to the encoder, so no need for raw data to be saved in the first place. <br><br></td></tr></table><br>
<a name="1293013"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#58">[#58]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hiya TomToad,<br><br>.wav is a simple container for raw pcm already. The only difference being that the wav header describes the data, and a raw pcm file contains just the data only.<br><br><div class="quote"> Also could try compressing the data as it streams to the encoder <br></div><br>The encoder is the compressor :p<br><br>I think encoding on the fly is the way to go, and coupled with large file support you could store days of music in one file :-)<br>I did briefly mention it up at post #36. <br><br></td></tr></table><br>
<a name="1293024"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#59">[#59]</a></td></tr></table></td></tr><tr ><td class="posttext"> In my naive world I thought that the current code already reads out chunks of data. So I didn't think of bigger files being a problem. Until I got multiple user requests that wanted to use larger WAV files. <br><br>It would be elegant, if FMOD would write the streams directly as MP3 to disk. But such a feature doesn't exist. <br><br>I wouldn't mind, if the chunks encoded would be larger. Because tiny ones are slowing down the process. I already changed the code so that it only updates the progress bar in 1%-streps. <br><br></td></tr></table><br>
<a name="1293045"></a>

<a name="1293047"></a>

<a name="1293048"></a>

<a name="1293051"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#60">[#60]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> But such a feature doesn't exist.  <br></div><br>Not yet, but we can make it exist... in your app at least for the time being.<br><br>I'm been playing with fmod and I can get it to encode the live stream without the need of going to a .wav file first.<br><br>I assume you have some existing BlitzMax code to interface with the dll otherwise you wouldn't have it working already, I don't fancy writing the interface code if you already have it done ;-)<br><br>Are you using Bruceys module? <br><br></td></tr></table><br>
<a name="1293182"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#61">[#61]</a></td></tr></table></td></tr><tr ><td class="posttext"> I do. Using it for years now. Updated it to the latest Fmod 4 release that is. <br><br>Would it help, if I send you my apps source code? <br><br></td></tr></table><br>
<a name="1293194"></a>

<a name="1293195"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#62">[#62]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I know Brucey has a filesystemex module that depends on his boost module <br></div><br>NG has large file support as standard... :-)<br>(I've used TStream to process files in excess of 50GB)<br><br>But Grisu's code needs some work to become completely compatible - given the bad Windows API integration he is using (Ints &lt;&gt; pointers, etc). <br><br></td></tr></table><br>
<a name="1293242"></a>

<a name="1293244"></a>

<a name="1293245"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#63">[#63]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> NG has large file support as standard... :-) <br></div><br>Yeah I know ;-)<br><br><div class="quote"> Would it help, if I send you my apps source code? <br></div><br>Nah, It's ok, I tested with Bruceys Fmod4 module too.<br><br>I've reworked our little simple app above for the updates.<br><br>There are a couple of small tweaks needed in Bruceys module. The callback functions should be stdcall so Lines 2169, 2178 and 2187 of fmod.bmx from <a href="https://github.com/maxmods/bah.mod/tree/master/fmod.mod" target="_blank">https://github.com/maxmods/bah.mod/tree/master/fmod.mod</a> need the "Win32" declaration on the end of the parameters after the last parenthesis.<br><br>It was nasty to get this working with callbacks but don't we love a challenge eh.<br>There's an issue with the debug stack when running in debug mode when using FMOD callbacks. It shows the classic signs of the function calling convention being wrong somewhere. I *think* they are setup correctly now but it won't run in debug mode at all, so you have to run it in threaded release builds only. Maybe the fault will show up or it may just be because of the callback and the 'Max GC doesn't enjoy it in coming in from the 'backdoor' :D<br><br>I've hardcoded a net radio station ip so you'll need to be connected to 'net to try the app. I've had it encoding for 2 hours straight to ogg followed immediately by another 2 hours to mp3 and it's working lovely here - between 1.0 and 1.5% cpu usage while encoding live streams :-)<br><br>See how you get on with testing...<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

' Fancy Example by Col &amp; Grisu :D

Strict

Framework brl.system

Import brl.retro
Import brl.timer
Import brl.eventqueue
Import brl.threads

Import bah.fmod
Import srs.oggencoder
Import maxgui.drivers
Import maxgui.xpmanifest

' set up FMOD
Global NetRadio:TFMODController = New TFMODController.Create()
NetRadio.TuneTo("http://relay.181.fm:8030")

' UI
Global winMain:TGadget = CreateWindow("Basic Audio Encoder",0,0,600,200,Null,WINDOW_DEFAULT|WINDOW_CENTER ~ WINDOW_MENU)
Global EncoderQualitybox:TGadget=CreateComboBox(150,50,70,25,winMain)
SetGadgetLayout EncoderQualitybox, Null, Null, EDGE_ALIGNED, Null

' compressions
Global Mp3_Compressions:Int[] = [64, 80, 96, 112, 128, 160, 192, 224, 256, 320]
Global Ogg_Compressions:Float[] = [0.005, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]

For Local i:Int = 0 Until 10
	Local bitrate:String = RSet(String(Mp3_Compressions[i])+" kb",7)
	AddGadgetItem EncoderQualitybox,bitrate, GADGETITEM_NORMAL
Next



' which mp3 encoder?
Global hLameEncDll:Int
Global Enc_used:Int=0 ' 1 = Blade, 2 = Lame

If FileType("BladeMP3Enc.dll")=1 Then 
	hLameEncDll:Int = loadlibrarya("BladeMP3Enc.dll") 
    Enc_used=1
    SetStatusText ( WinMain, "Mp3-Encoding via BladeMP3Enc.dll." )
Else 
    If FileType("lame_enc.dll")=1 Then 
      hLameEncDll:Int = loadlibrarya("lame_enc.dll")
      Enc_used=2
      SetStatusText ( WinMain, "Mp3-Encoding via Lame_enc.dll." )
    EndIf
EndIf


' in file
Global butSelectOutfile:TGadget = CreateButton("Select output file:",20,20,100,25,winMain)
Global butOutFilename:TGadget = CreateTextArea(120,20,440,25,winMain,TEXTAREA_READONLY)
Global butEncode:TGadget = CreateButton("Start encoding",460,50,100,25,winMain)
DisableGadget(butEncode)

Global butOgg:TGadget = CreateButton("Ogg",20,50,50,25,winMain,BUTTON_RADIO)
Global butMp3:TGadget = CreateButton("Mp3",90,50,50,25,winMain,BUTTON_RADIO)
Global EncodingBar:TGadget = CreateProgBar(20,90,540,25,winMain)
Local style:Int = GetWindowLongW(TWindowsGadget(EncodingBar)._hwnd, GWL_STYLE)
SetWindowLongW(TWindowsGadget(EncodingBar)._hwnd , GWL_STYLE, style | PBS_MARQUEE | PBS_SMOOTH)
SendMessageW(TWindowsGadget(EncodingBar)._hwnd, PBM_SETMARQUEE, 0, 50)

Global Encoder:TEncoder = New TEncoder
Global IsEncoding:Int

' Default to OGG 192Kb
SetButtonState(butOgg,True)
SelectGadgetItem(EncoderQualitybox,6)

' main
CreateTimer(1)
Repeat
	WaitEvent
	
	Local ev:TEvent = CurrentEvent
	Select ev.id
	Case EVENT_GADGETACTION
		Select ev.source
		Case butSelectOutfile
			OnSelectOutfilePressed()
					
		Case butEncode
			OnEncodeButtonPressed()
			
		EndSelect
			
	Case EVENT_WINDOWCLOSE
		OnWindowClose()
		End

	EndSelect
	
	'NetRadio.SystemUpdate()
Forever



Function OnSelectOutfilePressed()
	Local Filter:String
	If ButtonState(butOGG) Filter = "ogg"
	If ButtonState(butMp3) Filter = "mp3"
	
	Local Outfilepath:String = RequestFile("Save As",Filter+":"+Filter,True,"")
	If Outfilepath &lt;&gt; ""
		SetGadgetText(butOutFilename,Outfilepath)
		EnableGadget(butEncode)
	EndIf
EndFunction

Function OnWindowClose()
	If IsEncoding Encoder.StopEncoding()
	NetRadio.Close()
EndFunction

Function OnEncodeButtonPressed()
	Local Encoding:Int = IsEncoding
	Encoding = 1 - Encoding
	
	If Encoding
		Local Samplerate:Int = NetRadio.CurrFrequency
		If ButtonState(butMp3)
			Local Bitrate:Int = Mp3_Compressions[SelectedGadgetItem(EncoderQualitybox)]
			If Not Encoder.Init(TEncoder.ENCODE_MP3,GadgetText(butOutFilename),Samplerate,Bitrate)
				Return
			EndIf
		EndIf
		
		If ButtonState(butOGG)
			Local Bitrate:Float = Ogg_Compressions[SelectedGadgetItem(EncoderQualitybox)]
			If Not Encoder.Init(TEncoder.ENCODE_OGG,GadgetText(butOutFilename),Samplerate,Bitrate)
				Return False
			EndIf
		EndIf
		SetGadgetText(butEncode,"Stop encoding")
	Else
		Encoder.StopEncoding()
		SetGadgetText(butEncode,"Start encoding")
		RedrawGadget EncodingBar ' hide the animation
	EndIf

	' We're definitely encoding now
	IsEncoding = Encoding
	SendMessageW(TWindowsGadget(EncodingBar)._hwnd,PBM_SETMARQUEE,IsEncoding,0)
	RedrawGadget(EncodingBar)
	
	If IsEncoding
		DisableGadget(butOgg)
		DisableGadget(butMp3)
		DisableGadget(butSelectOutfile)
		DisableGadget(butOutfilename)
		DisableGadget(EncoderQualitybox)
	Else
		EnableGadget(butOgg)
		EnableGadget(butMp3)
		EnableGadget(butSelectOutfile)
		EnableGadget(butOutfilename)
		EnableGadget(EncoderQualitybox)
	EndIf
EndFunction

' Encoding callback from FMOD
Function EncodeCallback:Int(sound:TFMODSound, data:Byte  Ptr, dataLen:Int)
	GCSuspend
	If IsEncoding Encoder.Encode(data,dataLen)
	GCResume
	Return 0
EndFunction

Type TEncoder
	Field beInitStream:Int(pbeConfig:Byte Ptr,pdwSamples: Int Ptr,pdwBufferSize:Int Ptr,phbeStream:Byte Ptr) = GetProcAddress(hLameEncDll,"beInitStream")
	Field beEncodeChunk:Int(hbeSream:Byte Ptr,nSamples:Int,pSamples:Short Ptr,pOutput:Byte Ptr,pdwOutput:Int Ptr) = GetProcAddress(hLameEncDll,"beEncodeChunk")
	Field beDeInitStream:Int(hbeStream:Byte Ptr,pOutput:Byte Ptr,pdwOutput:Int Ptr) = GetProcAddress(hLameEncDll,"beDeinitStream")
	Field beCloseStream:Int(hbeStream:Byte Ptr) = GetProcAddress(hLameEncDll,"beCloseStream")

	Const ENCODE_NONE:Int = 0
	Const ENCODE_OGG:Int = 1
	Const ENCODE_MP3:Int = 2

	Field _EncodingMutex:TMutex

	Field _EncodeMethod:Int
	Field _Filepath:String
	Field _Outfile:TStream
	Field _IsEncoding:Int
	
	Field _EncoderInstance:Byte Ptr
	Field _LameBufferSize:Int
	
	Field _SampleBuffer:Short[4096]
	Field _EncodedBuffer:Byte[8192]
	
	Field _SampleRate:Int
	Field _Bitrate:Float
	
	Method New()
		_EncodingMutex = CreateMutex()
	EndMethod
	
	Method Init:Int(EncMethod:Int,Filepath:String,SampleRate,Bitrate:Float)
		_Filepath = Filepath
		_EncodeMethod = EncMethod
		_SampleRate = SampleRate
		_Bitrate = Bitrate
		
		Select EncMethod
		Case ENCODE_NONE
			Return
			
		Case ENCODE_MP3
			If Not InitMp3Encoder() Return False
			
		Case ENCODE_OGG
			If Not InitOggEncoder() Return False
			
		EndSelect
		
		Return True
	EndMethod
	
	Method Encode(Data:Byte Ptr,Length:Int)
		LockMutex(_EncodingMutex)
		If _EncodeMethod = ENCODE_MP3 EncodeMp3(Data,Length)
		If _EncodeMethod = ENCODE_OGG EncodeOgg(Data,Length)
		UnlockMutex(_EncodingMutex)
	EndMethod
	
	Method StopEncoding()
		LockMutex(_EncodingMutex)
		If _EncodeMethod = ENCODE_MP3 StopEncodingMp3()
		If _EncodeMethod = ENCODE_OGG StopEncodingOgg()
		UnlockMutex(_EncodingMutex)
	EndMethod
	
	' Mp3 Encoding	
	Method InitMp3Encoder:Int()
		Local config:BE_CONFIG_LAME = New BE_CONFIG_LAME
		config.dwConfig = 256
		config.dwStructVersion = 1
		config.dwStructSize = SizeOf(BE_CONFIG_LAME)
		config.dwSampleRate = _SampleRate
		config.dwBitrate = _Bitrate
		config.dwMaxBitrate = _Bitrate
		config.nPreset = 9000
		config.dwMpegVersion = 1
		config.bWriteVBRHeader = True
		config.bNoRes = True
	
		Local wavBufferSize,encBufferSize
	  	' create an instance of the lame encoder via the blade dll
		If beInitStream(config,Varptr wavBufferSize,Varptr encBufferSize,Varptr _EncoderInstance) &lt;&gt; 0 Then
	    	Notify "Error: Setting config!"
			Return False
		End If 
	
		' make sure the instance is valid
		If Not _EncoderInstance
			Notify "Error: Handle is invalid!"
			Return False
		EndIf
		
		' create the output file
		_Outfile = WriteFile(_Filepath)
		
		Return True
	EndMethod
	
	Method EncodeMp3(Samples:Byte Ptr,Length:Int)
		Local iBytesEncoded:Int
		Local EncoderStatus:Int

		EncoderStatus = beEncodeChunk(_EncoderInstance,Length/2,Short Ptr Samples,_EncodedBuffer,Varptr iBytesEncoded)
		If EncoderStatus &lt;&gt; 0 Then 
			Notify "Error: Encoding chunk failed!"
			End
		EndIf
			
		For Local i:Int = 0 Until iBytesEncoded
			WriteByte(_Outfile,_EncodedBuffer[i])
		Next 
	EndMethod
	
	Method StopEncodingMp3()
		_EncodeMethod = ENCODE_NONE

		Local iBytesEncoded
		beDeInitStream(_EncoderInstance, _EncodedBuffer, Varptr iBytesEncoded)
		beCloseStream(_EncoderInstance)
		_EncoderInstance = Null

		For Local i:Int = 0 Until iBytesEncoded
			WriteByte(_Outfile,_EncodedBuffer[i])
		Next
		
		If _Outfile CloseFile(_Outfile)
		_Outfile = Null
	EndMethod
	
	
	
	' OGG Encoding
	Method InitOGGEncoder()
		Local iBytesEncoded:Int
		If oggInitStream(2,_SampleRate,_Bitrate, Varptr _EncoderInstance,_EncodedBuffer,Varptr iBytesEncoded) &lt;&gt; 0
			Notify "Error - invalid ogg handle"
			Return False
		EndIf
		
		' create the output file
		_Outfile = WriteFile(_Filepath)
		
		' save the header information
		For Local i:Int = 0 Until iBytesEncoded
			WriteByte(_Outfile,_EncodedBuffer[i])
		Next

		Return True
	EndMethod
	
	Method EncodeOgg(Samples:Byte Ptr,Length:Int)
		Local iBytesEncoded:Int
		Local EncoderStatus:Int

		EncoderStatus = oggEncodeChunk(_EncoderInstance,Short Ptr Samples,Length/4,_EncodedBuffer,Varptr iBytesEncoded)
		If EncoderStatus &lt;&gt; 0 Then 
			Notify "Error: Encoding chunk failed!"
			End
		EndIf
			
		For Local i:Int = 0 Until iBytesEncoded
			WriteByte(_Outfile,_EncodedBuffer[i])
		Next
	EndMethod
	
	Method StopEncodingOgg()
		_EncodeMethod = ENCODE_NONE

		Local iBytesEncoded
		oggDeinitStream(_EncoderInstance, _EncodedBuffer,Varptr iBytesEncoded)
		oggCloseStream(_EncoderInstance)
		_EncoderInstance = Null

		For Local i:Int = 0 Until iBytesEncoded
			WriteByte(_Outfile,_EncodedBuffer[i])
		Next
		
		If _Outfile CloseFile(_Outfile)
		_Outfile = Null
	EndMethod
EndType



Type TFMODController
	Field fmSystem:TFMODSystem
	Field fmSound:TFMODSound
	Field fmChannel:TFMODChannel
	Field CurrFrequency:Float

	Method Create:TFMODController()
		fmSystem = New TFMODSystem.Create()
		fmSystem.Init(32)
		
		Return Self
	EndMethod
	
	Method TuneTo(RadioStation:String)
		CloseStation()

		Local fmSoundExInfo:TFMODCreateSoundExInfo = New TFMODCreateSoundExInfo
		fmSoundExInfo.SetPCMReadCallback(EncodeCallback)
		fmSound = fmSystem.CreateStreamURL(RadioStation,FMOD_HARDWARE|FMOD_CREATESTREAM,FmSoundExInfo)
		
		fmChannel = fmSystem.PlaySound(0,fmSound)
		fmChannel.GetFrequency(CurrFrequency)
	EndMethod
	
	Method SystemUpdate()
		fmSystem.Update
	EndMethod
	
	Method CloseStation()
		If fmChannel fmChannel.Stop()
		If fmSound fmSound.SoundRelease()
	EndMethod
	
	Method Close()
		CloseStation()
	EndMethod
EndType

Type BE_CONFIG_LAME
	Field dwConfig:Int
	
	Field dwStructVersion:Int
	Field dwStructSize:Int
	
	Field dwSampleRate:Int
	Field dwResampleRate:Int
	Field nMode:Int
	Field dwBitrate:Int
	Field dwMaxBitrate:Int
	Field nPreset:Int
	Field dwMpegVersion:Int
	Field dwEmpahasis:Int
	
	Field bPrivate:Int
	Field bCRC:Int
	Field bCopyright:Int
	Field bOriginal:Int
	
	Field bWriteVBRHeader:Int
	Field bEnableVBR:Int
	Field nVBRQuality:Int
	Field dwVBRAbr_bps:Int
	Field nVbrMethod:Int
	Field bNoRes:Int
	
	Field bStrictIso:Int
	Field nQuality:Int
	
	Field btReservered0:Long,btReservered1:Long,btReservered2:Long,btReservered3:Long
	Field btReservered4:Long,btReservered5:Long,btReservered6:Long,btReservered7:Long
	Field btReservered8:Long,btReservered9:Long,btReservered10:Long,btReservered11:Long
	Field btReservered12:Long,btReservered13:Long,btReservered14:Long,btReservered15:Long
	Field btReservered16:Long,btReservered17:Long,btReservered18:Long,btReservered19:Long
	Field btReservered20:Long,btReservered21:Long,btReservered22:Long,btReservered23:Long
	Field btReservered24:Long,btReservered25:Long,btReservered26:Long,btReservered27:Long
	Field btReservered28:Long,btReservered29:Short,btReserved30:Byte
EndType
</textarea> <br><br></td></tr></table><br>
<a name="1294342"></a>

<a name="1294344"></a>

<a name="1294346"></a>

<a name="1294354"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#64">[#64]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey, thank you for looking into this!<br><br>Done some testing over the week. Ripped out the old code, made the new one "super strict" and also replaced the whole "fmod overhead". <br><br><img src="http://oi65.tinypic.com/2zteqeg.jpg"><br><br>A new test build of my player is available: <a href="http://www.mediafire.com/download/ii4r8r474sbdl4u/prp_win32_test.zip" target="_blank">http://www.mediafire.com/download/ii4r8r474sbdl4u/prp_win32_test.zip</a><br><br>So far it works nicely. Though I'm happy to get some more user feedback / from different hardware.<br><br>The debug mode crash is the only thing that bothers me a bit. I get a random crash after some minutes of ogg recording. But I can't track it when I can't use the debug mode. <br><br></td></tr></table><br>
<a name="1294612"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#65">[#65]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I get a random crash after some minutes of ogg recording <br></div><br>I left it playing all night without encoding and it crashed here too. So far I've managed to get it working in debug mode by using the old debugger but it still bugs out after about 10 mins.<br><br>There's plenty of hints as to where its going wrong, the callback is the main culprit and all hell breaks loose when the code is multple stack frames deep into the mt debugger. Something changes and it looks as thought the GC might not holding a reference to an instance somewhere. I may look at another way to get at the samples, maybe even a different api.<br><br>More investigations... <br><br></td></tr></table><br>
<a name="1294614"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#66">[#66]</a></td></tr></table></td></tr><tr ><td class="posttext"> The legacy GC doesn't like it if you callback into Max from a separate thread - like, for example if you are doing it from FMOD.<br><br>Either :<br>1) Don't do any GC-related work from the callback<br>2) Don't use the legacy GC ;-) <br><br></td></tr></table><br>
<a name="1294685"></a>

<a name="1294686"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#67">[#67]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm still using the old GC as I lack the skills and time to make a full 64 Bit transfer.<br><br>After about 10 mins it crashes for me when running a release build (with ogg encoding) here. <br><br></td></tr></table><br>
<a name="1294688"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#68">[#68]</a></td></tr></table></td></tr><tr ><td class="posttext"> NG does also compile to 32 bit targets ...<br><br>So you would need to transfer your "int" to "byte ptr" (handlers) and of course your code must be at least strict.<br>Dunno if all your used modules are compatible to NG ...<br><br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1294703"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#69">[#69]</a></td></tr></table></td></tr><tr ><td class="posttext"> I have the little sample app running in NG in x64 on windows :-)<br>It took about 2 mins and only half a dozen modifications.<br><br>It has the exact same fault, so either I'm using Fmod wrong or there's something else somewhere in Fmod. I notice that the sample length in the callback starts out as 13824 in length and then changes to a length of 4608. I believe the first packets are a 'pre-buffering' of the incoming music, filling the internal buffers, so that when you want it to play then it will play instantly. As the music is streamed at a more regular pace then the data length drops down to 4608. This is quite normal for this kind of thing.<br><br>When in debug mode the crash happens exactly at the point that the buffer size changes.<br><br>Any ideas? <br><br></td></tr></table><br>
<a name="1294705"></a>

<a name="1294706"></a>

<a name="1294707"></a>

<a name="1294709"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#70">[#70]</a></td></tr></table></td></tr><tr ><td class="posttext"> In release mode the NG version fails after a few minutes with an error 'collecting from wrong thread'. It seems FMod is just proving to be a pain in the a$$ with garbage collectors. <br><br></td></tr></table><br>
<a name="1294712"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#71">[#71]</a></td></tr></table></td></tr><tr ><td class="posttext"> That "Collecting from unknown thread" is a message from the GC... (ng... blitz.mod/bdwgc/pthread_stop_world.c) so you might be right, that GC and your code (maybe FMOD) do not play well together.<br><br>In this <a href="/posts.php?topic=78818" target="_blank">Thread</a> Skidracer/Nitro/Simonarmstrong suggested to code your callback in C and to have a look at brl.system on how to communicate with your app.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1294723"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#72">[#72]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks Derron,<br>funny that Fmod is mentioned in that thread too.<br><br>Thanks for the pointer to brl.system. <br><br></td></tr></table><br>
<a name="1294938"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#73">[#73]</a></td></tr></table></td></tr><tr ><td class="posttext"> If everything else fails; I can also live the the extra manual encoding option. So you don't need to mess around with FMod directly. <br><br></td></tr></table><br>
<a name="1303627"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#74">[#74]</a></td></tr></table></td></tr><tr ><td class="posttext"> Bumping...<br><br>Getting back on to this over the next couple of days... <br><br></td></tr></table><br>
<a name="1303638"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#75">[#75]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks again for helping me out with this. <br><br></td></tr></table><br>
<a name="1304191"></a>

<a name="1304192"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#76">[#76]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hiya,<br><br>A little progress over the past evenings and today. Mp3 encoding is done and seems to be working well.<br>If you want to do some Mp3 testing the current code without Ogg encoding is on github at <a href="https://github.com/SRSSoftware/FModEncoder" target="_blank">https://github.com/SRSSoftware/FModEncoder</a><br><br>What are you thoughts on using the latest libmp3lame.dll?<br>My 2c...<br>I changed to use the latest libmp3lame dll as it only seemed right being as lame will keep things up to date if needed. The blade dll, which uses a version of lame, could possible fall behind if lame gets updated. It's LGPL so linking via the dll allows you to keep your source closed. <br><br></td></tr></table><br>
<a name="1304254"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#77">[#77]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm away till the end of next week so I can't check it out now.<br><br>Sure, drop the Blade support. It will make the code more future-proof and it will be easier to update/fix.<br><br>I'm going to give the users 3 options:<br>A. Wav encoding<br>B. Ogg encoding (default)<br>C. MP3 encoding (optional/external)<br><br>BTW. Does the 2 GB filesize limit still apply to your new code? <br><br></td></tr></table><br>
<a name="1304297"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#78">[#78]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm the example... yes the 2gb limit applies. I'll get it to support large files. Saying that I encoded in ogg at 320kbs for 16 hrs and it was just under 2gb file size. The cpu was at 1%, using 7mb while encoding in debug mode. <br><br></td></tr></table><br>
<a name="1304300"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#79">[#79]</a></td></tr></table></td></tr><tr ><td class="posttext"> Should be "long" enough for most cases. Will the app just quit recording when the limit is reached? I don't want it to cash. <br><br></td></tr></table><br>
<a name="1304348"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#80">[#80]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Will the app just quit recording when the limit is reached? <br></div><br>I'd imagine that with large file support you'd be able to record for months before the limit is reached :-) but I'll put some checks in to stop the recording. <br><br></td></tr></table><br>
<a name="1304400"></a>

<a name="1304401"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#81">[#81]</a></td></tr></table></td></tr><tr ><td class="posttext"> My provider usually disconnects after 48h, so I won't be able to check that. But I'll create a test build for the users that wanted this kind of feature.<br><br>P.S. Do you think you can finalise the code until next monday? <br><br></td></tr></table><br>
<a name="1304530"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#82">[#82]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Do you think you can finalise the code until next monday? <br></div><br>I would think so yes, a release candidate at least. <br><br></td></tr></table><br>
<a name="1304645"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#83">[#83]</a></td></tr></table></td></tr><tr ><td class="posttext"> That would be great as I'm going to be back in monday and spend the week on PRP. Please tell me when you have updated the code by then. <br><br></td></tr></table><br>
<a name="1304822"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#84">[#84]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey Grisu,<br>ogg encoding is now in the repo <br><br></td></tr></table><br>
<a name="1304832"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#85">[#85]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for the update, will be able to check it out on monday. <br><br></td></tr></table><br>
<a name="1304899"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#86">[#86]</a></td></tr></table></td></tr><tr ><td class="posttext"> I got you latest code and recompiled all modules (normal, debug, threaded).<br><br>When trying to run your example app I get a MAV error for "NetRadio.Init()". :( <br><br></td></tr></table><br>
<a name="1304913"></a>

<a name="1304921"></a>

<a name="1304922"></a>

<a name="1304923"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#87">[#87]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ahh you probably need a different version of MingW. I used <a href="http://www.tomtoad.com/BlitzMax/MinGW.7z" target="_blank"> this one </a> from <a href="/posts.php?topic=105745" target="_blank">Tom Toads guide, 'no 2 the old way'</a><br><br>Don't forget to rebuild all modules so that they are all built with the same mingw. <br><br></td></tr></table><br>
<a name="1304952"></a>

<a name="1304953"></a>

<a name="1304954"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#88">[#88]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm using GCC 5.1.0: <a href="https://sourceforge.net/projects/tdm-gcc/files/TDM-GCC%20Installer/tdm-gcc-5.1.0-3.exe/download" target="_blank">https://sourceforge.net/projects/tdm-gcc/files/TDM-GCC%20Installer/tdm-gcc-5.1.0-3.exe/download</a><br><br>It has a better runtime and compiling speed. I really don't want to downgrade to 4.6.x. <br><br></td></tr></table><br>
<a name="1305017"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#89">[#89]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'll look into compiling it with that version. <br><br></td></tr></table><br>
<a name="1305018"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#90">[#90]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi, I'm now using the lasted build from the thread you posted before: <a href="http://www.blitzbasic.com/Community/post.php?topic=105745&amp;post=1293859" target="_blank">http://www.blitzbasic.com/Community/post.php?topic=105745&amp;post=1293859</a><br><br>With this build it, I get a proper error message:<br><pre class=code>
[ 46%] Compiling:fmodencoder.cpp
[ 46%] Compiling:fmodencodercodec_mp3.cpp
[ 47%] Compiling:fmodencodercodec_ogg.cpp
[ 47%] Compiling:fmodencodercodec_wav.cpp
[ 47%] Compiling:bitwise.c
[ 47%] Compiling:framing.c
[ 47%] Compiling:analysis.c
[ 47%] Compiling:bitrate.c
[ 47%] Compiling:block.c
[ 47%] Compiling:codebook.c
[ 48%] Compiling:envelope.c
[ 48%] Compiling:floor0.c
[ 48%] Compiling:floor1.c
[ 48%] Compiling:info.c
[ 48%] Compiling:lpc.c
[ 48%] Compiling:lsp.c
[ 48%] Compiling:mapping0.c
[ 48%] Compiling:mdct.c
[ 49%] Compiling:psy.c
[ 49%] Compiling:registry.c
[ 49%] Compiling:res0.c
[ 49%] Compiling:sharedbook.c
[ 49%] Compiling:smallft.c
[ 49%] Compiling:synthesis.c
[ 49%] Compiling:vorbisenc.c
[ 49%] Compiling:vorbisfile.c
[ 50%] Compiling:window.c
[ 50%] Compiling:bitwise.c
[ 50%] Compiling:framing.c
C:/BlitzMax/mod/srs.mod/fmodencoder.mod/fmodencoder.cpp:2:26: error: token "=" is not valid in preprocessor expressions
 #define _FILE_OFFSET_BITS=64
                          ^
C:/BlitzMax/mod/srs.mod/fmodencoder.mod/fmodencoder.cpp:2:26: error: token "=" is not valid in preprocessor expressions
 #define _FILE_OFFSET_BITS=64
                          ^
C:/BlitzMax/mod/srs.mod/fmodencoder.mod/fmodencoder.cpp:2:26: error: token "=" is not valid in preprocessor expressions
 #define _FILE_OFFSET_BITS=64
                          ^
[ 50%] Compiling:analysis.c
[ 50%] Compiling:bitrate.c
[ 50%] Compiling:block.c
[ 50%] Compiling:codebook.c
[ 50%] Compiling:envelope.c
[ 51%] Compiling:floor0.c
[ 51%] Compiling:floor1.c
[ 51%] Compiling:info.c
[ 51%] Compiling:lpc.c
[ 51%] Compiling:lsp.c
[ 51%] Compiling:mapping0.c
[ 51%] Compiling:mdct.c
[ 51%] Compiling:psy.c
Build Error: failed to compile (1) C:/BlitzMax/mod/srs.mod/fmodencoder.mod/fmodencoder.cpp
</pre><br><br>Does this help to get to core of this?<br><br>Grisu <br><br></td></tr></table><br>
<a name="1305020"></a>

<a name="1305021"></a>

<a name="1305022"></a>

<a name="1305023"></a>

<a name="1305024"></a>

<a name="1305025"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#91">[#91]</a></td></tr></table></td></tr><tr ><td class="posttext"> Using the exact same version of MingW in your link, it turns out to be the calling convention for interfaces in cpp, lol.<br><br>I've updated it on the repo.<br><br>edit: large file support isn't finalised just yet, that '#define' shouldnt have been in there :p<br>edit2: are you testing with the legacy bmax 150 ( on account of your copy/paste )? none of this has been tested in ng at the mo. Let me know which one you want to prioritise for... <br><br></td></tr></table><br>
<a name="1305026"></a>

<a name="1305027"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#92">[#92]</a></td></tr></table></td></tr><tr ><td class="posttext"> I only switched to get you some error message. Because the legacy compiler crashes without any error message at all.<br><br>Switched back to my old setup (legacy BMX + core modules updates) + GCC 5.x.<br><br>It seems to work now. Encoding is in progress. ;)<br><br>Now I have to get rid off all the PRP code / gui and put the new stuff in. Will keep you updated. <br><br></td></tr></table><br>
<a name="1305028"></a>

<a name="1305029"></a>

<a name="1305030"></a>

<a name="1305031"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#93">[#93]</a></td></tr></table></td></tr><tr ><td class="posttext"> Do these functions need to be in C code?<br><br>NetRadio.Init()<br>NetRadio.SetRadioStation("http://relay.181.fm:8030")<br><br>I'd love to set the values, such as the volume fmod flag myself. For instance the recording channel will mostly run on volume=0.<br><br>Also, is the "libmp3lame.dll" set for a reason. Most dlls you find on the net are called "lame_enc.dll"? Or is there a difference between them? <br><br></td></tr></table><br>
<a name="1305049"></a>

<a name="1305087"></a>

<a name="1305088"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#94">[#94]</a></td></tr></table></td></tr><tr ><td class="posttext"> Can you not supply the dll with your app?<br><br>The fmod functionality is all kept in the c files to keep the structure of the code under control. I guess you can write some getters to get the fmod system, sound and channel instances and then call the FMOD** functions directly. A tidier solution is always to wrap the low level stuff away from the regular 'max code. If you make a list a of the functions that you use then I'll put add them in, feel free to email me if you want to discuss some of your closed source stuff.<br><br>[edited due to predictive text getting it wrong :D] <br><br></td></tr></table><br>
<a name="1305153"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#95">[#95]</a></td></tr></table></td></tr><tr ><td class="posttext"> I found some time earlier to include wav file output. <br><br></td></tr></table><br>
<a name="1305177"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grisu</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#96">[#96]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah noticed that, though wav file output was already supported. You can use the "normal" fmod commands for that.<br><br>Did you get my mail? :) <br><br></td></tr></table><br>
<a name="1305201"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#97">[#97]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> wav file output was already supported <br></div><br>oh well it makes this little app more complete :D<br><br><div class="quote"> Did you get my mail? <br></div><br>Yep :-) <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
