<!DOCTYPE html><html lang="en" ><head ><title >how to use DLL in BMX ?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >how to use DLL in BMX ?</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >how to use DLL in BMX ?</a><br><br>
<a name="918756"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >K@li</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> i have a .DLL and i know the synthax to call function<br><br>how to intégrate the dll into bmx ?<br><br>how to call the function ? <br><br></td></tr></table><br>
<a name="918759"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >kfprimm</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Do a forum search. There are plenty of discussions that have already been started about this. <br><br></td></tr></table><br>
<a name="918908"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >K@li</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> no really found anything.<br><br>i foud in the forum dll created with bmx<br><br>this is ot that i will<br><br>i will use a totaly external dll... <br><br></td></tr></table><br>
<a name="918909"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >plash</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Keep looking. <br><br></td></tr></table><br>
<a name="918910"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Jesse</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> maybe this can help:<br><a href="http://www.blitzbasic.com/Community/posts.php?topic=41803" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=41803</a> <br><br></td></tr></table><br>
<a name="918913"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >plash</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> That was 3 years ago, you don't need to do the function pointer stuff anymore.<br><a href="/codearcs.php?code=1899" target="_blank">Escapi</a> is a good example of using dll's. <br><br></td></tr></table><br>
<a name="919131"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >K@li</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> i try this :<br><br>Global this = LoadLibraryA("Interop.ActiveHomeScriptLib.dll")<br><br>Global send(a:Byte  Ptr, b:Byte Ptr) "C"<br><br>send = GetProcAddress( this, "SendAction")<br><br>send("sendplc"," A8 off")*<br><br>but encouter an error : <br><br>Building testhome<br>Compiling:testhome.bmx<br>flat assembler  version 1.66<br>3 passes, 2644 bytes.<br>Linking:testhome.exe<br>Executing:testhome.exe<br>Attempt to call uninitialized function pointer<br>Process complete<br><br><br>wat is rong ?<br><br>the parameters for the dll is : <br><br>SendAction("queryplc", " a10 on")  for exemple.... <br><br></td></tr></table><br>
<a name="919132"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >skidracer</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm not sure anyone has ever got a dot net dll working with BlitzMax, I'm pretty sure they are for managed languages only. <br><br></td></tr></table><br>
<a name="919160"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> I suppose it depends how the ABI is exposed, whether it's C-style (good) or C++-style (bad), or something else (probably worse).<br><br>If you look at the names of the functions inside the DLL, and you can read them, then it might work. Otherwise you may need some intermediate wrapping (another dll) to connect them together.<br>I've managed to plug BlitzMax into some MSVC C++ DLLs, but failed (miserably) with Oracle's OCCI. So, some work, some don't. :-p <br><br></td></tr></table><br>
<a name="919283"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >K@li</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> the SendAction is one of the multiple command from dll<br><br>but nothing work<br><br>i dont really understand the use of    GetProcAddress   and   <br>Global send(xxx:Byte Ptr, xxx:Byte Ptr) "C" <br><br></td></tr></table><br>
<a name="920362"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >K@li</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> work perfectly under vba 2008 !<br><br>lol<br><br>the power of blitz !!<br><br>vba is free, i use it now for windows applications, much faster dev time... <br><br></td></tr></table><br>
<a name="920368"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Good for you :-) <br><br></td></tr></table><br>
<a name="920432"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dabhand</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>I'm not sure anyone has ever got a dot net dll working with BlitzMax, I'm pretty sure they are for managed languages only. <br> <br></div><br><br>Not BlitzMax, but to unmanage a managed DLL for BlitzBasic via userlibs, I used this....<br><br><div class="quote"> <br>=== BlitzBasic and Microsoft.NET =====================================<br>Written by: Jim Teeuwen / Defiance &lt;JimTeeuwen@...;<br><br>Table Of Contents<br><br>I. Preface : What, Where and Why?<br>II. Requirements : The goods<br>III. Gettting Started : Creating the Dll<br>IV. The real Business : Preparing it for use with Blitz.<br>V. Finalize : Recompile the Dll and use it<br><br><br>I. Preface<br>The following Article explains in detail how to use any .NET Assembly from BlitzPlus/Blitz3D.<br><br>This Article focusses on how to use a DLL created with the Microsoft .NET Framework with Blitz. I have written this article since I personally believe, the .NET Framework is the best that ever happened to the programming part of the world, and I found it unbearable that Blitz could not utilize the potential power it offers in terms of both Game and Application development.<br><br>In this article I am going to assume a few things about you.<br><br>1. You know what the .NET Framework is and how it works. 2. You know how to use at least 1 .NET enabled programming language like C# (C-sharp), VB.BET, Managed C++, IL, etc. 3. You know about IL Code, the IL Assembler and Disassembler. You do not have to be a guru, just some knowledge about it's existance will do, I will try to explain as much about it as possible. This is actually an important part, since the actual code exporting is done using IL Code. 4. You know how Blitz userlibs work.<br><br>If either of these items are not met, I suggest you try ad learn about those before you continue with this article. I will try to explain all the steps involved as good as I can, so a complete newbie should be able to use it as well, but lack of knowledge about some of these items might get you into trouble at some stage.<br><br>II. Requirements<br>Goody, enough with the whining, On to the list of required items for this stuff to work. Below is a list of things you will need to make all the stuff come together.<br><br>1. Your very own purchased version of either Blitz3D or BlitzPlus. Both have to support UserLibs.<br><br>You can buy Blitz3D/BlitzPlus from: www.blitzbasic.com<br><br>2. The Microsoft .NET Framework Software Development Kit. This is crucial, since you need to write your DLL's with it. Also, this SDK contains the required IL (dis)assembler.<br><br>You can download the SDK from: msdn.microsoft.com/downloads/<br><br>3. A little patience and the will to learn. The process for creating your Blitz DLL's with .NET is not hard, but it will require you to pay attention to some details about the gory CLR internal workings.<br><br>If you got all this sorted, we're ready to rock!<br><br>III. Gettting Started<br>Now that everything is sorted out, we can start to create our first managed DLL.<br><br>In this article I will create a DLL wich exports 1 Function wich Blitz can Call. We will call it: SayHello()<br><br>As said before in this article, I am asuming you know how to write a normal DLL using the .NET framework and any language it supports. From here on I will be using C#, since I consider it the best language ever to be created, but the sample should not be too hard to convert to your own liking.<br><br>Below is the code for my simple dll.<br><br>*CODE*<br>// HelloWorldDll.cs<br>using System;<br><br>namespace HelloWorldDll<br>{<br>public class HelloWorldClass<br>{<br>public static string SayHello(string name)<br>{<br>return ("Hello " + name);<br>}<br>}<br>}<br>*CODE*<br><br>Up until now, this should appear pretty straightforward to any of you. I didnt do anything special. just create a namespace HelloWorldDll. Create a class called HelloWorldClass. and give it 1 method called SayHello(string name).<br><br>Now, all our function does is take a string value as a parameter, combine it with the string "Hello " and return the resulting string.<br><br>Note that I have made the class PUBLIC. this is NOT required! it does not matter how you define your class for the final result to work. it's just cos I felt like doing it this way. The same goes for the function declaration. Your function does not have to be public or static for that matter. just use whatever suits your needs.<br><br>The reason I used a parameter and a return value, is because I want to show you that passing parameters ands getting return values does not pose any problem in Blitz. You can use any basic Data type like byte, short, long, int, string, uint, ulong etc etc etc. Yes, you can even use a struct as a parameter. in wich case, you create a Type in your blitz code wich has exactly the same fields as the struct in your .NET assembly.<br><br>Example:<br><br>*CODE*<br>// C#<br>public struct SomeStruct<br>{<br>public int X, Y, Z;<br>public string Name;<br>public object Obj;<br>}<br><br>;// Blitz<br>Type SomeType<br>Field X, Y, Z<br>Field Name$<br>Field Obj<br>End Type<br>*CODE*<br><br>The above will work if you pass an instance of your SomeType Type to the function as a parameter. The only limitation is the fact that you cannot have the .NET function have such a struct as a return value. Just pass the instance as as a parameter and have it filled like that. Example:<br><br>*CODE*<br>// BAD<br>public SomeStruct DoStuff()<br>{<br>SomeStruct obj = new SomeStruct();<br>obj.X = 0;<br>obj.Y = 0;<br>obj.Name = "This will never arrive in blitz!";<br>obj.Obj = null;<br>return obj;<br>}<br><br>// GOOD<br>public void SomeStruct(ref SomeStruct obj) // ref = Pass the SomeStruct instance By Reference (ByRef for VB people)<br>{<br>obj.X = 0;<br>obj.Y = 0;<br>obj.Name = "This *will* arrive in blitz!";<br>obj.Obj = null;<br>}<br>*CODE*<br><br>Now that this is sorted, I want to get back to the main issue, before we loose track of it.<br><br>We created our Dll code, and now it's time to compile it. Just hit Shift-F5 in Visual Studio .NET if you have it, or use the commandline compiler.<br><br>*CODE*<br>In the case of C# code, use:<br>c:\csc /OUT:HelloWorldDll.dll /target:library HelloWorldDll.cs<br><br>In the case of VB.NET code, use:<br>c:\vbc /OUT:HelloWorldDll.dll /target:library HelloWorldDll.vb<br>*CODE*<br><br>If all is ok, you should now have a new file called HelloWorldDll.dll in your working directory.<br><br>IV. The real Business<br>Now it's time to get down n dirty. We need to create a Dll wich normally runs in a managed environment, and have it work with completely unmanaged code. How, o, how do we fix this?? First of all, Exporting managed code for use in unmanaged assemblies/code is normally possible through a technology called COM interop. This basicly means that you create a COM interface for your DLL and have the unmanaged code use this to interact with your Dll.<br><br>...BUT...<br><br>You guessed it, Blitz does not support COM! Bummer! What now? Well, the answer lies in the magical world of IL Code! For the ones of you who never heard of it, a short introduction to IL.<br><br>MSIL (MicroSoft Intermediate Language), or IL for short, is basicly the assembly version of the .NET Framework. Tt behaves like Java Bytecode, or at least, it performs the same task, in that IL Code is the Final step that ALL .NET languages like C#, VB.NET, C++ etc get to before being compiled to native machine code (by the JIT compiler). Meaning that all these languages Ultimatly compile to Pure IL Code.<br><br>It is this IL Code, wich makes sure that all the previously named languages can be used with eachother, and wich (theoreticly) makes any .NET assenbly Platform independant. This IL Code is compiled into the resulting Exe or Dll, together with an extensive description of it's actuall contents, called MetaData.<br><br>What we are interested in, is the IL Code itself. As I just explained, this is stored in the final Exe/Dll, so we need a way to extract it. The answer to this is the nifty little tool called: IldAsm.exe wich comes with the .NET Framework SDK. As the name suggests, it DE-compiles .NET Assemblies into IL Code. That's right, you can decompile any .NET Exe or DLL into pure IL code! Good or bad? That's a matter of discussion I guess, and many ppl are still wondering whether to consider it a bug or a feature. Personally I think it's great for learning purposes and situations such as the one we face in this article, where a regular language just wont cut it, and we need that extra edge IL code offers.<br><br>To Business. We will now decompile our dll into IL code, so we can edit it around a bit and then re-compile it into our Dll. To do this we open a command prompt and CD to the directory with our Dll in it. Then type:<br><br>c:\somedir\ildasm /OUT:HelloWorldDll.il HelloWorldDll.dll<br><br>This will create 2 new files: - HelloWorldDll.il - HelloWorldDll.res<br><br>We can safely delete the .res file, since it's not needed for our current DLL. this .res file contains resource information about our DLL. wich is needed if your dll contains forms and controls and such, but in our case it's just a file waiting to be deleted.<br><br>The file of interest is, offcourse, HelloWorldDll.il Open it in a text editor and be amazed at the mess you see. Please dont get put off by the garbled presentation of the code, since it's really not that bad. First of all, you may want to clean it up a bit by removing all the residual blank lines and unsightly comments (starting with '// ..')<br><br>Note that this is NOT needed!. this code will compile into a dll perfectly, it's just to make life easier on you when you edit the code.<br><br>Below is what our IL Code should look like after cleaning it up. All I am leaving in there is the relevant parts. eg: the parts we need for our final DLL<br><br>*CODE*<br><br>.assembly extern mscorlib<br>{<br>.publickeytoken = (B7 7A 5C 56 19 34 E0 89 )<br>.ver 1:0:3300:0<br>}<br>.assembly HelloWorld<br>{<br>.hash algorithm 0x00008004<br>.ver 0:0:0:0<br>}<br>.module HelloWorld.dll<br>.imagebase 0x00400000<br>.subsystem 0x00000003<br>.file alignment 512<br>.corflags 0x00000001<br><br>.namespace HelloWorldDll<br>{<br>.class public auto ansi beforefieldinit HelloWorldClass extends [mscorlib]System.Object{}<br>}<br><br>.namespace HelloWorldDll<br>{<br>.class public auto ansi beforefieldinit HelloWorldClass extends [mscorlib]System.Object<br>{<br>.method public hidebysig static string SayHello(string name) cil managed<br>{<br>.maxstack 2<br>.locals init (string V_0)<br>IL_0000: ldstr "Hello "<br>IL_0005: ldarg.0<br>IL_0006: call string [mscorlib]System.String::Concat(string, string)<br>IL_000b: stloc.0<br>IL_000c: br.s IL_000e<br><br>IL_000e: ldloc.0<br>IL_000f: ret<br>}<br><br>.method public hidebysig specialname rtspecialname instance void .ctor() cil managed<br>{<br>.maxstack 1<br>IL_0000: ldarg.0<br>IL_0001: call instance void [mscorlib]System.Object::.ctor()<br>IL_0006: ret<br>}<br>}<br>}<br>*CODE*<br><br>Now isn't that beautifull? As you can see, IL looks like a genuine programming language! In effect, it is a genuine programming language, because you can actually write your programs straight in IL if you want. It's a pretty straigh forward language. Easy to understand as well. Not anything at all like MASM32 or TASM or any of that stuff. IL Code is a Stack Based Assembly language. The big difference with languages like MASM32 and TASM is that IL does NOT use Registers, but all is done through the Stack and Heap. But thats all gory details wich you probably wont need, enless you want to become an IL guru. In wich case by the way, I would like to recommend to you an excellent book called:<br><br>Inside Microsoft .NET IL Assembler, by Serge Lidin<br><br>This book is the best possible read about IL and the Common Language Runtime available. Serge Lidin is the guy who designed IL and a large part of the CLR itself so he knows what he's talking about. The book explains a lot of the really gory details about the inner workings of IL code, the CLR and also Why it works the way it does. VERY interesting read! Btw. if you ever need to ask Mr. Lidin some questions about IL, I happen to know he frequently visits the IL Code Forum on www.gotdotnet.com<br><br>Anyways... we want to export our code for use in blitz. So let's get to it.<br><br>First we will change the line that says: .corflags 0x00000001 into: .corflags 0x00000002<br><br>Why? Well, this flag is part of the Common language Runtime Header, wich tells windows that it's dealing with a genuine .NET assembly and not a regular windows executable.<br><br>This value is, by default, always set to COMIMAGE_FLAGS_ILONLY (0x00000001) This means that the assembly contains only Pure IL Code. So no Embedded native/unmanaged code is present in the Exe or Dll.<br><br>&lt;THEORY&gt; COMIMAGE_FLAGS_ILONLY (0x00000001) The Image Flags contains IL Code Only. with no embedded native unmanaged code, except the startup stub. Because Comon Language Runtime - aware Operating Systems (such as Windows XP) ignore the startup stub, for all practicle Purposes the file can be considered Pure-IL. However using this flag can cause certain IlAsm compiler-specific problems when running under Windows XP. If This flag is set, WinXP ignores not only the startup stub but also the .reloc section. &lt;/THEORY&gt;<br><br>Now the important part is 'WinXP ignores not only the startup stub but also the .reloc section' This means that the functions we will export as unmanaged code will not be properly loaded. So, Fix our problem we will change the default flag to: COMIMAGE_FLAGS_32BITSREQUIRED (0x00000002)<br><br>&lt;THEORY&gt; COMIMAGE_FLAGS_32BITSREQUIRED (0x00000002) The Image file can be loaded only into a 32-bit process. This flag is set wheb native unmanaged code is embedded in the PE file or when the .reloc section is not empty. &lt;/THEORY&gt;<br><br>Next up: Reserving some space in our final Dll to store the address of our function. This will be filled at runtime with the actual address of the function, we just need to reserve the space.<br><br>&lt;THEORY&gt; In order to expose managed methods as unmanaged exports, the ILAsm compiler builds a v-Table, A v-Table Fixup (VTableFixup) table, and a group of unmanaged export tables, wich include the Export Address Table, the Name Pointer Table, the Ordinal Table, the Export Name Table and the Export Directory Table.<br><br>The VTableFixup table is an array of VTableFixup Descriptors with each Descriptor carying the RVA of a v-table entry, the number of slots in the entry, and the binary flags indicating the size of each slot (32 or 64 bit) and any special features of the entry.<br><br>Each slot of a V-table in a managed PE File carries the token of the method the slot represents. At runtime the V-table fixups are executed, replacing the method tokens with actual method addresses.<br><br>The IlAsm syntax for a v-table fixup is: .vtfixup [&lt;num_slots&gt;] &lt;flags&gt; at &lt;data_label&gt;<br><br>Note that the square brackets in [&lt;num_slots&gt;] are part of the statement, and do not mean that &lt;num_slots&gt; is optional!<br><br>&lt;num_slots&gt; is an Integer constant indicating the number of v-table slots grouped into one entry because their flags are identical. This serves no other purpose except to save space in your Code file. you can use a seperate .vtfixup statement for each method if you like.<br><br>The &lt;flags&gt; statement can consist of any of the following: - int32 Each slot of the vtable entry is 4 bytes wide. - int64 Each slot of the vtable entry is 8 bytes wide. (int32 and int64 flags are mutually exclusive) - fromunmanaged The entry is to be called from the unmanaged code, so the marshalling thunk must be created by the runtime. - callmostderived Currently not used.<br><br>The order of appearance of .vtfixup declarations defines the order of the respective VTableFixup descriptors in the VTableFixup table. The Vtable entries are defined simply as data entries. Note that the VTable must be contiguous. I other words, the data definitions fot the vtable entries must immediatly follow one another.<br><br>Example:<br><br>*CODE*<br>...<br>.vtfixup [1] int32 fromunmanaged at VT_01<br>...<br>.vtfixup [1] int32 at VT_02<br><br>...<br><br>.data VT_01 = int32(0x0600001A)<br>.data VT_02 = int32(0x0600001B)<br>*CODE*<br><br>The actuall data representing the Method tokens is automaticly generated by the IlAsm compiler and placed in designated vTable slots. To achieve that, it is necesarry to indicate wich method is represented by wich Vtable slot. IlAsm provides the .vtentry directive for this purpose<br><br>.vtentry &lt;entry_number&gt; : &lt;slot_number&gt;<br><br>Where &lt;entry_number&gt; and &lt;slot_number&gt; are 1-based integer constants. The .vtentry directive is placed within the respective method's scope. as shown in the following code:<br><br>*CODE*<br>...<br>.vtfixup [1] int32 fromunmanaged at VT_01<br>.data VT_01 = int32(0) // alays use 0, the slot will be filled automaticly by ILASM.exe<br><br>.method public static void Foo()<br>{<br>.vtentry 1 : 1 // entry 1, slot 1<br>}<br>*CODE*<br><br>The ILAsm syntax for actually declaring a method as exported code is quite simple:<br><br>.export [&lt;ordinal&gt;] as &lt;export_name&gt;<br><br>Where &lt;ordinal&gt; is an integer constant. The &lt;export_name&gt; provides an alias for the exported method, so this is what you will use to call the method from your blitz program. the &lt;export_name&gt; directive us required, even if it is the same as the original method name. &lt;/THEORY&gt;<br><br>Well then, now we know all this, we will apply it to our own little Dll. All changes are marked with '// ### CHANGE ####'<br><br>*CODE*<br><br>.assembly extern mscorlib<br>{<br>.publickeytoken = (B7 7A 5C 56 19 34 E0 89 )<br>.ver 1:0:3300:0<br>}<br>.assembly HelloWorld<br>{<br>.hash algorithm 0x00008004<br>.ver 0:0:0:0<br>}<br>.module HelloWorld.dll<br>.imagebase 0x00400000<br>.subsystem 0x00000003<br>.file alignment 512<br><br>.corflags 0x00000002 // ### CHANGE ####<br>.vtfixup [1] int32 fromunmanaged at VT_01 // ### CHANGE ####<br>.data VT_01 = int32(0) // ### CHANGE ####<br><br>.namespace HelloWorldDll<br>{<br>.class public auto ansi beforefieldinit HelloWorldClass extends [mscorlib]System.Object{}<br>}<br><br>.namespace HelloWorldDll<br>{<br>.class public auto ansi beforefieldinit HelloWorldClass extends [mscorlib]System.Object<br>{<br>.method public hidebysig static string SayHello(string name) cil managed<br>{<br><br>.vtentry 1 : 1 // ### CHANGE ####<br>.export [1] as SayHello // ### CHANGE ####<br><br>.maxstack 2<br>.locals init (string V_0)<br>IL_0000: ldstr "Hello "<br>IL_0005: ldarg.0<br>IL_0006: call string [mscorlib]System.String::Concat(string, string)<br>IL_000b: stloc.0<br>IL_000c: br.s IL_000e<br><br>IL_000e: ldloc.0<br>IL_000f: ret<br>}<br><br>.method public hidebysig specialname rtspecialname instance void .ctor() cil managed<br>{<br>.maxstack 1<br>IL_0000: ldarg.0<br>IL_0001: call instance void [mscorlib]System.Object::.ctor()<br>IL_0006: ret<br>}<br>}<br>}<br>*CODE*<br><br>There ya go! we're done! After all the theoreticle mumbo-jumbo it seemed a daunting task, but as you see, it requires you add just a few lines of code and your set. Really no big deal. Time to re-compile our dll and use it in blitz!<br><br>V. Finalize<br>Save the HelloWorldDll.il file and close your text editor. Open a commandline and CD to the dir your il file resides in. Then type:<br><br>c:\somedir\ilasm /OUT:HelloWorldDll.dll HelloWorldDll.il /DLL (Do not forget the /DLL switch!)<br><br>Congratulations! Now you have a newly compiled HelloWorldDll.dll file wich you can use in blitz! Your vewy first Blitz-compatible-.NET-assembly! To test it, copy the Dll into the Blitz3D\Userlibs\ directory and create a new textfile called 'HelloWorldDll.decls'<br><br>Open it in notepad and add the following:<br><br>*CODE*<br>.lib "HelloWorldDll.dll"<br>SayHello$(name$) : "SayHello"<br>*CODE*<br><br>Save it and Close it. then open Blitzbasic. create a new sourcefile and type:<br><br>*CODE*<br>Print( SayHello("Your Name Here") )<br>*CODE*<br><br>Hit F5 and be amazed at your work!<br><br>Thats it folks! You now have the power to use the entire Microsoft .NET Framework with BlitzPlus and Blitz3D! Use it!<br><br>Regards, Jim Teeuwen. <br> <br></div><br><br>Brilliant tut written by Jim ages ago! ;)<br><br>Dabz <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
