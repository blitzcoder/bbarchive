<!DOCTYPE html><html lang="en" ><head ><title >Function overloading</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Function overloading</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Function overloading</a><br><br>
<a name="856466"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >*</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> will we ever see function overloading in BlitzMax, it would be very useful IMHO. For those that dont know it allows you to have the same function return loads of different types. An example would be:<br><pre class=code>
Function PlayerInformation:Int()
   return 3
End Function

Function PlayerInformation:String()
   return "Playername"
End Function
</pre><br><br>Both functions have the same name just different parameters, this would be an overloaded function and would be massively helpful in coding some systems in max. Another approach would be a extra variable type var as an example:<br><br><pre class=code>
Function ReturnInformation:Var( operator:Int )
   Select Operator
   case 0
      return 1
   case 1
      return "PlayerName"
   end Select
end function
</pre><br><br>All are do-able and would be majorly helpful IMHO. <br><br></td></tr></table><br>
<a name="856487"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >plash</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Doesn't function overloading typically allow parameter changes too? like so:<br><pre class=code>Function PlayerInformation:Int(a:Int, b:Int)
   return a + b
End Function

Function PlayerInformation:String(name:String)
   return "Hello " + name + "!"
End Function</pre> <br><br></td></tr></table><br>
<a name="856488"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >*</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> yeah <br><br></td></tr></table><br>
<a name="856492"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Torrente</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> I didn't know Function Overloading allowed different return types for functions with the same number (and type) of arguments. To be honest, I don't really even like that idea.<br><br>What if you just called PlayerInformation(), without setting a variable equal to the value returned -- which one would it call?<br><br>I would like to see the function overloading that I was familiar with -- different parameters for the same function. Also, Plash's example would work better in my opinion, because the different parameters would dictate the return type. <br><br></td></tr></table><br>
<a name="856500"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I didn't know Function Overloading allowed different return types for functions with the same number (and type) of arguments. <br></div><br><br>I didn't think you could do that either. The original code is missing () on the functions anyway, so I think there's been a typo somewhere.. <br><br></td></tr></table><br>
<a name="856737"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >plash</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> The original code is missing () on the functions anyway <br></div><br><br>What code? both examples (EdzUp's and mine) are valid as pseudo code. <br><br></td></tr></table><br>
<a name="856746"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >*</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> yup <br><br></td></tr></table><br>
<a name="856750"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Who was John Galt?</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well C doesn't allow this type of overloading, does it? It's possible but not a great idea IMHO. Overloading for different calling parameters would be both useful and easy to implement. <br><br></td></tr></table><br>
<a name="856752"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >*</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> I agree it would be nice if it was in there as it would mean we didnt need to write loads of functions to just return values and would make code easier to read. <br><br></td></tr></table><br>
<a name="856759"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> no it wouldn't be easier to read as it would become impossible to tell from the function name what it does when it takes totally different things for the same purpose. Thats a thing that C thinks of as beeing nice but its actually about the only major OO language allowing type unsafe overloading. <br><br></td></tr></table><br>
<a name="856773"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Perturbatio</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Overloading return types I'm not sure I would need, but overloading parameters is a definite thumbs up for me.<br><br>Along with read and write methods for fields like object pascal has.<br><br>something like:<br><pre class=code>

Type myType
	
	Field name:String Read getName write setName
	
	Method getName()
		return name
	End Method
	
	Method setName(value:String)
		If value.contains("trainers") Then
			RuntimeError("Sorry, no trainers allowed")
		Else
			Name = value
		EndIf
	End Method
	
End Type

</pre> <br><br></td></tr></table><br>
<a name="856780"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >plash</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> C# has a good system for Get and Set Methods<br><pre class=code>public class PropertyHolder
{
    private int someProperty = 0;

    public int SomeProperty
    {
        get
       {
            return someProperty;
        }
        set
       {
            someProperty = value;
        }
    }
}</pre><br>Using that system you can also just use the set/get bits of it to signify write or read only variables. <br><br></td></tr></table><br>
<a name="856783"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> you get-set as well as access restriction possibilities are about the most requested OO extensions for BM ( beside multiple inheritance / implementation *like java interface* and overloading. BM only supports undefine which happens when you declare the same field in an extended class which will "mask" the parents field and replace it with the new one) <br><br></td></tr></table><br>
<a name="856787"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >plash</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Which is pretty much how brucey's wxmax mod is designed, extended types for overloading methods, like OnInit() etc. <br><br></td></tr></table><br>
<a name="856820"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Russell</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> If both functions have the same parameters (none in the case of the examples above), how does the compiler know which one to use? I think at least one parameter would be required, and the type/number of parameter(s) would determine which function would be used. Right?<br><br>Russell <br><br></td></tr></table><br>
<a name="856831"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Overloading lets you have functions with the same name, but different numbers of parameters, or parameters of different types. It can be a convienience, but doesn't allow you to do anything you couldn't anyway. The compiler can work out which function is which from the types of the variables sent as parameters, and compiles. There's no 'magic' post-compiling.<br><br><pre class=code>Function PlayerInformation:Int()
   return 3
End Function

Function PlayerInformation:String()
   return "Playername"
End Function</pre><br><br>Possible this could work if the function is being stored into a variable of known type, but as stated above how can the compiler know for sure which function to run. It doesn't seem a very tidy solution. The work around is to simply name the functions differently... PlayerInformationString and PlayerInformationInt or a shorter, more convienient name.<br><br>Functions which can return different types (int or string for example) would require functions to work differently during program execution, and this is hard to implement in a compiled language. It is possible in Javascript and PHP, interperated languages.<br><br>A work around could be... returning numbers as strings ("1") for some functions. Or returning a custom Type containing as fields the possible types, with some indicator of the desired type. Not very elegant. but should work. <br><br></td></tr></table><br>
<a name="856880"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >*</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think it would be useful when you have a system that has loads of different data to return, multiple functions dont seem as neat as function overloading would.<br><br>The programmer would be the one to decide what was being returned and read at the other end. <br><br></td></tr></table><br>
<a name="856903"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >nawi</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> It could work by defining the return type of the function when you use it, in this instance:<br><br><pre class=code>
Print PlayerInformation:String()
Local a:Int = PlayerInformation:Int()
</pre> <br><br></td></tr></table><br>
<a name="856905"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >plash</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> That doesn't work with other objects, you can't get an integer from a function that returns a non standard Object (TList, TMap, TMyType etc..)<br><br>EDIT: Using what you posted would not allow different return <i>values</i>. <br><br></td></tr></table><br>
<a name="856916"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> you could just return :object and send integers as strings back and the like.<br>that definitely is the least problem.<br><br>but if you have such a function like that one especially your code is a mess ... if you can have "anything" returned from it, how is the correct work of your program guaranteed? Hope definitely isn't an acceptable part of software development sorry. <br><br></td></tr></table><br>
<a name="856931"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gabriel</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Don't know if anyone has mentioned this, but the reason we don't have overloading is because BlitzMax is still too beginner friendly. In C# for example, you can't start passing ints as floats and vice versa, but in BlitzMax you can. C# requires all type changes are explicit casts, but BlitzMax allows implicit casting all over the place. ( Much to my annoyance, actually. ) <br><br>If you had something like this :<br><br><pre class=code>
Type MyType
   Function Create(Param1:Float,Param2:Float)
   End Function

   Function Create(Param1:Int,Param2:Int)
   End Function

   Function Create(Param1:Double, Param2:Double)
   End Function

End Type
</pre><br>Now if you call MyType.Create(1,1) then BlitzMax has no clue which function you just called, because 1 is valid as an integer, float and double. You can specify the type of a constant value, but you're not required to.<br><br>So essentially, BlitzMax is doing it all backwards. When you call that function, it looks at the function prototype and then tries to cast your parameters to match the function prototype. But with overloading, it can't look at the function prototype because there are several.<br><br>So it would require a complete rewrite of the way BlitzMax handles variable casting, and it would require ditching the noob-friendly attitude of implicitly casting everything.<br><br>In short, much as I would like to, I don't see Mark doing that. Heavens, there are enough people whining about BlitzMax trying to become a more professional language as it is. <br><br></td></tr></table><br>
<a name="856941"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >H&amp;K</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> We should explictly cast anyway tho.... <br><br></td></tr></table><br>
<a name="856942"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gabriel</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> We should explicitly cast, yes, to avoid unexplained errors where implicit casts are changing the result, but until BlitzMax enforces explicit casting, it won't change the situation with regard to overloading. <br><br></td></tr></table><br>
<a name="856966"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >plash</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> How about when calling functions you can tell the compiler which one to use by calling it like this:<br><pre class=code>MyType.Create(12:Float, 0.12) 'first parameter is not a float so you can tell it to convert to a float, second is a float so the compiler should know already which one this refers to
MyType.Create(12:Int, 2.4:int) 'first parameter is an integer so the :int part is not required, second parameter gets rounded</pre><br><br>EDIT: I just realized what I posted probably didn't make too much sense. Basically you can just tell the compiler which one to call by just putting <i>:ObjectType</i> (:String/:Int/:Float/:Object etc) after each variable. <br><br></td></tr></table><br>
<a name="856978"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >H&amp;K</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> How about when calling functions you can tell the compiler which one to use by calling it like this <br></div>Oh you mean explicitly casting ;) <br><br></td></tr></table><br>
<a name="857286"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> It could work by defining the return type of the function when you use it, in this instance:<br><br><pre class=code>Print PlayerInformation:String()
Local a:Int = PlayerInformation:Int()</pre><br> <br></div><br><br>For all intents and purposes, how is that different to :<br><pre class=code>
Print PlayerInformationString()
Local a:Int = PlayerInformationInt()
</pre><br><br>...where the functions have same base name, but different by something that lets you know what type they are. <br><br></td></tr></table><br>
<a name="857288"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> There is none especially with reflection that would allow<br><br>invoke(functionname + returnType, data) <br><br></td></tr></table><br>
<a name="859758"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Scaremonger</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> It's always bothered me why GET and a SET are coded seperately. <br><div class="quote"> <br>Type myType<br>	<br>	Field name:String Read getName write setName<br>	<br>	Method getName()<br>		return name<br>	End Method<br>	<br>	Method setName(value:String)<br>		If value.contains("trainers") Then<br>			RuntimeError("Sorry, no trainers allowed")<br>		Else<br>			Name = value<br>		EndIf<br>	End Method<br>	<br>End Type<br> <br></div><br>Sometimes it is required I agree, but I usually use a bit of code that I call a GETSET... Like this:<br><pre class=code>
Type myType
Field _name:String

	Method name:String(value:String=Null)
	Local result:String = _name
		If value Then _name = value
	Return result
	End Method
	
End Type
</pre>Simple and clean... <br><br></td></tr></table><br>
<a name="860651"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> Not sure why you have If indented. It's a nice idea, but you will always have an unused string somewhere whenever you use that method. <br><br></td></tr></table><br>
<a name="860652"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >plash</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> you will always have an unused string somewhere whenever you use that method <br></div><br>Given the example he has shown, yes mytype._name is never used but it probably would be in a real world application. <br><br></td></tr></table><br>
<a name="860771"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> you could turn it into the following if you are worried because of the unused string:<br><br><pre class=code>
Type myType
Field _name:String

	Method name:String(value:String=Null)
		Local result:String = _name
		If value 
			_name = value
			return null
		endif
		Return result
	End Method
	
End Type
</pre><br><br>this would return null whenever you use it as setter <br><br></td></tr></table><br>
<a name="860832"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >plash</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> or this:<br><pre class=code>Type myType

	Method name:String(value:String = Null)
	  Global getval:String
		If value
			getval = value
		  Return Null
		EndIf
		
	   Return getval
	End Method
	
End Type

Local mt:myType = New myType
	mt.name "test"
	Print mt.name()</pre><br>The only problem without using a built in solution is you can't do name = "blahblahblah" etc, you always have to use it as a method/function :/ <br><br></td></tr></table><br>
<a name="860839"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kistjes</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> Whats wrong with:<br><pre class=code>
Type MyType
	Field _name:String

	Method name:String(value:String = Null)
		If value Then _name = value
		Return _name
	End Method

End Type

</pre> <br><br></td></tr></table><br>
<a name="860902"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Scaremonger</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> Kistjes: Your version is good as long as you never want to set and save the old value in one hit.<br><br>For example:<br><br><pre class=code>
local oldvalue = myType.name( "newvalue" )
print oldvalue
</pre><br><br>It is very handy when you want to save a value temporarily and put it back the way it was later. Colour is a good example.<br><br>Also, the "unused" string is only unused if you never get the value. In which case it's pointless using this method which is by definition a GetSet. <br><br></td></tr></table><br>
<a name="860916"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Dreamora</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> Plash: Nice attempt. But it will not solve the issue with the not needed string reference that has to be collected if that was the idea of it (but it removes the need for the field in the type. Nice trick :) )<br><br>At least for the case of strings (not tested with object) it seems like NOT the string reference is given out but a clone of it. (varptr getval is different to varptr of the returned string which I stored in a different string object )<br><br>Scaremonger:<br>Well you won't want it to return the old one.<br>Whats the point of get / set if it does not what one expect:<br><br>Set: Sets the value<br>Get: Gets the <b>current</b> value<br><br>But as mentioned above, returning anything when you set means a lot of extra work for the GC when you use them more often as the object will always be returned and if you don't assign it, it means useless extra work for the GC to clean. With large strings a considerable issue. <br><br></td></tr></table><br>
<a name="861050"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >plash</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> Damn, this would be handy. <br><br></td></tr></table><br>
<a name="861061"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Czar Flavius</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here's a good way that's super efficient<br><pre class=code>Type  MyType
	Field name:String
End Type
..

type.name = "bob"
print type.name</pre><br>:) <br><br></td></tr></table><br>
<a name="861068"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >plash</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> Do you not understand how get/set was intended to be used? or are you just being sarcastic?<br><br>The purpose of the get/set bits of a field is used for playing around with the value thats coming in or doing something else along with setting or getting the value.<br><br>example:<br><pre class=code>Type myType

	Field otherfield:Float
		
		Method dostuff(fab:String, par:String)
			Print fab + " is being " + par
			'... do some other stuff
		End Method
		
		Method name:String(value:String = Null)
		  Global getval:String
			
			'set
			If value
				otherfield = 0.0002
				dostuff("name", "set!")
				getval = value + otherfield
			   Return Null
			EndIf
			
			'get
			dostuff("name", "requested!")
			otherfield = RndFloat()
		   Return getval
		End Method
		
End Type

Local mt:myType = New myType
	mt.name "test"
	Print mt.name()</pre> <br><br></td></tr></table><br>
<a name="861216"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Russell</td><td align="right"><font class=tiny>(Posted 2008)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> True, if you just change the value of a field directly like Czar Flavius says, no "action" is taken after the change because the functions or methods within the type are called after the change. In this case, it is better to have a set/get method/function that does the change, updates whatever it needs to and can also do bounds checking on the parameter as an extra precaution.<br><br>That being said, there are cases where Czar's example is valid and basically safe. ;)<br><br>Russell <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
