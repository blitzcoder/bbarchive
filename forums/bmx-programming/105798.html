<!DOCTYPE html><html lang="en" ><head ><title >Steam Overlay &amp; VirtualResolution Issue</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Steam Overlay &amp; VirtualResolution Issue</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Steam Overlay &amp; VirtualResolution Issue</a><br><br>
<a name="1294919"></a>

<a name="1294920"></a>

<a name="1294921"></a>

<a name="1294922"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi All,<br><br>When running the following code as a non-Steam game with the Steam Overlay I get graphics issues:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict

' -----------------------------------------------------------------------------
' USAGE: Note that the order is important!
' -----------------------------------------------------------------------------

' 1) Call InitVirtualGraphics before anything else;
' 2) Call Graphics as normal to create display;
' 3) Call SetVirtualGraphics to set virtual display size.

' The optional 'monitor_stretch' parameter of SetVirtualGraphics is there
' because some monitors have the option to stretch non-native ratios to native
' ratios, and you cannot detect this programmatically.

' For instance, my monitor's native resolution is 1920 x 1080, and if I set the
' Graphics mode to 1024, 768, it defaults to stretching that to fill the screen,
' meaning the image is stretched horizontally, so a square will appear non-
' square; however, it also provides an option to scale to the correct aspect
' ratio. Since this is set on the monitor, there's no way to detect or correct
' it other than by offering the option to the user. Leave it off if unsure...

' -----------------------------------------------------------------------------
' Copy this...
' -----------------------------------------------------------------------------

Type VirtualGfx

	Global VG:VirtualGfx
	
	Global DTInitComplete:Int = False
	Global DTW:Int
	Global DTH:Int

	Field vwidth:Int
	Field vheight:Int

	Field vxoff:Float
	Field vyoff:Float

	Field vscale:Float
	
	Global width:Float
	Global height:Float
	
	Function CreateVG:VirtualGfx (width:Int, height:Int)
		VG = New VirtualGfx
		VG.vwidth = width
		VG.vheight = height
	End Function
	
	Function SetVirtualGraphics (vwidth:Int, vheight:Int, monitor_stretch:Int = False)

		' InitVirtualGraphics has been called...
		
		If VirtualGfx.DTInitComplete
		
			' Graphics has been called...
			
			If GraphicsWidth () = 0 Or GraphicsHeight () = 0
				Notify "2 Programmer error! Must call Graphics before SetVirtualGraphics", True; End
			EndIf
			
		Else
			EndGraphics; Notify " 3 Programmer error! Call InitVirtualGraphics before Graphics!", True; End
		EndIf

		' Reset of display needed when re-calculating virtual graphics stuff/clearing borders...
			
		SetVirtualResolution GraphicsWidth (), GraphicsHeight ()
		SetViewport 0, 0, GraphicsWidth (), GraphicsHeight ()
		SetOrigin 0, 0

		' Store current Cls colours...
		
		Local clsr:Int, clsg:Int, clsb:Int
		GetClsColor clsr, clsg, clsb
		
		' Set to black...
		
		SetClsColor 0, 0, 0
		
		' Got to clear both front AND back buffers or it flickers if new display area is smaller...
		
		Cls
		Flip

		Cls
		Flip
		
		Cls
		Flip
		
		' EDIT, 10 Nov 2011: I had a 3rd Cls/Flip here in case triple-buffering was enabled, but have finally
		' tested this and it wasn't needed. (Tested on NVIDIA GTX 260, Windows 7, with driver
		' version 275.33.)

		' EDIT 2, 30 Dec 2011: Reinstated 3rd Cls/Flip for triple-buffering; see first thread comment!

		' Put back Cls colours...

		SetClsColor clsr, clsg, clsb
		
		' Create new (global) virtual display object...
		
		VirtualGfx.CreateVG (vwidth, vheight)
		
		' Real Graphics width/height...
		
		Local gwidth:Int
		Local gheight:Int
		
		' If monitor is correcting aspect ratio IN FULL-SCREEN MODE, use desktop size, otherwise use
		' specified Graphics size. NB. This assumes user's desktop is using native monitor resolution,
		' as most laptops would be by default...
		
		If monitor_stretch And GraphicsDepth ()

			' Pretend real Graphics mode is desktop width/height...

			gwidth = DTW
			gheight = DTH

		Else

			' Use real Graphics width/height...

			gwidth = GraphicsWidth ()
			gheight = GraphicsHeight ()

		EndIf
		
		' Width/height ratios...
		
		Local graphicsratio:Float = Float (gwidth) / Float (gheight)
		Local virtualratio:Float = Float (VirtualGfx.VG.vwidth) / Float (VirtualGfx.VG.vheight)
		
		' Ratio-to-ratio. Don't even know what you'd call this, but hours of trial and error
		' provided the right numbers in the end...
		
		Local gtovratio:Float = graphicsratio / virtualratio
		Local vtogratio:Float = virtualratio / graphicsratio
		
		' Compare ratios...

		If graphicsratio =&gt; virtualratio
			
			' Graphics ratio wider than (or same as) virtual graphics ratio...

			VirtualGfx.VG.vscale = Float (gheight) / Float (VirtualGfx.VG.vheight)
			
			' Now go crazy with trial-and-error... ooh, it works! This tiny bit of code took FOREVER.
			
			Local pixels:Float = Float (VirtualGfx.VG.vwidth) / (1.0 / VirtualGfx.VG.vscale) ' Width after scaling
			Local half_scale:Float = (1.0 / VirtualGfx.VG.vscale) / 2.0
			
			VirtualGfx.width = VirtualGfx.VG.vwidth * gtovratio
			VirtualGfx.height = VirtualGfx.VG.vheight
			
			SetVirtualResolution VirtualGfx.width, VirtualGfx.height

			' Offset into 'real' display area...
			
			VirtualGfx.VG.vxoff = (gwidth - pixels) * half_scale
			VirtualGfx.VG.vyoff = 0
		
			' Set up virtual graphics area...
			
			SetViewport VirtualGfx.VG.vxoff, VirtualGfx.VG.vyoff, VirtualGfx.VG.vwidth, VirtualGfx.VG.vheight
			SetOrigin VirtualGfx.VG.vxoff, VirtualGfx.VG.vyoff
			
		Else
			
			' Graphics ratio narrower...
		
			VirtualGfx.VG.vscale = Float (gwidth) / Float (VirtualGfx.VG.vwidth)
			
			Local pixels:Float = Float (VirtualGfx.VG.vheight) / (1.0 / VirtualGfx.VG.vscale) ' Height after scaling
			Local half_scale:Float = (1.0 / VirtualGfx.VG.vscale) / 2.0
			
			VirtualGfx.width = VirtualGfx.VG.vwidth
			VirtualGfx.height = VirtualGfx.VG.vheight * vtogratio
			
			SetVirtualResolution VirtualGfx.width, VirtualGfx.height
		
			VirtualGfx.VG.vxoff = 0
			VirtualGfx.VG.vyoff = (gheight - pixels) * half_scale
		
			SetViewport VirtualGfx.VG.vxoff, VirtualGfx.VG.vyoff, VirtualGfx.VG.vwidth, VirtualGfx.VG.vheight
			SetOrigin VirtualGfx.VG.vxoff, VirtualGfx.VG.vyoff
			
		EndIf
	
	End Function

	Method VMouseX:Float ()
		Local mx:Float = VirtualMouseX () - vxoff
		If mx &lt; 0 Then mx = 0 Else If mx &gt; vwidth - 1 Then mx = vwidth - 1
		Return mx
	End Method
	
	Method VMouseY:Float ()
		Local my:Float = VirtualMouseY () - vyoff
		If my &lt; 0 Then my = 0 Else If my &gt; vheight - 1 Then my = vheight - 1
		Return my
	End Method
	
	Method VirtualWidth:Int ()
		Return vwidth
	End Method

	Method VirtualHeight:Int ()
		Return vheight
	End Method
	
End Type

' -----------------------------------------------------------------------------
' ... and these helper functions (required)...
' -----------------------------------------------------------------------------

Function InitVirtualGraphics ()

	' There must be a smarter way to check if Graphics has been called...
	
	If GraphicsWidth () &gt; 0 Or GraphicsHeight () &gt; 0 Then EndGraphics; Notify " 1 Programmer error! Call InitVirtualGraphics BEFORE Graphics!", True; End

	VirtualGfx.DTW = DesktopWidth ()
	VirtualGfx.DTH = DesktopHeight ()

	' This only checks once... best to call InitVirtualGraphics again before any further Graphics calls (if you call EndGraphics at all)...
	
	VirtualGfx.DTInitComplete = True

End Function

Function SetVirtualGraphics (vwidth:Int, vheight:Int, monitor_stretch:Int = False)
	VirtualGfx.SetVirtualGraphics (vwidth, vheight, monitor_stretch)
End Function

Function VMouseX:Float ()
	Return VirtualGfx.VG.VMouseX ()
End Function

Function VMouseY:Float ()
	Return VirtualGfx.VG.VMouseY ()
End Function

' Don't need VirtualMouseXSpeed/YSpeed replacements!

Function VirtualWidth:Int ()
	Return VirtualGfx.VG.VirtualWidth ()
End Function

Function VirtualHeight:Int ()
	Return VirtualGfx.VG.VirtualHeight ()
End Function

' -----------------------------------------------------------------------------
' Don't copy after this...
' -----------------------------------------------------------------------------


Function SetDriver:Int(mode:Int)
	'0 = DirectX, 1 = OpenGL
	If mode = 0 Then
		'Don't do anything if Driver is already 0
		If Driver = 0 Then Return 0
		Driver = 0
	Else			
		'Don't do anything if Driver is already 0
		If Driver = 1 Then Return 0
		Driver = 1
	EndIf
	EndGraphics() 'safety
	
' I recommend calling this on the off-chance that the user's desktop size has changed...
		
		InitVirtualGraphics
		
		' Windowed/full-screen...
		
		
		If driver = DIRECTX_DRIVER Then
			SetGraphicsDriver D3D9Max2DDriver()
		Else
			SetGraphicsDriver GLMax2DDriver()
		End If
		
		If FULLSCREEN_TOGGLE
			Graphics fullscreenwidth, fullscreenheight, fullscreendepth
			SetVirtualGraphics 1280, 1024, monitor_adjusting
		Else
			Graphics windowedwidth, windowedheight, windoweddepth
			SetVirtualGraphics 1280, 1024
		EndIf
		
		' These get reset when exiting graphics mode...
		
		SetClsColor 64, 96, 128
		SetMaskColor 255, 0, 255
	Return 1
End Function



' -----------------------------------------------------------------------------
' D E M O . . .
' -----------------------------------------------------------------------------

' REQUIRED! BEFORE Graphics!

InitVirtualGraphics

' Toggle for demo's windowed/full-screen switching...

Global FULLSCREEN_TOGGLE:Int = True

' Change this if your monitor doesn't support it!

Global fullscreenwidth:Int = 1024
Global fullscreenheight:Int = 768
Global fullscreendepth:Int = 32

Global windowedwidth:Int = 640
Global windowedheight:Int = 400
Global windoweddepth:Int = 0
Const DIRECTX_DRIVER:Int = 0
Const OPENGL_DRIVER:Int = 1
Global driver:Int = DIRECTX_DRIVER

If driver = DIRECTX_DRIVER Then
	SetGraphicsDriver D3D9Max2DDriver()
Else
	SetGraphicsDriver GLMax2DDriver()
End If
		
Graphics fullscreenwidth, fullscreenheight, fullscreendepth

' If user's monitor is set to stretch to its native resolution, this needs to be set to True. I
' would recommend making this a selectable option in your game's configuration as there's no way
' to check this from any program...

Global monitor_adjusting:Int = True

' REQUIRED! AFTER InitVirtualGraphics!

SetVirtualGraphics 1280, 1024, monitor_adjusting

SetClsColor 64, 96, 128
SetMaskColor 255, 0, 255

' Some boxes...

Type Box
	Field x:Float, y:Float
	Field xs:Float, ys:Float
	Field size:Int
	Field r:Int, g:Int, b:Int
End Type

Local boxes:TList = CreateList ()

For Local loop:Int = 0 Until 100
	Local b:Box = New Box
	b.size = Rand (32)
	b.x = Rnd (VirtualWidth () - b.size)
	b.y = Rnd (VirtualHeight () - b.size)
	b.xs = Rnd (-4.0, 4.0)
	b.ys = Rnd (-4.0, 4.0)
	b.r = Rand (100, 255)
	b.g = Rand (100, 255)
	b.b = Rand (100, 255)
	ListAddLast boxes, b
Next

Repeat

	If KeyHit(KEY_G)
		SetDriver(Not driver)
	End If

	If FULLSCREEN_TOGGLE And KeyHit (KEY_RETURN)

		monitor_adjusting = 1 - monitor_adjusting
		SetVirtualGraphics 1280, 1024, monitor_adjusting

	EndIf
	
	If KeyHit (KEY_SPACE)

		FULLSCREEN_TOGGLE = 1 - FULLSCREEN_TOGGLE

		' Demo of how to change graphics mode...

		EndGraphics
		
		' I recommend calling this on the off-chance that the user's desktop size has changed...
		
		InitVirtualGraphics
		
		' Windowed/full-screen...
		
		If FULLSCREEN_TOGGLE
			Graphics fullscreenwidth, fullscreenheight, fullscreendepth
			SetVirtualGraphics 1280, 1024, monitor_adjusting
		Else
			Graphics windowedwidth, windowedheight, windoweddepth
			SetVirtualGraphics 1280, 1024
		EndIf
		
		' These get reset when exiting graphics mode...
		
		SetClsColor 64, 96, 128
		SetMaskColor 255, 0, 255
		
	EndIf
	
	Cls()
	
	SetScale 1, 1
	
			
	For Local b:Box = EachIn boxes
		b.x = b.x + b.xs
		b.y = b.y + b.ys
		If b.x &lt; 0 Or (b.x + b.size) &gt; VirtualWidth () Then b.xs = -b.xs; b.x = b.x + b.xs
		If b.y &lt; 0 Or (b.y + b.size) &gt; VirtualHeight () Then b.ys = -b.ys; b.y = b.y + b.ys
		SetColor b.r, b.g, b.b
		DrawRect b.x, b.y, b.size, b.size
	Next
	
	SetColor 255, 0, 0
	DrawRect 0, 0, 16, 16
	DrawRect 0, VirtualHeight () - 16, 16, 16
	DrawRect VirtualWidth () - 16, 0, 16, 16
	DrawRect VirtualWidth () - 16, VirtualHeight () - 16, 16, 16
	
	SetColor 0, 0, 255
	DrawOval VMouseX () - 32, VMouseY () - 32, 64, 64
	
	SetScale 4, 4
	SetColor 255, 255, 255
	DrawText "SPACE: Windowed/full-screen", 20, 20
	If FULLSCREEN_TOGGLE Then DrawText "ENTER: Monitor stretch correction", 20, 60
	If driver = DIRECTX_DRIVER
		DrawText "G to change Graphics Driver: DIRECTX", 20, 100
	Else
		DrawText "G to change Graphics Driver: OPENGL", 20, 100
	End If
	

	Flip
	
Until KeyHit (KEY_ESCAPE)

End</textarea><br><br>Does anyone know why or suggest a fix?<br><br>I can fix it by overloading the Cls call, but this hurts performance:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Function Cls()
	Local steam:Int = True
	If steam
		Local clsr:Int, clsg:Int, clsb:Int
		Local r:Int, g:Int, b:Int
		
		GetClsColor clsr, clsg, clsb
		GetColor r, g, b
		
		SetVirtualResolution GraphicsWidth (), GraphicsHeight ()
		SetViewport 0, 0, GraphicsWidth (), GraphicsHeight ()
		SetOrigin 0, 0
		SetClsColor 0, 0, 0
		brl.max2d.Cls()
		
		SetVirtualResolution VirtualGfx.width, VirtualGfx.height
		SetViewport VirtualGfx.VG.vxoff, VirtualGfx.VG.vyoff, VirtualGfx.VG.vwidth, VirtualGfx.VG.vheight
		SetOrigin VirtualGfx.VG.vxoff, VirtualGfx.VG.vyoff
		SetClsColor clsr, clsg, clsb
		SetColor r, g, b
		brl.max2d.Cls()
	Else
		brl.max2d.Cls()
	EndIf
End Function</textarea><br><br>If I use the DX11 driver I get a slightly different issue, the "cropped" section goes blue instead of black and if I go between the drivers I lose the oval which is following the mouse:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict
Import SRS.D3D11Max2D

' -----------------------------------------------------------------------------
' USAGE: Note that the order is important!
' -----------------------------------------------------------------------------

' 1) Call InitVirtualGraphics before anything else;
' 2) Call Graphics as normal to create display;
' 3) Call SetVirtualGraphics to set virtual display size.

' The optional 'monitor_stretch' parameter of SetVirtualGraphics is there
' because some monitors have the option to stretch non-native ratios to native
' ratios, and you cannot detect this programmatically.

' For instance, my monitor's native resolution is 1920 x 1080, and if I set the
' Graphics mode to 1024, 768, it defaults to stretching that to fill the screen,
' meaning the image is stretched horizontally, so a square will appear non-
' square; however, it also provides an option to scale to the correct aspect
' ratio. Since this is set on the monitor, there's no way to detect or correct
' it other than by offering the option to the user. Leave it off if unsure...

' -----------------------------------------------------------------------------
' Copy this...
' -----------------------------------------------------------------------------

Type VirtualGfx

	Global VG:VirtualGfx
	
	Global DTInitComplete:Int = False
	Global DTW:Int
	Global DTH:Int

	Field vwidth:Int
	Field vheight:Int

	Field vxoff:Float
	Field vyoff:Float

	Field vscale:Float
	
	Global width:Float
	Global height:Float
	
	Function CreateVG:VirtualGfx (width:Int, height:Int)
		VG = New VirtualGfx
		VG.vwidth = width
		VG.vheight = height
	End Function
	
	Function SetVirtualGraphics (vwidth:Int, vheight:Int, monitor_stretch:Int = False)

		' InitVirtualGraphics has been called...
		
		If VirtualGfx.DTInitComplete
		
			' Graphics has been called...
			
			If GraphicsWidth () = 0 Or GraphicsHeight () = 0
				Notify "2 Programmer error! Must call Graphics before SetVirtualGraphics", True; End
			EndIf
			
		Else
			EndGraphics; Notify " 3 Programmer error! Call InitVirtualGraphics before Graphics!", True; End
		EndIf

		' Reset of display needed when re-calculating virtual graphics stuff/clearing borders...
			
		SetVirtualResolution GraphicsWidth (), GraphicsHeight ()
		SetViewport 0, 0, GraphicsWidth (), GraphicsHeight ()
		SetOrigin 0, 0

		' Store current Cls colours...
		
		Local clsr:Int, clsg:Int, clsb:Int
		GetClsColor clsr, clsg, clsb
		
		' Set to black...
		
		SetClsColor 0, 0, 0
		
		' Got to clear both front AND back buffers or it flickers if new display area is smaller...
		
		Cls
		Flip

		Cls
		Flip
		
		Cls
		Flip
		
		' EDIT, 10 Nov 2011: I had a 3rd Cls/Flip here in case triple-buffering was enabled, but have finally
		' tested this and it wasn't needed. (Tested on NVIDIA GTX 260, Windows 7, with driver
		' version 275.33.)

		' EDIT 2, 30 Dec 2011: Reinstated 3rd Cls/Flip for triple-buffering; see first thread comment!

		' Put back Cls colours...

		SetClsColor clsr, clsg, clsb
		
		' Create new (global) virtual display object...
		
		VirtualGfx.CreateVG (vwidth, vheight)
		
		' Real Graphics width/height...
		
		Local gwidth:Int
		Local gheight:Int
		
		' If monitor is correcting aspect ratio IN FULL-SCREEN MODE, use desktop size, otherwise use
		' specified Graphics size. NB. This assumes user's desktop is using native monitor resolution,
		' as most laptops would be by default...
		
		If monitor_stretch And GraphicsDepth ()

			' Pretend real Graphics mode is desktop width/height...

			gwidth = DTW
			gheight = DTH

		Else

			' Use real Graphics width/height...

			gwidth = GraphicsWidth ()
			gheight = GraphicsHeight ()

		EndIf
		
		' Width/height ratios...
		
		Local graphicsratio:Float = Float (gwidth) / Float (gheight)
		Local virtualratio:Float = Float (VirtualGfx.VG.vwidth) / Float (VirtualGfx.VG.vheight)
		
		' Ratio-to-ratio. Don't even know what you'd call this, but hours of trial and error
		' provided the right numbers in the end...
		
		Local gtovratio:Float = graphicsratio / virtualratio
		Local vtogratio:Float = virtualratio / graphicsratio
		
		' Compare ratios...

		If graphicsratio =&gt; virtualratio
			
			' Graphics ratio wider than (or same as) virtual graphics ratio...

			VirtualGfx.VG.vscale = Float (gheight) / Float (VirtualGfx.VG.vheight)
			
			' Now go crazy with trial-and-error... ooh, it works! This tiny bit of code took FOREVER.
			
			Local pixels:Float = Float (VirtualGfx.VG.vwidth) / (1.0 / VirtualGfx.VG.vscale) ' Width after scaling
			Local half_scale:Float = (1.0 / VirtualGfx.VG.vscale) / 2.0
			
			VirtualGfx.width = VirtualGfx.VG.vwidth * gtovratio
			VirtualGfx.height = VirtualGfx.VG.vheight
			
			SetVirtualResolution VirtualGfx.width, VirtualGfx.height

			' Offset into 'real' display area...
			
			VirtualGfx.VG.vxoff = (gwidth - pixels) * half_scale
			VirtualGfx.VG.vyoff = 0
		
			' Set up virtual graphics area...
			
			SetViewport VirtualGfx.VG.vxoff, VirtualGfx.VG.vyoff, VirtualGfx.VG.vwidth, VirtualGfx.VG.vheight
			SetOrigin VirtualGfx.VG.vxoff, VirtualGfx.VG.vyoff
			
		Else
			
			' Graphics ratio narrower...
		
			VirtualGfx.VG.vscale = Float (gwidth) / Float (VirtualGfx.VG.vwidth)
			
			Local pixels:Float = Float (VirtualGfx.VG.vheight) / (1.0 / VirtualGfx.VG.vscale) ' Height after scaling
			Local half_scale:Float = (1.0 / VirtualGfx.VG.vscale) / 2.0
			
			VirtualGfx.width = VirtualGfx.VG.vwidth
			VirtualGfx.height = VirtualGfx.VG.vheight * vtogratio
			
			SetVirtualResolution VirtualGfx.width, VirtualGfx.height
		
			VirtualGfx.VG.vxoff = 0
			VirtualGfx.VG.vyoff = (gheight - pixels) * half_scale
		
			SetViewport VirtualGfx.VG.vxoff, VirtualGfx.VG.vyoff, VirtualGfx.VG.vwidth, VirtualGfx.VG.vheight
			SetOrigin VirtualGfx.VG.vxoff, VirtualGfx.VG.vyoff
			
		EndIf
	
	End Function

	Method VMouseX:Float ()
		Local mx:Float = VirtualMouseX () - vxoff
		If mx &lt; 0 Then mx = 0 Else If mx &gt; vwidth - 1 Then mx = vwidth - 1
		Return mx
	End Method
	
	Method VMouseY:Float ()
		Local my:Float = VirtualMouseY () - vyoff
		If my &lt; 0 Then my = 0 Else If my &gt; vheight - 1 Then my = vheight - 1
		Return my
	End Method
	
	Method VirtualWidth:Int ()
		Return vwidth
	End Method

	Method VirtualHeight:Int ()
		Return vheight
	End Method
	
End Type

' -----------------------------------------------------------------------------
' ... and these helper functions (required)...
' -----------------------------------------------------------------------------

Function InitVirtualGraphics ()

	' There must be a smarter way to check if Graphics has been called...
	
	If GraphicsWidth () &gt; 0 Or GraphicsHeight () &gt; 0 Then EndGraphics; Notify " 1 Programmer error! Call InitVirtualGraphics BEFORE Graphics!", True; End

	VirtualGfx.DTW = DesktopWidth ()
	VirtualGfx.DTH = DesktopHeight ()

	' This only checks once... best to call InitVirtualGraphics again before any further Graphics calls (if you call EndGraphics at all)...
	
	VirtualGfx.DTInitComplete = True

End Function

Function SetVirtualGraphics (vwidth:Int, vheight:Int, monitor_stretch:Int = False)
	VirtualGfx.SetVirtualGraphics (vwidth, vheight, monitor_stretch)
End Function

Function VMouseX:Float ()
	Return VirtualGfx.VG.VMouseX ()
End Function

Function VMouseY:Float ()
	Return VirtualGfx.VG.VMouseY ()
End Function

' Don't need VirtualMouseXSpeed/YSpeed replacements!

Function VirtualWidth:Int ()
	Return VirtualGfx.VG.VirtualWidth ()
End Function

Function VirtualHeight:Int ()
	Return VirtualGfx.VG.VirtualHeight ()
End Function

' -----------------------------------------------------------------------------
' Don't copy after this...
' -----------------------------------------------------------------------------


Function SetDriver:Int(mode:Int)
	'0 = DirectX9, 1=DX11, 2 = OpenGL
	If mode = 0 Then
		'Don't do anything if Driver is already 0
		If Driver = 0 Then Return 0
		Driver = 0
	EndIf
	
	If mode = 1 Then
		'Don't do anything if Driver is already 0
		If Driver = 1 Then Return 0
		Driver = 1
	EndIf
	
	If mode = 2
		'Don't do anything if Driver is already 0
		If Driver = 2 Then Return 0
		Driver = 2
	EndIf
	EndGraphics() 'safety
	
' I recommend calling this on the off-chance that the user's desktop size has changed...
		
		InitVirtualGraphics
		
		' Windowed/full-screen...
		
		
		If driver = 0 Then
			SetGraphicsDriver D3D9Max2DDriver()
		ElseIf driver = 1 Then
			SetGraphicsDriver D3D11Max2DDriver()
		Else
			SetGraphicsDriver GLMax2DDriver()
		End If
		
		If FULLSCREEN_TOGGLE
			Graphics fullscreenwidth, fullscreenheight, fullscreendepth
			SetVirtualGraphics 1280, 1024, monitor_adjusting
		Else
			Graphics windowedwidth, windowedheight, windoweddepth
			SetVirtualGraphics 1280, 1024
		EndIf
		
		' These get reset when exiting graphics mode...
		
		SetClsColor 64, 96, 128
		SetMaskColor 255, 0, 255
	Return 1
End Function



' -----------------------------------------------------------------------------
' D E M O . . .
' -----------------------------------------------------------------------------

' REQUIRED! BEFORE Graphics!

InitVirtualGraphics

' Toggle for demo's windowed/full-screen switching...

Global FULLSCREEN_TOGGLE:Int = True

' Change this if your monitor doesn't support it!

Global fullscreenwidth:Int = 1024
Global fullscreenheight:Int = 768
Global fullscreendepth:Int = 32

Global windowedwidth:Int = 640
Global windowedheight:Int = 400
Global windoweddepth:Int = 0
Const DIRECTX_DRIVER:Int = 0
Const OPENGL_DRIVER:Int = 1
Global driver:Int = DIRECTX_DRIVER

If driver = 0 Then
	SetGraphicsDriver D3D9Max2DDriver()
ElseIf driver = 1 Then
	SetGraphicsDriver D3D11Max2DDriver()
Else
	SetGraphicsDriver GLMax2DDriver()
End If
		
Graphics fullscreenwidth, fullscreenheight, fullscreendepth

' If user's monitor is set to stretch to its native resolution, this needs to be set to True. I
' would recommend making this a selectable option in your game's configuration as there's no way
' to check this from any program...

Global monitor_adjusting:Int = True

' REQUIRED! AFTER InitVirtualGraphics!

SetVirtualGraphics 1280, 1024, monitor_adjusting

SetClsColor 64, 96, 128
SetMaskColor 255, 0, 255

' Some boxes...

Type Box
	Field x:Float, y:Float
	Field xs:Float, ys:Float
	Field size:Int
	Field r:Int, g:Int, b:Int
End Type

Local boxes:TList = CreateList ()

For Local loop:Int = 0 Until 100
	Local b:Box = New Box
	b.size = Rand (32)
	b.x = Rnd (VirtualWidth () - b.size)
	b.y = Rnd (VirtualHeight () - b.size)
	b.xs = Rnd (-4.0, 4.0)
	b.ys = Rnd (-4.0, 4.0)
	b.r = Rand (100, 255)
	b.g = Rand (100, 255)
	b.b = Rand (100, 255)
	ListAddLast boxes, b
Next

Local d:Int = 0

Repeat
	If KeyHit(KEY_G)
		d:+1
		If d&gt;2 Then d = 0
		SetDriver(d)
	End If

	If FULLSCREEN_TOGGLE And KeyHit (KEY_RETURN)

		monitor_adjusting = 1 - monitor_adjusting
		SetVirtualGraphics 1280, 1024, monitor_adjusting

	EndIf
	
	If KeyHit (KEY_SPACE)

		FULLSCREEN_TOGGLE = 1 - FULLSCREEN_TOGGLE

		' Demo of how to change graphics mode...

		EndGraphics
		
		' I recommend calling this on the off-chance that the user's desktop size has changed...
		
		InitVirtualGraphics
		
		' Windowed/full-screen...
		
		If FULLSCREEN_TOGGLE
			Graphics fullscreenwidth, fullscreenheight, fullscreendepth
			SetVirtualGraphics 1280, 1024, monitor_adjusting
		Else
			Graphics windowedwidth, windowedheight, windoweddepth
			SetVirtualGraphics 1280, 1024
		EndIf
		
		' These get reset when exiting graphics mode...
		
		SetClsColor 64, 96, 128
		SetMaskColor 255, 0, 255
		
	EndIf
	
	Cls()
	
	SetScale 1, 1
	
			
	For Local b:Box = EachIn boxes
		b.x = b.x + b.xs
		b.y = b.y + b.ys
		If b.x &lt; 0 Or (b.x + b.size) &gt; VirtualWidth () Then b.xs = -b.xs; b.x = b.x + b.xs
		If b.y &lt; 0 Or (b.y + b.size) &gt; VirtualHeight () Then b.ys = -b.ys; b.y = b.y + b.ys
		SetColor b.r, b.g, b.b
		DrawRect b.x, b.y, b.size, b.size
	Next
	
	SetColor 255, 0, 0
	DrawRect 0, 0, 16, 16
	DrawRect 0, VirtualHeight () - 16, 16, 16
	DrawRect VirtualWidth () - 16, 0, 16, 16
	DrawRect VirtualWidth () - 16, VirtualHeight () - 16, 16, 16
	
	SetColor 0, 0, 255
	DrawOval VMouseX () - 32, VMouseY () - 32, 64, 64
	
	SetScale 4, 4
	SetColor 255, 255, 255
	DrawText "SPACE: Windowed/full-screen", 20, 20
	If FULLSCREEN_TOGGLE Then DrawText "ENTER: Monitor stretch correction", 20, 60
	If driver = 0
		DrawText "G to change Graphics Driver: DIRECTX9", 20, 100
	ElseIf driver = 1
		DrawText "G to change Graphics Driver: DIRECTX11", 20, 100
	Else
		DrawText "G to change Graphics Driver: OPENGL", 20, 100
	End If
	DrawText "Mouse : " + MouseX() +","+MouseY(), 20, 160	
	DrawText "VMouse: " + VMouseX () +","+VMouseY (), 20, 220	

	Flip
	
Until KeyHit (KEY_ESCAPE)

End
</textarea><br><br>Thanks,<br>Steve <br><br></td></tr></table><br>
<a name="1295058"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hiya Steve,<br><br>I've corrected a bug in the d3d11 code thats related to the blue oval issue. I'll look into the borders over the weekend.<br><br>There appears to be some minor bugs in the NG version when using this test code. It'll help me track those down too.<br><br>Whats the graphics issue that you're getting with the other drivers? I don't see anything obvious here. <br><br></td></tr></table><br>
<a name="1295062"></a>

<a name="1295063"></a>

<a name="1295064"></a>

<a name="1295067"></a>

<a name="1295068"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for looking :)<br><br><div class="quote"> Whats the graphics issue that you're getting with the other drivers? I don't see anything obvious here.  <br></div><br><br>Did you add the exe to Steam? When showing/hiding the Steam Overlay, the OpenGL driver has graphics corruption and the DX9/DX11 has similar border issues. With DX9 the images outside the virtual res are still displayed. <br><br>OpenGL just after hiding Steam Overlay:<br><img src="https://dl.dropboxusercontent.com/u/35103024/mx/opengl_steam_overlay.JPG"><br><br>DX9 before Steam Overlay:<br><img src="https://dl.dropboxusercontent.com/u/35103024/mx/dx9_steam_overlay_1.JPG"><br>DX9 after Steam Overlay (notice you can see the full oval even thought its at zero):<br><img src="https://dl.dropboxusercontent.com/u/35103024/mx/dx9_steam_overlay_2.JPG"> <br><br></td></tr></table><br>
<a name="1295129"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >dw817</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Therevills, don't forget everyone is using a different resolution. If you are writing absolute pixel coordinates and elements to hide the background of ads for whatever reason, it may not work - or even get worse results on some platforms.<br><br>As for me in my 1024x768 screen, ran just fine. :) <br><br></td></tr></table><br>
<a name="1295237"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote">  don't forget everyone is using a different resolution <br></div><br><br>That's why I use a virtual resolution and it works perfect, but for Steam I have this small issue with the Steam Overlay. <br><br></td></tr></table><br>
<a name="1295247"></a>

<a name="1295248"></a>

<a name="1295267"></a>

<a name="1295269"></a>

<a name="1295270"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >grable</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> You can sortof detect the overlay by loading GameOverlayRenderer.dll and calling some of the functions in it.<br>And through that know when to overload <b>Cls</b>. Its more of a quick fix though, as it should work.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Const STEAM_GAMEOVERLAY_RENDDER_DLL:String = "GameOverlayRenderer.dll"
Const STEAM_DEFAULT_PATH:String = "C:\Program Files (x86)\Steam"


' 0 = top-left
' 1 = top-right
' 2 = bottom-left
' 3 = bottom-right
Global SetNotificationPosition( corner:Int)
Global SetNotificationInset( enabled:Int)
Global IsOverlayEnabled:Int()
Global OverlayHookD3D3:Byte Ptr()
Global BOverlayNeedsPresent:Int()
Global SteamOverlayIsUsingGamepad:Int()
Global SteamOverlayIsUsingKeyboard:Int()
Global SteamOverlayIsUsingMouse:Int()
Private
Global OverlayDLL:Int
Public

Function LoadSteamOverlay:Int( path:String = Null)
	If OverlayDLL Then Return True
	
	If Not path Then path = STEAM_DEFAULT_PATH
	path :+ "\" + STEAM_GAMEOVERLAY_RENDDER_DLL

	OverlayDLL = LoadLibraryA(path)
	If OverlayDLL = 0 Then Return False
	
	SetNotificationPosition = GetProcAddress( OverlayDLL, "SetNotificationPosition")
	SetNotificationInset = GetProcAddress( OverlayDLL, "SetNotificationInset")
	IsOverlayEnabled = GetProcAddress( OverlayDLL, "IsOverlayEnabled")	
	OverlayHookD3D3 = GetProcAddress( OverlayDLL, "OverlayHookD3D3")
	BOverlayNeedsPresent = GetProcAddress( OverlayDLL, "BOverlayNeedsPresent")
	SteamOverlayIsUsingGamepad = GetProcAddress( OverlayDLL, "SteamOverlayIsUsingGamepad")
	SteamOverlayIsUsingKeyboard = GetProcAddress( OverlayDLL, "SteamOverlayIsUsingKeyboard")
	SteamOverlayIsUsingMouse = GetProcAddress( OverlayDLL, "SteamOverlayIsUsingMouse")
	
	Return True
EndFunction

Function UnloadSteamOverlay()
	Extern "Win32"
		Function FreeLibrary( lib:Int)
	EndExtern
	
	If Not OverlayDLL Then Return

	FreeLibrary(OverlayDLL)
	SetNotificationPosition = Null
	IsOverlayEnabled = Null
	BOverlayNeedsPresent = Null
	OverlayHookD3D3 = Null
	SteamOverlayIsUsingGamepad = Null
	SteamOverlayIsUsingKeyboard = Null
	SteamOverlayIsUsingMouse = Null
	OverlayDLL = 0
EndFunction

Function IsSteamOverlayActive:Int()
	If Not OverlayDLL Or Not IsOverlayEnabled() Then Return False
	Return SteamOverlayIsUsingGamepad() Or SteamOverlayIsUsingKeyboard() Or SteamOverlayIsUsingMouse()
EndFunction
</textarea><br>Doing this will also load the steam overlay without having to run it through steam, as the dll does the hooking when its loaded.<br>It doesnt work with D3D9 unless running it through steam for some reason.<br><br>EDIT:<br>Even though it loads the overlay this way, it will not notify steam about it. But the overlay is still usable.<br>And using the SteamOverlayIsUsingXXX() isnt perfect, my tests show it doesnt work correctly with OpenGL as they allways return True.<br><br>Its too bad they havent added more functions to control the overlay really, like an IsOverlayActive() or ShowOverlay().<br>One has to resort to reversing it and hooking huge and confusing object hierarchies to able to do anything like that, and they have a tendency to change things in updates and then having to re-reverse everything :( <br><br></td></tr></table><br>
<a name="1295330"></a>

<a name="1295331"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> If I use the DX11 driver I get a slightly different issue, the "cropped" section goes blue instead of black and if I go between the drivers I lose the oval which is following the mouse: <br></div><br><br>The oval and alt-tab issues were bugs and should now be fixed.<br>The cropped vertical bars... hmm... MSDN states the full size of the back buffer will be cleared to the colour specified, ie the ClsColor and the viewport/scissor settings for the rasterizer will be ignored. Why that did that I shall never know. Dx9 and OpenGL take those viewport and scissor settings into consideration. I have a possible solution for this.<br><br>The Steam overlay is another issue. <br><br></td></tr></table><br>
<a name="1295339"></a>

<a name="1295340"></a>

<a name="1295342"></a>

<a name="1295343"></a>

<a name="1295347"></a>

<a name="1295349"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Does anyone know why? <br></div><br>Steam is changing the scissor rectangle settings for the gpu, and not resetting them to what they were before it changed them. I guess you could blame Steam for this.<br><br>In your example that includes Dx11 if you replace from Line 461 with these couple of lines you can see it changing for Dx9 when the Steam overlays come in.<br><br>[edit]use this example[/edit]<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict
Import SRS.D3D11Max2D
Global g:TGraphics

' -----------------------------------------------------------------------------
' USAGE: Note that the order is important!
' -----------------------------------------------------------------------------

' 1) Call InitVirtualGraphics before anything else;
' 2) Call Graphics as normal to create display;
' 3) Call SetVirtualGraphics to set virtual display size.

' The optional 'monitor_stretch' parameter of SetVirtualGraphics is there
' because some monitors have the option to stretch non-native ratios to native
' ratios, and you cannot detect this programmatically.

' For instance, my monitor's native resolution is 1920 x 1080, and if I set the
' Graphics mode to 1024, 768, it defaults to stretching that to fill the screen,
' meaning the image is stretched horizontally, so a square will appear non-
' square; however, it also provides an option to scale to the correct aspect
' ratio. Since this is set on the monitor, there's no way to detect or correct
' it other than by offering the option to the user. Leave it off if unsure...

' -----------------------------------------------------------------------------
' Copy this...
' -----------------------------------------------------------------------------

Type VirtualGfx

	Global VG:VirtualGfx
	
	Global DTInitComplete:Int = False
	Global DTW:Int
	Global DTH:Int

	Field vwidth:Int
	Field vheight:Int

	Field vxoff:Float
	Field vyoff:Float

	Field vscale:Float
	
	Global width:Float
	Global height:Float
	
	Function CreateVG:VirtualGfx (width:Int, height:Int)
		VG = New VirtualGfx
		VG.vwidth = width
		VG.vheight = height
	End Function
	
	Function SetVirtualGraphics (vwidth:Int, vheight:Int, monitor_stretch:Int = False)

		' InitVirtualGraphics has been called...
		
		If VirtualGfx.DTInitComplete
		
			' Graphics has been called...
			
			If GraphicsWidth () = 0 Or GraphicsHeight () = 0
				Notify "2 Programmer error! Must call Graphics before SetVirtualGraphics", True; End
			EndIf
			
		Else
			EndGraphics; Notify " 3 Programmer error! Call InitVirtualGraphics before Graphics!", True; End
		EndIf

		' Reset of display needed when re-calculating virtual graphics stuff/clearing borders...
			
		SetVirtualResolution GraphicsWidth (), GraphicsHeight ()
		SetViewport 0, 0, GraphicsWidth (), GraphicsHeight ()
		SetOrigin 0, 0

		' Store current Cls colours...
		
		Local clsr:Int, clsg:Int, clsb:Int
		GetClsColor clsr, clsg, clsb
		
		' Set to black...
		
		SetClsColor 0, 0, 0
		
		' Got to clear both front AND back buffers or it flickers if new display area is smaller...
		
		Cls
		Flip

		Cls
		Flip
		
		Cls
		Flip
		
		' EDIT, 10 Nov 2011: I had a 3rd Cls/Flip here in case triple-buffering was enabled, but have finally
		' tested this and it wasn't needed. (Tested on NVIDIA GTX 260, Windows 7, with driver
		' version 275.33.)

		' EDIT 2, 30 Dec 2011: Reinstated 3rd Cls/Flip for triple-buffering; see first thread comment!

		' Put back Cls colours...

		SetClsColor clsr, clsg, clsb
		
		' Create new (global) virtual display object...
		
		VirtualGfx.CreateVG (vwidth, vheight)
		
		' Real Graphics width/height...
		
		Local gwidth:Int
		Local gheight:Int
		
		' If monitor is correcting aspect ratio IN FULL-SCREEN MODE, use desktop size, otherwise use
		' specified Graphics size. NB. This assumes user's desktop is using native monitor resolution,
		' as most laptops would be by default...
		
		If monitor_stretch And GraphicsDepth ()

			' Pretend real Graphics mode is desktop width/height...

			gwidth = DTW
			gheight = DTH

		Else

			' Use real Graphics width/height...

			gwidth = GraphicsWidth ()
			gheight = GraphicsHeight ()

		EndIf
		
		' Width/height ratios...
		
		Local graphicsratio:Float = Float (gwidth) / Float (gheight)
		Local virtualratio:Float = Float (VirtualGfx.VG.vwidth) / Float (VirtualGfx.VG.vheight)
		
		' Ratio-to-ratio. Don't even know what you'd call this, but hours of trial and error
		' provided the right numbers in the end...
		
		Local gtovratio:Float = graphicsratio / virtualratio
		Local vtogratio:Float = virtualratio / graphicsratio
		
		' Compare ratios...

		If graphicsratio =&gt; virtualratio
			
			' Graphics ratio wider than (or same as) virtual graphics ratio...

			VirtualGfx.VG.vscale = Float (gheight) / Float (VirtualGfx.VG.vheight)
			
			' Now go crazy with trial-and-error... ooh, it works! This tiny bit of code took FOREVER.
			
			Local pixels:Float = Float (VirtualGfx.VG.vwidth) / (1.0 / VirtualGfx.VG.vscale) ' Width after scaling
			Local half_scale:Float = (1.0 / VirtualGfx.VG.vscale) / 2.0
			
			VirtualGfx.width = VirtualGfx.VG.vwidth * gtovratio
			VirtualGfx.height = VirtualGfx.VG.vheight
			
			SetVirtualResolution VirtualGfx.width, VirtualGfx.height

			' Offset into 'real' display area...
			
			VirtualGfx.VG.vxoff = (gwidth - pixels) * half_scale
			VirtualGfx.VG.vyoff = 0
		
			' Set up virtual graphics area...
			
			SetViewport VirtualGfx.VG.vxoff, VirtualGfx.VG.vyoff, VirtualGfx.VG.vwidth, VirtualGfx.VG.vheight
			SetOrigin VirtualGfx.VG.vxoff, VirtualGfx.VG.vyoff
			Cls
			
		Else
			
			' Graphics ratio narrower...
		
			VirtualGfx.VG.vscale = Float (gwidth) / Float (VirtualGfx.VG.vwidth)
			
			Local pixels:Float = Float (VirtualGfx.VG.vheight) / (1.0 / VirtualGfx.VG.vscale) ' Height after scaling
			Local half_scale:Float = (1.0 / VirtualGfx.VG.vscale) / 2.0
			
			VirtualGfx.width = VirtualGfx.VG.vwidth
			VirtualGfx.height = VirtualGfx.VG.vheight * vtogratio
			
			SetVirtualResolution VirtualGfx.width, VirtualGfx.height
		
			VirtualGfx.VG.vxoff = 0
			VirtualGfx.VG.vyoff = (gheight - pixels) * half_scale
		
			SetViewport VirtualGfx.VG.vxoff, VirtualGfx.VG.vyoff, VirtualGfx.VG.vwidth, VirtualGfx.VG.vheight
			SetOrigin VirtualGfx.VG.vxoff, VirtualGfx.VG.vyoff
			Cls
		EndIf
	
	End Function

	Method VMouseX:Float ()
		Local mx:Float = VirtualMouseX () - vxoff
		If mx &lt; 0 Then mx = 0 Else If mx &gt; vwidth - 1 Then mx = vwidth - 1
		Return mx
	End Method
	
	Method VMouseY:Float ()
		Local my:Float = VirtualMouseY () - vyoff
		If my &lt; 0 Then my = 0 Else If my &gt; vheight - 1 Then my = vheight - 1
		Return my
	End Method
	
	Method VirtualWidth:Int ()
		Return vwidth
	End Method

	Method VirtualHeight:Int ()
		Return vheight
	End Method
	
End Type

' -----------------------------------------------------------------------------
' ... and these helper functions (required)...
' -----------------------------------------------------------------------------

Function InitVirtualGraphics ()

	' There must be a smarter way to check if Graphics has been called...
	
	If GraphicsWidth () &gt; 0 Or GraphicsHeight () &gt; 0 Then EndGraphics; Notify " 1 Programmer error! Call InitVirtualGraphics BEFORE Graphics!", True; End

	VirtualGfx.DTW = DesktopWidth ()
	VirtualGfx.DTH = DesktopHeight ()

	' This only checks once... best to call InitVirtualGraphics again before any further Graphics calls (if you call EndGraphics at all)...
	
	VirtualGfx.DTInitComplete = True

End Function

Function SetVirtualGraphics (vwidth:Int, vheight:Int, monitor_stretch:Int = False)
	VirtualGfx.SetVirtualGraphics (vwidth, vheight, monitor_stretch)
End Function

Function VMouseX:Float ()
	Return VirtualGfx.VG.VMouseX ()
End Function

Function VMouseY:Float ()
	Return VirtualGfx.VG.VMouseY ()
End Function

' Don't need VirtualMouseXSpeed/YSpeed replacements!

Function VirtualWidth:Int ()
	Return VirtualGfx.VG.VirtualWidth ()
End Function

Function VirtualHeight:Int ()
	Return VirtualGfx.VG.VirtualHeight ()
End Function

' -----------------------------------------------------------------------------
' Don't copy after this...
' -----------------------------------------------------------------------------


Function SetDriver:Int(mode:Int)
	'0 = DirectX9, 1=DX11, 2 = OpenGL
	If mode = 0 Then
		'Don't do anything if Driver is already 0
		If Driver = 0 Then Return 0
		Driver = 0
	EndIf
	
	If mode = 1 Then
		'Don't do anything if Driver is already 0
		If Driver = 1 Then Return 0
		Driver = 1
	EndIf
	
	If mode = 2
		'Don't do anything if Driver is already 0
		If Driver = 2 Then Return 0
		Driver = 2
	EndIf
	EndGraphics() 'safety
	
' I recommend calling this on the off-chance that the user's desktop size has changed...
		
		InitVirtualGraphics
		
		' Windowed/full-screen...
		
		
		If driver = 0 Then
			SetGraphicsDriver D3D9Max2DDriver()
		ElseIf driver = 1 Then
			SetGraphicsDriver D3D11Max2DDriver()
		Else
			SetGraphicsDriver GLMax2DDriver()
		End If
		
		If FULLSCREEN_TOGGLE
			g=Graphics (fullscreenwidth, fullscreenheight, fullscreendepth)
			SetVirtualGraphics 1280, 1024, monitor_adjusting
		Else
			g=Graphics (windowedwidth, windowedheight, windoweddepth)
			SetVirtualGraphics 1280, 1024
		EndIf
		
		' These get reset when exiting graphics mode...
		
		SetClsColor 64, 96, 128
		SetMaskColor 255, 0, 255
	Return 1
End Function



' -----------------------------------------------------------------------------
' D E M O . . .
' -----------------------------------------------------------------------------

' REQUIRED! BEFORE Graphics!

InitVirtualGraphics

' Toggle for demo's windowed/full-screen switching...

Global FULLSCREEN_TOGGLE:Int = True

' Change this if your monitor doesn't support it!

Global fullscreenwidth:Int = 1024
Global fullscreenheight:Int = 768
Global fullscreendepth:Int = 32

Global windowedwidth:Int = 640
Global windowedheight:Int = 400
Global windoweddepth:Int = 0
Const DIRECTX_DRIVER:Int = 0
Const OPENGL_DRIVER:Int = 1
Global driver:Int = DIRECTX_DRIVER

If driver = 0 Then
	SetGraphicsDriver D3D9Max2DDriver()
ElseIf driver = 1 Then
	SetGraphicsDriver D3D11Max2DDriver()
Else
	SetGraphicsDriver GLMax2DDriver()
End If

g=Graphics (windowedwidth, windowedheight, windoweddepth)

' If user's monitor is set to stretch to its native resolution, this needs to be set to True. I
' would recommend making this a selectable option in your game's configuration as there's no way
' to check this from any program...

Global monitor_adjusting:Int = False

' REQUIRED! AFTER InitVirtualGraphics!
SetVirtualGraphics 1280, 1024, monitor_adjusting

SetClsColor 64, 96, 128
SetMaskColor 255, 0, 255

' Some boxes...

Type Box
	Field x:Float, y:Float
	Field xs:Float, ys:Float
	Field size:Int
	Field r:Int, g:Int, b:Int
End Type

Local boxes:TList = CreateList ()

For Local loop:Int = 0 Until 100
	Local b:Box = New Box
	b.size = Rand (32)
	b.x = Rnd (VirtualWidth () - b.size)
	b.y = Rnd (VirtualHeight () - b.size)
	b.xs = Rnd (-4.0, 4.0)
	b.ys = Rnd (-4.0, 4.0)
	b.r = Rand (100, 255)
	b.g = Rand (100, 255)
	b.b = Rand (100, 255)
	ListAddLast boxes, b
Next

Local d:Int = 0

Repeat
	If KeyHit(KEY_G)
		d:+1
		If d&gt;2 Then d = 0
		SetDriver(d)
	End If

	If FULLSCREEN_TOGGLE And KeyHit (KEY_RETURN)

		monitor_adjusting = 1 - monitor_adjusting
		SetVirtualGraphics 1280, 1024, monitor_adjusting

	EndIf
	
	If KeyHit (KEY_SPACE)

		FULLSCREEN_TOGGLE = 1 - FULLSCREEN_TOGGLE

		' Demo of how to change graphics mode...

		EndGraphics
		
		' I recommend calling this on the off-chance that the user's desktop size has changed...
		
		InitVirtualGraphics
		
		' Windowed/full-screen...
		
		If FULLSCREEN_TOGGLE
			g=Graphics (fullscreenwidth, fullscreenheight, fullscreendepth)
			SetVirtualGraphics 1280, 1024, monitor_adjusting
		Else
			g=Graphics (windowedwidth, windowedheight, windoweddepth)
			SetVirtualGraphics 1280, 1024
		EndIf
		
		' These get reset when exiting graphics mode...
		
		SetClsColor 64, 96, 128
		SetMaskColor 255, 0, 255
		
	EndIf	
	
	Cls
	SetScale 1, 1
			
	For Local b:Box = EachIn boxes
		b.x = b.x + b.xs
		b.y = b.y + b.ys
		If b.x &lt; 0 Or (b.x + b.size) &gt; VirtualWidth () Then b.xs = -b.xs; b.x = b.x + b.xs
		If b.y &lt; 0 Or (b.y + b.size) &gt; VirtualHeight () Then b.ys = -b.ys; b.y = b.y + b.ys
		SetColor b.r, b.g, b.b
		DrawRect b.x, b.y, b.size, b.size
	Next
	
	SetColor 255, 0, 0
	DrawRect 0, 0, 16, 16
	DrawRect 0, VirtualHeight () - 16, 16, 16
	DrawRect VirtualWidth () - 16, 0, 16, 16
	DrawRect VirtualWidth () - 16, VirtualHeight () - 16, 16, 16
	
	SetColor 0, 0, 255
	DrawOval VMouseX () - 32, VMouseY () - 32, 64, 64
	
	SetScale 4, 4
	SetColor 255, 255, 255
	DrawText "SPACE: Windowed/full-screen", 20, 20
	If FULLSCREEN_TOGGLE Then DrawText "ENTER: Monitor stretch correction", 20, 60
	
	If driver = 0
		DrawText "G to change Graphics Driver: DIRECTX9", 20, 100
		
		Local gd3d:TD3D9Graphics = TD3D9Graphics(TMax2dGraphics(g)._graphics)
		Local d3ddev:IDirect3DDevice9 = gd3d.GetDirect3DDevice()
		Local rect:Int[4]
		d3ddev.GetScissorRect(rect)
		DrawText "X: " + rect[0],20,300
		DrawText "Y: " + rect[1],20,340
		DrawText "W: " + rect[2],20,380
		DrawText "H: " + rect[3],20,420
		
	ElseIf driver = 1
		DrawText "G to change Graphics Driver: DIRECTX11", 20, 100
	Else
		DrawText "G to change Graphics Driver: OPENGL", 20, 100
	End If
	DrawText "Mouse : " + MouseX() +","+MouseY(), 20, 160	
	DrawText "VMouse: " + VMouseX () +","+VMouseY (), 20, 220	

	Flip
Until KeyHit (KEY_ESCAPE)

End

</textarea><br><br>For me pressing Enter to invoke the ratio change fixes it. Now to find a sensible solution... <br><br></td></tr></table><br>
<a name="1295345"></a>

<a name="1295346"></a>

<a name="1295350"></a>

<a name="1295395"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> @grable - thanks for trying :)<br><br>Nice find and I would love to blame Steam, but need to find a better fix than my overloaded CLS :)<br><br>In your code what is "g"? I tried Local g:TGraphicsDriver =  GetGraphicsDriver(), but it still didnt compile.<br> <br>Cheers,<br>Steve<br><br>[edit: found it... g is Global g:TGraphics :) ] <br><br></td></tr></table><br>
<a name="1295348"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> I just thought of 'g' and no one would know so I've changed the code in my post to the complete working example :D <br><br></td></tr></table><br>
<a name="1295356"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks Dave - okay on my machine before Steam Overlay is displayed:<br><br>Viewport X: 69<br>Viewport Y: 0<br>Viewport W: 569<br>Viewport H: 400<br><br>After Steam Overlay:<br><br>Viewport X: 0<br>Viewport Y: 0<br>Viewport W: 640<br>Viewport H: 400<br><br>Do you know what the equivalent for DX11 and OpenGL for IDirect3DDevice9?<br><pre class=code>	Local gd3d:TD3D11Graphics = TD3D11Graphics(TMax2dGraphics(g)._graphics)
	Local d3ddev:IDirect3DDevice11 = gd3d.GetDirect3DDevice()</pre><br><br>Cheers,<br>Steve <br><br></td></tr></table><br>
<a name="1295357"></a>

<a name="1295358"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just thought of a really simple (hack) solution for DX9 and DX11... draw black rects outside the virtual resolution, not perfect but should be faster than my overloaded CLS.<br><br>Doesnt work for OpenGL though... <br><br></td></tr></table><br>
<a name="1295361"></a>

<a name="1295362"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> D3D11 would be<br><br><pre class=code>
Local gd3d:TD3D11Graphics = TD3D11Graphics(TMax2dGraphics(g)._graphics)
		Local d3ddev:ID3D11DeviceContext = gd3d.GetDirect3DDeviceContext()
		Local rect:Int[4]
		Local count:Int
		d3ddev.RSGetScissorRects(count,Null)
		d3ddev.RSGetScissorRects(count,rect)

		DrawText "Viewport X: " + rect[0],20,300
		DrawText "Viewport Y: " + rect[1],20,340
		DrawText "Viewport W: " + rect[2],20,380
		DrawText "Viewport H: " + rect[3],20,420
</pre><br><br><div class="quote"> Just thought of a really simple (hack) <br></div><br>Do you have that working already? <br><br></td></tr></table><br>
<a name="1295381"></a>

<a name="1295382"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> D3D11 would be <br></div><br><br>Ah, quite different... Ta :) <br><br>DX11 without Steam:<br><br>Viewport X: 0<br>Viewport Y: 0<br>Viewport W: 640<br>Viewport H: 400<br><br><div class="quote"> Do you have that working already?  <br></div><br>Not yet, been out shopping ;) <br><br></td></tr></table><br>
<a name="1295388"></a>

<a name="1295391"></a>

<a name="1295393"></a>

<a name="1295402"></a>

<a name="1295403"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> Been testing with DX7 as well, it has the same issue as OpenGL,  so I draw black rects for DX9 and DX11, but still do my CLS overload for OpenGL and DX7. Which means slow downs for OpenGL and DX7 :(<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict
Import SRS.D3D11Max2D

Extern "win32"
	Function GetActiveWindow%()
End Extern

Type VirtualGfx

	Global VG:VirtualGfx
	
	Global DTInitComplete:Int = False
	Global DTW:Int
	Global DTH:Int

	Field vwidth:Int
	Field vheight:Int

	Field vxoff:Float
	Field vyoff:Float

	Field vscale:Float
	
	Global width:Float
	Global height:Float
	
	Function CreateVG:VirtualGfx (width:Int, height:Int)
		VG = New VirtualGfx
		VG.vwidth = width
		VG.vheight = height
	End Function
	
	Function SetVirtualGraphics (vwidth:Int, vheight:Int, monitor_stretch:Int = False)

		' InitVirtualGraphics has been called...
		
		If VirtualGfx.DTInitComplete
		
			' Graphics has been called...
			
			If GraphicsWidth () = 0 Or GraphicsHeight () = 0
				Notify "2 Programmer error! Must call Graphics before SetVirtualGraphics", True; End
			EndIf
			
		Else
			EndGraphics; Notify " 3 Programmer error! Call InitVirtualGraphics before Graphics!", True; End
		EndIf

		' Reset of display needed when re-calculating virtual graphics stuff/clearing borders...
			
		SetVirtualResolution GraphicsWidth (), GraphicsHeight ()
		SetViewport 0, 0, GraphicsWidth (), GraphicsHeight ()
		SetOrigin 0, 0

		' Store current Cls colours...
		
		Local clsr:Int, clsg:Int, clsb:Int
		GetClsColor clsr, clsg, clsb
		
		' Set to black...
		
		SetClsColor 0, 0, 0
		
		' Got to clear both front AND back buffers or it flickers if new display area is smaller...
		
		Cls
		Flip

		Cls
		Flip
		
		Cls
		Flip
		
		' EDIT, 10 Nov 2011: I had a 3rd Cls/Flip here in case triple-buffering was enabled, but have finally
		' tested this and it wasn't needed. (Tested on NVIDIA GTX 260, Windows 7, with driver
		' version 275.33.)

		' EDIT 2, 30 Dec 2011: Reinstated 3rd Cls/Flip for triple-buffering; see first thread comment!

		' Put back Cls colours...

		SetClsColor clsr, clsg, clsb
		
		' Create new (global) virtual display object...
		
		VirtualGfx.CreateVG (vwidth, vheight)
		
		' Real Graphics width/height...
		
		Local gwidth:Int
		Local gheight:Int
		
		' If monitor is correcting aspect ratio IN FULL-SCREEN MODE, use desktop size, otherwise use
		' specified Graphics size. NB. This assumes user's desktop is using native monitor resolution,
		' as most laptops would be by default...
		
		If monitor_stretch And GraphicsDepth ()

			' Pretend real Graphics mode is desktop width/height...

			gwidth = DTW
			gheight = DTH

		Else

			' Use real Graphics width/height...

			gwidth = GraphicsWidth ()
			gheight = GraphicsHeight ()

		EndIf
		
		' Width/height ratios...
		
		Local graphicsratio:Float = Float (gwidth) / Float (gheight)
		Local virtualratio:Float = Float (VirtualGfx.VG.vwidth) / Float (VirtualGfx.VG.vheight)
		
		' Ratio-to-ratio. Don't even know what you'd call this, but hours of trial and error
		' provided the right numbers in the end...
		
		Local gtovratio:Float = graphicsratio / virtualratio
		Local vtogratio:Float = virtualratio / graphicsratio
		
		' Compare ratios...

		If graphicsratio =&gt; virtualratio
			
			' Graphics ratio wider than (or same as) virtual graphics ratio...

			VirtualGfx.VG.vscale = Float (gheight) / Float (VirtualGfx.VG.vheight)
			
			' Now go crazy with trial-and-error... ooh, it works! This tiny bit of code took FOREVER.
			
			Local pixels:Float = Float (VirtualGfx.VG.vwidth) / (1.0 / VirtualGfx.VG.vscale) ' Width after scaling
			Local half_scale:Float = (1.0 / VirtualGfx.VG.vscale) / 2.0
			
			VirtualGfx.width = VirtualGfx.VG.vwidth * gtovratio
			VirtualGfx.height = VirtualGfx.VG.vheight
			
			SetVirtualResolution VirtualGfx.width, VirtualGfx.height

			' Offset into 'real' display area...
			
			VirtualGfx.VG.vxoff = (gwidth - pixels) * half_scale
			VirtualGfx.VG.vyoff = 0
		
			' Set up virtual graphics area...
			
			SetViewport VirtualGfx.VG.vxoff, VirtualGfx.VG.vyoff, VirtualGfx.VG.vwidth, VirtualGfx.VG.vheight
			SetOrigin VirtualGfx.VG.vxoff, VirtualGfx.VG.vyoff
			DebugLog VirtualGfx.VG.vxoff
		Else
			
			' Graphics ratio narrower...
		
			VirtualGfx.VG.vscale = Float (gwidth) / Float (VirtualGfx.VG.vwidth)
			
			Local pixels:Float = Float (VirtualGfx.VG.vheight) / (1.0 / VirtualGfx.VG.vscale) ' Height after scaling
			Local half_scale:Float = (1.0 / VirtualGfx.VG.vscale) / 2.0
			
			VirtualGfx.width = VirtualGfx.VG.vwidth
			VirtualGfx.height = VirtualGfx.VG.vheight * vtogratio
			
			SetVirtualResolution VirtualGfx.width, VirtualGfx.height
		
			VirtualGfx.VG.vxoff = 0
			VirtualGfx.VG.vyoff = (gheight - pixels) * half_scale
		
			SetViewport VirtualGfx.VG.vxoff, VirtualGfx.VG.vyoff, VirtualGfx.VG.vwidth, VirtualGfx.VG.vheight
			SetOrigin VirtualGfx.VG.vxoff, VirtualGfx.VG.vyoff
			
		EndIf
	
	End Function

	Method VMouseX:Float ()
		Local mx:Float = VirtualMouseX () - vxoff
		If mx &lt; 0 Then mx = 0 Else If mx &gt; vwidth - 1 Then mx = vwidth - 1
		Return mx
	End Method
	
	Method VMouseY:Float ()
		Local my:Float = VirtualMouseY () - vyoff
		If my &lt; 0 Then my = 0 Else If my &gt; vheight - 1 Then my = vheight - 1
		Return my
	End Method

	Method GetVxoff:Float()
		Return Floor(vxoff)
	EndMethod
	
	Method GetVyoff:Float()
		Return Floor(vyoff)
	EndMethod
	
	Method VirtualWidth:Int ()
		Return vwidth
	End Method

	Method VirtualHeight:Int ()
		Return vheight
	End Method
	
End Type

' -----------------------------------------------------------------------------
' ... and these helper functions (required)...
' -----------------------------------------------------------------------------

Function InitVirtualGraphics ()

	' There must be a smarter way to check if Graphics has been called...
	
	If GraphicsWidth () &gt; 0 Or GraphicsHeight () &gt; 0 Then EndGraphics; Notify " 1 Programmer error! Call InitVirtualGraphics BEFORE Graphics!", True; End

	VirtualGfx.DTW = DesktopWidth ()
	VirtualGfx.DTH = DesktopHeight ()

	' This only checks once... best to call InitVirtualGraphics again before any further Graphics calls (if you call EndGraphics at all)...
	
	VirtualGfx.DTInitComplete = True

End Function

Function SetVirtualGraphics (vwidth:Int, vheight:Int, monitor_stretch:Int = False)
	VirtualGfx.SetVirtualGraphics (vwidth, vheight, monitor_stretch)
End Function

Function VMouseX:Float ()
	Return VirtualGfx.VG.VMouseX ()
End Function

Function VMouseY:Float ()
	Return VirtualGfx.VG.VMouseY ()
End Function

' Don't need VirtualMouseXSpeed/YSpeed replacements!

Function VirtualWidth:Int ()
	Return VirtualGfx.VG.VirtualWidth ()
End Function

Function VirtualHeight:Int ()
	Return VirtualGfx.VG.VirtualHeight ()
End Function

' -----------------------------------------------------------------------------
' Don't copy after this...
' -----------------------------------------------------------------------------


Function SetDriver:Int(mode:Int)
	If mode = DIRECTX7_DRIVER Then
		If Driver = DIRECTX7_DRIVER Then Return 0
		Driver = DIRECTX7_DRIVER
	EndIf
	
	If mode = DIRECTX9_DRIVER Then
		'Don't do anything if Driver is already 0
		If Driver = DIRECTX9_DRIVER Then Return 0
		Driver = DIRECTX9_DRIVER
	EndIf
	
	If mode = DIRECTX11_DRIVER Then
		'Don't do anything if Driver is already 0
		If Driver = DIRECTX11_DRIVER Then Return 0
		Driver = DIRECTX11_DRIVER
	EndIf
	
	If mode = OPENGL_DRIVER
		'Don't do anything if Driver is already 0
		If Driver = OPENGL_DRIVER Then Return 0
		Driver = OPENGL_DRIVER
	EndIf
	EndGraphics() 'safety
	
' I recommend calling this on the off-chance that the user's desktop size has changed...
		
		InitVirtualGraphics
		
		' Windowed/full-screen...
		
		
		If driver = DIRECTX9_DRIVER Then
			SetGraphicsDriver D3D9Max2DDriver()
		ElseIf driver = DIRECTX11_DRIVER Then
			SetGraphicsDriver D3D11Max2DDriver()
		ElseIf driver = OPENGL_DRIVER Then
			SetGraphicsDriver GLMax2DDriver()
		ElseIf driver = DIRECTX7_DRIVER Then
			SetGraphicsDriver D3D7Max2DDriver()		
		End If
		
		If FULLSCREEN_TOGGLE
			g = Graphics(fullscreenwidth, fullscreenheight, fullscreendepth)
			SetVirtualGraphics virtualscreenwidth, virtualscreenheight, monitor_adjusting
		Else
			g = Graphics(windowedwidth, windowedheight, windoweddepth)
			SetVirtualGraphics virtualscreenwidth, virtualscreenheight
		EndIf
		GetActiveWindow()
		SetClsColor 0,0,0
		Cls
		
		' These get reset when exiting graphics mode...
		
		SetClsColor 64, 96, 128
		SetMaskColor 255, 0, 255
	Return 1
End Function



' -----------------------------------------------------------------------------
' D E M O . . .
' -----------------------------------------------------------------------------

' REQUIRED! BEFORE Graphics!

InitVirtualGraphics

' Toggle for demo's windowed/full-screen switching...

Global FULLSCREEN_TOGGLE:Int = False

' Change this if your monitor doesn't support it!

Global virtualscreenwidth:Int = 1280
Global virtualscreenheight:Int = 1024


Global fullscreenwidth:Int = 1024
Global fullscreenheight:Int = 768
Global fullscreendepth:Int = 32

Global windowedwidth:Int = 640
Global windowedheight:Int = 400
Global windoweddepth:Int = 0
Const DIRECTX9_DRIVER:Int = 0
Const DIRECTX11_DRIVER:Int = 2
Const DIRECTX7_DRIVER:Int = 3
Const OPENGL_DRIVER:Int = 1
Global driver:Int = DIRECTX11_DRIVER

If driver = DIRECTX7_DRIVER Then
	SetGraphicsDriver D3D7Max2DDriver()
ElseIf driver = DIRECTX9_DRIVER Then
	SetGraphicsDriver D3D9Max2DDriver()
ElseIf driver = DIRECTX11_DRIVER Then
	SetGraphicsDriver D3D11Max2DDriver()
ElseIf driver =  OPENGL_DRIVER Then
	SetGraphicsDriver GLMax2DDriver()
End If

Global g:TGraphics
		
If FULLSCREEN_TOGGLE
	g = Graphics(fullscreenwidth, fullscreenheight, fullscreendepth)
Else
	g = Graphics(windowedwidth, windowedheight, windoweddepth)

EndIf

' If user's monitor is set to stretch to its native resolution, this needs to be set to True. I
' would recommend making this a selectable option in your game's configuration as there's no way
' to check this from any program...

Global monitor_adjusting:Int = True

' REQUIRED! AFTER InitVirtualGraphics!

SetVirtualGraphics virtualscreenwidth, virtualscreenheight, monitor_adjusting

SetClsColor 64, 96, 128
SetMaskColor 255, 0, 255

' Some boxes...

Type Box
	Field x:Float, y:Float
	Field xs:Float, ys:Float
	Field size:Int
	Field r:Int, g:Int, b:Int
End Type

Local boxes:TList = CreateList ()

For Local loop:Int = 0 Until 100
	Local b:Box = New Box
	b.size = Rand (32)
	b.x = Rnd (VirtualWidth () - b.size)
	b.y = Rnd (VirtualHeight () - b.size)
	b.xs = Rnd (-4.0, 4.0)
	b.ys = Rnd (-4.0, 4.0)
	b.r = Rand (100, 255)
	b.g = Rand (100, 255)
	b.b = Rand (100, 255)
	ListAddLast boxes, b
Next

Local d:Int = driver 

Function ChangeVirtualResolution(w:Int, h:Int)
	EndGraphics
	virtualscreenwidth = w
	virtualscreenheight = h
	
	InitVirtualGraphics
	If FULLSCREEN_TOGGLE
		g =Graphics(fullscreenwidth, fullscreenheight, fullscreendepth)
		SetVirtualGraphics virtualscreenwidth, virtualscreenheight, monitor_adjusting
	Else
		g =Graphics(windowedwidth, windowedheight, windoweddepth)
		SetVirtualGraphics virtualscreenwidth, virtualscreenheight
	EndIf
		
	SetClsColor 64, 96, 128
	SetMaskColor 255, 0, 255
		
	GetActiveWindow()

EndFunction

Repeat
	If KeyHit(KEY_G)
		d:+1
		If d&gt;3 Then d = 0
		SetDriver(d)
	End If

	If FULLSCREEN_TOGGLE And KeyHit (KEY_RETURN)

		monitor_adjusting = 1 - monitor_adjusting
		SetVirtualGraphics virtualscreenwidth, virtualscreenheight, monitor_adjusting

	EndIf
	
	If KeyHit (KEY_SPACE)

		FULLSCREEN_TOGGLE = 1 - FULLSCREEN_TOGGLE

		' Demo of how to change graphics mode...

		EndGraphics
		
		' I recommend calling this on the off-chance that the user's desktop size has changed...
		
		InitVirtualGraphics
		
		' Windowed/full-screen...
		
		If FULLSCREEN_TOGGLE
			g =Graphics(fullscreenwidth, fullscreenheight, fullscreendepth)
			SetVirtualGraphics virtualscreenwidth, virtualscreenheight, monitor_adjusting
		Else
			g =Graphics(windowedwidth, windowedheight, windoweddepth)
			SetVirtualGraphics virtualscreenwidth, virtualscreenheight
		EndIf
		
		' These get reset when exiting graphics mode...
		
		SetClsColor 64, 96, 128
		SetMaskColor 255, 0, 255
		
	EndIf
	
	If KeyHit(KEY_1)
		ChangeVirtualResolution(2048,1024)
	EndIf
	If KeyHit(KEY_2)
		ChangeVirtualResolution(1280,1024)
	EndIf
	
	Cls()
	
	SetScale 1, 1
	
			
	For Local b:Box = EachIn boxes
		b.x = b.x + b.xs
		b.y = b.y + b.ys
		If b.x &lt; -100 Or (b.x + b.size) &gt; VirtualWidth () Then b.xs = -b.xs; b.x = b.x + b.xs
		If b.y &lt; 0 Or (b.y + b.size) &gt; VirtualHeight () Then b.ys = -b.ys; b.y = b.y + b.ys
		SetColor b.r, b.g, b.b
		DrawRect b.x, b.y, b.size, b.size
	Next
		
	SetColor 255, 0, 0
	DrawRect 0, 0, 16, 16
	DrawRect 0, VirtualHeight () - 16, 16, 16
	DrawRect VirtualWidth () - 16, 0, 16, 16
	DrawRect VirtualWidth () - 16, VirtualHeight () - 16, 16, 16
	
	SetColor 0, 0, 255
	DrawOval VMouseX () - 32, VMouseY () - 32, 64, 64
	SetColor 255, 0, 255
	DrawOval VMouseX () - 32, VMouseY () + 50, 64, 64
	
	SetScale 4, 4
	SetColor 255, 255, 255
	Local c:TextCursor = New TextCursor
	c.Init(20, 20, 50)
	
	c.Out "SPACE: Windowed/full-screen"
	c.Out "1: 2048x1024"
	c.Out "2: 1280x1024"
	c.Out "Current Res: " + VirtualWidth () + ", " + VirtualHeight () 

	If FULLSCREEN_TOGGLE Then c.Out "ENTER: Monitor stretch correction"

	If driver = DIRECTX9_DRIVER 
		c.Out "G to change Graphics Driver: DIRECTX9"
		Local gd3d:TD3D9Graphics = TD3D9Graphics(TMax2dGraphics(g)._graphics)
		Local d3ddev:IDirect3DDevice9 = gd3d.GetDirect3DDevice()
		Local rect:Int[4]
		d3ddev.GetScissorRect(rect)
		c.Out "Viewport X: " + rect[0]
		c.Out "Viewport Y: " + rect[1]
		c.Out "Viewport W: " + rect[2]
		c.Out "Viewport H: " + rect[3]
	ElseIf driver =DIRECTX11_DRIVER 
		c.Out "G to change Graphics Driver: DIRECTX11"

		Local gd3d:TD3D11Graphics = TD3D11Graphics(TMax2dGraphics(g)._graphics)
		Local d3ddev:ID3D11DeviceContext  = gd3d.GetDirect3DDeviceContext()
		Local rect:Int[4]
		Local count:Int
		d3ddev.RSGetScissorRects(count,Null)
		d3ddev.RSGetScissorRects(count,rect)
		c.Out "Viewport X: " + rect[0]
		c.Out "Viewport Y: " + rect[1]
		c.Out "Viewport W: " + rect[2]
		c.Out "Viewport H: " + rect[3]
	ElseIf driver = OPENGL_DRIVER 
		c.Out "G to change Graphics Driver: OPENGL"
	ElseIf driver = DIRECTX7_DRIVER 
		c.Out "G to change Graphics Driver: DIRECT7"
	End If
	c.Out "Mouse : " + MouseX() +","+MouseY()
	c.Out "VMouse: " + VMouseX () +","+VMouseY ()
	c.Out VirtualGfx.VG.GetVxoff () +","+VirtualGfx.VG.GetVyoff ()

	DrawBlackBars()
	SetScale 4, 4

	C.Out "FPS = " + FPS.Calc()
	
	Flip
	
Until KeyHit (KEY_ESCAPE)

Function DrawBlackBars()
	If driver &lt;&gt; OPENGL_DRIVER And driver &lt;&gt; DIRECTX7_DRIVER
		SetScale 1, 1
	
		SetColor 0,0,0
		'left
		DrawRect -VirtualGfx.VG.GetVxoff(), 0, VirtualGfx.VG.GetVxoff(), virtualscreenheight
		'right
		DrawRect virtualscreenwidth + 1, 0, VirtualGfx.VG.GetVxoff(), virtualscreenheight
		'top
		DrawRect 0, -VirtualGfx.VG.GetVyoff(), virtualscreenwidth, VirtualGfx.VG.GetVyoff()
		'bottom
		DrawRect 0, virtualscreenheight + 1, virtualscreenwidth, VirtualGfx.VG.GetVyoff()
		
		SetColor 255,255,255
	EndIf
EndFunction

Function Cls()
	Local steam:Int = 1
	If (driver = OPENGL_DRIVER Or driver = DIRECTX7_DRIVER) And steam
		Local clsr:Int, clsg:Int, clsb:Int
		Local r:Int, g:Int, b:Int
		
		GetClsColor clsr, clsg, clsb
		GetColor r, g, b
		
		SetVirtualResolution GraphicsWidth (), GraphicsHeight ()
		SetViewport 0, 0, GraphicsWidth (), GraphicsHeight ()
		SetOrigin 0, 0
		SetClsColor 0, 0, 0
		brl.max2d.Cls()
		
		SetVirtualResolution VirtualGfx.width, VirtualGfx.height
		SetViewport VirtualGfx.VG.vxoff, VirtualGfx.VG.vyoff, VirtualGfx.VG.vwidth, VirtualGfx.VG.vheight
		SetOrigin VirtualGfx.VG.vxoff, VirtualGfx.VG.vyoff
		SetClsColor clsr, clsg, clsb
		SetColor r, g, b
		brl.max2d.Cls()
	Else
		brl.max2d.Cls()
	EndIf
End Function

Type TextCursor
	Field x:Int = 0
	Field y:Int = 0
	Field gap:Int = 20
		
	Method Init(x:Int = 0, y:Int = 0, gap:Int = 20)
		Self.x = x
		Self.y = y
		Self.gap = gap
	End Method

	Method NewLine()
		y :+ gap
	EndMethod
	
	Method Out(text:String)
		DrawText(text, x, y)
		NewLine()
	EndMethod
End Type

Type FPS
	Global counter:Int
	Global time:Int
	Global fpsCounter:Int
	
	Function Calc:Int()
		counter :+ 1
		If time &lt; MilliSecs()
			fpsCounter = counter
			time = MilliSecs() + 1000
			counter = 0
		EndIf
		Return fpsCounter
	EndFunction
	
	Function DrawFPS()
		DrawText "FPS = " + FPS.Calc(), 0, 0
	EndFunction
EndType

End</textarea><br><br>Also found out that DX7 seems to be locked at 30FPS in fullscreen mode!? (On Windows 8.1 at least...)<br><br>Cheers,<br>Steve <br><br></td></tr></table><br>
<a name="1295503"></a>

<a name="1295505"></a>

<a name="1295506"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hey Steve,<br><br>On Windows 7 and 10 I'm getting the correct black vertical borders for all the drivers before and after showing the Steam overlay [edit]but then I would as you have put a 'fix' in there :D I get the same as you for Dx7 and Ogl[/edit].<br><br>All are @60fps.<br><br>Window7 pro GTX750<br>Window10 home GT650m<br><br>Both systems have the latest drivers. <br><br></td></tr></table><br>
<a name="1295601"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for testing Dave :)<br><br>Any idea what is going on with DX7 and OGL?<br><br>Cheers,<br>Steve <br><br></td></tr></table><br>
<a name="1295629"></a>

<a name="1295631"></a>

<a name="1295633"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> I guess you could comment out the code in the SetViewport methods for the OpenGL and D3D7 Max2DDrivers. You'll need to keep the method just comment out the code. In the D3D7Max2DDriver.SetViewport method I think you'll need to keep the <b>vp_rect=[x,y,x+width,y+height]</b> line as it's used elsewhere, then you will need to use your 'blackbar' function.<br><br>I'm not sure if this would break other peoples code though.<br><br>The fix I had in mind was to setup some black bar parameters when you setup the viewport via SetViewport. Then in the Flip method call some code to actually draw the black bars if they are needed. You may be able to use your existing code in the SetViewport methods? I've not written or tested any of this - just ideas. <br><br></td></tr></table><br>
<a name="1295695"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks again Dave - I'll have a go at removing the code out of SetViewport tonight :)<br><br>(Any ETA regarding the Alt-Tab bug for DX11?)<br><br>Cheers,<br>Steve <br><br></td></tr></table><br>
<a name="1296159"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sorry for the late reply, RL got in the way...<br><br>Just tested commenting out the code in OpenGL and D3D7, looks good in the test app, of course I need to draw the black border now for all drivers but I can live with that :)<br><br>Now just that alt-tab issue for DX11... <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
