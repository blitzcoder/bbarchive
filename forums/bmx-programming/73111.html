<!DOCTYPE html><html lang="en" ><head ><title >BlitzMax Modules</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >BlitzMax Modules</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >BlitzMax Modules</a><br><br>
<a name="817198"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MacSven</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> How can i create my own BlitzMax Module! My idea is to create a usb mod from libusb! Is that possible and easy or not? <br><br></td></tr></table><br>
<a name="817199"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Thareh</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br>Creating your own module shouldn't be so hard,<br>I've never done it myself, but I found this tutorial:<br><a href="http://www.blitzbasic.com/Community/posts.php?topic=42290" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=42290</a><br><br>Hope that helps, Good luck! :) <br><br></td></tr></table><br>
<a name="817203"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MacSven</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> I will take a look to it. But i think it is a hard work! <br><br></td></tr></table><br>
<a name="817215"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Doesn't look too difficult.<br><br>If one were to do it properly of course, you might do libusb (for linux/OS X support) and libusb-win32 (for windows) wrapped up in the same module. Then you cover all the bases.<br><br>If you do go ahead, please include half-decent documentation and examples. The whole idea of having a wrapped library is that you don't want to have to go and look at the original library documentation to get an idea what such-and-such function is meant to do.<br>And if you can hide pointers and structs from the user, more the better.<br>If I have to use library pointers, via a module, directly in my app then I may as well have not bothered using the module at all and simply talked to the library instead.<br><br>Just some thoughts ;-) <br><br></td></tr></table><br>
<a name="817464"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MacSven</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi Brucey,<br><br>Is it this that you meen:<br><br><a href="http://search.cpan.org/~gwadej/Device-USB-0.21/lib/Device/USB.pm" target="_blank">http://search.cpan.org/~gwadej/Device-USB-0.21/lib/Device/USB.pm</a> <br><br></td></tr></table><br>
<a name="817510"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MacSven</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Again @ Brucey:<br><br>I found this:<br><br>www.math.ias.edu/doc/libusb-devel-0.1.8/manual.ps<br><br>Reward MainframeOSX <br><br></td></tr></table><br>
<a name="817524"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >SebHoll</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> My idea is to create a usb mod from libusb! <br></div><br>I would be interested in having such a module too! Although I'm too busy at the moment to help, sorry! <br><br></td></tr></table><br>
<a name="817553"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MacSven</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Is this the right way:<br><br>Module pub.libusb<br>ModuleInfo "Version: 1.00"<br>ModuleInfo "Modserver: Not yet implemented"<br>ModuleInfo "Author: Sven Schwiecker(MacOS part)"<br>ModuleInfo "License: Public Domain"<br>ModuleInfo "Contact: Sven.Schweicker@..."<br>ModuleInfo "Homepage: www.SvenSchwiecker.de"<br><br><br>Import "usb.c"<br>Import "linux.c"<br>Import "darwin.c"<br>Import "error.c"<br><br><br>Extern "C"<br><br>Function usb_descriptor_header		(bLength:Int Ptr,bDescriptorType:Int Ptr)<br>Function usb_string_descriptor		(bLength:Int Ptr,bDescriptorType:Int Ptr,wData:Int Ptr)<br>Function usb_hid_descriptor			(bLength:Int Ptr,bDescriptorType:Int Ptr,bcdHDI:Int Ptr,bCountryCode:Int Ptr,bNumDescriptors:Int Ptr)<br><br>EndExtern<br><br>After Build Modules no errors is shown.<br>Is this good? <br><br></td></tr></table><br>
<a name="817561"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Perturbatio</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Try using the functions and see what happens. <br><br></td></tr></table><br>
<a name="817564"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> usb_descriptor_header etc, aren't functions. They are C-structs.<br><br>This function "usb_init()" initializes the library, which, according to the docs, you call *first*.<br><br>"usb_find_busses()" looks like it returns a count of busses... and "usb_find_devices()" looks to return a count of devices... etc.<br><br>Since it's LGPL, you may wish to rather link to a DLL/.so/.dylib, rather than compile in or statically link to the library - unless your code is in-house or GPL'd.<br><br><pre class=code>
struct usb_descriptor_header {
	u_int8_t  bLength;
	u_int8_t  bDescriptorType;
};
</pre><br>If you have, say, a pointer to this struct, you could retrieve the "length" field with something like :<br>length = Byte Ptr(headerPtr)[0]<br>.. and for the descriptor type :<br>descType = Byte Ptr(headerPtr)[1]<br>, since they both appear to be byte-size values.<br><br>Things like :<br><pre class=code>
	struct usb_interface *interface;
</pre><br>inside another struct, is a pointer to a struct of "usb_interface", which itself might contain pointers to other structs.<br><br>The two ways you might go about accessing all this information is either via the Ptr access like I've mentioned above, or by writing glue c/cpp code which makes your BlitzMax code easier to manage. <br><br></td></tr></table><br>
<a name="817955"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MacSven</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>My first test of the libusb module<br><br>Strict<br><br>Module Pub.libusb<br><br>ModuleInfo "Version: 1.00"<br>ModuleInfo "Modserver: Not yet implemented"<br>ModuleInfo "Author: Sven Schwiecker(MacOS part)"<br>ModuleInfo "License: Public Domain"<br>ModuleInfo "Contact: Sven.Schwiecker@..."<br>ModuleInfo "Homepage: www.SvenSchwiecker.de"<br><br>?MacOS<br>Import "darwin.c"<br>Import "error.c"<br>Import "usb.c"<br>Import "descriptors.c"<br><br><br>Extern "C"<br>Function usb_init()<br>Function usb_find_busses()<br>Function usb_find_devices()<br>EndExtern<br><br>Testprogramm:<br><br>'usbtest<br><br>usb_init()<br>Print x<br>x=usb_find_busses()<br>Print x<br>x=usb_find_devices()<br>Print x<br><br>and it works. Now it comes the next part. <br><br></td></tr></table><br>
<a name="817958"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> I suggest you use your own namespace, rather than Pub.<br><br>Also, you might find it easier to define the return values of the functions...<br><pre class=code>
Function usb_find_busses:Int()
</pre><br><br>If you use SuperStrict, it will force you to define things like this, which in the long run should help maintainability, since you only have to look at the function definition to see what it returns, if anything. <br><br></td></tr></table><br>
<a name="817962"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MacSven</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> I change the namespace as soon as possible, at this time it is only for testings.<br>The problem that i had is, i have import "linux.c" and this is a problem under MacOS X.<br>But thanks for the help @Brucey, i hope i can make more then this.<br>It is my first time to make a module! <br><br></td></tr></table><br>
<a name="818363"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MacSven</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Need a little bit more help:<br><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
SuperStrict

Module Pub.libusb

ModuleInfo "Version:	 1.00"
ModuleInfo "Modserver:	 Not yet implemented"
ModuleInfo "Author:	 Sven Schwiecker(MacOS part)"
ModuleInfo "License:	 Public Domain"
ModuleInfo "Contact:	 Sven.Schwiecker@..."
ModuleInfo "Homepage:	 www.SvenSchwiecker.de"

?MacOS
Import "darwin.c"
Import "usb.c"
Import "descriptors.c"
Import "error.c"

Extern "C"
Function usb_init()
Function usb_find_busses:Int()
Function usb_find_devices:Int()
Function usb_device:Int()
EndExtern
</textarea><br>All the function work in my Testprogram. The function usb_device:int() returns this: 2080899750 is this the adress of the last usb_device?<br>How can i get a list of all USB-Busses and USB-Devices from <br>this c-source (i'm working under MacOS X):<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
/*
 * Main API entry point
 *
 * Copyright (c) 2000-2003 Johannes Erdfelt &lt;johannes@...;
 *
 * This library is covered by the LGPL, read LICENSE for details.
 */

#include &lt;stdlib.h&gt;	/* getenv */
#include &lt;stdio.h&gt;	/* stderr */
#include &lt;string.h&gt;	/* strcmp */
#include &lt;errno.h&gt;

#include "usbi.h"

int usb_debug = 0;
struct usb_bus *usb_busses = NULL;

int usb_find_busses(void)
{
  struct usb_bus *busses, *bus;
  int ret, changes = 0;

  ret = usb_os_find_busses(&amp;busses);
  if (ret &lt; 0)
    return ret;

  /*
   * Now walk through all of the busses we know about and compare against
   * this new list. Any duplicates will be removed from the new list.
   * If we don't find it in the new list, the bus was removed. Any
   * busses still in the new list, are new to us.
   */
  bus = usb_busses;
  while (bus) {
    int found = 0;
    struct usb_bus *nbus, *tbus = bus-&gt;next;

    nbus = busses;
    while (nbus) {
      struct usb_bus *tnbus = nbus-&gt;next;

      if (!strcmp(bus-&gt;dirname, nbus-&gt;dirname)) {
        /* Remove it from the new busses list */
        LIST_DEL(busses, nbus);

        usb_free_bus(nbus);
        found = 1;
        break;
      }

      nbus = tnbus;
    }

    if (!found) {
      /* The bus was removed from the system */
      LIST_DEL(usb_busses, bus);
      usb_free_bus(bus);
      changes++;
    }

    bus = tbus;
  }

  /*
   * Anything on the *busses list is new. So add them to usb_busses and
   * process them like the new bus it is.
   */
  bus = busses;
  while (bus) {
    struct usb_bus *tbus = bus-&gt;next;

    /*
     * Remove it from the temporary list first and add it to the real
     * usb_busses list.
     */
    LIST_DEL(busses, bus);

    LIST_ADD(usb_busses, bus);

    changes++;

    bus = tbus;
  }

  return changes;
}

int usb_find_devices(void)
{
  struct usb_bus *bus;
  int ret, changes = 0;

  for (bus = usb_busses; bus; bus = bus-&gt;next) {
    struct usb_device *devices, *dev;

    /* Find all of the devices and put them into a temporary list */
    ret = usb_os_find_devices(bus, &amp;devices);
    if (ret &lt; 0)
      return ret;

    /*
     * Now walk through all of the devices we know about and compare
     * against this new list. Any duplicates will be removed from the new
     * list. If we don't find it in the new list, the device was removed.
     * Any devices still in the new list, are new to us.
     */
    dev = bus-&gt;devices;
    while (dev) {
      int found = 0;
      struct usb_device *ndev, *tdev = dev-&gt;next;

      ndev = devices;
      while (ndev) {
        struct usb_device *tndev = ndev-&gt;next;

        if (!strcmp(dev-&gt;filename, ndev-&gt;filename)) {
          /* Remove it from the new devices list */
          LIST_DEL(devices, ndev);

          usb_free_dev(ndev);
          found = 1;
          break;
        }

        ndev = tndev;
      }

      if (!found) {
        /* The device was removed from the system */
        LIST_DEL(bus-&gt;devices, dev);
        usb_free_dev(dev);
        changes++;
      }

      dev = tdev;
    }

    /*
     * Anything on the *devices list is new. So add them to bus-&gt;devices and
     * process them like the new device it is.
     */
    dev = devices;
    while (dev) {
      struct usb_device *tdev = dev-&gt;next;

      /*
       * Remove it from the temporary list first and add it to the real
       * bus-&gt;devices list.
       */
      LIST_DEL(devices, dev);

      LIST_ADD(bus-&gt;devices, dev);

      /*
       * Some ports fetch the descriptors on scanning (like Linux) so we don't
       * need to fetch them again.
       */
      if (!dev-&gt;config) {
        usb_dev_handle *udev;

        udev = usb_open(dev);
        if (udev) {
          usb_fetch_and_parse_descriptors(udev);

          usb_close(udev);
        }
      }

      changes++;

      dev = tdev;
    }

    usb_os_determine_children(bus);
  }

  return changes;
}

void usb_set_debug(int level)
{
  if (usb_debug || level)
    fprintf(stderr, "usb_set_debug: Setting debugging level to %d (%s)\n",
	level, level ? "on" : "off");

  usb_debug = level;
}

void usb_init(void)
{
  if (getenv("USB_DEBUG"))
    usb_set_debug(atoi(getenv("USB_DEBUG")));

  usb_os_init();
}

usb_dev_handle *usb_open(struct usb_device *dev)
{
  usb_dev_handle *udev;

  udev = malloc(sizeof(*udev));
  if (!udev)
    return NULL;

  udev-&gt;fd = -1;
  udev-&gt;device = dev;
  udev-&gt;bus = dev-&gt;bus;
  udev-&gt;config = udev-&gt;interface = udev-&gt;altsetting = -1;

  if (usb_os_open(udev) &lt; 0) {
    free(udev);
    return NULL;
  }

  return udev;
}

int usb_get_string(usb_dev_handle *dev, int index, int langid, char *buf,
	size_t buflen)
{
  /*
   * We can't use usb_get_descriptor() because it's lacking the index
   * parameter. This will be fixed in libusb 1.0
   */
  return usb_control_msg(dev, USB_ENDPOINT_IN, USB_REQ_GET_DESCRIPTOR,
			(USB_DT_STRING &lt;&lt; 8) + index, langid, buf, buflen, 1000);
}

int usb_get_string_simple(usb_dev_handle *dev, int index, char *buf, size_t buflen)
{
  char tbuf[255];	/* Some devices choke on size &gt; 255 */
  int ret, langid, si, di;

  /*
   * Asking for the zero'th index is special - it returns a string
   * descriptor that contains all the language IDs supported by the
   * device. Typically there aren't many - often only one. The
   * language IDs are 16 bit numbers, and they start at the third byte
   * in the descriptor. See USB 2.0 specification, section 9.6.7, for
   * more information on this. */
  ret = usb_get_string(dev, 0, 0, tbuf, sizeof(tbuf));
  if (ret &lt; 0)
    return ret;

  if (ret &lt; 4)
    return -EIO;

  langid = tbuf[2] | (tbuf[3] &lt;&lt; 8);

  ret = usb_get_string(dev, index, langid, tbuf, sizeof(tbuf));
  if (ret &lt; 0)
    return ret;

  if (tbuf[1] != USB_DT_STRING)
    return -EIO;

  if (tbuf[0] &gt; ret)
    return -EFBIG;

  for (di = 0, si = 2; si &lt; tbuf[0]; si += 2) {
    if (di &gt;= (buflen - 1))
      break;

    if (tbuf[si + 1])	/* high byte */
      buf[di++] = '?';
    else
      buf[di++] = tbuf[si];
  }

  buf[di] = 0;

  return di;
}

int usb_close(usb_dev_handle *dev)
{
  int ret;

  ret = usb_os_close(dev);
  free(dev);

  return ret;
}

struct usb_device *usb_device(usb_dev_handle *dev)
{
  return dev-&gt;device;
}

void usb_free_dev(struct usb_device *dev)
{
  usb_destroy_configuration(dev);
  free(dev-&gt;children);
  free(dev);
}

struct usb_bus *usb_get_busses(void)
{
  return usb_busses;
}

void usb_free_bus(struct usb_bus *bus)
{
  free(bus);
}

</textarea> <br><br></td></tr></table><br>
<a name="818378"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> You will find using {codebox}{/codebox} (replace curly brackets with square) for your code, takes up much less room, and keeps the formatting. <br><br></td></tr></table><br>
<a name="818380"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MacSven</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Is this better? <br><br></td></tr></table><br>
<a name="818385"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Much.<br><br>Have a look at testlibusb.c in the tests dir of libusb.<br>It shows how to access all the information.<br><br>Specifically :<br><pre class=code>
  usb_init();

  usb_find_busses();
  usb_find_devices();

  for (bus = usb_busses; bus; bus = bus-&gt;next) {
    if (bus-&gt;root_dev &amp;&amp; !verbose)
      print_device(bus-&gt;root_dev, 0);
    else {
      struct usb_device *dev;

      for (dev = bus-&gt;devices; dev; dev = dev-&gt;next)
        print_device(dev, 0);
    }
  }
</pre><br>"usb_busses" is a static variable, which you won't be able to access directly from BlitzMax. You'll need to add some C/C++ wrapping. The struct that it points to is a linked-list of buses, each of which has information on the devices that are connected to it.<br><br>:o) <br><br></td></tr></table><br>
<a name="818396"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >MacSven</td><td align="right"><font class=tiny>(Posted 2007)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi Brucey,<br><br>Can you make a little example? <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
