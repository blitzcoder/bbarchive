<!DOCTYPE html><html lang="en" ><head ><title >Module: Passing a function to a c function</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Module: Passing a function to a c function</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Module: Passing a function to a c function</a><br><br>
<a name="1212154"></a>

<a name="1212155"></a>

<a name="1212156"></a>

<a name="1212157"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sub_Zero</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi!<br><br>I'm trying to make a module out of libsmbclient for linux (apt-get install libsmbclient-dev), wich is a shared library.<br><br>Some of the functions works ok, except for those that require a (callback?) function as parameter. I've been trying for hours with different approaches but can't get it to work..<br><br>The problem is in the Init method (smbc_init) and I've also tried using the smbc_get_auth_data_fn function supplied with the smbclient-dev examples, also with no luck. I figured if i could get that working I'd figure out how to do it...<br><br>here is my module code:<br><br>dir structure: mod/sub.mod/libsmbclient.mod/<br><br>file libsmbclient.bmx:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' By Sub_Zero 2013
SuperStrict


Rem
bbdoc: Libsmbclient
End Rem
Module Sub.libsmbclient

ModuleInfo "Version: 1.00"
ModuleInfo "License: BSD"
ModuleInfo "Copyright: Wrapper by Sub_Zero"

Import BRL.Blitz
Import BRL.StandardIO

Import "include/*.h"
Import "glue.cpp"

?linux
Import "-ldl"
Import "-lsmbclient"
?

Extern

	Function bmx_smbc_new_context:Byte Ptr()
	Function bmx_smbc_init_context:Byte Ptr(context:Byte Ptr)
	Function bmx_smbc_set_context:Byte Ptr(context:Byte Ptr)
	Function smbc_init:Int(setauthdatafn(server:String, share:String, workgroup:Byte Ptr, wglen:Int, username:Byte Ptr, unlen:Int, password:Byte Ptr, pwlen:Int), debug:Int)
	Function bmx_get_auth_data_fn(server:String, share:String, workgroup:Byte Ptr, wglen:Int, username:Byte Ptr, unlen:Int, password:Byte Ptr, pwlen:Int)
	Function smbc_opendir:Int(durl:String)
	
End Extern


Rem
bbdoc: A SMB Context.
End Rem
Type SMBCCTX

	Field ctxPtr:Byte Ptr
	Global _server:String, _share:String, _workgroup:Byte Ptr, _workgrouplen:Int, _user:Byte Ptr, _userlen:Int, _password:Byte Ptr, _passwordlen:Int

	Rem
	bbdoc: Creates a SMB Context.
	End Rem
	Function CreateContext:SMBCCTX()
		Return New SMBCCTX.Create()
	End Function
	
	Rem
	bbdoc: Creates a SMB Context.
	End Rem
	Method Create:SMBCCTX()
		ctxPtr = bmx_smbc_new_context()
		Return Self
	End Method
	
	Rem
	bbdoc: Initializes a SMB Context.
	End Rem
	Method Init_Context()
		ctxPtr = bmx_smbc_init_context(ctxPtr)
	End Method
		
	Rem
	bbdoc: Init Context with server and share data + connection credentials
	End Rem
	Method Init:Int(server:String, share:String, workgroup:String, user:String, password:String)
		ctxPtr = bmx_smbc_set_context(ctxPtr);
		setauthdata(server, share, workgroup, user, password)
		Return smbc_init(setauthdatafn, 10) 'smbc_init(bmx_get_auth_data_fn, 10)
	End Method
	
	Rem
	bbdoc: Open a smb dir using smb address
	End Rem
	Method OpenDir:Int(dir:String)
		Return smbc_opendir(dir)
	End Method

	Method setauthdata(server:String, share:String, workgroup:String, user:String, password:String)
		_server = server
		_share = share
		_workgroup = workgroup.ToCString()
		_workgrouplen = Len(workgroup)
		_user = user.ToCString()
		_userlen = Len(user)
		_password = password.ToCString()
		_passwordlen = Len(password)
	End Method
		
	Function setauthdatafn(server:String, share:String, workgroup:Byte Ptr, workgrouplen:Int, user:Byte Ptr, userlen:Int, password:Byte Ptr, passwordlen:Int)
		server = _server
		share = _share
		workgroup = _workgroup
		workgrouplen = _workgrouplen
		user = _user
		userlen = _userlen
		password = _password
		passwordlen = _passwordlen
	End Function
End Type
</textarea><br><br>file glue.cpp:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
#include &lt;libsmbclient.h&gt;
#include &lt;include/get_auth_data_fn.h&gt;

extern "C" {

#include "blitz.h"

	SMBCCTX * bmx_smbc_new_context();
	SMBCCTX * bmx_smbc_init_context(SMBCCTX * ctx);
	SMBCCTX * bmx_smbc_set_context(SMBCCTX * ctx);
	void bmx_get_auth_data_fn(const char * pServer,const char * pShare,char * pWorkgroup,int maxLenWorkgroup,char * pUsername,int maxLenUsername,char * pPassword,int maxLenPassword);
	}


SMBCCTX * bmx_smbc_new_context() {
	SMBCCTX * ctx = new SMBCCTX;
	return ctx;
	}

SMBCCTX * bmx_smbc_init_context(SMBCCTX * ctx) {
	smbc_init_context(ctx);
	return ctx;
	}
	
SMBCCTX * bmx_smbc_set_context(SMBCCTX * ctx) {
	smbc_set_context(ctx);
	return ctx;
	}
	
void bmx_get_auth_data_fn(const char * pServer,const char * pShare,char * pWorkgroup,int maxLenWorkgroup,char * pUsername,int maxLenUsername,char * pPassword,int maxLenPassword) {
	get_auth_data_fn(pServer,pShare,pWorkgroup,maxLenWorkgroup,pUsername,maxLenUsername,pPassword,maxLenPassword);
	}
</textarea><br><br>file include/get_auth_data_fn.h:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
#include &lt;stdlib.h&gt;

static void
get_auth_data_fn(const char * pServer,
                 const char * pShare,
                 char * pWorkgroup,
                 int maxLenWorkgroup,
                 char * pUsername,
                 int maxLenUsername,
                 char * pPassword,
                 int maxLenPassword)
{
    char            temp[128];
    char            server[256] = { '\0' };
    char            share[256] = { '\0' };
    char            workgroup[256] = { '\0' };
    char            username[256] = { '\0' };
    char            password[256] = { '\0' };

    static int krb5_set = 1;

    if (strcmp(server, pServer) == 0 &amp;&amp;
        strcmp(share, pShare) == 0 &amp;&amp;
        *workgroup != '\0' &amp;&amp;
        *username != '\0')
    {
        strncpy(pWorkgroup, workgroup, maxLenWorkgroup - 1);
        strncpy(pUsername, username, maxLenUsername - 1);
        strncpy(pPassword, password, maxLenPassword - 1);
        return;
    }

    if (krb5_set &amp;&amp; getenv("KRB5CCNAME")) {
      krb5_set = 0;
      return;
    }

    fprintf(stdout, "Workgroup: [%s] ", pWorkgroup);
    fgets(temp, sizeof(temp), stdin);
    
    if (temp[strlen(temp) - 1] == '\n') /* A new line? */
    {
        temp[strlen(temp) - 1] = '\0';
    }
    
    if (temp[0] != '\0')
    {
        strncpy(pWorkgroup, temp, maxLenWorkgroup - 1);
    }
    
    fprintf(stdout, "Username: [%s] ", pUsername);
    fgets(temp, sizeof(temp), stdin);
    
    if (temp[strlen(temp) - 1] == '\n') /* A new line? */
    {
        temp[strlen(temp) - 1] = '\0';
    }
    
    if (temp[0] != '\0')
    {
        strncpy(pUsername, temp, maxLenUsername - 1);
    }
    
    fprintf(stdout, "Password: ");
    fgets(temp, sizeof(temp), stdin);
    
    if (temp[strlen(temp) - 1] == '\n') /* A new line? */
    {
        temp[strlen(temp) - 1] = '\0';
    }
    
    if (temp[0] != '\0')
    {
        strncpy(pPassword, temp, maxLenPassword - 1);
    }

    strncpy(workgroup, pWorkgroup, sizeof(workgroup) - 1);
    strncpy(username, pUsername, sizeof(username) - 1);
    strncpy(password, pPassword, sizeof(password) - 1);

    krb5_set = 1;
}
</textarea><br><br><br>and then the test bmx file: testsmb.bmx, in the src/ folder:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict

Framework BRL.StandardIO
Import Sub.libsmbclient

Local smb:SMBCCTX

smb = New SMBCCTX
If smb Print "SMB Context Created..."
Print smb.Init("127.0.0.1", "test", "WORKGROUP", "username", "password")
Print "Inited with Auth data set"
Print smb.OpenDir("smb://127.0.0.1/test/")
</textarea> <br><br></td></tr></table><br>
<a name="1212207"></a>

<a name="1212209"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hiya,<br><br>I've not looked through your code ( I have a hangover :D ) but you usually have the BMax function that will call the c code have a Byte Ptr as the callback parameter and pass the function name as that parameter.<br><br>Heres a little working example that hopefully will help figure it out...<br><br>BMax code<br><pre class=code>


Import "Callbacks.c"      ' Import the c code below

Extern
	Function Init(Callback:Byte Ptr) ' Pass the function name into here a parameter
EndExtern

Function C_Callback(Value1,Value2)
	Print "C_Callback Value1: " + Value1 + ", Value2: " + Value2
EndFunction



Init(C_Callback) ' Pass the name of C_Callback function into C code
</pre><br><br>C Code - filename "Callbacks.c"<br><pre class=code>

// There will be a type definition for the callback signature in the headers somewhere, I made one here for this example
typedef void( *BMX_CALLBACK )(int, int);
BMX_CALLBACK BMaxCallback;



void Init(BMX_CALLBACK callbackFn)	// BMax would pass the funcion name into here but as a :Byte Ptr
{	
	BMaxCallback = callbackFn;		// Assign the variable to the function address
	
	callbackFn(10,20);				// call the function in Bmax with parameters
}
</pre> <br><br></td></tr></table><br>
<a name="1212210"></a>

<a name="1212211"></a>

<a name="1212213"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just had a cold shower, feel much better now...<br><br>Had a little look through the functions that are calling the c code.<br><br>You shouldn't pass in the BMax String as a variable type unless you have the same type ( BBSTRING ) in your c code. BMax String is a BMax Object not a standard string of characters as in standard c char strings ( which are just arrays of bytes ). If you need strings to be passed directly into straight into the c/++ code you need to know what size of characters the c/++ code is expecting ( single byte or 'wide byte' ), in this case the c code is expecting single byte char(s), and then...<br><br>so instead of<br><br>Function smbc_opendir:Int(<b>durl:String</b>)<br><br>use<br><br>Function smbc_opendir:Int(<b>durl$z</b>) ' BMax will internally pass the string characters as single bytes including adding in the null terminator.<br><br>or<br><br>Function smbc_opendir:Int(<b>durl$w</b>) ' BMax will internally pass the string as wide chars ( 2 bytes per character ) including adding a null terminator.<br><br>EDIT:- For beginners learning this stuff :- Also I noticed youre using cpp and my example is in c so in your cpp code you would wrap the Init function with the standard extern"C"{ [...] } ( as you are already doing ) to prevent cpp name-mangling so the linker can find the function. <br><br></td></tr></table><br>
<a name="1212216"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sub_Zero</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks alot for the help, I will have a look at it :) <br><br></td></tr></table><br>
<a name="1212219"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Oops theres a typo in the c example I posted.<br><br>The Init function should be<br><br><pre class=code>
void Init(BMX_CALLBACK callbackFn)
{	
	BMaxCallback = callbackFn;
	
	BMaxCallback(10,20);
}
</pre><br><br>Equates to the same thing really but uses the global BMaxCallback to call back into BMax.<br><br>Any probs feel free to ask for more help. <br><br></td></tr></table><br>
<a name="1212226"></a>

<a name="1212227"></a>

<a name="1212228"></a>

<a name="1212231"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sub_Zero</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi<br><br>I've had a go or five and now everything compiles ok, except for this line in glue.cpp (it compiles fine without this line):<br><br><pre class=code>
BMaxCallback(server, share, wrkgrp, 3, user, 3, pass, 3);
</pre><br><br>I also tried to replace the line with this:<br><pre class=code>
return smbc_init(BMaxCallback, debug);
</pre><br><br>But that wouldn't compile either..<br><br>here's my current libsmbclient.bmx:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' By Sub_Zero 2013
SuperStrict


Rem
bbdoc: Libsmbclient
End Rem
Module Sub.libsmbclient

ModuleInfo "Version: 1.00"
ModuleInfo "License: BSD"
ModuleInfo "Copyright: Wrapper by Sub_Zero"

Import BRL.Blitz
Import BRL.StandardIO

Import "include/*.h"
Import "glue.cpp"

?linux
Import "-ldl"
Import "-lsmbclient"
?

Extern

	Function bmx_smbc_new_context:Byte Ptr()
	Function bmx_smbc_init_context:Byte Ptr(context:Byte Ptr)
	Function bmx_smbc_set_context:Byte Ptr(context:Byte Ptr)
	Function bmx_smbc_init:Int(Callback:Byte Ptr, debug:Int)
	Function bmx_get_auth_data_fn(server:String, share:String, workgroup:Byte Ptr, wglen:Int, username:Byte Ptr, unlen:Int, password:Byte Ptr, pwlen:Int)
	Function smbc_opendir:Int(durl$z)
	
End Extern


Rem
bbdoc: A SMB Context.
End Rem
Type SMBCCTX

	Field ctxPtr:Byte Ptr
	Global _server:String, _share:String, _workgroup:Byte Ptr, _workgrouplen:Int, _user:Byte Ptr, _userlen:Int, _password:Byte Ptr, _passwordlen:Int

	Rem
	bbdoc: Creates a SMB Context.
	End Rem
	Function CreateContext:SMBCCTX()
		Return New SMBCCTX.Create()
	End Function
	
	Rem
	bbdoc: Creates a SMB Context.
	End Rem
	Method Create:SMBCCTX()
		ctxPtr = bmx_smbc_new_context()
		Return Self
	End Method
	
	Rem
	bbdoc: Initializes a SMB Context.
	End Rem
	Method Init_Context()
		ctxPtr = bmx_smbc_init_context(ctxPtr)
	End Method
		
	Rem
	bbdoc: Init Context with server and share data + connection credentials
	End Rem
	Method Init:Int(server:String, share:String, workgroup:String, user:String, password:String)
		ctxPtr = bmx_smbc_set_context(ctxPtr);
		setauthdata(server, share, workgroup, user, password)
		Return bmx_smbc_init(setauthdatafn, 10) 'smbc_init(bmx_get_auth_data_fn, 10)
	End Method
	
	Rem
	bbdoc: Open a smb dir using smb address
	End Rem
	Method OpenDir:Int(dir:String)
		Return smbc_opendir(dir)
	End Method

	Method setauthdata(server:String, share:String, workgroup:String, user:String, password:String)
		_server = server
		_share = share
		_workgroup = workgroup.ToCString()
		_workgrouplen = Len(workgroup)
		_user = user.ToCString()
		_userlen = Len(user)
		_password = password.ToCString()
		_passwordlen = Len(password)
	End Method
		
	Function setauthdatafn(server:String, share:String, workgroup:Byte Ptr, workgrouplen:Int, user:Byte Ptr, userlen:Int, password:Byte Ptr, passwordlen:Int)
		server = _server
		share = _share
		workgroup = _workgroup
		workgrouplen = _workgrouplen
		user = _user
		userlen = _userlen
		password = _password
		passwordlen = _passwordlen
	End Function
End Type
</textarea><br><br>and my glue.cpp:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
#include &lt;libsmbclient.h&gt;
//#include &lt;include/get_auth_data_fn.h&gt;

extern "C" {

#include "blitz.h"

	smbc_get_auth_data_fn * BMaxCallback;
	SMBCCTX * bmx_smbc_new_context();
	SMBCCTX * bmx_smbc_init_context(SMBCCTX * ctx);
	SMBCCTX * bmx_smbc_set_context(SMBCCTX * ctx);
	int bmx_smbc_init(smbc_get_auth_data_fn * fn, int debug);
	}


SMBCCTX * bmx_smbc_new_context() {
	SMBCCTX * ctx = new SMBCCTX;
	return ctx;
	}

SMBCCTX * bmx_smbc_init_context(SMBCCTX * ctx) {
	smbc_init_context(ctx);
	return ctx;
	}
	
SMBCCTX * bmx_smbc_set_context(SMBCCTX * ctx) {
	smbc_set_context(ctx);
	return ctx;
	}
	
int bmx_smbc_init(smbc_get_auth_data_fn * fn, int debug) {
	BMaxCallback = fn;
	const char *server = "server";
	const char *share = "share";
	char *wrkgrp = "workgroup";
	char *user = "user";
	char *pass = "pass";
	BMaxCallback(server, share, wrkgrp, 3, user, 3, pass, 3);

	}
</textarea><br><br>the typedef for the callback function is as follows (taken from libsmbclient.h):<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
/**@ingroup callback
 * Authentication callback function type (traditional method)
 * 
 * Type for the the authentication function called by the library to
 * obtain authentication credentals
 *
 * For kerberos support the function should just be called without
 * prompting the user for credentials. Which means a simple 'return'
 * should work. Take a look at examples/libsmbclient/get_auth_data_fn.h
 * and examples/libsmbclient/testbrowse.c.
 *
 * @param srv       Server being authenticated to
 *
 * @param shr       Share being authenticated to
 *
 * @param wg        Pointer to buffer containing a "hint" for the
 *                  workgroup to be authenticated.  Should be filled in
 *                  with the correct workgroup if the hint is wrong.
 * 
 * @param wglen     The size of the workgroup buffer in bytes
 *
 * @param un        Pointer to buffer containing a "hint" for the
 *                  user name to be use for authentication. Should be
 *                  filled in with the correct workgroup if the hint is
 *                  wrong.
 * 
 * @param unlen     The size of the username buffer in bytes
 *
 * @param pw        Pointer to buffer containing to which password 
 *                  copied
 * 
 * @param pwlen     The size of the password buffer in bytes
 *           
 */
typedef void (*smbc_get_auth_data_fn)(const char *srv, 
                                      const char *shr,
                                      char *wg, int wglen, 
                                      char *un, int unlen,
                                      char *pw, int pwlen);
</textarea> <br><br></td></tr></table><br>
<a name="1212232"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sub_Zero</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Double post! <br><br></td></tr></table><br>
<a name="1212242"></a>

<a name="1212246"></a>

<a name="1212248"></a>

<a name="1212249"></a>

<a name="1212250"></a>

<a name="1212251"></a>

<a name="1212253"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> In your glue code try..<br><br><pre class=code>
int bmx_smbc_init(smbc_get_auth_data_fn * fn, int debug) {
	BMaxCallback = fn;
		
	return smb_init( BMaxCallback,debug );
	//BMaxCallback(server, share, wrkgrp, 3, user, 3, pass, 3);

	}

</pre><br><br>Then in the module...<br><br><pre class=code>
Function setauthdatafn(server:Byte Ptr Var, share:Byte Ptr Var, workgroup:Byte Ptr Var, workgrouplen:Int Var, user:Byte Ptr Var, userlen:Int Var, password:Byte Ptr Var, passwordlen:Int Var)
	server = _server.ToCString()
	share = _share.ToCString()
	workgroup = _workgroup
	workgrouplen = _workgrouplen
	user = _user
	userlen = _userlen
	password = _password
	passwordlen = _passwordlen
End Function
</pre><br><br>EDIT:- OMG Hangover.... I've tidied the above after multi-edits.<br><br>The function is used to SET the variables so you will have to use Var on the end of the parameters, and use ( for eg ) server = _server.ToCString() to return the strings as c style strings. <br><br></td></tr></table><br>
<a name="1212243"></a>

<a name="1212244"></a>

<a name="1212258"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> oh I see you have tried the <br><br>return smbc_init(BMaxCallback,debug);<br><br>You should have<br><br><pre class=code>
smbc_get_auth_data_fn BMaxCallback;
</pre><br><br>as opposed to using a pointer. Or just pass the fn parameter of your bmx_smbc_init function straight into the smbc_init call if you don't need to save it - it looks like the lib will hold its own reference. <br><br></td></tr></table><br>
<a name="1212252"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sub_Zero</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> I will try that after eating dinner with my family, if my head still gets around :) <br><br></td></tr></table><br>
<a name="1212262"></a>

<a name="1212267"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sub_Zero</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thank you so much for the help!<br><br>Now it compiles :)<br><br>It compiles and runs, but I get a segfault when the callback function is actually being called (during smbc_opendir())<br><br>Any clues how to solve it? :)<br><br>here's my current libsmbclient.bmx:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' By Sub_Zero 2013
SuperStrict


Rem
bbdoc: Libsmbclient
End Rem
Module Sub.libsmbclient

ModuleInfo "Version: 1.00"
ModuleInfo "License: BSD"
ModuleInfo "Copyright: Wrapper by Sub_Zero"

Import BRL.Blitz
Import BRL.StandardIO

Import "include/*.h"
Import "glue.cpp"

?linux
Import "-ldl"
Import "-lsmbclient"
?

Extern

	Function bmx_smbc_new_context:Byte Ptr()
	Function bmx_smbc_init_context:Byte Ptr(context:Byte Ptr)
	Function bmx_smbc_set_context:Byte Ptr(context:Byte Ptr)
	Function bmx_smbc_init:Int(Callback:Byte Ptr, debug:Int)
	'Function bmx_get_auth_data_fn(server:String, share:String, workgroup:Byte Ptr, wglen:Int, username:Byte Ptr, unlen:Int, password:Byte Ptr, pwlen:Int)
	Function smbc_opendir:Int(durl$z)
	
End Extern


Rem
bbdoc: A SMB Context.
End Rem
Type SMBCCTX

	Field ctxPtr:Byte Ptr
	Global _server:String, _share:String, _workgroup:Byte Ptr, _workgrouplen:Int, _user:Byte Ptr, _userlen:Int, _password:Byte Ptr, _passwordlen:Int

	Rem
	bbdoc: Creates a SMB Context.
	End Rem
	Function CreateContext:SMBCCTX()
		Return New SMBCCTX.Create()
	End Function
	
	Rem
	bbdoc: Creates a SMB Context.
	End Rem
	Method Create:SMBCCTX()
		ctxPtr = bmx_smbc_new_context()
		Return Self
	End Method
	
	Rem
	bbdoc: Initializes a SMB Context.
	End Rem
	Method Init_Context()
		ctxPtr = bmx_smbc_init_context(ctxPtr)
	End Method
		
	Rem
	bbdoc: Init Context with server and share data + connection credentials
	End Rem
	Method Init:Int(server:String, share:String, workgroup:String, user:String, password:String)
		ctxPtr = bmx_smbc_set_context(ctxPtr);
		setauthdata(server, share, workgroup, user, password)
		Return bmx_smbc_init(setauthdatafn, 10) 'smbc_init(bmx_get_auth_data_fn, 10)
	End Method
	
	Rem
	bbdoc: Open a smb dir using smb address
	End Rem
	Method OpenDir:Int(dir:String)
		Return smbc_opendir(dir)
	End Method

	Method setauthdata(server:String, share:String, workgroup:String, user:String, password:String)
		_server = server
		_share = share
		_workgroup = workgroup.ToCString()
		_workgrouplen = Len(workgroup)
		_user = user.ToCString()
		_userlen = Len(user)
		_password = password.ToCString()
		_passwordlen = Len(password)
	End Method
		
	Function setauthdatafn(server:Byte Ptr Var, share:Byte Ptr Var, workgroup:Byte Ptr Var, workgrouplen:Int Var, user:Byte Ptr Var, userlen:Int Var, password:Byte Ptr Var, passwordlen:Int Var)
		server = _server.ToCString()
		share = _share.ToCString()
		workgroup = _workgroup
		workgrouplen = _workgrouplen
		user = _user
		userlen = _userlen
		password = _password
		passwordlen = _passwordlen
	End Function
End Type
</textarea><br><br>my glue.cpp:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
#include &lt;libsmbclient.h&gt;
//#include &lt;include/get_auth_data_fn.h&gt;

extern "C" {

#include "blitz.h"

	smbc_get_auth_data_fn BMaxCallback;
	SMBCCTX * bmx_smbc_new_context();
	SMBCCTX * bmx_smbc_init_context(SMBCCTX * ctx);
	SMBCCTX * bmx_smbc_set_context(SMBCCTX * ctx);
	int bmx_smbc_init(smbc_get_auth_data_fn fn, int debug);
	}


SMBCCTX * bmx_smbc_new_context() {
	SMBCCTX * ctx = new SMBCCTX;
	return ctx;
	}

SMBCCTX * bmx_smbc_init_context(SMBCCTX * ctx) {
	smbc_init_context(ctx);
	return ctx;
	}
	
SMBCCTX * bmx_smbc_set_context(SMBCCTX * ctx) {
	smbc_set_context(ctx);
	return ctx;
	}
	
int bmx_smbc_init(smbc_get_auth_data_fn fn, int debug) {
	BMaxCallback = fn;
	return smbc_init(BMaxCallback, debug);
	}
</textarea> <br><br></td></tr></table><br>
<a name="1212268"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> I would make sure - check the docs very carefully - as to what is expected to happen inside the callback. Even try commenting out the code inside the callback to rule out any problem with it - I'm assuming it is asking for what I think - setting the data - i dont have the lib in question, im on windows, and i came to that conclusion because of the way youre setting the 'max variables to the parameters - are you sure thats what's expected in the callback?<br><br>I'm out for night again - back tomorrow afternoon :) <br><br></td></tr></table><br>
<a name="1212270"></a>

<a name="1212272"></a>

<a name="1212273"></a>

<a name="1212274"></a>

<a name="1212276"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sub_Zero</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> First of all thanks for all your help! :)<br><br>Edit: I tried commenting out everything inside my setauthdatafn function, and it didn't segfault!! Instead i got a working connection with smbc_opendir using the default username and password supplied by the lib.<br><br>Here is two different callback functions that works if I compile some of the .c examples supplied with the lib:<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
static void
get_auth_data_fn(const char * pServer,
                 const char * pShare,
                 char * pWorkgroup,
                 int maxLenWorkgroup,
                 char * pUsername,
                 int maxLenUsername,
                 char * pPassword,
                 int maxLenPassword)
{
    char            temp[128];
    char            server[256] = { '\0' };
    char            share[256] = { '\0' };
    char            workgroup[256] = { '\0' };
    char            username[256] = { '\0' };
    char            password[256] = { '\0' };

    static int krb5_set = 1;

    if (strcmp(server, pServer) == 0 &amp;&amp;
        strcmp(share, pShare) == 0 &amp;&amp;
        *workgroup != '\0' &amp;&amp;
        *username != '\0')
    {
        strncpy(pWorkgroup, workgroup, maxLenWorkgroup - 1);
        strncpy(pUsername, username, maxLenUsername - 1);
        strncpy(pPassword, password, maxLenPassword - 1);
        return;
    }

    if (krb5_set &amp;&amp; getenv("KRB5CCNAME")) {
      krb5_set = 0;
      return;
    }

    fprintf(stdout, "Workgroup: [%s] ", pWorkgroup);
    fgets(temp, sizeof(temp), stdin);
    
    if (temp[strlen(temp) - 1] == '\n') /* A new line? */
    {
        temp[strlen(temp) - 1] = '\0';
    }
    
    if (temp[0] != '\0')
    {
        strncpy(pWorkgroup, temp, maxLenWorkgroup - 1);
    }
    
    fprintf(stdout, "Username: [%s] ", pUsername);
    fgets(temp, sizeof(temp), stdin);
    
    if (temp[strlen(temp) - 1] == '\n') /* A new line? */
    {
        temp[strlen(temp) - 1] = '\0';
    }
    
    if (temp[0] != '\0')
    {
        strncpy(pUsername, temp, maxLenUsername - 1);
    }
    
    fprintf(stdout, "Password: ");
    fgets(temp, sizeof(temp), stdin);
    
    if (temp[strlen(temp) - 1] == '\n') /* A new line? */
    {
        temp[strlen(temp) - 1] = '\0';
    }
    
    if (temp[0] != '\0')
    {
        strncpy(pPassword, temp, maxLenPassword - 1);
    }

    strncpy(workgroup, pWorkgroup, sizeof(workgroup) - 1);
    strncpy(username, pUsername, sizeof(username) - 1);
    strncpy(password, pPassword, sizeof(password) - 1);

    krb5_set = 1;
}
</textarea><br><br>Alernative: Here is another one that doesn't set the server or share name, used for just printing eg. available shares or access as guest user:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
const char	*workgroup	= "NT";
const char	*username	= "guest";
const char	*password	= "";

static void smbc_auth_fn(
                const char      *server,
		const char      *share,
		char            *wrkgrp, int wrkgrplen,
		char            *user,   int userlen,
		char            *passwd, int passwdlen){
		
    (void) server;
    (void) share;
    (void) wrkgrp;
    (void) wrkgrplen;

    strncpy(wrkgrp, workgroup, wrkgrplen - 1); wrkgrp[wrkgrplen - 1] = 0;
    strncpy(user, username, userlen - 1); user[userlen - 1] = 0;
    strncpy(passwd, password, passwdlen - 1); passwd[passwdlen - 1] = 0;
}
</textarea> <br><br></td></tr></table><br>
<a name="1212286"></a>

<a name="1212287"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sub_Zero</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Double post again!<br><br>(I'm on a packet loss line right now) <br><br></td></tr></table><br>
<a name="1212291"></a>

<a name="1212292"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> You're welcome for the help.<br><br>Aside from the checking of the memory contents pointed at by the variables in the callback ( if the server and share pointer contents are the same as you would set them, and making sure that the memory contents are emtpy via chaking for a null terminator at the start of the string ) it looks like a simple MemCopy would get the job done. In that case remove the Var(s) in the parameters of the BMax callback and use a MemCopy to copy across  the strings into the pointers provided to you in the callback function...<br><br>in other words change :-<br><pre class=code>
Function setauthdatafn(server:Byte Ptr Var, share:Byte Ptr Var, workgroup:Byte Ptr Var, workgrouplen:Int Var, user:Byte Ptr Var, userlen:Int Var, password:Byte Ptr Var, passwordlen:Int Var)
</pre><br><br>back to :-<br><br><pre class=code>
Function setauthdatafn(server:Byte Ptr, share:Byte Ptr, workgroup:Byte Ptr, workgrouplen:Int, user:Byte Ptr, userlen:Int, password:Byte Ptr, passwordlen:Int)
</pre><br>and use a simple MemCopy to copy the strings across, so instead of using server = _server.ToCString()<br><br>use:-<br><pre class=code>
MemClear(server,256) ' You don't really need this as the .ToCString() will add a null terminator for you, but they are doing similar in your example above.
MemCopy(server,_server.ToCString(),Len(_server)+1) ' This will copy the data across into the memory address provided for you.

MemClear(share,256)
MemCopy(share,_share.ToCString(),Len(_share)+1) ' +1 to include the null terminator in the length
</pre><br>and so on, keep using the .ToCString() for each string copy making sure that the length of the workgroup,user and password variable lengths never exceed the maximum length coming in via the workgrouplen,userlen and passwordlen parameters by using either Len(workgroup) or workgroup.Length. It looks like a max length of 255 is allowed for each.<br><br>Have fun :) <br><br></td></tr></table><br>
<a name="1212305"></a>

<a name="1212306"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Brucey</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> _server.ToCString() <br></div><br>... is a memory leak in the way you've used it there.<br><br>And you probably want to use ToUTF8String() instead, anyway. (again, not in the way used above) <br><br></td></tr></table><br>
<a name="1212308"></a>

<a name="1212309"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>... is a memory leak in the way you've used it there<br> <br></div><br><br>Indeed it is. I forgot about that, thanks!<br><br>Assign it to a variable and free the variable with MemFree afterwards :-<br><br><pre class=code>
Local serverSring:Byte ptr = _server.ToUTF8String()  ' as Brucey rightly suggests
MemCopy(server,serverString,Len(_server)+1) ' copy the string
MemFree(serverString) ' free the memory used by the string! important!
</pre> <br><br></td></tr></table><br>
<a name="1212365"></a>

<a name="1212371"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sub_Zero</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks for all your help...<br><br>I've now managed to get the lib to recognize the parameters, it recognizes server, share, workgroup, username and password.. It also connects to the share :)<br><br>EDIT: Now it works flawlessly :)<br><br>I'll post the code as example:<br><br>libsmbclient.bmx:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
' By Sub_Zero 2013
SuperStrict


Rem
bbdoc: Libsmbclient
End Rem
Module Sub.libsmbclient

ModuleInfo "Version: 1.00"
ModuleInfo "License: BSD"
ModuleInfo "Copyright: Wrapper by Sub_Zero"

Import BRL.Blitz
Import BRL.StandardIO

Import "include/*.h"
Import "glue.cpp"

?linux
'Import "-ldl"
Import "-lsmbclient"
?

Extern

	Function bmx_smbc_new_context:Byte Ptr()
	Function bmx_smbc_init_context:Byte Ptr(context:Byte Ptr)
	Function bmx_smbc_set_context:Byte Ptr(context:Byte Ptr)
	Function bmx_smbc_free_context:Int(context:Byte Ptr, shutdown_ctx:Int)
	Function bmx_smbc_init:Int(Callback:Byte Ptr, debug:Int)
	Function smbc_opendir:Int(durl$z)
	
End Extern


Rem
bbdoc: A SMB Context.
End Rem
Type SMBCCTX

	Field ctxPtr:Byte Ptr
	Global _server:Byte Ptr, _serverlen:Int, _share:Byte Ptr, _sharelen:Int, _workgroup:Byte Ptr, _workgrouplen:Int, _user:Byte Ptr, _userlen:Int, _password:Byte Ptr, _passwordlen:Int

	Rem
	bbdoc: Creates a SMB Context.
	End Rem
	Function CreateContext:SMBCCTX()
		Return New SMBCCTX.Create()
	End Function
	
	Rem
	bbdoc: Creates a SMB Context.
	End Rem
	Method Create:SMBCCTX()
		ctxPtr = bmx_smbc_new_context()
		Return Self
	End Method
	
	Rem
	bbdoc: Initializes a SMB Context.
	End Rem
	Method Init_Context()
		ctxPtr = bmx_smbc_init_context(ctxPtr)
	End Method
			
	Rem
	bbdoc: Init Context with server and share data + connection credentials
	End Rem
	Method Init:Int(server:String, share:String, workgroup:String, user:String, password:String)
		ctxPtr = bmx_smbc_set_context(ctxPtr);
		setauthdata(server, share, workgroup, user, password)
		Return bmx_smbc_init(setauthdatafn, 10)
	End Method
	
	Rem
	bbdoc: Open a smb dir using smb address
	End Rem
	Method OpenDir:Int(dir:String)
		Return smbc_opendir(dir)
	End Method

	Method setauthdata(server:String, share:String, workgroup:String, user:String, password:String)
		_server = server.ToUTF8String()
		_serverlen = Len(server)
		_share = share.ToUTF8String()
		_sharelen = Len(share)
		_workgroup = workgroup.ToUTF8String()
		_workgrouplen = Len(workgroup)
		_user = user.ToUTF8String()
		_userlen = Len(user)
		_password = password.ToUTF8String()
		_passwordlen = Len(password)
	End Method
	
	'Auth data callback function
	Function setauthdatafn(server:Byte Ptr, share:Byte Ptr, workgroup:Byte Ptr, workgrouplen:Int, user:Byte Ptr, userlen:Int, password:Byte Ptr, passwordlen:Int)
		MemClear(server, _serverlen+1)
		MemClear(share, _sharelen+1)
		MemClear(workgroup,256)
		MemClear(user,256)
		MemClear(password,256)
		MemCopy(server,_server, _serverlen+1)
		MemCopy(share,_share, _sharelen+1)
		MemCopy(workgroup,_workgroup, _workgrouplen+1)
		MemCopy(user,_user, _userlen+1)
		MemCopy(password,_password, _passwordlen+1)
	End Function
	
	Rem
	bbdoc: Close and free the SMB Context
	End Rem
	Method Close()
		If ctxPtr Then
			bmx_smbc_free_context(ctxPtr, 1);
			ctxPtr = Null
		End If
	End Method
	
	Method Delete()
		Close()
	End Method

End Type
</textarea><br><br>glue.cpp:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
#include &lt;libsmbclient.h&gt;

extern "C" {

#include "blitz.h"

	SMBCCTX * bmx_smbc_new_context();
	SMBCCTX * bmx_smbc_init_context(SMBCCTX * ctx);
	SMBCCTX * bmx_smbc_set_context(SMBCCTX * ctx);
	int bmx_smbc_free_context(SMBCCTX * ctx, int shutdown_ctx);
	int bmx_smbc_init(smbc_get_auth_data_fn fn, int debug);
	}


SMBCCTX * bmx_smbc_new_context() {
	SMBCCTX * ctx = new SMBCCTX;
	return ctx;
	}

SMBCCTX * bmx_smbc_init_context(SMBCCTX * ctx) {
	smbc_init_context(ctx);
	return ctx;
	}
	
SMBCCTX * bmx_smbc_set_context(SMBCCTX * ctx) {
	smbc_set_context(ctx);
	return ctx;
	}
	
int bmx_smbc_free_context(SMBCCTX * ctx, int shutdown_ctx) {
	return smbc_free_context(ctx, shutdown_ctx);	
	}
	
int bmx_smbc_init(smbc_get_auth_data_fn fn, int debug) {
	return smbc_init(fn, debug);
	}
</textarea><br><br>testsmb.bmx:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict

Framework BRL.StandardIO
Import Sub.libsmbclient

Local smb:SMBCCTX

smb = New SMBCCTX
If smb Print "SMB Context Created..."
Print smb.Init("127.0.0.1", "test", "WORKGROUP", "meg", "1234")
Print "Inited with Auth data set"
Print smb.OpenDir("smb://127.0.0.1/test/")
smb.Close()
</textarea><br><br>Now I understand how to wrap a callback function. Thanks guys! <br><br></td></tr></table><br>
<a name="1212387"></a>

<a name="1212388"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well done!!<br><br>Dont forget to MemFree all of the 'string' field variables inside the SMBCCTX.Close method. <br><br></td></tr></table><br>
<a name="1212389"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sub_Zero</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ofcourse, I forgot :) Cheers! <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
