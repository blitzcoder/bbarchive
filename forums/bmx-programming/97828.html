<!DOCTYPE html><html lang="en" ><head ><title >BBRETAIN</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >BBRETAIN</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >BBRETAIN</a><br><br>
<a name="1138680"></a>

<a name="1138681"></a>

<a name="1138682"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Armitage 1982</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm currently analyzing modules code to correctly port C++ Libraries myself and found this situation in the Brucey Box2D module.<br><br>This is the C++ part, everything is correctly Extern and accessible from BlitzMax:<br><br><pre class=code>b2BodyDef * bmx_b2bodydef_create() {
	return new b2BodyDef;
}

b2Body * bmx_b2world_createbody(b2World * world, b2BodyDef * def, BBObject * body) {
	def-&gt;userData = body;
	BBRETAIN(body);
	return world-&gt;CreateBody(def);
}</pre><br>And this is the BlitzMax part :<br><pre class=code>Type b2World

	Field b2ObjectPtr:Byte Ptr	' The b2World object is correctly init somewhere else

	'...
	
	Method CreateBody:b2Body(def:b2BodyDef)
		Local body:b2Body = New b2Body
		body.b2ObjectPtr = bmx_b2world_createbody(b2ObjectPtr, def.b2ObjectPtr, body)
		body.userData = def.userData ' copy the userData
		Return body
	End Method

End Type

Type b2BodyDef
	
	Field b2ObjectPtr:Byte Ptr
	Field userData:Object
	
	Method New()
		b2ObjectPtr = bmx_b2bodydef_create()
	End Method
	
End Type</pre><br><br>Consider the b2BodyDef pointer as a <b>Definition</b> object used by a factory (<i>world-&gt;CreateBody(def)</i>) to create <b>body</b> object in this physical library.<br>You can reuse <b>Definition</b> or nullify them, it's up to you.<br>You can also set your own userData inside, it will be transferred in your body at creation time.<br><br><br>My question is: <b>why using BBRETAIN in this case?</b><br><br>A link is also created between the definition object and the body (<i>def-&gt;userData = body</i>) while it's not supposed to happen in the original library.<br><br>In fact, rewriting this C++ function this way would work as well:<br><pre class=code>b2Body * bmx_b2world_createbody(b2World * world, b2BodyDef * def) {
	return world-&gt;CreateBody(def);
}</pre><br>I tried in a big project using GCcollect and didn't notice any loss or crash bug...<br><br><br>In other words:<br><b>Why BBRETAIN() an object created inside BlitzMax itself?</b><br>Normally the garbage collector won't collect it unless you forget about it yourself inside BlitzMax, no ?<br><br>Won't the C++ object persist in memory thanks to the pointer returned and managed inside BlitzMax ?<br><br>I never really used BBRETAIN before and don't know much about the GC so there is probably a few things I'm missing there...<br><br><br>Afaik Brucey is using this tricks while creating body, shape, joint and controller. But not for definition objects or C++ struct.<br>Too bad I cannot ask him why anymore :(<br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1138689"></a>

<a name="1138710"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Won't the C++ object persist in memory thanks to the pointer returned and managed inside BlitzMax ? <br></div><br><br>Nope.<br><br>BlitzMax uses reference counting (you're thinking of "tracing", which... is different). When you set a variable to a pointer the refcount for that pointer is adjusted at the same time by code added by the BlitzMax compiler. Because the variable is being set <i>in C++ code</i>, the C++ is just compiled to the set operation alone. Therefore the C++ code needs to have the reference count code added explicitly, or the garbage collector won't have been informed that a new reference to the object exists.<br><br>(In other words, <i>no it does not</i> scan anything, and therefore if it isn't watching when ref.userData is set, it will never know a pointer existed there.)<br><br><b>EDIT:</b> Your rewrite that only calls CreateBody is not going to cause a memory leak since the BBRETAIN isn't needed if the userData field isn't being set (I make no comment on whether the field <i>should</i> be being set), so within that one function at least, that change is safe.<br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1138769"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Armitage 1982</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks Yasha.<br>I roughly understand the use of BBRETAIN.<br>Unfortunately my skills is a bit low about wrapping library :(<br><br>If you are interested in a Box2d module maybe you can give me a hand on this : <a href="http://code.google.com/p/arme-mod/" target="_blank">http://code.google.com/p/arme-mod/</a> ? <br><br></td></tr></table><br>
<a name="1139790"></a>

<a name="1139791"></a>

<a name="1139792"></a>

<a name="1139793"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> So to re-iterate its use...<br><br>This is how I understand it, so please free to correct me if I'm wrong :-<br><br>The scenario will be using BMax to call a C wrapped function in C++ that will create an instance of  a C++ object/class/whatever and pass the address as a pointer back into BMax to be used as an 'instance handle'.<br><br>In the BMax code, you call the ( C wrapped ) C++  function that creates the instance and returns its address :- you save this with a :Byte Ptr in BMax. This 32bit memory pointer will be GC managed within BMax, but ONLY the memory pointer. From what I understand the actual object is hanging on a thread now, preying that it isn't overwritten or trampled over, as its now 'out of scope' of the function that created it and BMax doesnt know of the actual C++ object itself.<br><br>So now in the C++ we need to GC manage this object too. Therefore we'd wrap the C++ object with BBRETAIN / BBRELEASE when creating and destroying the instance.<br><br>Also in the C++ code, if we have a 'global' variable and create an instance of something in a C++ function using that variable, we pass that variable back into BMax, I've assumed the C++ object still needs BMax GC management too?<br><br>Am I correct in the usage in said scenarios?<br><br><br><br><br>Next scenario...<br><br>You have the C++ object created as above. You pass the object back into C++ and attach it as another C++ object as one of its members. So you'd also use BBRETAIN again to add another reference to it?<br><br><font class="tiny">Last edited 2012</font> <br><br></td></tr></table><br>
<a name="1139795"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Yasha</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Am I correct in the usage in said scenarios? <br></div><br><br>No.<br><br>BBRETAIN and BBRELEASE are for use with BlitzMax objects <i>only</i>. They are only for use when assigning BlitzMax object pointers in non-BlitzMax code, nothing else.<br><br>C++ doesn't have any built-in concept of reference-counting, nor does it even have a base object class, so there is no reference count in a C++ object for the BlitzMax refcount system to adjust. C++ objects are completely separate animals from BlitzMax objects, and you either have to manually destroy them with an appropriate Free function provided by the library, or roll your own GC from the ground up (...don't do this!).<br><br>Using BBRETAIN and BBRELEASE on a C++ object <i>will</i>, without question, break your code, not work as expected, and not actually have anything to do with garbage collection either (since the C++ object isn't in any way part of the BlitzMax GC runtime).<br><br>Short answer: BlitzMax reference counting cannot be used on C++ objects. You need a completely separate lifecycle management system, either built into the library, or managed from your BlitzMax application; neither of these is provided by BlitzMax.<br><br>One way to manage C++ object lifecycle from BlitzMax is to store the C++ object in a BlitzMax wrapper object that will free the C++ object in its finaliser (and make sure that the C++ object is not stored directly anywhere else).<br><br><br><div class="quote"> This 32bit memory pointer will be GC managed within BMax, but ONLY the memory pointer. <br></div><br><br>...this 32-bit value will be a simple numeric value; the concept of garbage collection doesn't really apply to it (any more than it applies to e.g. ints). A pointer is not an object: it <i>refers to</i> an object.<br><br><br><div class="quote"> you call the ( C wrapped ) C++ function that creates the instance and returns its address :- you save this with a :Byte Ptr in BMax <br></div><br><br>...if you like, but remember you can also have Extern Types (which lets you access C++ methods from BlitzMax, always handy), for better type safety.<br><br><br><div class="quote"> So you'd also use BBRETAIN again to add another reference to it? <br></div><br><br>No, because you wouldn't use BBRETAIN on a C++ object. (I'm not sure I'm reading the question correctly but it also looks like you might be establishing a circular reference there...?).<br><br><br>Sorry if that sounds harsh, but basically you have almost the exact opposite of the right idea: don't use BlitzMax memory management for C++ objects, as it will end in disaster. <br><br></td></tr></table><br>
<a name="1139799"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> Sorry if that sounds harsh, but basically you have almost the exact opposite of the right idea: don't use BlitzMax memory management for C++ objects, as it will end in disaster. <br></div><br><br>No need to apologise. After seeing it used in Armitage example, I thought that I was doing it wrong and then had the concept that I described above pop into my head.<br><br>It has always been a guess for me before but you've confirmed it for me that it's ok the way I've doing it.<br>Thanks for the explanation. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
