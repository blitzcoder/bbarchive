<!DOCTYPE html><html lang="en" ><head ><title >Are these image sizes safe?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Are these image sizes safe?</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Are these image sizes safe?</a><br><br>
<a name="1217806"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GfK</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I need to have an info panel at the bottom of the screen.  It will be 1024x64 pixels.  Is that safe on the majority of hardware nowadays, or am I better off having it split into 64x64 images and tiling it? <br><br></td></tr></table><br>
<a name="1217808"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> It just depends on the max-size of textures a graphics card can handle.<br><br>If you are not sure about it - create your own image-class handling splitting too large images automatically - think there was a BigImage-type posted some years ago.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1217809"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GfK</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've already done that and used it in past games.  I just wondered if it was a pointless exercise in 2014. <br><br></td></tr></table><br>
<a name="1217812"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Most people nowadays have 2048 texture size, even all mobile devices since like iPhone 4 or before. <br><br></td></tr></table><br>
<a name="1217829"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Calibrator</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Interesting question - I was wondering the same recently.<br><br>I often read that a texture size of 1024 would be a "good minimum" to reach a bigger audience but what will I really lose if I would work with a 2048 texture size?<br>In other words: What minimum PC/Mac graphics hardware would I need for a 2048 texture size?<br><br>Background:<br><br>I'm dabbling with a tile-based game and will use 64x64 pixel tiles (not smaller, except for "missiles" and other effect). Using a 1024x1024 texture would only allow for 256 tiles, though.<br><br>A texture size of 2048x2048 would naturally increase that to 1024 tiles - which would be much better: More animations, a general library of landscape and object tiles and, last but not least, simplify programming.<br>I'm strictly speaking "pure" Bmax/Max2D commands like DrawImage() etc. here and I'd like to avoid unnecessary slowdowns because of excessive texture swapping behind the scenes.<br>Obviously, a larger texture size increases RAM usage as well but it seems to me that this is a smaller problem. <br><br></td></tr></table><br>
<a name="1217853"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >xlsior</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Correct me if I'm wrong, but I thought that Blitzmax by default wasn't smart enough to retain the texture in between multiple drawing commands?<br><br>I seem to remember that there were some 3rd party tweaks necessary to actually get any speed benefits from cramming all of them into a single image <br><br></td></tr></table><br>
<a name="1217859"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Floyd</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Many years ago some cards/drivers couldn't deal a width and height that were very different. <br>A 1024x1024 texture might work, but not 1024x64.<br><br>I have no idea if this is still true. <br><br></td></tr></table><br>
<a name="1217860"></a>

<a name="1217861"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >BLaBZ</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> You can query the users machine to determine max texture size -<br><br>May need to change the drawing to OpenGL - <br><br><pre class=code>
local s:int 
glGetIntegerv(GL_MAX_TEXTURE_SIZE, varptr s)
</pre><br><br>Also, I'm pretty sure blitzMAX resizes images for openGL<br><br>ie: an image size 1024x64 will actually be stored in graphic memory as 1024x1024 <br><br></td></tr></table><br>
<a name="1217862"></a>

<a name="1217863"></a>

<a name="1217864"></a>

<a name="1217865"></a>

<a name="1217866"></a>

<a name="1217867"></a>

<a name="1217868"></a>

<a name="1217869"></a>

<a name="1217870"></a>

<a name="1217873"></a>

<a name="1217949"></a>

<a name="1217950"></a>

<a name="1217951"></a>

<a name="1217954"></a>

<a name="1217955"></a>

<a name="1217957"></a>

<a name="1217958"></a>

<a name="1217959"></a>

<a name="1217964"></a>

<a name="1217965"></a>

<a name="1217967"></a>

<a name="1217968"></a>

<a name="1217969"></a>

<a name="1217970"></a>

<a name="1217971"></a>

<a name="1217972"></a>

<a name="1217973"></a>

<a name="1217974"></a>

<a name="1217976"></a>

<a name="1217977"></a>

<a name="1217978"></a>

<a name="1217979"></a>

<a name="1217980"></a>

<a name="1218143"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> General texturing optimizations for both the APIs offered by Max2D can be seen here:<br><br>OpenGL:<br><a href="http://www.mesa3d.org/brianp/sig97/perfopt.htm#Texturing" target="_blank">http://www.mesa3d.org/brianp/sig97/perfopt.htm#Texturing</a><br><br>Direct3D 9:<br><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/bb147263(v=vs.85).aspx#Texture_Size" target="_blank">http://msdn.microsoft.com/en-us/library/windows/desktop/bb147263(v=vs.85).aspx#Texture_Size</a><br><br>What you can do is compare the desired image size with the maximum size supported by the hardware. If it's bigger than the maximum then split it to something smaller. This is done at a pixmap level - no TImages being used yet. If the splitting is necessary, you can easily create two pixmaps from splitting a bigger one, and then create images from those pixmaps.<br>One can use the following API calls to find out the largest texture dimensions supported by the hardware. <br><br>OpenGL:<br><font class="tiny">Note that the OpenGL method below is more reliable than querying the GL_MAX_TEXTURE_SIZE constant, which is regarded by the OpenGL documentation as an "estimated value," since it's not involving the cost of the pixel format.</font><br><pre class=code>SetGraphicsDriver( GLMax2DDriver() )
Graphics( 800, 600 )

Local maxTextureSize:Int

Local tempSize:Int = 65536 'Start with a prohibitively large power-of-two size.
Repeat
	Local t:Int

	'Test if a dummy texture can be created with a large size.
	
	glTexImage2D( GL_PROXY_TEXTURE_2D, 0, 4, tempSize, tempSize, 0, GL_RGBA, GL_UNSIGNED_BYTE, Null )
	glGetTexLevelParameteriv( GL_PROXY_TEXTURE_2D, 0, GL_TEXTURE_WIDTH, Varptr t )
	
	If t Then 
		maxTextureSize = tempSize 'Found the biggest size supported.
		Exit
	EndIf	
	
	If tempSize = 1 Then RuntimeError "Unable to calculate maximum texture size."
	If tempSize &gt; 1 Then tempSize :/ 2
Forever

Print maxTextureSize 'This is the maximum size for the width and height.

End</pre><br>Direct3D 9:<br><pre class=code>SetGraphicsDriver( D3D9Max2DDriver() ) 
Graphics( 800, 600 )

Local d3d9:IDirect3D9 = D3D9GraphicsDriver().GetDirect3D()

Local myCaps:D3DCAPS9 = New D3DCAPS9
d3d9.GetDeviceCaps( D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, myCaps )

'Capability names obtained from 'pub.mod\directx.mod\d3d9.bmx.'

Print myCaps.MaxTextureWidth
Print myCaps.MaxTextureHeight

'The following is the maximum value that you can have in one dimension 
'of a texture when the other dimension is '1.' 
'For example, if the value is '4096,' you can make textures with a ratio of
'4096 : 1.'
'The ratio isn't necessarily the maximum width or height: You can have
'a maximum width or height of '8192' but a maximum ratio of '4096 : 1.'
'This would mean that you can have textures of actual sizes of 
'4096 x 1' or '8192 x 2,' but not not '8192 : 1.'

Print myCaps.MaxTextureAspectRatio

'OpenGL does not have a 'maximum aspect ratio value,' so you can assume
'it is the maximum width or height supported: 'maxTextureSize : 1.'

myCaps	= Null
d3d9	= Null

End</pre><br><div class="quote"> Correct me if I'm wrong, but I thought that Blitzmax by default wasn't smart enough to retain the texture in between multiple drawing commands? <br></div><br>I have looked at the source to assert the following. <br>Independently of the driver used, Max2D keeps the last texture used between multiple drawing commands.<br>Consecutive DrawImages() of the exact same image only bind and enable the texture for the image on the first call. So it would be wise to order one's drawing calls so that the repeated images are drawn consecutively and benefit from this.<br><br><div class="quote"> Also, I'm pretty sure blitzMAX resizes images for openGL. <br></div><br>If you load an image that is already of a power-of-two size and such size is supported by the hardware, regardless of the driver, <i>no</i> scaling is done. <br>If one of the dimensions of the image is not a power-of-two, the texture that will contain the pixmap is padded up to the next highest power-of-two value. The pixmap is still not scaled - the texture that contains it is just bigger (with unused data). There's no visual difference to the original image, and collisions still work as usual.<br>The only occasion where a pixmap is scaled (that is, what you loaded is different than what is being displayed) happens with the OpenGL driver: If the image that you loaded or created from a pixmap has a size (be it power-of-two or not) that <i>exceeds</i> the maximum size supported by the hardware, the pixmap is scaled down to acceptability. With the Direct3D driver, it tries to create the texture anyway and throws an error if it fails.<br><br><div class="quote"> Many years ago some cards/drivers couldn't deal a width and height that were very different. <br>A 1024x1024 texture might work, but not 1024x64. <br></div><br>For non-square textures (textures that have differing width and height, although both being power-of-two), it seems that graphic cards from the GeForce 2 series and its peers and earlier do require that the width and height of a texture are made equal. But then they also have some other strange requirements such as maximum texture sizes of 256 x 256 etc.<br>But those are very old cards (2002 and earlier). <br>If your game uses power-of-two, non-square textures with either of the official graphics drivers for Max2D, it should be supported by most systems beyond 2003, which is quite a broad audience.<br><br>Further reading:<br>- <a href="http://www.ogre3d.org/forums/viewtopic.php?p=66038&amp;sid=c19c6f95fdb3a44036c4a936b4a67993#p66038" target="_blank">Ogre3D forum post</a><br>- <a href="http://www.gamedev.net/topic/112860-textures-larger-than-256x256/" target="_blank">GameDev Net forum post</a><br>- http://www.hard-light.net/forums/index.php?topic=973.10;wap2 <br><br></td></tr></table><br>
<a name="1217871"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >xlsior</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> For the OpenGL driver only, if the image exceeds the supported hardware size then it is downscaled to acceptability. <br></div><br><br>Of course, that would mean muddy/blurry sprites in that case, I presume. <br><br></td></tr></table><br>
<a name="1217921"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Calibrator</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks folks, especially Kryzon for providing the test routines.<br><br>I modified the OGL one a bit to make it easier to test it on other machines:<br><br><pre class=code>
SetGraphicsDriver GLMax2DDriver()

Graphics 800,600

DrawText "GLMax2DDriver",50,100

Local tempSize:Int = 16384    'Start with a prohibitively large power-of-two size.
Local maxTextureSize:Int

Repeat
	Local t:Int

	'Test if a dummy texture can be created with a large size.

	glTexImage2D( GL_PROXY_TEXTURE_2D, 0, 4, tempSize, tempSize, 0, GL_RGBA, GL_UNSIGNED_BYTE, Null )
	glGetTexLevelParameteriv( GL_PROXY_TEXTURE_2D, 0, GL_TEXTURE_WIDTH, Varptr t )

	If t Then
		maxTextureSize = tempSize 'Found the biggest size supported.
		Exit
	EndIf

	If tempSize = 1 Then RuntimeError "Unable to calculate maximum texture size."
	If tempSize &gt; 1 Then tempSize :/ 2
	Forever

DrawText "MaxTextureSize = " + maxTextureSize, 50, 150    'This is the maximum size for the width and height.

DrawText "(Hit a key to close the window)",50,400

Flip

WaitKey
EndGraphics

End
</pre><br><br>A Geforce 770 on Win7 throws out 16K (very likely the maximum, increasing the initial tempsize value doesn't change it), while an old XP PC from 2006 with an Intel 945GM Express Chipset yields 2K.<br><br>Given that my game is still right at the beginning of development I can comfortably live with a 2K maximum... <br><br></td></tr></table><br>
<a name="1217929"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just one thought... if you are targeting desktops.. and pretty much the minimum desktop resolution now is at least 1024x768 (although higher is more popular), to show such a resolution REQUIRES a `texture size` of at least 1024 (at least from what I've seen I don't think I've ever encountered a resolution which is larger than the max texture size).... so it would tend to suggest 1024 is at least very widely supported. I don't think you have to worry about anything smaller. <br><br></td></tr></table><br>
<a name="1217961"></a>

<a name="1217962"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> and pretty much the minimum desktop resolution now is at least 1024x768  <br></div><br>Not quite true... there are quite a few laptops which has a maximum resolution height of 600...<br><br><br>As to the original question, I would have thought 1024x64 would be blown up to 1024x1024 by BMax... To be safe I think I would split it into smaller images - "GrandMa" hasn't updated her PC in decades. <br><br></td></tr></table><br>
<a name="1218113"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Look at Unity's webplayer stats, or steams hardware survey, there's probably less than 1% of users with anything less than 1024x768. <br><br></td></tr></table><br>
<a name="1218114"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GfK</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> there's probably less than 1% of users with anything less than 1024x768. <br></div>It's actually 1.5%.  But that can add up to a hell of a lot of potential customers. <br><br></td></tr></table><br>
<a name="1218115"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gabriel</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> If your game uses power-of-two, non-square textures with either of the official graphics drivers for Max2D, it should be supported by most systems beyond 2003, which is quite a broad audience. <br></div><br>I don't think that's what Floyd was referring to. There was an issue on hardware which does support NPOT textures that they only supported them up to a maximum ratio of 8:1 or 1:8 width/height. <br><br>Since 1024 to 64 is 16:1 ratio, that would cause a problem if that issue still exists. Like Floyd, however, I have no idea if it's still an issue. I pack all of my odd-shaped images into 2048x2048 texture atlases for performance reasons. I doubt it's an issue on modern hardware, but wouldn't want to say 100%. <br><br></td></tr></table><br>
<a name="1218117"></a>

<a name="1218118"></a>

<a name="1218119"></a>

<a name="1218120"></a>

<a name="1218123"></a>

<a name="1218132"></a>

<a name="1218158"></a>

<a name="1218160"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> <br>I would have thought 1024x64 would be blown up to 1024x1024 by BMax...<br> <br></div><br><br>Nah...<br><br>From what I remember pixmaps and textures are handled in this way...<br><br>ALL textures and pixmaps are initially loaded and stored in Max2D as pixmaps.<br>When it comes to drawing a pixmap it's pretty much a byte copy to the display surface.<br><br><br>EDIT:- This isnt explained very well, Kryzons explanation is clearer and correct.<br>Now when it comes to textures ( TImage ) its a completely different story :)<br>When it comes to drawing an TImage, remember it was graphic file was loaded as a TPixmap and now needs to be uploaded to the gpu as a texture. If one, or both, of the pixmap dimensions is SMALLER than its NEAREST ( images are not down-sized, only up sized if needed ) power of 2 <strike>then a copy of the pixmap is created and rescaled to that nearsest power of 2 dimensions, this copy is then uploaded to the gpu card to be used as the texture that you'll end up seeing. So if you load an image of 1000x60 it will be resized as a pixmap to 1024x64 and that temporary pixmap is passed to the gpu. You may be thinking about aspect ratios at the point, but thats taken care of by the texture being displayed on a 2 triangle quad at the size of the original pixmap dimensions.</strike><br><br>And after that...<br><br>Depending on the flags used is whether mip maps are generated or not, and if they are then the mip maps are generated manually as separate pixmaps too. As I'm sure you know each mipmap is the same image but reduced in size by half the width and half the height for each mip map. The mip maps are then halved again and the process keeps going until they are 1 x 1 pixels. Each mipmap is loaded into to appropriate gpu texture as its generated.<br><br>This all happens during the first use of the DrawImage call that uses the TImage. The now newly created gpu texture is stored with the TImage and used in any further calls that use that TImage - ie its texture is not created every frame, just the very first one. EDIT:- Actually the texture is saved in a TImageFrame which is driver related and the TImageFrame is queried for the appropriate TImage instance which is then drawn use the appropriate driver. <br><br></td></tr></table><br>
<a name="1218150"></a>

<a name="1218151"></a>

<a name="1218162"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hello.<br><br><div class="quote"> There was an issue on hardware which does support NPOT textures that they only supported them up to a maximum ratio of 8:1 or 1:8 width/height. <br><br>Since 1024 to 64 is 16:1 ratio, that would cause a problem if that issue still exists. Like Floyd, however, I have no idea if it's still an issue. I pack all of my odd-shaped images into 2048x2048 texture atlases for performance reasons. I doubt it's an issue on modern hardware, but wouldn't want to say 100%. <br></div><br>Since the Direct3D 9 driver has that 'MaxTextureAspectRatio' capability field, we can assume that a piece of hardware that supports D3D9a and above does not have that limitation - or at least, you can verify if it does (that field would have to report a value of '8').<br>In any case, when Max2D is unable to create a texture for an image, the OpenGL driver throws a RuntimeError and the Direct3D 9 driver writes the error to the StdOut stream (that is, it writes to the console). <br>The error can be intercepted.<br><br><div class="quote"> If one, or both, of the pixmap dimensions is SMALLER than its NEAREST ( images are not down-sized, only up sized if needed ) power of 2 then a copy of the pixmap is created and rescaled to that nearsest power of 2 dimensions, <br></div><br><strike>This is incorrect</strike> EDIT: It's correctly actually. Both the dimensions are always converted to a power-of-two value, but if a dimension is <i>already</i> a power-of-two value, it is preserved (vide function Pow2Size() on both drivers). <br>So it's not any smaller value that is modified - this value would also have to be non power-of-two.<br><br>An image can be downscaled (in that you lose detail) with the OpenGL driver if the ideal power-of-two dimensions found for it (whether they were preserved from the original image dimensions or computed as the next nearest values) are too large such that they're not supported by the hardware.<br>GLMax2D uses that "proxy texture" mechanism to test if the texture can be created, and if it can't - even with a perfect power-of-two size - the pixmap is scaled down.<br><br><div class="quote"> So if you load an image of 1000x60 it will be resized as a pixmap to 1024x64 and that temporary pixmap is passed to the gpu. You may be thinking about aspect ratios at the point, but thats taken care of by the texture being displayed on a 2 triangle quad at the size of the original pixmap dimensions. <br></div><br>To make sure that no confusion is being made here, what both drivers do in this case is that they get the original 1000x60 pixmap and <i>paste</i> it on the top-left corner of a new blank 1024x64 pixmap, and then they convert this new pixmap to a texture that has UV values that capture only 1000x60 pixels. The original image resolution is preserved, as only the 1000x60 portion is drawn. The rest of the pixels are not visible.<br>If you load an image with a size of 256x512, for example, it would yield a pixmap and consequent texture of 256x512. The image is already sized as a power-of-two.<br><br>For more clarification, the following is what happens on both drivers when you load an image that is not a power-of-two:<br><img src="http://s28.postimg.org/cnyjrsxtp/blitzmax_pixmaps.png"> <br><br></td></tr></table><br>
<a name="1218157"></a>

<a name="1218159"></a>

<a name="1218161"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >col</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> We are saying the same thing, you worded it better. If a pixmap dimension isn't a power of 2 then it is scaled up to its nearest, this is for both dimensions. The dimension is always scaled up though, not down via the Pow2Size() function.<br><br><div class="quote"> <br>So it's not any smaller value that is modified - this value would also have to be non power-of-two.<br> <br></div><br>I don't understand why you're querying here? The Pow2Size() checks if the value is smaller than its nearest but higher power of 2, is that not I've written?<br><br><br><div class="quote"> <br>So if you load an image of 1000x60 it will be resized as a pixmap to 1024x64 and that temporary pixmap is passed to the gpu.<br> <br></div><br>I stand corrected here, what you show in your pics is the correct method.<br><br>In my defense I was recalling from memory :P  after checking, it turns out I was wrong! <br><br></td></tr></table><br>
<a name="1218163"></a>

<a name="1218165"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hello.<br>I must have read it wrong; On that point you are correct indeed.<br><br>Regards. <br><br></td></tr></table><br>
<a name="1218179"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TomToad</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> Wait! You mean it isn't all done by magic? :D<br><br>Actually knew that graphic cards had a size limit, especially older ones.  Never even thought of the possibility of an aspect ratio limit.  Am I right in thinking if I have an anim strip that is 32 pixels wide, but 2048 pixels long, I should be ok if it is loaded as 32x32 pixel frames?  I believe that BMax divides the image down into several individual images with LoadAnimImage(), or is it something I need to consider if I want my programs to run on older hardware? <br><br></td></tr></table><br>
<a name="1218180"></a>

<a name="1218181"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GfK</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> Right, think I'm going to stick with my tiledImage class.  I think we're all agreed that splitting it into 128x32-pixel tiles is mostly safe, yes?  (the original image is actually 1024x96).<br><br>I figure if somebody hasn't updated their PC in the last fifteen years, then they're not likely to be buying games for it anyway. <br><br></td></tr></table><br>
<a name="1218182"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> Why splitting it to 128x32 ?<br><br>I thought 2x 512*64 + 2x 512*32 would do too. Remember to minimize draw calls and texture swaps so use as less portions as possible.<br><br>That "tiledImage"-class should take care of it by itself.<br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1218184"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GfK</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well, currently all the cells have to be the same size since it just uses LoadAnimImage.  I could push it to 256x32 but then I'm right on the 8:1 ratio.<br><br>If you want to demonstrate how the tiledImage class could handle cells of varying sizes whilst taking into account scale and image handle position, then I'm all ears. <br><br></td></tr></table><br>
<a name="1218190"></a>

<a name="1218191"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> This must be something I have found years ago somewhere here on the forums.<br><br>It takes care of scale - feel free to add the image handle.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Const MINFRAGSIZE:Int = 64 ' maximum image fragment size
Const MAXFRAGSIZE:Int = 256 ' maximum image fragment size
Type ImageFragment

    Field img:TImage
    Field x:Float,y:Float,w:Float,h:Float

    ' ----------------------------------
    ' constructor
    ' ----------------------------------
    Function Create:ImageFragment(pmap:TPixmap,x:Float,y:Float,w:Float,h:Float)

        Local frag:ImageFragment = New ImageFragment
        frag.img = LoadImage(PixmapWindow(pmap,x,y,w,h),0)'|FILTEREDIMAGE)
        frag.x = x
        frag.y = y
        frag.w = w
        frag.h = h

        Return frag

    End Function

    ' --------------------
    ' Draw individual tile
    ' --------------------
    Method render(xoff:Float = 0, yoff:Float = 0, Scale:Float = 1.0)
	    Local vx:Int = 0, vy:Int = 0, vh:Int = 0
	    GetViewport(vx,vy,vx,vh)
		If yoff + Scale * Self.y + Self.h &gt; 0 And yoff + Scale * Self.y &lt; vy + vh Then
          DrawImage(Self.img, xoff + Scale * Self.x, yoff + Scale * Self.y)
		EndIf
    End Method

    Method renderInViewPort(xoff:Float = 0, yoff:Float = 0, vx:Float, vy:Float, vw:Float, vh:Float)
		'DrawSubImageRect(Self.img,xoff + Self.x, yoff + Self.y, vw, vh,  vx,vy,vw,vh,0,0,0)

		ClipImageToViewport(Self.img, xoff + Self.x, yoff + Self.y, vx, vy, vw, vh, 0, 0, 0)
	End Method

End Type




Type TBigImage
    Field pixmap:TPixmap
    Field px:Float, py:Float
    Field fragments:TList
    Field width:Float
    Field height:Float
	Field PixFormat:Int
    Field x:Float = 0
    Field y:Float = 0

    ' ----------------------------------
    ' constructor
    ' ----------------------------------
	Function CreateFromImage:TBigImage(i:TImage)
		Local pix:TPixmap = i.pixmaps[0]
		Return TBigImage.Create(pix)
	End Function


	Function CreateFromPixmap:TBigImage(i:TPixmap)
		Return TBigImage.Create(i)
	End Function


	Function Create:TBigImage(p:TPixmap)
		Local bi:TBigImage = New TBigImage
		bi.pixmap = p
		bi.width = p.width
		bi.height = p.height
		bi.fragments = CreateList()
		bi.Load()
		bi.PixFormat = p.format
		bi.pixmap = Null
		Return bi
    End Function


    Method RestorePixmap:TPixmap()
		Local Pix:TPixmap = TPixmap.Create(Self.width, Self.height, Self.PixFormat)
		For Local ImgFrag:ImageFragment = EachIn Self.fragments
			DrawImageOnImage(ImgFrag.img, Pix, ImgFrag.x, ImgFrag.y)
		Next
		Return Pix
	End Method


	' -------------------------------------
    ' convert pixmap into image fragments
    ' -------------------------------------
    Method Load()
		'Print "Adding Fragments..."

        Local px:Float = 0
        Local py:Float = 0
        Local loading:Byte = True

        While (loading)
            Local w:Int = MAXFRAGSIZE
            Local h:Int = MAXFRAGSIZE
            If Self.pixmap.width - px &lt; MAXFRAGSIZE w = Self.pixmap.width - px
            If Self.pixmap.Height - py &lt; MAXFRAGSIZE h = Self.pixmap.Height - py
            Local f1:ImageFragment = ImageFragment.Create(Self.pixmap, px, py, w, h)
			'Print "Added Fragment: w" + w + " h" + h
            ListAddLast Self.fragments, f1
            px:+MAXFRAGSIZE
            If px &gt;= Self.pixmap.width
                px = 0
                py:+MAXFRAGSIZE
                If py &gt;= Self.pixmap.height loading = False
            EndIf
        Wend
    End Method


    ' -----------------
    ' Draw entire image
    ' -----------------
    Method render(x:Float = 0, y:Float = 0, Scale:Float = 1.0)
        For Local f:ImageFragment = EachIn Self.fragments
            f.render(x, y, Scale)
        Next
    End Method


    ' -----------------
    ' Draw entire image
    ' -----------------
    Method renderInViewPort(x:Float = 0, y:Float = 0, vx:Float, vy:Float, vw:Float, vh:Float)
        For Local f:ImageFragment = EachIn Self.fragments
            f.renderInViewPort(x, y, vx, vy, vw, vh)
        Next
    End Method
End Type
</textarea><br><br><br>I do not use this code currently as I minimize texture swaps - which gets foiled by this approach.<br><br>EDIT: Some of the code was replaced by individual functions - should be no problem to rewire that parts with functions of yours - don't know if the original code contained something in there.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1218197"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImaginaryHuman</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> If it was me I wouldn't bother splitting it at all, I'd just use the 1024 texture. Why try to support 15-year old pc's? Most game releases these days barely even support anything older than 5-10 years. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
