<!DOCTYPE html><html lang="en" ><head ><title >Anyone ever get smooth scrolling tiles working?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Anyone ever get smooth scrolling tiles working?</h1><a href="forums.php" >BlitzMax Forums</a>/<a href="topics.php?forum=102" >BlitzMax Programming</a>/<a href="#bottom" >Anyone ever get smooth scrolling tiles working?</a><br><br>
<a name="1263994"></a>

<a name="1263996"></a>

<a name="1264009"></a>

<a name="1264015"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> See this old thread: <a href="http://www.blitzbasic.com/Community/posts.php?topic=86549" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=86549</a><br><br>Basically I'm talking about the fact that if you draw a bunch of tiles in BlitzMax and then scroll them at floating point coords (or zoom in on them), the joins will look jerky as the move across pixel boundaries. OR if you add a 1 pixel blank border (popular technique with sprites to avoid jerking edges) you'll get dark lines showing up in between then. (see my code sample about halfway down that thread above)<br><br>[edit]Found an even older thread of mine with images. <a href="http://www.blitzbasic.com/Community/posts.php?topic=66157#739230" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=66157#739230</a><br><br>This is because each tile doesn't know about its neighbours and so their edges are antialiased to the background instead of the neighbouring tiles.<br><br>If you were able to draw all the tiles at integer coords and *then* draw the whole lot in one go (as if it was a texture) at floating point coords/zooomed in, that would work fine because the antialiasing would be applied to the image as a whole.  However, it's too slow to render to a texture first before outputting, so that solution is out.<br><br>Back in the day indiepath kept going on about using a mesh (like in 3D programming) to do it but none ever materialised in BMax.<br><br>Or is there a way to use something like a viewport to show a portion of a bigger tiled area grabbed from a floating point source coordinate? Or a projection matrix solution using something like: D3D7GraphicsDriver().Direct3DDevice7().SetTransform(D3DTS_PROJECTION,matrix)<br><br>Then there's TileMax.  Did _Skully ever solve this issue (can't see it mentioned in the feature list).<br><br>Any info/suggestions you may have are most welcome. <br><br></td></tr></table><br>
<a name="1264001"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >GW</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> I didn't know this was a problem. I've never encountered it myself. <br>Are you talking about the little black lines that can show up between tiles when they are drawn at float coords?<br><br>It seems the simplest solution would be to use the center handle on your tiles and set the scale to small amount over 1.0. <br><br></td></tr></table><br>
<a name="1264002"></a>

<a name="1264010"></a>

<a name="1264011"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes I am talking about those black lines when drawn at floating point coords (if using a filtered image with a 1 pixel border - I updated the original post to add more detail)<br><br>I haven't tried boosting the scale but I'm not sure that's entirely viable. <br><br></td></tr></table><br>
<a name="1264030"></a>

<a name="1264036"></a>

<a name="1264037"></a>

<a name="1264038"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Kryzon</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Each DrawImage has a glBegin\glEnd or BeginScene\EndScene pair. This means that each tile drawn costs one draw call. Imagine a full map.<br><br>The "right" way to render a tile map would be to use a canvas texture and generating a single mesh for all the tiles, then rendering this mesh with a single call. <br>Since the vertices are also joined (they're separate vertices, but at the same position), this should also solve the rasterisation problem.<br><br>Can you implement this? Do you need example code? <br><br></td></tr></table><br>
<a name="1264049"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> No I cannot implement it, it's beyond my current knowledge. Anyone done that sort of thing in BlitzMax? <br><br></td></tr></table><br>
<a name="1264055"></a>

<a name="1264063"></a>

<a name="1264064"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zoqfotpik</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> I never had a problem with this but when I view your example I do see what you're saying.<br><br>A couple of other solutions might be rounding your FP coordinates down to integer in software, or batching the tilemap into one or more larger images and then moving and drawing that as you wish.  That's obviously going to be much faster than 64x64 or however many individual draw calls.<br><br>Not to minimize your concern or anything like that but I'm questioning whether this would even be noticeable to the vast majority of users.  When I ran your example I couldn't see what you were talking about even though it had been pointed out to me, until I looked very closely.  The example that flashes a little bit is more noticeable.<br><br>This isn't fixing the underlying problem but my gut feeling is that if you're drawing a large number of tiles every frame, you might want to find ways of not doing that, for performance reasons irrespective of anything else.  How exactly to do that is something I'm still kicking around but I'm thinking for me it's going to involve rendering to pixmaps-- lots of blast scars and that sort of thing and when you are drawing all those every frame things can get real slow real fast. <br><br></td></tr></table><br>
<a name="1264065"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> I don't want to round the FP down to int, that's what most people do and it looks jerky.  Yes I do want to batch the tilemap into a larger image but I don't know how to do that with a mesh or whatever. There's no point in using render to texture stuff as far as I know because it's supposed to be very slow.  Also, drawing a screen of tiles on a modern PC is extremely trivial in terms of GPU power. Drawing thousands of particles is the sort of thing that needs to be optimised.<br><br>As for if people will notice, yeah that's valid for sure.  There are lots of successful indie games with awful scrolling/framerate that sell fine. But I'm still interested to know if it's possible in BMax for my own satisfaction at least.  I know it's possible in Unity and other engines where it's all drawn as 3D geometry for example. <br><br></td></tr></table><br>
<a name="1264067"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> When I perform scrolling I keep the logic as floating points but only render as integers. <br><br></td></tr></table><br>
<a name="1264077"></a>

<a name="1264078"></a>

<a name="1264079"></a>

<a name="1264080"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah for sure I'd do that if I wanted to render at int coords but I want to try and render at float coords and sort this out once and for all.<br><br>Considering another approach. Using a projection maxtrix. Draw the tiles at int coords, then project the whole lot at a floating point end coord.<br><br>I've currently got this projection matrix code that I was using for zooming in on a screen (works well), but do you know if it can be modified to apply an x,y coord (using floats) somewhere in that matrix?<br><br><pre class=code>
		If D3D7GraphicsDriver().Direct3DDevice7() = Null
			glMatrixMode GL_PROJECTION
			glLoadIdentity
			glOrtho 0, Self.width, Self.height, 0, -1, 1
			glMatrixMode GL_MODELVIEW
		Else
		     Local matrix:Float[] = ..
		     [..
		         2.0 / Self.width ,    0.0,    0.0,    0.0, ..
		         0.0,   -2.0 / Self.height,    0.0,    0.0, ..
		         0.0,   0.0,    1.0,    0.0, ..
		         -1-( 1.0 / Self.width ), 1+( 1.0 / Self.height ), 1.0, 1.0 ..
		     ]
		     D3D7GraphicsDriver().Direct3DDevice7().SetTransform(D3DTS_PROJECTION,matrix)
		EndIf
</pre><br><br>Though admitedly if I do that I have to make sure I can revert the matrix back to normal and draw the HUD over the top, if that's possible...<br><br>Hmm scratch that because of course you need to call SetTransform before you start drawing the tiles, so they'll no longer be at int coords as the matrix will have changed them. <br><br></td></tr></table><br>
<a name="1264081"></a>

<a name="1264083"></a>

<a name="1264084"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well then it seems the only way is to use a 3D mesh, whatever that is, and make sure the graphics card knows to render all the tiles at once and thus calculate the join anti-aliasing correctly.<br><br>There's nothing to do that in BlitzMax, but it does have access to certain DX/GL commands and it's possible to add more commands (via C++) so it's gotta be doable. Something like this: <br><br><a href="http://www.riemers.net/eng/Tutorials/DirectX/Csharp/Series1/tut13.php" target="_blank">http://www.riemers.net/eng/Tutorials/DirectX/Csharp/Series1/tut13.php</a><br><br>and this (it's gotta work with DX9 and not use DX11 shaders to render the mesh)<br><br><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb153263%28v=vs.85%29.aspx" target="_blank">https://msdn.microsoft.com/en-us/library/windows/desktop/bb153263%28v=vs.85%29.aspx</a> <br><br></td></tr></table><br>
<a name="1264094"></a>

<a name="1264095"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zoqfotpik</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> How jerky can it possibly be if you are rounding to int?  How large is your screen resolution?<br><br>Drawing screen-aligned textured quads as a display list should be trivial but I don't know if I'm buying it that rounding to int would not be smooth, or at any rate that the lack of smoothness would be noticeable at all unless you're looking at the screen with an electron microscope or something.  Pixels these days are easily sub-millimeter, it looks on my screen like there are 2 per millimeter. <br><br></td></tr></table><br>
<a name="1264116"></a>

<a name="1264117"></a>

<a name="1264118"></a>

<a name="1264119"></a>

<a name="1264120"></a>

<a name="1264121"></a>

<a name="1264122"></a>

<a name="1264123"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just checked some of my previous games scrolling code.<br><br>For The Bloobles I did use Ints and did the following:<br><pre class=code>		For Local x% = xstart To xend
			For Local y% = ystart To yend
				c = tiles[x, y]
				tile = c.CellType
				If tile &gt; 0 Then DrawImage TilesImage.Image, Int(x * TILE_SIZE - Game.ScrollX), Int(y * TILE_SIZE - Game.ScrollY), tile
			Next
		Next	</pre><br>But the movement was always at a set speed.<br><br>For the map in LoS:COTD, I used floats as it looked a lot better.<br><br>Heres a cut-down version of the map code and I've made so that you can switch between Ints and Floats using the spacebar:<br><br><a href="https://dl.dropboxusercontent.com/u/35103024/bmx/Scrolling.zip" target="_blank">https://dl.dropboxusercontent.com/u/35103024/bmx/Scrolling.zip</a><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">SuperStrict

Const SCREEN_WIDTH:Int = 800
Const SCREEN_HEIGHT:Int = 600

Global game:TGame = New TGame

SeedRnd MilliSecs()

game.Init()
game.Update()

End

Type TGame
	Field mapX:Float, mapY:Float
	Field omx:Float, omy:Float
	Field map:TImage
	Field maxTiles:Int
	Field useInts:Int
	
	Const MAP_SIZE:Int = 2048
	Const TILE_SIZE:Int = 128

	Method Init()
		Graphics SCREEN_WIDTH, SCREEN_HEIGHT
		
		Local noOfFrames:Int = MAP_SIZE / TILE_SIZE

		maxTiles = noOfFrames

		map = LoadAnimImage("FantasyWorldMap.jpg", TILE_SIZE, TILE_SIZE, 0, noOfFrames * noOfFrames, FILTEREDIMAGE)
		Assert map, "Error loading map"
		
		For Local i:Int = 1 To 5
			Local t:TTarget = TTarget.Create(Rnd(0, MAP_SIZE), Rnd(0, MAP_SIZE), i)
			t.offx = mapX
			t.offy = mapY
			t.r = Rand(0, 100)
			t.g = Rand(0, 100)
			t.b = Rand(0, 100)
		Next
		
		useInts = False
	EndMethod

	Method MoveMap()
		Local sx:Int = MouseXSpeed()
		Local sy:Int = MouseYSpeed()
		
		If MouseDown(1)
			mapX :+ sx
			mapY :+ sy
			
			If Abs(sx) &gt; 0 Then omx = sx / 8
			If Abs(sy) &gt; 0 Then omy = sy / 8
		Else
			If Abs(omx) &gt; 0
				mapX:+omx
				omx:/1.03
			Else
				mapX = Int(mapX)
			EndIf
			If Abs(omy) &gt; 0
				mapY:+omy
				omy:/1.03
			Else
				mapY = Int(mapY)
			EndIf
		EndIf		
	EndMethod

	Method Update()
		While (Not AppTerminate() And Not KeyHit(KEY_ESCAPE))
			MoveMap()
			TTarget.UpdateAll(mapX, mapY)
			If KeyHit(KEY_SPACE)
				useInts = Not useInts 
			EndIf
			Render()
		Wend
	EndMethod
	
	Method Render()
		Cls		
			RenderMap(useInts)
			TTarget.Render(useInts)
			RenderHUD()
		Flip
	EndMethod
	
	Method RenderHUD()
		Local y:Int = 10
		Local gapY:Int = 15
		DrawShadowText("Press Space to Change Render", 10, y)
		y:+gapY
		DrawShadowText("Mouse Fling to Move the Map", 10, y)
		y:+gapY
		DrawShadowText("Using Ints = " + useInts, 10, y)
	EndMethod
	
	Method DrawShadowText(txt:String, x:Int, y:Int)
		SetColor 0, 0, 0
		DrawText txt, x + 2, y + 2
		SetColor 255, 255, 255
		DrawText txt, x, y
	EndMethod
	
	Method RenderMap(usingInts:Int)
		Local frame:Int = 0
		For Local j:Int = 0 To maxTiles - 1
			For Local i:Int = 0 To maxTiles - 1
				If usingInts
					Local x:Int = mapX + (TILE_SIZE * i)
					Local y:Int = mapY + (TILE_SIZE * j)
					DrawImage map, x, y, frame
				Else
					DrawImage map, mapX + (TILE_SIZE * i), mapY + (TILE_SIZE * j), frame
				EndIf
				frame:+1
			Next
		Next
	EndMethod
EndType

Type TTarget Extends TSprite
	Global targets:TList = New TList
	
	Field id:Int
	Field drawArrow:Int
	Field arrowX:Int, arrowY:Int
	Field arrowAngle:Float
	Field r:Int, g:Int, b:Int
	
	Function Create:TTarget(x:Float, y:Float, id:Int)
		Local t:TTarget = New TTarget 
		targets.AddLast(t)
		t.x = x
		t.y = y
		t.w = 20
		t.h = 20
		t.id = id
		Return t
	EndFunction
	
	Method Draw(useInts:Int)
		SetColor r, g, b

		If useInts
			DrawOval Int((x - w / 2) + offx), Int((y - h / 2) + offy), w, h
		Else
			DrawOval (x - w / 2) + offx, (y - h / 2) + offy, w, h
		EndIf
		
		If drawArrow
			SetRotation arrowAngle
			DrawRect(arrowX, arrowY, 40, 4)
			SetRotation 0
			SetColor 255, 255, 255
			DrawText(id, arrowX, arrowY)
		EndIf
		
		SetColor 255, 255, 255
	EndMethod
	
	Function Render(useInts:Int)
		For Local t:TTarget= EachIn TTarget.targets
			t.Draw(useInts)		
		Next
	EndFunction
	
	Method Update(offx:Float, offy:Float)
		Self.offx = offx
		Self.offy = offy
		If TargetOffScreen()
			drawArrow = True
		Else
			drawArrow = False
		EndIf
	EndMethod
	
	Method CalcArrow(ax:Float, ay:Float)
		Local centerX:Float = ax - (SCREEN_WIDTH / 2)
		Local centerY:Float = ay - (SCREEN_HEIGHT / 2)

		' find slope
		Local slope:Float = centerY / centerX
		
		Local pad:Int = 200
		Local paddingX:Int = pad
		Local paddingY:Int = pad
		
		Local padWidth:Float = SCREEN_WIDTH - paddingX
		Local padHeight:Float = SCREEN_HEIGHT - paddingY
		
		If centerY &lt; 0 'top of the screen
			arrowX = (-padHeight / 2) / slope
			arrowY = -padHeight / 2
		Else ' bottom of the screen
			arrowX = (padHeight / 2) / slope
			arrowY = padHeight / 2
		EndIf
		
		If arrowX &lt; - padWidth / 2 ' left side
			arrowX  = -padWidth / 2
			arrowY  = slope * -padWidth / 2
		ElseIf arrowX &gt; padWidth / 2' right side
			arrowX = padWidth / 2
			arrowY = slope * padWidth / 2
		EndIf
		
		arrowAngle = GetAngle2D(SCREEN_WIDTH / 2, SCREEN_HEIGHT/ 2, ax, ay)
		arrowX = arrowX + SCREEN_WIDTH / 2
		arrowY = arrowY + SCREEN_HEIGHT / 2
	EndMethod
	
	Method TargetOffScreen:Int(border:Int = 75)
		Local rv:Int = False
		Local ssx:Float = x + offx
		Local ssy:Float = y + offy
		
		If ssx &lt; border Or ssx &gt; SCREEN_WIDTH - border Or ssy &lt; border Or ssy &gt; SCREEN_HEIGHT - border
			rv = True
		EndIf
		
		If rv
			CalcArrow(ssx, ssy)
		EndIf
		
		Return rv
	EndMethod
	
	Function UpdateAll(offx:Float, offy:Float)
		For Local t:TTarget= EachIn TTarget.targets
			t.Update(offx, offy)		
		Next
	EndFunction

EndType

Type TSprite
	Field x:Float, y:Float
	Field w:Float, h:Float
	Field offx:Float, offy:Float
EndType

Function GetAngle2D:Float(x1:Float, y1:Float, x2:Float, y2:Float)
	Local dx:Float = x2 - x1
	Local dy:Float = y2 - y1
	Return ATan2(dy, dx) + 360 Mod 360
EndFunction</textarea> <br><br></td></tr></table><br>
<a name="1264166"></a>

<a name="1264167"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi therevills, thanks for sharing that code and exe.  Yeah the floats do look a lot better in it (jerkiness is gone as expected). However, you are still getting artefacts at the 128pixel joins, although they are quite minor due to the image type you've used (more on that below).<br><br>For example, find the 3rd vertical blank line in from the left edge of the map, then scroll it slowly.  You'll see that black line "shimmers" even though the other lines do not. That's because it falls on a 128 pixel boundary and the issue I've been discussing crops up. There are a few other smaller examples but that's the most obvious.<br><br>So if I'm making a tile based games which has lots of square block graphics e.g. a castle, they will often have vertical and horizontal lines on the edges of the textures. When I draw the tilemap at a subpixel coordinate, I'll get loads of those shimmering lines everywhere, which I want to avoid.  You are lucky that for that map the tile size you chose doesn't fall on very many lines as this issue is less pronounced on more "organic" looking textures.<br><br>In fact I modified your image to move it left 10 pixels and changed the tile size to 82 pixels and now I get shimmering joins on many of the vertical lines. <br><br></td></tr></table><br>
<a name="1264168"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Anyway after discussion with some other devs, I think the solution must be to use some render to texture (render target) code like this:<br><br><a href="http://www.blitzmax.com/codearcs/codearcs.php?code=2222" target="_blank">http://www.blitzmax.com/codearcs/codearcs.php?code=2222</a><br><br>That's only OpenGL though and I haven't tested it yet for a tile engine.  I'll need a DX version but I just can't find one on these forums (there are references to one by indiepath that doesn't with new BMax).<br><br>Also I found an old thread elsewhere from TonyG saying he couldn't get a DX8+ render to texture working because "BlitzMax uses the TEXTUREMANAGE flag which means I couldn't set videomemory. Took out the texturemanage and it all worked OK."  However, I'm pretty wary of doing that. Like where does BlitzMax use that flag? Just on creating textures, or when setting up DX? It could be pretty important! Like what if it causes alt+tab issues, or maybe I'm just being paranoid - but I've learned not to assume stuff will just work and be safe after all these years coding :-) <br><br></td></tr></table><br>
<a name="1264296"></a>

<a name="1264297"></a>

<a name="1264298"></a>

<a name="1264299"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zoqfotpik</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> IMO the entire graphics engine should be doing this.  I thought it was already.<br><br>You could also do it with fixed pipeline quads rendered in 3d but orthographic, with or without even using displaylists.  That would be extremely simple and supported on everything and if you were doing, say, 32x32 tiles the speed would be perfectly fine. <br><br></td></tr></table><br>
<a name="1264330"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah if the whole of BMax's backbuffer was a texture, you rendered on that, and then it was copied onto the main backbuffer (scaled as needed and at floating point coords if required) that would make all the projection matrix and virtual resolution stuff way simpler and would anti-alias/filter the entire texture nicely. Like building up a single image in photoshop and scaling it afterwards.<br><br>Currently you have to draw each sprite individually and if you've set up a projection matrix at the start, it means each sprite is scaled and drawn at floating point coords which yields a less cohesive final image. <br><br></td></tr></table><br>
<a name="1264337"></a>

<a name="1264338"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zoqfotpik</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> Think of all the other stuff you could do as well, like postprocessing and color cycling effects in shaders.  Seems like it would offer a gigantic speed boost as well as all the other benefits.<br><br>I would be willing to help with any sort of development along those lines. <br><br></td></tr></table><br>
<a name="1264344"></a>

<a name="1264345"></a>

<a name="1264346"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yep, you could do all sorts of cool stuff afterwards. Sorta fancy effects I see in other games.<br><br>Well the main thing is to convert that openGL render to texture stuff (link above) to DirectX. Then we can just make a texture and swap the drawing code to it (though that might be tricky, dunno), then draw that whole thing on the backbuffer at the end.<br><br>Though I wonder if any of Brucey's mods has a DX version? (hmm doesn't look like it: <a href="https://code.google.com/p/maxmods/)" target="_blank">https://code.google.com/p/maxmods/)</a><br><br>I'm also in contact with Indiepath who made a DX version years ago that stopped working with BMax updates, so I'll see if anything comes of that. <br><br></td></tr></table><br>
<a name="1264374"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zoqfotpik</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> Why do render to texture at all?  If it's a tilemap, why not just texture your bitmaps to individual quads in a mesh?  Render to texture would probably be better and easier because it would be more transparent for people used to 2D but weren't you saying it was slow?<br><br>If it was just individual quads, you could have some of them missing to let a background show through.  You could also use the OpenGL vertex lighting and coloring. <br><br></td></tr></table><br>
<a name="1264378"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> No I was wrong about it being slow. I got confused with pixmaps.<br><br>A mesh might work, but it might also still have the join lines issue. Can't tell until I see it. If I'm going to spend my time working on one, I'd rather do the render target one as I know that will work. <br><br></td></tr></table><br>
<a name="1264382"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zoqfotpik</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> A mesh might work, but it might also still have the join lines issue. <br></div><br>That's conceivably possible but wouldn't someone have noticed in 25 years of OpenGL?<br><br>I will see if I can throw a demo together this week, been about 3 years since I touched OpenGL to any extent but I've been meaning to get back at it... my tendency to be a retro-luddite is bad. <br><br></td></tr></table><br>
<a name="1264383"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pingus</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> Maybe it could work with textured polygons :<br>ex(there many threads about textured poly)<br><br>[a /posts.php?topic=100299#1183143[/a]<br><br>If each tile is drawn on a polygon, the antialiasing should be 'cut' on polygon's limits. There could be artifacts but no dark lines. Quite tedious to do tough. And I wonder about the performance with many polygons drawn 'by hand'. <br><br></td></tr></table><br>
<a name="1264386"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zoqfotpik</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> It's certainly not too bad for say 32x32 and that's a pretty large tilegrid. <br><br></td></tr></table><br>
<a name="1264400"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >*</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> On monkey with a atlas sheet it would give the desired effect as it uses one texture for tile drawing operations and changes the UV coordinates of the image you want to draw, if you want to get rid of it you have to turn it off but it can be useful for these sort of problems. <br><br></td></tr></table><br>
<a name="1264420"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >TomToad</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> Do you really need anti-aliasing on tiles?  Here is the example from the other thread, but with FILTEREDIMAGE disabled on the second image.<br><pre class=code>Strict

Graphics 800,600,0

Local x# = 0
Local y#=50
Local speed#=0.23
Local size=64

Local tiles1:TImage = LoadImage("tiles1.png")
Local tiles2:TImage = LoadImage("tiles1.png",MASKEDIMAGE)


While Not KeyHit(KEY_Escape) And Not AppTerminate()
	SetBlend AlphaBlend
	Cls
	'rectangles
	SetColor 200,200,200
	DrawRect x,y,size,size
	SetColor 200,100,100
	DrawRect x+20,y+20,20,20
	SetColor 100,100,100
	DrawRect x+size,y,size,size
	'two images with FILTEREDIMAGE set
	SetColor 255,255,255
	DrawImage tiles1,x,y+100
	DrawImage tiles1,x+size,y+100
	'two images with FILTEREDIMAGE removed
	DrawImage tiles2,x,y+200
	DrawImage tiles2,x+size,y+200
	
	'move
	x:+speed
	DrawText x,0,0
	Flip 1
Wend
</pre> <br><br></td></tr></table><br>
<a name="1264428"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> @TomToad: Try this and you'll see the issue (note I've dropped size to 32 pixels so modify if need be). The joins (and edges) are perfect but that's because they are clamped to integer coords by the graphics driver, and so when moving slowly they all jiggle badly.<br><br>If you add a 1 pixel blank border to those images (so they are 34x34) and draw those (but keep size variable at 32), you'll see the middle set (the filtered set) has nice smooth outer lines (no jiggling), but there's a black join line in the middle. The unfiltered set still jiggle badly.<br><br><br><pre class=code>
Strict

Graphics 800,600,0

Local x# = 0
Local y#=50
Local speed#=0.23
Local size=32

Local tiles1:TImage = LoadImage("testimage1.png")
Local tiles2:TImage = LoadImage("testimage2.png")
Local tiles3:TImage = LoadImage("testimage1.png",MASKEDIMAGE)
Local tiles4:TImage = LoadImage("testimage2.png",MASKEDIMAGE)


While Not KeyHit(KEY_Escape) And Not AppTerminate()
	SetBlend AlphaBlend
	Cls
	'rectangles
	SetColor 200,200,200
	DrawRect x,y,size,size
	SetColor 200,100,100
	DrawRect x+20,y+20,20,20
	SetColor 100,100,100
	DrawRect x+size,y,size,size
	'two images with FILTEREDIMAGE set
	SetColor 255,255,255
	DrawImage tiles1,x,y+100
	DrawImage tiles2,x+size,y+100
	'two images with FILTEREDIMAGE removed
	DrawImage tiles3,x,y+200
	DrawImage tiles4,x+size,y+200
	
	'move
	x:+speed
	DrawText x,0,0
	Flip 1
Wend
</pre> <br><br></td></tr></table><br>
<a name="1264429"></a>

<a name="1264430"></a>

<a name="1264431"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> @zoqfotpik someone sent me a demo using a mesh but it exhibited join lines. So until I see one where it works, I'm ruling out that as a possible solution.<br><br>@Pingus I don't think that will solve it. The issue is that we want both adjacent tiles to know about each other and anti-alias along the join as if they were actually one large image. Drawing them separately (at floating point coords), they won't know about each other, which is why there's a join line in the first place. Also cutting anti-aliasing at polygon edge will result in jiggling on integer boundaries. Unless I'm misunderstanding you.<br><br>@EdzUp A texture atlas won't solve the issue I'm talking about. Whether you render a filtered tile from a single image, or an atlas it doesn't matter. The graphics driver will still sample the pixels around the tile you are using for the anti-aliasing. In a single tile, it'll sample blank space (result in a black join), in an atlas it'll sample the adjacent tile and use its colours as part of the anti-alias result. I've tested this and seen it in action.<br><br>Basically folks, we need render to texture for DX and OpenGL in BMax and it'll make this problem go away and allow us to do totally rad things. <br><br></td></tr></table><br>
<a name="1264436"></a>

<a name="1264437"></a>

<a name="1264438"></a>

<a name="1264439"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Pingus</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> In fact dmaz already suggested the same thing... 8 years ago :-)<br><br><a href="http://www.blitzbasic.com/Community/posts.php?topic=66157#739279" target="_blank">http://www.blitzbasic.com/Community/posts.php?topic=66157#739279</a><br><br>IF the drawpoly can be drawn at floating coordinates (antialiased subpixel), this should work. <br><br></td></tr></table><br>
<a name="1264446"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zoqfotpik</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah GA it is way below my threshold of detail that I notice but I would love such a thing for other reasons, like the postprocessing thing.  It would be easy to add in hooks for postprocessing shaders. <br><br></td></tr></table><br>
<a name="1264453"></a>

<a name="1264455"></a>

<a name="1264456"></a>

<a name="1264457"></a>

<a name="1264458"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Pingus Nope the mesh doesn't work (based on my limited test). It doesn't anti-alias the joins properly. Like I said, someone sent me a demo and it didn't work. It's because when the mesh is drawn at a floating point coord the edge anti-aliasing looks at the pixels OUTSIDE the original tile size (say 32x32) and uses those (which come from the neighboring tile in the atlas). I proved this in the demo I was sent by drawing over the neighboring tile in the atlas with bright red and I could see that was what the mesh was using for anti-aliasing.<br><br>What all that means is maybe it's possible to make a 34x34 tile where the edge of the 32x32 tile is repeated in the outer border. Then when drawing in the mesh, use UV coords of the inner 32x32 square and it'll use a better colour for the anti-aliased join. Still not ideal though as the destination background colour will come through due to the join having an alpha value, and then you draw the adjacent tile on top of that (again with some alpha on the join) which results in a 3 colour blend. So it's not as accurate as if you just got the 2 adjacent tiles and blended those two colours for the join (based on their floating point coords used as weight).<br><br>However, I'm willing to be proved wrong! :-)<br><br>Still I say, render to texture is the way to go. <br><br></td></tr></table><br>
<a name="1264482"></a>

<a name="1264495"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zoqfotpik</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> What if there was a 1 pixel transparent border around the texture?<br><br>You said this " if you add a 1 pixel blank border "<br>but it's not clear if you meant transparent.  I presume you did. <br><br></td></tr></table><br>
<a name="1264500"></a>

<a name="1264502"></a>

<a name="1264503"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yeah sorry transparent is what I meant. However, you can still run into issues because paint programs like photoshop give the transparent pixels a white colour which can be taken into account during rendering edges scaled or at sub-pixel coords. You can definge images like that (to remove the colouring) but I've found that just goes back to jiggly floating point scrolling as if it were at int coords, very strange. <br><br></td></tr></table><br>
<a name="1264670"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >*</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> Maybe rendering to a pixmap then drawing that might be the only way, I would have thought a quad sheet would have worked where each quad is a image then when rendered it would use its neighbours but I haven't run tests on that. <br><br></td></tr></table><br>
<a name="1264690"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well you can't do drawimage on a pixmap can you? Only poke and peek pixels as far as I knew (after you've called LockImage() on it) <br><br></td></tr></table><br>
<a name="1264691"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >John G</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> @ Grey Alien -- One brute-force method I've used is to tape the joints between 2 tiles -- like a builder tapes the ugly seam between 2 sheets of dry-wall.  Offline or during startup, place 2 adjacent tiles side-by-side using integer coordinates and GrabImage of several pixels from each tile.  During dynamic floating-point run, tape over the gaps.  Seems to mask flicker at different zoom levels.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
	' Grey Alien ScrollTest  from long ago   modified with TAPE between 2 Tile Images
	
	Strict
	
	Graphics 800,600,0
	
	Local x#=0
	Local y#=50
	Local speed#=0.23*0.5     ' Speed effects Quality
	Local size=64
	
	SetClsColor 0,0,128

	Local tiles1:TImage = LoadImage("tiles1.png")
	Local tiles2:TImage = LoadImage("tiles2.png")
	Local tiles3:TImage = LoadImage("tiles3.png")
	Local tapes1:TImage = CreateImage( 4,64,1, MASKEDIMAGE | FILTEREDIMAGE | DYNAMICIMAGE ) 	' CREATE TAPE

	SetBlend AlphaBlend
	SetColor 255,255,255
	DrawImage tiles1,0,y+100
	DrawImage tiles1,size,y+100
	Flip
	GrabImage tapes1, size-2, y+100									  	' GRAB TAPE
	SetImageHandle tapes1, 2, 0	
	Delay 2000
	Cls
	
	While Not KeyHit(KEY_Escape)	

		Cls
		SetBlend AlphaBlend
		'rectangles
		SetColor 200,200,200
		DrawRect x,y,size,size
		SetColor 200,100,100
		DrawRect x+20,y+20,20,20
		SetColor 100,100,100
		DrawRect x+size,y,size,size
		'two images
		SetColor 255,255,255
		DrawImage tiles1,x,y+100
		DrawImage tiles1,x+size,y+100
		DrawImage tapes1,x+size,y+100										  ' DRAW TAPE between 2 Tile Images
		'single combined image
		DrawImage tiles2,x,y+200
		'draw tile with 1 pixel border
		DrawImage tiles3,x,y+300					' tiles3 not tiles2 ?
	
		'move
		x:+speed
		DrawText x,0,0
		Flip 1
	Wend

</textarea><br><br>I've used this for side-scrolling of long backgrounds sliced into 512 pixel chunks where drawing 4 pixel tapes doesn't effect overhead much. <br><br></td></tr></table><br>
<a name="1264692"></a>

<a name="1264693"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Grey Alien</td><td align="right"><font class=tiny>(Posted 2015)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ha that's a novel solution. Thought I'm still looking for a render to texture solution... Pretty sure I've searched these whole forums now.  Found bits but nothing 100% <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
