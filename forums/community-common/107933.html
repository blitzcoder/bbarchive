<!DOCTYPE html><html lang="en" ><head ><title >Blitz community Game Project built in modules on a flowchart</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Blitz community Game Project built in modules on a flowchart</h1><a href="forums.php" >Community Forums</a>/<a href="topics.php?forum=206" >Common Room</a>/<a href="#bottom" >Blitz community Game Project built in modules on a flowchart</a><br><br>
<a name="1338719"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I was thinking about a community game built by all of us in a single project. we provide details for each module needed eg: a functions inputs and a functions outputs, <br><br>eg input X,Y module to check Left right keys output X,Y<br><br>that's a simple example but it shows what I mean. it means we all need to build a flowchart and decide on modules on the flowchart then we choose what module to do.<br><br>would you guys be interested in this? <br><br></td></tr></table><br>
<a name="1338721"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> there would not need to be collaboration, just design a module in the flowchart, not time table, and you could work alone, theretically hot swapping different modules for the same flowchart module, so people could improve a module or change it for someone elses <br><br></td></tr></table><br>
<a name="1338745"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Therefor you need to know in advance which kind of game it should become.<br><br>module "unit movement" with input "x,y" and output "x,y" would not help that much for a tile which is not moving at all.<br><br><br><br>Then there is something like a "music"-module. Is it supposed to automatically play something or does it need triggers from a "scene-management"-module ?<br><br><br>While "components" could be swapped before running a game it needs a certain "common foundation/idea" to build everything on it.<br><br><br><br>Your idea works best if you design everything of a game - eg. a game with two AIs battling each other. Then you could ask others to build the best AI - by having functions you call ("onYourTurn", "onUnitDestroyed" ...) and functions the AI is able to call ("MoveUnit(u,x,y)", "GetUnitArmor(u)") ...<br><br><br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1338754"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> you would have things like a display module, its inputs would be tile array, x,y of player and px,py positions on the tiles. what I'm suggesting is classic software design, I believe its called Jackson structured programing(JSP)<br><br>it dosnt need an A.I. an app can be made just to respond to your actions<br><br>I thought we could community decide the game, its a project everyone could contribute to with no time constraints and each module could be redone by anyone. <br><br></td></tr></table><br>
<a name="1338755"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> The "AI" was just an example in which components or similar things would work.<br><br><br>@ tile array<br>Ok, then add a z-component which your original "input/output"-design did not catch. Or maybe something needs holding a certain key-combination ...<br><br>I agree that an output state could get defined, but the inputs are based on the game(play) you decided before.<br><br><br>@ JSP<br>Even there you need to know in advance what the "flow" of your programme will be.<br>Yes, you could modularize things like "player figure control" (input -&gt; output) but therefor you need in advance if you have just one figure, or if the game is something like SimCity, which does not need player units.<br><br><br>So once you decided for a game(play) you could of course split that into modules - which could be done by various coders.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1338756"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> a module named update globals could be made, you feed it with new set of data and it updates globals like x,y,<br><br>you would have another module fetch globals,<br><br>you may be used to locals, but globals is what could used <br><br></td></tr></table><br>
<a name="1338758"></a>

<a name="1338759"></a>

<a name="1338760"></a>

<a name="1338761"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >skidracer</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> You could start with a uml style editor with network features and use that to design a click'n play game construction kit. I made an attempt at a <a href="http://nitrologic.blogspot.co.nz/2012/08/monkey-graphing.html" target="_blank">monkey node editor</a> a few years back inspired by derivative touch designer but didn't get that far. <br><br>IMHO It would be way cool if it looks anything like Adam Strange's chip synth. <br><br></td></tr></table><br>
<a name="1338784"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> maybe do a text adventure first to testout the process? <br><br></td></tr></table><br>
<a name="1338831"></a>

<a name="1338832"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> <img src="https://img.itch.zone/aW1hZ2UvMTM0ODE3LzYxOTQ5Mi5wbmc=/original/HjKz4Q.png"><br><br><br><br>If people are interested in a community game project, I'm prepared to provide my game Rogue3 and source code to be a start point , so this first project would be just to improve a game? would anybody be interested in this?<br><br>The first step would be better text in the game rather than what I wrote, then add more events that could happen with each move, then better artwork, <br><br>is this worth me giving the community my game code? I need more than one person to show interest in this? <br><br></td></tr></table><br>
<a name="1338836"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> Text replacement could happen once the design of the game (HUD and so on) is done.<br>Else you end up doing things twice.<br><br>So design first:<br>- are options/actions limited or of avariable length (list versus eg. 5 properly layouted action buttons versus &lt;- button button button -&gt;) <br>- is undo/redo possible (go back in time...)<br>- is "playfield size" limited or dynamically resizeable<br>...<br><br>All these things (and way more) define how things could be presented. I am not talking about artwork but just general layout - to keep things structured, nice and tidy.<br><br>Of course above is just able to get designed once the gameplay is fixed. I am not sure if that is done as you wanted "that could happen" events. These events are limited by how you present things (or ... you present things according to the possibilities events have).<br><br><br>Dunno how to describe it properly, but imho it needs a certain "scenario/limit/design" for a collaboration between multiple people.<br>Maybe someone else will jump in and write what he/she things should be done first. As said I am not thinking that "text" or "events" is the right thing to do.<br><br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1338837"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think it should be turn-based so it keeps things simple, <br><br>I think we need some input from others to decide what to do. <br><br></td></tr></table><br>
<a name="1338842"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> I suppose it really depends on what the game is and how it plays.<br><br>looking above (I haven't played anything so be kind), it seems to be:<br>1. a map (of some sort) - showing your location and others<br>2. quests -e.g. pick up passenger - probably shown on map?<br>3. your actual ship - so there would be some form of crafting and money system to upgrade ship etc<br>4. if there is money of some sort, then this could be gained by doing quests, etc<br>5. possibly some sort of 'other' display, 2d, 3d isometric, etc. maybe there is a global map and a local one?<br><br>looking at the above list. Skyrim and any rpg fits into this very well.<br><br>lets make some assumptions...<br>1. lets assume the global map is of a star system. with planets, moons and nebulae, etc<br>2. to get from planet A to planet B (x,y location on global map) you will need a ship capable of doing it. - we're sort a into elite territory now. and you will have to avoid thieves, engine overheating, enemy battles, etc<br>3. You could have different factions with different objectives. E.G. The Dohnutty are a raiding race who track any food deliveries and raid them...<br>4. on completion, you get a rating and awarded monies to upgrade your ship... and on to the next challenge.<br>5. Challenges could keep coming and you pick the one you like. like in transport tycoon.<br>6. more points awarded for completing task first. E.G. the dohnutty will pay the first person to deliver sprinkles for their "great bake off". if you accept and don't get there on time or dont get there first - they go ballistic and raid you...<br><br>Note - there is no UI, no dataset, just the basic concept <br><br></td></tr></table><br>
<a name="1338843"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#13">[#13]</a></td></tr></table></td></tr><tr ><td class="posttext"> I like the game your suggesting as an improvement on what Ive done.<br><br>if your starting from screatch....<br><br>all variables must be globals to be accessed from all individual functions, so anybody can work on a full function by them selves, each function has to be defined with strict inputs and output so again they can be worked on by any individual, or even inproved on another function, each function should be able to be hotsawapped with any function doing the same job. no time limit on working , after time there may be many modules doing the same job, so the game could be instantly built with different modules easily.<br><br>so I would start with a globals module, this is the only module that is flexible and can be build as each module needs different variables. so first thing is how we name the globals. eg MOVEMENT_X = 0 , MAP_X = 0 etc...<br><br>If you guys want to improve rogue 3 s code, its not perfect but understandable, personaly Id like to see rogue 3 upgraded by brains that see it better than me, Adam has a much more structured and different viewpoint than me, and I think rogue 3 would improve with his input. but I think a wider community would even be better.<br><br>Why don't we just cutup rogue 3 and replace each function, then add functions&gt;? <br><br></td></tr></table><br>
<a name="1338844"></a>

<a name="1338845"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#14">[#14]</a></td></tr></table></td></tr><tr ><td class="posttext"> Adam, there is no map in rogue 3, I used a new idea to progress in a straight path from a random line of locations and events. I think it works amazingly <br><br></td></tr></table><br>
<a name="1338846"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#15">[#15]</a></td></tr></table></td></tr><tr ><td class="posttext"> <a href="https://numbergamer8.itch.io/rogue-three-privateer" target="_blank">https://numbergamer8.itch.io/rogue-three-privateer</a><br><br>ok Ive put soucecode online, so we can talk about what we want to do? <br><br></td></tr></table><br>
<a name="1338847"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#16">[#16]</a></td></tr></table></td></tr><tr ><td class="posttext"> I would say first thing to do is, to select graphics files paths to be rewrote to work on a Mac?<br><br>I don't know who uses Linux? <br><br></td></tr></table><br>
<a name="1338848"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#17">[#17]</a></td></tr></table></td></tr><tr ><td class="posttext"> There is no need to have file assets at all.<br><br>I thought you want to use modules for everything.<br><br>So every unit is kind of an module with defined methods (prepare (init assets if not done yet), update move renderBackground RenderForeground RenderDecoration...).<br><br>So if one wants to use vector drawing..he might do so.<br><br><br>@ globals<br>You could consider checking my Data-container-class it is kind of an registry for numbers, strings, objects (GitHub.com/GWRon/Dig.git/base.util.data.bmx). Of course you cannot guarantee existence of variables as you would do with a globals-container but the benefit is a non-changing base class for variables. <br><br>Hmm depends on how strict input/output predefinition becomes.<br><br><br><br>Back to files/URIs<br>Just use a generic function to sanitize/repair/... File urls. And to replace slashes (all OS will work nicely with slashes, so no backslashes needed IMHO).<br><br>Bye<br>Ron <br><br></td></tr></table><br>
<a name="1338849"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#18">[#18]</a></td></tr></table></td></tr><tr ><td class="posttext"> <a href="https://github.com/GWRon/Dig/blob/master/base.util.data.bmx" target="_blank">https://github.com/GWRon/Dig/blob/master/base.util.data.bmx</a><br><br>I needed to get a new link, above works <br><br></td></tr></table><br>
<a name="1338850"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#19">[#19]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think for the community to joinin all code has to be super simple to understand , <br><br></td></tr></table><br>
<a name="1338851"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#20">[#20]</a></td></tr></table></td></tr><tr ><td class="posttext"> this project could be ongoing perminantly. <br><br></td></tr></table><br>
<a name="1338852"></a>

<a name="1338853"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#21">[#21]</a></td></tr></table></td></tr><tr ><td class="posttext"> we should use rogue 3, and split it into functions(modules) and create a better structure &amp; cut out new modules, then use it as a base game, then let everyone rewrite modules?<br><br>create better var names etc... <br><br></td></tr></table><br>
<a name="1338854"></a>

<a name="1338855"></a>

<a name="1338856"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#22">[#22]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Derron I think just a list of globals is a more simple way of accessing and updating globals, we need to be simple for everyone to join in? I only used intergers, so super simple. but if a 3d battle module was added by someone you may possible use float, but to keep it simple just use intergers for everthing<br><br>the file paths I use on windows don't work on Adams Mac. <br><br></td></tr></table><br>
<a name="1338910"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#23">[#23]</a></td></tr></table></td></tr><tr ><td class="posttext"> @derron If we start from scratch, then your right a text game with no asset files would be good to do.  I think the space adventure would be good to do.<br><br>that's quite a list of bmx files you have online :) <br><br></td></tr></table><br>
<a name="1338915"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#24">[#24]</a></td></tr></table></td></tr><tr ><td class="posttext"> I like the thought of a universe system. sorta like this:<br><img src="http://education2.marssociety.org/wp-content/uploads/2013/07/blog-20-the-suns-neighborhood-education-net.jpg"><br><br>with each system being zoomed into to show the system itself - sorta like this:<br><img src="http://www.skymarvels.com/infopages/images/SolSys3d.jpg"><br><br>but that is really getting ahead of things... <br><br></td></tr></table><br>
<a name="1338921"></a>

<a name="1338923"></a>

<a name="1338924"></a>

<a name="1338925"></a>

<a name="1338926"></a>

<a name="1338927"></a>

<a name="1338928"></a>

<a name="1338929"></a>

<a name="1338930"></a>

<a name="1338931"></a>

<a name="1338932"></a>

<a name="1338935"></a>

<a name="1338939"></a>

<a name="1338940"></a>

<a name="1338942"></a>

<a name="1338943"></a>

<a name="1338944"></a>

<a name="1338946"></a>

<a name="1338947"></a>

<a name="1338948"></a>

<a name="1338949"></a>

<a name="1338951"></a>

<a name="1338952"></a>

<a name="1338953"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#25">[#25]</a></td></tr></table></td></tr><tr ><td class="posttext"> Adam If were doing graphics ,if you ever played elite frontier 2 , you moved a cursor that locked onto a planet or star as you moved around the map with the mouse, so the first map would be easy to do as it is, just define the zone for each dot. <br><br>the second map same thing except this second map would be different every time,, so define dot locations would need to be dynamic( I would have the same dot locations but either on off for all possible numbers of planets)<br><br>you would need a 3rd closer map for citys or moons or space stations in the same location.<br><br>so for the first module I would do a simple set of arrays , easily understood by all skill levels of the comunity<br><br>global universe[solor,sys,orbit,base,basetype]<br><br>global description$[solor,sys,orbit,base,basetypedescription]<br><br>global goods[solor,sys,orbit,base,basetype,comodity,comoditytype,number]<br><br>global army[solor,sys,orbit,base,basetype,army,armytype,number]<br><br>global ships[solor,sys,orbit,base,ships,shiptype,number] ship number 1 could be player, ship number 2 could be pirate, ship 3 trader, ship 4 army, ship 5 destroyer, ship 6 transport etc...<br><br>global shipsweapons[solor,sys,orbit,base,ship,weapontype,number]<br><br>global shipscargo[solor,sys,orbit,base,ship,cargotype,number]<br><br>global playerweapons[weapontype,number] weapons type can have shields and other types of equipment<br><br>global playercargo[weapontype,number] cargo can have rooms such as bridge engineering cabins etc...<br><br>THE ARRAYS HAVE TO BE SET IN STONE SO ALL MODULES CAN INTERACT WITH THEM.<br><br>so the second module select destination on the nav map. draw map mouseclick select one<br><br>third module save and load arrays.<br><br>fourth module display location &amp; description etc...<br><br>fifth module draw HUD and select an action for a command set of buttons<br><br>sixth module movemen from A to B with interuptions for pirates etc,,,<br><br>seventh module pirate interdiction to movement<br><br>eigth module setup randomly generate arrays<br><br>ninth module buy and sell commodity, so transfer to ship and transfer to base,<br><br>tenth shipyard for upgrades<br><br>11th module combat(this is the most complicated, but if the other modules generate where all the pirates are, it should be smooth) I would keep it turn based, but its upto the programer<br><br>12th module generate who is where, eg where are the pirates.<br><br>THE IDEA HERE IS NO ONE IS RIGHT WE DO ANY MODULE AT ANY TIME, WE JUST NEED TO DEFINE THE MODULES THAT WE THEN CAN CHOOSE TO WORK ON AS WE WISH, BUT THE BASE HAS TO BE THE SAME FOR EVERYONE. SO IM TRYING TO LAY DOWN THE MODULE LIST PLEASE ADD TO IT BEFORE ANYBODY STARTS PROGRAMING.<br><br>THE INPUTS ARE ALL THE SAME THE ARRAYS<br><br>THE OUTPUTS ARE ALL THE SAME THE ARRAYS<br><br>I TRYING TO MAKE THE MODULES EASY FOR ANYBODY TO CONTRIBUTE<br><br><br>OK I HAVE NOW SET THE FRAMEWORK, WE NEED TO ADD AND AMEND. PLEASE PLEASE KEEP IN MIND THAT THIS IS FOR ANYBODY TO PARTISIPATE SO IT HAS TO BE SUPER SIMPLE.<br><br>Have I got it started then? <br><br></td></tr></table><br>
<a name="1338954"></a>

<a name="1338955"></a>

<a name="1338956"></a>

<a name="1338957"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#26">[#26]</a></td></tr></table></td></tr><tr ><td class="posttext"> all we have to do to start this community project is set the arrays in stone, DO WE AGREE SO FAR? once we agree its upto individual programers how they do each module , text or graphical, turnbased or real time, 2d or 3d<br><br>also if we set the arrays in stone, extra modules can be added to the list with ease, the world exists in the arrays. <br><br></td></tr></table><br>
<a name="1338958"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#27">[#27]</a></td></tr></table></td></tr><tr ><td class="posttext"> once we agree, the array structure has to be created, eg ship 1 player, ship number 2 pirate, ship number 3 trader, <br><br>base number 1 city, base 2, space station base 3 shipyard etc... <br><br></td></tr></table><br>
<a name="1338959"></a>

<a name="1338960"></a>

<a name="1338961"></a>

<a name="1338962"></a>

<a name="1338963"></a>

<a name="1338964"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#28">[#28]</a></td></tr></table></td></tr><tr ><td class="posttext"> there is another alternative, is to add modules to my game rogue 3 , eg the maps Adam has done can be inserted into a nav module in rogue 3 quite easily, we could use rogue 3 as our base starting point&gt;?<br><br>all need be done is to take the emergency move back 5 button in rogue 3 and instead of moving take it to Adams Map, and select destination? call it navigation. then have the program at startup randomly create the paths from one location to all others, the distances are pre known.<br><br>replace rogue 3 random mission generation , now every individual journey would be the same each time you travel it, but different from all others. you could randomise some things like passengers.<br><br>I think this is a good improvement to rogue 3<br><br>IF I was being honest, I realy like rogue 3, and if it got worked on and improved that would be my first choice <br><br></td></tr></table><br>
<a name="1338981"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#29">[#29]</a></td></tr></table></td></tr><tr ><td class="posttext"> mmm.<br>ok. a few points:<br><br>1. the rogue3 code runs fine on my mac<br><br>2. blitzmax will soon be dead on macOS when 32bit support is removed - it is comping rapidly, probably by the end of the year.<br><br>3. although blitzNG is 64bit, it is using max as the base and it really is past it.<br><br>Sooo, that would mean me having to say no on the coding front.<br>But... I moved to monkey2 and it is very similar and I can help hold any ones hand and I have a uber stable editor (which blitz does not)<br><br>Code style. I think here @Mainsworthy you might have a few issues with other people not using goto's, etc. In this respect you may have to up your programming skills - DONT despair I can hold you hand...<br><br>Similar to the above, even if the rogue3 source was used as a base it would need be cleaned up and made readable and more modern. E.G. #uuy is not a simple understandable label. #DrawIntro is.<br><br>Now... to kick start this. I will take rogue3 and convert to monkey2. I will modularise and reformat the code. and I will bring Mainsworthy with me... <br><br></td></tr></table><br>
<a name="1338982"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#30">[#30]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok. looked over the rogue3 code. You have some error in the code.<br><br>start game &gt; click on blackmarket = unhandled exception. attempt to index array element beyond array length.<br><br>Checking the code line 794<br>If pos = 5 And raidrun2[pos2] &lt; 5<br>pos2 is 99 maximum array size is 55!<br><br>I'll see about finding a fix <br><br></td></tr></table><br>
<a name="1338983"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#31">[#31]</a></td></tr></table></td></tr><tr ><td class="posttext"> indenting... <br><br></td></tr></table><br>
<a name="1338984"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#32">[#32]</a></td></tr></table></td></tr><tr ><td class="posttext"> @ monkey2 conversion<br><br>I think this is a "nice" idea (not a good or superb ... a nice one) as this allows to introduce us to monkey2. Because modules would allow to try out things.<br><br>Did not check the editor but I do not like "custom solutions" which do not follow OS guidelines (shortcuts, behaviour ...). Hope this is properly done. So no OGL-Window hogging ressources but therefor an event driven widget system only doing something if it is really needed.<br><br><br>@ goto<br>Yepp, this is a nogo today. And readable names are areally needed. in collab projects "readability" and "guidelines" are a must.<br><br>So uber-complex formulas either need to be written "differently" or need clear documentation of what they do.<br><br><pre class=code>
iDmg = (atkDmg*psyDmgMod)*(1-armPct*(1-atkTpArmRed))*(Rand(100)/100.0&lt;hitCh)
</pre><br><br>It is not that beautiful isn't it - and I even used variable names which are not that hard.<br><br><br><pre class=code>
'skip calculations if we did not hit at all
if (Rand(100)/100.0 &gt; hitChance) then return 0


'damage calculation is done by calculating the effective
'armor and then calculate the effective out of  the incoming
'raw damage. This also includes modifiers of armor and damage
'based on the attack type (eg. used weapon type). 


'calculate effective armor
local armorReductionPercentage:Float = armorPercentage

'take into consideration the armor ignorance of certain attack types (heavy, light, pierce...)
armorReductionPercentage :* attackTypeArmorReduction


'calculate effectively incoming damage
local incomingDamage:Float = attackDamage

'increase or lower damage depending on how frightened you are of
'the visual appearance of that enemy (it hurts more if you are afraid)
incomingDamage :* psychologicDamageMod

'reduce damage to what the armor lets through
incomingDamage :* (1 - armorReductionPercentage)


return incomingDamage
</pre><br><br><br>Depending on how descriptive your Method/Variable/...-names become you could leave out some comments. But I assume while reading above's code you know what the code does.<br>But I understand, that "too much" of comments makes things less snappier looking - and not able to get "catched" in one blink of an eye.<br><br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1338985"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#33">[#33]</a></td></tr></table></td></tr><tr ><td class="posttext"> OK. first steps. monkey2 is event driven, so I'm afraid Mainsworthy is not going to initially like it<br><br>step 1.<br>basic monkey 2 setup with initial framework with documentation showing layout of a monkey2 system with basic keyboard handling<br>done<br><br>step2.<br>add mouse handling and introduce gamemodes. gamemodes are different mode of operation. E.G. in rogue3 the first thing is the intro with text. this is GAMEMODE_INTRO. next it goes into the game, or GAMEMODE_GAME<br>To make it play really nice with OS systems I have set up an 60fps timer which handles display.<br>done<br><br>step3.<br>assets... <br><br></td></tr></table><br>
<a name="1338986"></a>

<a name="1339174"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#34">[#34]</a></td></tr></table></td></tr><tr ><td class="posttext"> step1 monkey code<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
'step 1 - framework
'this is the base framework of the app with all the basic stuff like main window created




'namespace is what we call the app.
'Other files with the same namespace will behave as if they are a single unified file
Namespace myLetterboxApp

'import std and mojo to provide basic monkey commands and window extensions
#Import "&lt;std&gt;"
#Import "&lt;mojo&gt;"

'Using allows us to reference commands in std and mojo without std. or mojo. prefixes
Using std..
Using mojo..


'set the initial size of the window
'note :=  instead of :type. this means use the type given (in this case it is vec2i)
Const Size := New Vec2i( 950,720 )

const GAMEMODE_INTRO:int = 1

'every app needs a main() function
Function Main()
	New AppInstance
	
	New MyWindow
	
	App.Run()
End


'this is the core class the new app is based from. it is a window!
Class MyWindow Extends Window

	'new is called when we first create the class
	Method New()
		Super.New( "Rogue3", Size.X, Size.Y, WindowFlags.Resizable )
	
		'if you want a constant canvas size use this
'		Layout = "letterbox"
		'or If you want the canvas to always fill the window use this
		Layout = "fill"
	End

protected
	'Although we dont need it OnRender is called every time we need to draw the screen
	'it is set to override any previous class OnRenders
	'the canvas is the place that is shown to the user
	Method OnRender( canvas:Canvas ) Override
		
		'fill the screen canvas with a color
		canvas.Color = Color.Black
		canvas.DrawRect( 0, 0, Width, Height )

		Select _gameMode
			Case GAMEMODE_INTRO
				DrawIntro( canvas )
		End Select
	End

	method DrawIntro( canvas:Canvas )
	End method

	
	'respond to any key presses
	Method OnKeyEvent( event:KeyEvent ) Override
		'heres the best way to check for shift keys etc
		local shift:bool = event.Modifiers &amp; Modifier.Shift
		local alt:bool = event.Modifiers &amp; Modifier.Alt
		
		Local str:string = ""
		
		Select event.Type
			case EventType.KeyDown
			
				Select event.Key
					Case Key.Enter
						str = "Enter Down"
						If shift Then str = "Shift + " + str
						If alt Then str = "Alt + " + str
				End Select
				
			Case EventType.KeyUp
			
				Select event.Key
					Case Key.Enter
						str = "Enter Up"
						If shift Then str = "Shift + " + str
						If alt Then str = "Alt + " + str
				End Select
				
		End Select
		
		'show any key press in the console
		If str &lt;&gt; "" Then
			Print str
		Endif
	
	End

	'this is needed to allow the Size to be correct. this is called automatically
	Method OnMeasure:Vec2i() Override
		Return Size
	End
private
	field _gameMode:int = GAMEMODE_INTRO
End



</textarea> <br><br></td></tr></table><br>
<a name="1338987"></a>

<a name="1339173"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#35">[#35]</a></td></tr></table></td></tr><tr ><td class="posttext"> step 2 monkey code<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
'Step 2 - gamemodes
'Gamemodes are added and described along with the first gamemode: intro
'mouse events have also been added to the code


'namespace is what we call the app.
'Other files with the same namespace will behave as if they are a single unified file
Namespace myLetterboxApp

'import std and mojo to provide basic monkey commands and window extensions
#Import "&lt;std&gt;"
#Import "&lt;mojo&gt;"

'Using allows us to reference commands in std and mojo without std. or mojo. prefixes
Using std..
Using mojo..


'set the initial size of the window
'note :=  instead of :type. this means use the type given (in this case it is vec2i)
Const Size := New Vec2i( 950,720 )

'set the constant variables for the gamemodes. these are in capitals for ease of detection in the code
const GAMEMODE_INTRO:int = 1
const GAMEMODE_GAME:int = 2

'every app needs a main() function
Function Main()
	New AppInstance
	
	New MyWindow
	
	App.Run()
End


'this is the core class the new app is based from. it is a window!
Class MyWindow Extends Window

	'new is called when we first create the class
	Method New()
		Super.New( "My Window", Size.X, Size.Y, WindowFlags.Resizable )
	
		'if you want a constant canvas size use this
'		Layout = "letterbox"
		'or If you want the canvas to always fill the window use this
		Layout = "fill"

		'this is a timer. it will 'tick' 60 times a second. calling OnUpdate
		_timer = New Timer( 60, OnUpdate )
	End

protected
	method OnUpdate()
	
		'this will draw the screen
		RequestRender()
	End method
	
	
	'Although we dont need it OnRender is called every time we need to draw the screen
	'it is set to override any previous class OnRenders
	'the canvas is the place that is shown to the user
	Method OnRender( canvas:Canvas ) Override
		'fill the screen canvas with a color
		canvas.Color = Color.Black
		canvas.DrawRect( 0, 0, Width, Height )

		Select _gameMode
			Case GAMEMODE_INTRO
				DrawIntro( canvas )
			Case GAMEMODE_GAME
				DrawGame( canvas )
		End Select
	End


	method DrawGame( canvas:Canvas )
	End method
	
	
	method DrawIntro( canvas:Canvas )
		canvas.Color = Color.White
		canvas.DrawText( " 'Rogue three Privateer v14'   By Mark Ainsworth ref 210665",200,20 )
		canvas.DrawText( " ",20,50 )
		canvas.DrawText( " This is a Space Adventure you are a Privateer Rogue Three, with Random Missions",100,80 )
		
		canvas.DrawText( " complete as many missions as possible, however you can.",100,110)
		
		canvas.DrawText( "Your Main objective is to complete as many missions as possble.",50,150 )
		canvas.DrawText( "Your Mission is randomly generated and displayed at the bottom.",50,170 )
		canvas.DrawText( "The Mission has a number of objectives,from pickingup passenders",50,190 )
		canvas.DrawText( "collecting cargo,or mining ore, then reaching the objective.",50,210 )
		canvas.DrawText( "there are extra oppertunities for fule and anti-matter and cargo",50,230 )
		canvas.DrawText( "If you use your sensors. You can attack or fire missiles at ships",50,250 )
		canvas.DrawText( "If your Lasers are not at full power they cant attack or defend",50,270 )
		canvas.DrawText( "Your ship, you cant have a laser at level 4 it wont work! you",50,290 )
		canvas.DrawText( "Must charge your lasers to full level 4 for them to be of any use.",50,310 )
		canvas.DrawText( "Your Shield protect your Hull, you can have shields working on",50,330 )
		canvas.DrawText( "Lower power settings, but they will only absorb hits as much as",50,350 )
		canvas.DrawText( "there charged. the scoop control allows you to pickup lose cargo",50,370 )
		canvas.DrawText( "Or fuel or even anti-matter, use your sensors to find these.",50,390 )
		canvas.DrawText( "the repair and upgrade options are only available at starbases you",50,410 )
		canvas.DrawText( "see starbases in the mission track. you can buy missiles etc at",50,430 )
		canvas.DrawText( "starbases or mission start.",50,450 )
		canvas.DrawText( "You Need Engine Anti-matter to power your lasers &amp; Shields, you",50,470 )
		canvas.DrawText( "Start with a good amount, but as you take hits, you will need to",50,490 )
		canvas.DrawText( "Hunt with your sesers to find more. You cant replace anti-matter",50,510 )
		canvas.DrawText( "at a starbase, you have to find it, its easy to run out of it.",50,530 )
		canvas.DrawText( "You get Fuel at the start of a mission when you upgrade, But Not",50,550 )
		canvas.DrawText( "during the mission at starbases. Anti-matter is the most valuable",50,570 )
		canvas.DrawText( "Resource, hard to replace,without Lasers and shields you wont win",50,590 )
		canvas.DrawText( "Battles. You improve your score by improving Reputation &amp; Missions",50,610 )
		canvas.DrawText( "You wont be able to use the last 3 Power cells for lasers or shields.",50,630 )
		
		canvas.DrawText("- PRESS ENTER OR CLICK MOUSE -",200,670)
	End method

	
	'respond to any key presses
	Method OnKeyEvent( event:KeyEvent ) Override
		'heres the best way to check for shift keys etc
		local command:bool = event.Modifiers &amp; Modifier.Gui
		local shift:bool = event.Modifiers &amp; Modifier.Shift
		local alt:bool = event.Modifiers &amp; Modifier.Alt
		
		Select event.Type
			case EventType.KeyDown
			
				Select event.Key
					Case Key.Enter
						Select _gameMode
							case GAMEMODE_INTRO
								_gameMode = GAMEMODE_GAME
						End select
							
				End Select
				
			Case EventType.KeyUp
			
				Select event.Key
					Case Key.Enter
				End Select
				
		End Select
	End

	'here we track the mouse and all mouse related stuff
	Method OnMouseEvent( event:MouseEvent ) Override
		'set up some global mouse cars so we can use these throught to program
		_mouseX = event.Location.X
		_mouseY = event.Location.Y

		'here are the baci mouse events we are interested in
		Select event.Type
			Case EventType.MouseDown
				Select _gameMode
					Case GAMEMODE_INTRO
						_gameMode = GAMEMODE_GAME
				End select
			Case EventType.MouseUp
			Case EventType.MouseEnter
			Case EventType.MouseLeave
			Case EventType.MouseMove
		End
	End method
	
	
	'this is needed to allow the Size to be correct. this is called automatically
	Method OnMeasure:Vec2i() Override
		Return Size
	End
private
	'the timer ticks 60 times a second and handles the screen update
	field _timer:Timer
	
	'what mode is the game in, showing the intro, playing, ended, etc
	field _gameMode:int = GAMEMODE_INTRO
	
	'global mouse vars
	field _mouseX:int
	field _mouseY:int
End



</textarea> <br><br></td></tr></table><br>
<a name="1338994"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#36">[#36]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok. refactoring the rogue3 blitzmax code<br><br>refactoring is when you take code, and reformat it, adding tabs, spaces, then commands. basically making it look nice<br><br>Once it has a modern look I will then go into the code and start looking at ways it can be tidied up. from there I will get a better idea of how next to progress ;) <br><br></td></tr></table><br>
<a name="1338996"></a>

<a name="1338997"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#37">[#37]</a></td></tr></table></td></tr><tr ><td class="posttext"> @ monkey2 step2<br>I think you should handle mouse hit and gamestate changes in update rather than mouseevent handling. So store mousehits similar to mouseX and mouseY. Else you will sooner or later running into problems if scenes or modes are added dynamically and a lot of key combinations get added. For simple two-state games this might be overkill but as soon as things get complex that input handling should be redirected to the screens/gamestates.<br><br><br>This means I would create a gamestate-class. If you do not want to store moushits  and hit keys you will have to  call the active  gamestate during onkey/onmouse ...after! globally available things are handled (escape to switch to mainscreen or so).<br>So it is up to the gamestates to handle inputs.<br><br>The other method is to call them in update() in which they then check for mousehits or keys on their own. Resetting handled inputs afterwards.<br><br>At the end it is similar to how you handle draw/update of gamestates.<br><br><br><br>It's just a suggestion of how _I_ would tackle it.<br><br><br>Bye<br>Ron <br><br></td></tr></table><br>
<a name="1338999"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#38">[#38]</a></td></tr></table></td></tr><tr ><td class="posttext"> I have to disagree here.<br>We are dealing with an even based system. The OnUpdate may never be called.<br>The only thing you can depend on is using the correct event systems.<br><br>This actually goes much deeper, in that... once you master event programming, you can create a stand alone class that fits directly into any model.<br><br>To correctly use event based models, you have to track what is happening and plan for it.<br><br>But I also agree that passing mouse and keystones to separate classes would be better. but we have to get used to using event systems in the first place.<br><br>Otherwise we will end up with massive duplication, which is overkill for something simple<br><br>The other issue is I am attempting to convert the blitzmax code directly to monkey2 code. I am not trying to 'do it the right way' <br><br></td></tr></table><br>
<a name="1339004"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#39">[#39]</a></td></tr></table></td></tr><tr ><td class="posttext"> @ disagree<br><br>This is what I was talking about "redirection of input handling"<br><br><br>So with a "gamestate class" you could have "onKeyEvent()" too, and "onMouseEvent()". The main-files onKeyEvent handles "application wide" things and then sends the event to the current gamestate.<br><br>BUT this would of course not act the way Mainsworthy was supposing (modules). For them you need to encapsulate inputs so they can "easily" access them.<br>You will end up having an "Inputstate"-module, which stores keystates, (mousebutton)states ...<br>All modules could access them - and eg. when handled an mouse button hit, reset its state.<br><br><br>I know that this _isn't_ strictly an event based programming as it caches event data, but it is imho the only way to create something "modular" as Mainsworthy proposed.<br><br><br>Another way to make it "event based" is to have each module be able to register for events (defined by "main"). So an "input module" would register for "onmouseevent" and "onkeyevent". Each event needs a function which gets called as soon as the event happens (parameter = event data).<br>You then end with checking whether a module handled an event, vetos it etc.<br><br>Dunno if monkey2 already implements something in this regards.<br><br><br>You see - things become pretty more complex to achieve something similar to what Mainsworthy suggested.<br><br><br>Maybe I am just seeing it from my POV and and there is a way better solution so I wont stop you from doing "your thing" (this "conversion") in monkey2 - and if it works, fine, if not, we at least might have learned a bit monkey2-coding.<br><br><br>@ stand alone class<br>I hope you are creating such a thing, am interested in it (and how you tackled the related problems). Always enjoy learning something (to eg. improve my game).<br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1339005"></a>

<a name="1339006"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#40">[#40]</a></td></tr></table></td></tr><tr ><td class="posttext"> the first thing is to finish the refactoring and then correct the bugs. lots of index overruns at the moment...<br><br>On saying that I have found the Mainsworthy is using a 10x10 grid as the screen drawing ;) <br><br></td></tr></table><br>
<a name="1339013"></a>

<a name="1339015"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#41">[#41]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm just waking to this and playing catchup, I wll get monkey 2 installed ASAP, and the index overruns Adam I'm sure the arrays can be increased in size without problems.<br><br>Thankyou Adam for this , I will study what you've done, I didn't think Id convert to monkey2 but onwards I will probably need help though thankyou Adam.<br><br>Derron I can see a collab you need descriptive names :) <br><br></td></tr></table><br>
<a name="1339014"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#42">[#42]</a></td></tr></table></td></tr><tr ><td class="posttext"> Monkey2 comes with ted2go editor which gives intellisense, or you can download my own ted21 from itch.io too <br><br></td></tr></table><br>
<a name="1339016"></a>

<a name="1339171"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#43">[#43]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok...<br>Step 3<br>Lets add a class for ships<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">


'namespace is what we call the app.
'Other files with the same namespace will behave as if they are a single unified file
Namespace myLetterboxApp

'import std and mojo to provide basic monkey commands and window extensions
#Import "&lt;std&gt;"
#Import "&lt;mojo&gt;"

'Using allows us to reference commands in std and mojo without std. or mojo. prefixes
Using std..
Using mojo..

'import any images we need from the assets folder
'they are then references by "asset::name"
#Import "assets/r3b.png"


'set the initial size of the window
'note :=  instead of :type. this means use the type given (in this case it is vec2i)
Const Size := New Vec2i( 950,720 )

const GAMEMODE_INTRO:int = 1
const GAMEMODE_GAME:int = 2

'every app needs a main() function
Function Main()
	New AppInstance
	
	New MyWindow
	
	App.Run()
End


'this will be the base calss for all ships
class Ship
	'this is called when any new thing is derrived from this class
	method New()
	End method

	
	'we can now have a different new which can be fed with an int which becomes the energy
	' so New(67) would give you a ship with 67 energy
	method New( energy:int )
		_energy = energy
	End method

	
	'because _energy is private,  we need a property and setter
	' we only then need to access by myShip.Energy = 4,  or energy = myShip.Energy
	Property Energy:int()
		Return _energy
	Setter( energy:int )
		_energy = energy
	End


	' anything in private can't be accessed from outside the class (black box approach)
private
	'how much power does the ship have. the basic level is set at 4,  but we could change this with a different new
	field _energy:int = 4
End Class


'this is the core class the new app is based from. it is a window!
Class MyWindow Extends Window

	'new is called when we first create the class
	Method New()
		Super.New( "My Window", Size.X, Size.Y, WindowFlags.Resizable )
	
		'if you want a constant canvas size use this
'		Layout = "letterbox"
		'or If you want the canvas to always fill the window use this
		Layout = "fill"

		'this is a timer. it will 'tick' 60 times a second. calling OnUpdate
		_timer = New Timer( 60, OnUpdate )
		
		'load any images
		'these MUST have been first imported and are referenced by asset::name
		_imageBackground = Image.Load( "asset::r3b.png" )
		
		'we now need to set up our first class - the ship
		_myShip = New Ship()
	End

protected
	method OnUpdate()
	
		'this will draw the screen
		RequestRender()
	End method
	
	
	'Although we dont need it OnRender is called every time we need to draw the screen
	'it is set to override any previous class OnRenders
	'the canvas is the place that is shown to the user
	Method OnRender( canvas:Canvas ) Override
		'fill the screen canvas with a color
		canvas.Color = Color.Black
		canvas.DrawRect( 0, 0, Width, Height )

		Select _gameMode
			Case GAMEMODE_INTRO
				DrawIntro( canvas )
			Case GAMEMODE_GAME
				DrawGame( canvas )
		End Select
	End


	method DrawGame( canvas:Canvas )
		'grid drawing for debug
		'screensize 950,720

		local x:int
		local y:int
		canvas.Color = Color.DarkGrey
		for x = 10 to 950 step 10
			canvas.DrawLine( x,0, x,720 )
		Next
		for y = 10 to 720 step 10
			canvas.DrawLine( 0,y, 950,y )
		next
	End method
	
	
	method DrawIntro( canvas:Canvas )
		canvas.Color = Color.White
		canvas.DrawImage( _imageBackground, 700, 200 )
				
		canvas.DrawText( " 'Rogue three Privateer v14'   By Mark Ainsworth ref 210665",200,20 )
		canvas.DrawText( " ",20,50 )
		canvas.DrawText( " This is a Space Adventure you are a Privateer Rogue Three, with Random Missions",100,80 )
		
		canvas.DrawText( " complete as many missions as possible, however you can.",100,110)
		
		canvas.DrawText( "Your Main objective is to complete as many missions as possble.",50,150 )
		canvas.DrawText( "Your Mission is randomly generated and displayed at the bottom.",50,170 )
		canvas.DrawText( "The Mission has a number of objectives,from pickingup passenders",50,190 )
		canvas.DrawText( "collecting cargo,or mining ore, then reaching the objective.",50,210 )
		canvas.DrawText( "there are extra oppertunities for fule and anti-matter and cargo",50,230 )
		canvas.DrawText( "If you use your sensors. You can attack or fire missiles at ships",50,250 )
		canvas.DrawText( "If your Lasers are not at full power they cant attack or defend",50,270 )
		canvas.DrawText( "Your ship, you cant have a laser at level 4 it wont work! you",50,290 )
		canvas.DrawText( "Must charge your lasers to full level 4 for them to be of any use.",50,310 )
		canvas.DrawText( "Your Shield protect your Hull, you can have shields working on",50,330 )
		canvas.DrawText( "Lower power settings, but they will only absorb hits as much as",50,350 )
		canvas.DrawText( "there charged. the scoop control allows you to pickup lose cargo",50,370 )
		canvas.DrawText( "Or fuel or even anti-matter, use your sensors to find these.",50,390 )
		canvas.DrawText( "the repair and upgrade options are only available at starbases you",50,410 )
		canvas.DrawText( "see starbases in the mission track. you can buy missiles etc at",50,430 )
		canvas.DrawText( "starbases or mission start.",50,450 )
		canvas.DrawText( "You Need Engine Anti-matter to power your lasers &amp; Shields, you",50,470 )
		canvas.DrawText( "Start with a good amount, but as you take hits, you will need to",50,490 )
		canvas.DrawText( "Hunt with your sesers to find more. You cant replace anti-matter",50,510 )
		canvas.DrawText( "at a starbase, you have to find it, its easy to run out of it.",50,530 )
		canvas.DrawText( "You get Fuel at the start of a mission when you upgrade, But Not",50,550 )
		canvas.DrawText( "during the mission at starbases. Anti-matter is the most valuable",50,570 )
		canvas.DrawText( "Resource, hard to replace,without Lasers and shields you wont win",50,590 )
		canvas.DrawText( "Battles. You improve your score by improving Reputation &amp; Missions",50,610 )
		canvas.DrawText( "You wont be able to use the last 3 Power cells for lasers or shields.",50,630 )
		
		canvas.DrawText("- PRESS ENTER OR CLICK MOUSE -",200,670)
	End method

	
	'respond to any key presses
	Method OnKeyEvent( event:KeyEvent ) Override
		'heres the best way to check for shift keys etc
		local command:bool = event.Modifiers &amp; Modifier.Gui
		local shift:bool = event.Modifiers &amp; Modifier.Shift
		local alt:bool = event.Modifiers &amp; Modifier.Alt
		
		Select event.Type
			case EventType.KeyDown
			
				Select event.Key
					Case Key.Enter
						Select _gameMode
							case GAMEMODE_INTRO
								_gameMode = GAMEMODE_GAME
						End select
							
				End Select
				
			Case EventType.KeyUp
			
				Select event.Key
					Case Key.Enter
				End Select
				
		End Select
	End

	'here we track the mouse and all mouse related stuff
	Method OnMouseEvent( event:MouseEvent ) Override
		'set up some global mouse cars so we can use these throught to program
		_mouseX = event.Location.X
		_mouseY = event.Location.Y

		'here are the baci mouse events we are interested in
		Select event.Type
			Case EventType.MouseDown
				Select _gameMode
					Case GAMEMODE_INTRO
						_gameMode = GAMEMODE_GAME
				End select
			Case EventType.MouseUp
			Case EventType.MouseEnter
			Case EventType.MouseLeave
			Case EventType.MouseMove
		End
	End method
	
	
	'this is needed to allow the Size to be correct. this is called automatically
	Method OnMeasure:Vec2i() Override
		Return Size
	End
private
	'the timer ticks 60 times a second and handles the screen update
	field _timer:Timer
	
	'what mode is the game in, showing the intro, playing, ended, etc
	field _gameMode:int = GAMEMODE_INTRO
	
	'global mouse vars
	field _mouseX:int
	field _mouseY:int
	
	'image assets
	field _imageBackground:Image
	
	'set up some classes' these will need to be newed
	field _myShip:Ship
End

</textarea><br><br><br>not a great deal has changed apart from adding the initial class definition which has one variable _energy and setters, getters for accessing this variable.<br>I know that it seems a bit long winded, but there is an inherent elegance and simplicity hiding in there.<br><br>I have added lots of help text to let you know what is going on.<br><br>The game draw routine now has a default 10x10 grid showing.<br><br>Next step is to show the energy onscreen <br><br></td></tr></table><br>
<a name="1339017"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#44">[#44]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok , I got Monkey2 installed, I also downloaded your editor, but I think I need to get used to default first so I know the basics, your editor was much more impressive and as a programmer I want it, but I found as a newbie I needed a more simple view, I will progress to yours after a few compiles and when I know all the directories etc... <br><br>I'm sorta following the code, I will need some experiments as I go, but this is exciting :) <br><br></td></tr></table><br>
<a name="1339018"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#45">[#45]</a></td></tr></table></td></tr><tr ><td class="posttext"> i'm here to hold you hand. don't think that any question is dumb - just ask.<br><br>The best thing is to get a feel for things to begin with. there is a lot of stuff that is familiar, but a lot of really alien stuff in there too.<br><br>Again, just let me know if you want anything explained and I'll do my best... <br><br></td></tr></table><br>
<a name="1339020"></a>

<a name="1339021"></a>

<a name="1339022"></a>

<a name="1339023"></a>

<a name="1339024"></a>

<a name="1339025"></a>

<a name="1339026"></a>

<a name="1339027"></a>

<a name="1339028"></a>

<a name="1339029"></a>

<a name="1339030"></a>

<a name="1339031"></a>

<a name="1339032"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#46">[#46]</a></td></tr></table></td></tr><tr ><td class="posttext"> Image.Load( "asset::r3b.png"<br><br>what does the :: mean , I know this is OOP thingy probably meand directory variable, just wondering?<br><br><br>OK I'm FOLLOWING THIS QUITE WELL WITH THE DESCRIPTIVE WAY YOUR DOING IT, KEEP IT COMING :) <br><br></td></tr></table><br>
<a name="1339033"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#47">[#47]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok.<br>at the top of the file are 2 important #imports<br>#import &lt;mojo&gt;<br>#import &lt;std&gt;<br><br>std is the basic monkey2 language and support stuff<br>mojo is all the nice window and app stuff<br><br>Canvas comes from mojo and deals with the screen - the canvas if you will.<br>Mojo sets up a basic framework, and OnRender(canvas:Canvas) is called from there.<br><br>In practice, you will probably always be using this as a basis, so that is how it looks and works.<br><br>Yep<br>OnMouseEvent comes from mojo. Basically it has done all the nasty stuff for you - window, event, etc. You just need to deal with the nice stuff like responding and dealing with events.<br><br>OK the asset:: stuff is Marks way of abstracting things for you.<br>You know all the crap about getting resources being different on a mac from windows, and the trouble thing got into?<br>Well... When you #import an asset (from the asset folder) it gets put (inside mojo) into a list of available assets.<br><br>Image.Load("asset::file") means look inside the asset list and give me that asset.<br><br>Why is this odd and strange?<br>Well On ios, you might not be dealing with a folder, but a packed set of assets. You don't have to know how android or ios, or windows stored the assets, you just need to know, that when developing, every asset lives in the asset folder, and on compiling, all the assets are dragged around and put into their proper place for each system AUTOMATICALLY for you. In this respect Mark has done something wonderful for you. <br><br></td></tr></table><br>
<a name="1339034"></a>

<a name="1339035"></a>

<a name="1339036"></a>

<a name="1339037"></a>

<a name="1339038"></a>

<a name="1339039"></a>

<a name="1339040"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#48">[#48]</a></td></tr></table></td></tr><tr ><td class="posttext"> Adam this is great, I'm really getting into it now, <br><br>If I was doing step 4, I would of made a currentlocation class with ships forward ,right,rear &amp; left, drifting fuel , cargo, antimatter and ore, &amp; base ?<br><br>add gold , passengers &amp; cargo to ship class ?<br><br>I'm not saying do it, I'm saying its making sence :)<br><br>universe class with  mission track array[](so tracks can be added to each part of a wider universe in the future)  ?<br><br><br>does the Import PNGs have a sprite cutting option? I'm assuming there all transparent . <br><br></td></tr></table><br>
<a name="1339041"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#49">[#49]</a></td></tr></table></td></tr><tr ><td class="posttext"> Instead of adding passengers to the ship you create a TCargo class...and extending classes like TCargoPassenger TCargoLiquid ...<br><br>Each cargo gets a Getter for the current mass... And flags telling if they are incompatible to cargos with certain flags... So a forbiddenFlag could say "flammable" and another cargo could have a flag as "flammable"... They could not get stored together in the cargo list of a ship.<br><br>Each cargo also knows its own price and gets informed on load or unload (so it could eg. Explode or create special events).<br><br><br>Of course they could/should be able to/... also register for events...when following Adams suggestions.<br><br><br>Bye<br>Ron <br><br></td></tr></table><br>
<a name="1339042"></a>

<a name="1339043"></a>

<a name="1339044"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#50">[#50]</a></td></tr></table></td></tr><tr ><td class="posttext"> Derron, I like the cargo flags it would make the game much more interesting, and your right passengers are cargo too, I think though we need a base classes to start from, then add to them, we need a simple springboard.<br><br>I cant believe I'm saying class, I never thought Id do this, and its a real class for me <br><br></td></tr></table><br>
<a name="1339051"></a>

<a name="1339052"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#51">[#51]</a></td></tr></table></td></tr><tr ><td class="posttext"> Next to "cargo" you could do the SAME for the crew. So eg. a "mechanic from Alpha Xcr" wont work as effective with a "female engineer from Earth".<br><br>But THESE are things people could extend in their own module. So the base stays, that there is some kind of "crew member"-class. People then replace it with their incarnations.<br>The base class just needs to know in advance what this class could modify ... or you do it with your globals-class.<br><br>So eg. the perfect team would result in 100% usage of the machinery in a ship. The less perfect a team is mixed, the less efficient the machinery is used.<br>To make it adjustable you need to have all these little "mods" (shipEfficiencyMod - 100% = 1.0) accessible for modification.<br><br>We ignore for now, that "Getters" are nicer because you could override them and therefor extend them. So a "GetShipEfficiencyMod:float()" could use the parental definition or take into consideration way more than just a basic float "shipEfficiencyMod").<br><br>(Edit: that "efficiency" could even decrease if you have loaded liquids or explosives or ... depending on the engine of a ship and how this engine is working - magnetic impulses versus nuclear warp. An extended "GetShipEfficiencyMod:float()" could take these things into consideration by calling other "Getters" which itself could again get overridden/extended by even more complex things to consider)<br><br><br>Sorry for getting "offtopic" again by bringing in "new ideas" to make things more and more complex.<br><br><br><br>As you both said: first get it converted/error-corrected.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1339054"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#52">[#52]</a></td></tr></table></td></tr><tr ><td class="posttext"> Derron, its good to see these things, but right now I'm a noob at monkey2 , I just found the help files, Ive never programed like this, so it takes me a minite to know what GetShipEfficiencyMod:float() is made from, I can figure it out , but its not auto yet, but that said I'm lovin it :) <br><br></td></tr></table><br>
<a name="1339055"></a>

<a name="1339170"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#53">[#53]</a></td></tr></table></td></tr><tr ><td class="posttext"> Last post for today.<br>Step 4. some graphics<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

'Step 4 - first bits of graphics
'the first thing to note is we have not got a game of any sort yet.
' I am trying to replicate the  drawing routines from the original source
' So first thing first.
'we are drawing the ship energy bar,  the first of the 'bombs and the tv/terminal
'raw Monkey2 does not support animimage,  so a new button image for the 'bombs' will be needed
' the different colors will be got by using different colors
'I am also not using the tv, but making a terminal out of graphics to show some commands

'namespace is what we call the app.
'Other files with the same namespace will behave as if they are a single unified file
Namespace myLetterboxApp

'import std and mojo to provide basic monkey commands and window extensions
#Import "&lt;std&gt;"
#Import "&lt;mojo&gt;"

'Using allows us to reference commands in std and mojo without std. or mojo. prefixes
Using std..
Using mojo..

'import any images we need from the assets folder
'they are then references by "asset::name"
'NOTE it is best to include all assets one by one.
#Import "assets/r3b.png"
#Import "assets/power.png"
#Import "assets/newButton.png"


'set the initial size of the window
'note :=  instead of :type. this means use the type given (in this case it is vec2i)
Const Size := New Vec2i( 950,720 )

const GAMEMODE_INTRO:int = 1
const GAMEMODE_GAME:int = 2

'every app needs a main() function
Function Main()
	New AppInstance
	
	New MyWindow
	
	App.Run()
End


'this will be the base calss for all ships
class Ship
	'this is called when any new thing is derrived from this class
	method New()
	End method

	
	'we can now have a different new which can be fed with an int which becomes the energy
	' so New(67) would give you a ship with 67 energy
	method New( energy:int )
		_energy = energy
	End method

	
	'because _energy is private,  we need a property and setter
	' we only then need to access by myShip.Energy = 4,  or energy = myShip.Energy
	Property Energy:int()
		Return _energy
	Setter( energy:int )
		_energy = energy
	End


	' anything in private can't be accessed from outside the class (black box approach)
private
	'how much power does the ship have. the basic level is set at 4,  but we could change this with a different new
	field _energy:int = 4
End Class


'this is the core class the new app is based from. it is a window!
Class MyWindow Extends Window

	'new is called when we first create the class
	Method New()
		Super.New( "My Window", Size.X, Size.Y, WindowFlags.Resizable )
	
		'we will now make the background black and activate the ability to stretch the window
		ClearColor = Color.Black

		'if you want a constant canvas size use this
		Layout = "letterbox"
		'or If you want the canvas to always fill the window use this
'		Layout = "fill"

		'this is a timer. it will 'tick' 60 times a second. calling OnUpdate
		_timer = New Timer( 60, OnUpdate )
		
		'load any images
		'these MUST have been first imported and are referenced by asset::name
		_imageBackground = Image.Load( "asset::r3b.png" )
		_imageEnergy = Image.Load( "asset::power.png" )
		_imageNewButton = Image.Load( "asset::newButton.png" )
		
		'we now need to set up our first class - the ship
		_myShip = New Ship()
	End

protected
	method OnUpdate()
	
		'this will draw the screen
		RequestRender()
	End method
	
	
	'Although we dont need it OnRender is called every time we need to draw the screen
	'it is set to override any previous class OnRenders
	'the canvas is the place that is shown to the user
	Method OnRender( canvas:Canvas ) Override
		'fill the screen canvas with a color
		canvas.Color = Color.Black
		canvas.DrawRect( 0, 0, Width, Height )

		Select _gameMode
			Case GAMEMODE_INTRO
				DrawIntro( canvas )
			Case GAMEMODE_GAME
				DrawGame( canvas )
		End Select
	End


	method DrawGame( canvas:Canvas )
		'grid drawing for debug
		'screensize 950,720
		local x:int
		local y:int
		canvas.Color = Color.DarkGrey
		for x = 10 to 950 step 10
			canvas.DrawLine( x,0, x,720 )
		Next
		for y = 10 to 720 step 10
			canvas.DrawLine( 0,y, 950,y )
		Next
		
		'draw the available energy. we need to define f,  and set it up correctly to use it
		'make sure we are using white to correctly show the color
		canvas.Color = Color.White
		Local f:int
		For f = 0 To _myShip.Energy
			canvas.DrawImage( _imageEnergy, 40+(f*30), 30 )
		Next
		'and now lets draw all other available energy in a darker color. just makes things look nice
		canvas.Color = Color.DarkGrey
		For f = _myShip.Energy+1 To 28
			canvas.DrawImage( _imageEnergy, 40+(f*30), 30 )
		Next
		
		
		'ok we are now going to draw the 'bombs or the lasers and shields
		'we need to pass canvas as we wont be able to draw otherwise
		'so we are passing canvas,  x and y  positions,  and finally the actual setting
		DrawBombs( canvas, 40, 220, 1 )
		
		
		'mow draw the terminal (the tv thingy)
		DrawTerminal( canvas, 570, 230, "Terminal:" )
	End method
	
	
	'this will draw the terminal screen
	'I have decided not the draw the bitmap image of the screen,  but use graphics to to do it as
	'it shows how to do simple graphics
	method DrawTerminal( canvas:Canvas, x:int, y:int, title:String )
		'here we need a color that is not in the library - a sort of terminal green color
		' so we need a New Color with the color settings.
		' NOTE the color setting are in the range 0 to 1 and NOT 0 to 255 like blitzmax!
		canvas.Color = New Color( 0, 0.78, 0.19 )
		
		'first draw a green rectangle
		canvas.DrawRect( x, y, 370, 370 )

		'change the color to black and draw a second rectange inside the other one
		canvas.Color = Color.Black
		canvas.DrawRect( x+2, y+25, 366, 343 )

		'and finally draw some text
		canvas.DrawText( title, x+7, y+5 )
	End method
	
	
	'this will draw the 'bombs' with a grey background and proper colors
	'raw Monkey2 does not support anim amages like blitz,  so we are going to use a single graphic and
	'change the colors
	method DrawBombs( canvas:Canvas, x:int, y:int, pos:int )
		'ok here is a new command Clamp. it takes a var and keeps it within a defined range
		'if it is an int the rangfe must be ints,  of it is a float,  the you MUST use floats.
		'E.G. Clamp( var,  0.0, 1.0 )
		pos = Clamp( pos, 1, 4 )
		
		'set the color to grey
		canvas.Color = Color.Grey
		If pos = 4 Then canvas.Color = Color.Pine
		canvas.DrawImage( _imageNewButton, 40, 220 + 55 )
		If pos = 3 Then canvas.Color = Color.Yellow
		canvas.DrawImage( _imageNewButton, 40, 220 + 110 )
		If pos = 2 Then canvas.Color = Color.Orange
		canvas.DrawImage( _imageNewButton, 40, 220 + 165 )
		If pos = 1 Then canvas.Color = Color.Red
		canvas.DrawImage( _imageNewButton, 40, 220 + 220 )
	End method
	
		
	method DrawIntro( canvas:Canvas )
		canvas.Color = Color.White
		canvas.DrawImage( _imageBackground, 700, 200 )
				
		canvas.DrawText( " 'Rogue three Privateer v14'   By Mark Ainsworth ref 210665",200,20 )
		canvas.DrawText( " ",20,50 )
		canvas.DrawText( " This is a Space Adventure you are a Privateer Rogue Three, with Random Missions",100,80 )
		
		canvas.DrawText( " complete as many missions as possible, however you can.",100,110)
		
		canvas.DrawText( "Your Main objective is to complete as many missions as possble.",50,150 )
		canvas.DrawText( "Your Mission is randomly generated and displayed at the bottom.",50,170 )
		canvas.DrawText( "The Mission has a number of objectives,from pickingup passenders",50,190 )
		canvas.DrawText( "collecting cargo,or mining ore, then reaching the objective.",50,210 )
		canvas.DrawText( "there are extra oppertunities for fule and anti-matter and cargo",50,230 )
		canvas.DrawText( "If you use your sensors. You can attack or fire missiles at ships",50,250 )
		canvas.DrawText( "If your Lasers are not at full power they cant attack or defend",50,270 )
		canvas.DrawText( "Your ship, you cant have a laser at level 4 it wont work! you",50,290 )
		canvas.DrawText( "Must charge your lasers to full level 4 for them to be of any use.",50,310 )
		canvas.DrawText( "Your Shield protect your Hull, you can have shields working on",50,330 )
		canvas.DrawText( "Lower power settings, but they will only absorb hits as much as",50,350 )
		canvas.DrawText( "there charged. the scoop control allows you to pickup lose cargo",50,370 )
		canvas.DrawText( "Or fuel or even anti-matter, use your sensors to find these.",50,390 )
		canvas.DrawText( "the repair and upgrade options are only available at starbases you",50,410 )
		canvas.DrawText( "see starbases in the mission track. you can buy missiles etc at",50,430 )
		canvas.DrawText( "starbases or mission start.",50,450 )
		canvas.DrawText( "You Need Engine Anti-matter to power your lasers &amp; Shields, you",50,470 )
		canvas.DrawText( "Start with a good amount, but as you take hits, you will need to",50,490 )
		canvas.DrawText( "Hunt with your sesers to find more. You cant replace anti-matter",50,510 )
		canvas.DrawText( "at a starbase, you have to find it, its easy to run out of it.",50,530 )
		canvas.DrawText( "You get Fuel at the start of a mission when you upgrade, But Not",50,550 )
		canvas.DrawText( "during the mission at starbases. Anti-matter is the most valuable",50,570 )
		canvas.DrawText( "Resource, hard to replace,without Lasers and shields you wont win",50,590 )
		canvas.DrawText( "Battles. You improve your score by improving Reputation &amp; Missions",50,610 )
		canvas.DrawText( "You wont be able to use the last 3 Power cells for lasers or shields.",50,630 )
		
		canvas.DrawText("- PRESS ENTER OR CLICK MOUSE -",200,670)
	End method

	
	'respond to any key presses
	Method OnKeyEvent( event:KeyEvent ) Override
		'heres the best way to check for shift keys etc
		local command:bool = event.Modifiers &amp; Modifier.Gui
		local shift:bool = event.Modifiers &amp; Modifier.Shift
		local alt:bool = event.Modifiers &amp; Modifier.Alt
		
		Select event.Type
			case EventType.KeyDown
			
				Select event.Key
					Case Key.Enter
						Select _gameMode
							case GAMEMODE_INTRO
								_gameMode = GAMEMODE_GAME
						End select
							
				End Select
				
			Case EventType.KeyUp
			
				Select event.Key
					Case Key.Enter
				End Select
				
		End Select
	End

	'here we track the mouse and all mouse related stuff
	Method OnMouseEvent( event:MouseEvent ) Override
		'set up some global mouse cars so we can use these throught to program
		_mouseX = event.Location.X
		_mouseY = event.Location.Y

		'here are the baci mouse events we are interested in
		Select event.Type
			Case EventType.MouseDown
				Select _gameMode
					Case GAMEMODE_INTRO
						_gameMode = GAMEMODE_GAME
				End select
			Case EventType.MouseUp
			Case EventType.MouseEnter
			Case EventType.MouseLeave
			Case EventType.MouseMove
		End
	End method
	
	
	'this is needed to allow the Size to be correct. this is called automatically
	Method OnMeasure:Vec2i() Override
		Return Size
	End
private
	'the timer ticks 60 times a second and handles the screen update
	field _timer:Timer
	
	'what mode is the game in, showing the intro, playing, ended, etc
	field _gameMode:int = GAMEMODE_GAME'INTRO
	
	'global mouse vars
	field _mouseX:int
	field _mouseY:int
	
	'image assets
	field _imageBackground:Image
	field _imageEnergy:Image
	field _imageNewButton:Image
	
	'set up some classes' these will need to be newed
	field _myShip:Ship
End



</textarea><br><br><br>in essence I am expanding the code step by step, so it is in little jumps with full explanation of what's going on and some of the new commands.<br><br>@Mainsworthy There are no stupid questions. I'm here to help in any way possible.<br><br>You will also need the new button graphic png:<br><img src="https://vjointeractive.files.wordpress.com/2017/04/newbutton.png"><br><br>This is called newButton.png &lt;- watch the capitals<br><br>You'll also notice that it jumps straight into the game screen missing the intro. This is due to testing and if you look in the private section you will find a change to the following line:<br>	field _gameMode:int = GAMEMODE_GAME'INTRO<br>where I've commented out the INTRO bit... <br><br></td></tr></table><br>
<a name="1339057"></a>

<a name="1339061"></a>

<a name="1339062"></a>

<a name="1339068"></a>

<a name="1339071"></a>

<a name="1339076"></a>

<a name="1339078"></a>

<a name="1339082"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#54">[#54]</a></td></tr></table></td></tr><tr ><td class="posttext"> can I create global arrays at the top like const? and run external functions defined at the top, can I use variables outside of the class like public section of a class(does that exist?) I will test it soon, just idle thinking<br><br>the help in M2 is nice so far :) wow having some successful tests now, this is fun, I think I'm going to adopt Monkey2 now as my game creator. <br><br></td></tr></table><br>
<a name="1339084"></a>

<a name="1339088"></a>

<a name="1339089"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#55">[#55]</a></td></tr></table></td></tr><tr ><td class="posttext"> if you create a _myship<br><br>	'we now need to set up our first class - the ship<br>		_myShip = New Ship()<br><br><br> myShip.Energy = 4,  or energy = myShip.Energy<br><br>My serious Question here is if we create _myship  why do we access its variables as myShip? without the underscore, whats the relationship with the underscores, I know this is some kind of OOP but I'm sure you could tell me better than I could figure.?<br><br>I have to thank you Adam for getting me into Monkey2, I'm rotating scaling transarenting, globaling arraying. and thankyou Monkey2 devs this is to cool to say, and its fun like starting to program all over again. but I am still puzzled by the _underscores<br><br><br>just seen For f = _myShip.Energy+1 To 28 , so maybe I was to quick to look at the comments rather than the code, but is there a reason for the underscores, are they to denote class variables or something, is it voluntary? <br><br></td></tr></table><br>
<a name="1339092"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#56">[#56]</a></td></tr></table></td></tr><tr ><td class="posttext"> it's voluntary. but there is method in the madness<br><br>Variable naming is personal. you say yada, I say _yada. The first this the note is that monkey2 is case sensitive, so myVar is different from MyVar and different from myvar. in blitzmax they are all the same variable<br><br>if you look at the setters/getter/propery you will see it looks like this:<br><pre class=code>
	Property Energy:int()
		Return _energy
	Setter( energy:int )
		_energy = energy
	End
</pre><br><br>and when you access the variable it is through 'Energy' the setter uses 'Energy' even though in the code it is 'energy'. To keep your head from going to mush Mark uses _energy as the internal variable.<br><br>so in a class internal variables are generally _(lowercase)variable<br>E.G.<br>_myVar<br>_energy<br>_gold<br>_lotsOfGold<br><br>external properties (things you can get/set are (uppercase)Variable<br>E.G.<br>MyVar<br>Energy<br>Gold<br>LotsOfGold<br><br>For constants. this that don't change, like the GAMEMODE_STUFF I use all caps. that way you instantly know what sort of  variable it is.<br><br>The other thing is better naming of variables with caps<br>E.G.<br>myVar rather than myvar<br>or lotsOfGold rather that lotsofgold<br><br>again it's a clarity thing. you can instantly read lotsOfGold because the capitals stand out<br><br>What I'm trying to do is install some clarity in your code. it will be better for you, me and Mrs Quot at the corner shop will loveYouForIt2...<br><br>slightly off but related. It is better to start methods with a capital.<br><br>local variables (to a method) can just be normal, like j and f etc, but again stuff like uuuyys although valid isn't much help for readability.<br><br>I'm not going to talk about globals or functions, you can have then and I do in places, but if we keep things class related, you are going to see something magic happen... <br><br></td></tr></table><br>
<a name="1339093"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#57">[#57]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok. this is just so you know what i am going to be up to...<br><div class="quote"> universe class with mission track array[](so tracks can be added to each part of a wider universe in the future) ? <br></div><br><br>I'm going to start a completely new app and work on this as a Class. It can then be directly included into the main source with nothing extra added to the main code - a MODULE!!!!!!! - yep, that can be extended simply.... magic... <br><br></td></tr></table><br>
<a name="1339099"></a>

<a name="1339169"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#58">[#58]</a></td></tr></table></td></tr><tr ><td class="posttext"> universe step 1 ... 3 systems with planets<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Namespace myMojoApp

#Import "&lt;std&gt;"
#Import "&lt;mojo&gt;"

Using std..
Using mojo..

Const Size := New Vec2i( 950,720 )

Function Main()
	New AppInstance
	
	New MyWindow
	
	App.Run()
End



class Planet
End Class


'lets assume that x, z cordinates are a flat plane and go from 0 to 512. with 256 being the center
'And lets assume that y goes from 0 to 128 with 64 being the center
'we now have a box 512x512x128 with 256, 64, 256 as the center point
'lets also assume that is difficult to remember and have 0, 0, 0 as the center and correct the offsets in the class itself
class SolarSystem
	method New( x:float, y:float, z:float, name:string )
		'first we must to our internal correction
		_xPos = x + 256
		_zPos = z + 256
		
		_yPos = y + 64
		
		_name = name
		
		CreatePlanets()
	End method
	
	
	Property Name:string()
		Return _name
	Setter( name:string )
		_name = name
	End

	'note the additon of data processing in the property.
	' to us (outside the class), positons are centered around 0, 0, 0,  inside they are really centered at 256, 64, 256
	' so we will need to alter the internals when being inspected from outside the class
	Property XPos:float()
		Return _xPos - 256
	End

	Property ZPos:float()
		Return _zPos - 256
	End

	Property YPos:float()
		Return _yPos - 64
	End

	'note the different variables names and also we dont need a setter
	Property Planets:int()
		Return _planetCount
	End
	
protected

	method CreatePlanets()
		'we are going to do something odd but amazing here
		Local seed:uint = _xPos + (_zPos * 512) + (_yPos * 300000)
		'what this has done is created a unique uint (long int) for each solar system
		'we can then pass this to seedrnd a always get the same results for random numbers
		
		SeedRnd( seed )
		
		_planetCount = Rnd( 2, 12 )
	End method
	
private
	field _xPos:float
	field _yPos:float
	field _zPos:float
	
	field _name:string
	
	'a solar system has planets
	field _planetCount:int = 0
	field _planets:Planet[] = New Planet[13]
End Class




Class MyWindow Extends Window

	method New()
		Super.New( "My Window", Size.X, Size.Y, WindowFlags.Resizable )
		ClearColor = Color.Black

		'Create a solar system.... Magic
		_solarSystem[0] = New SolarSystem( 0, 0, 0, "Galactic Center" )

		'And now 2 more
		'beware of floats. they lie
		_solarSystem[1] = New SolarSystem( 12.4, 15, 6.1, "Ceti" )
		_solarSystem[2] = New SolarSystem( - 5, 8.3, -3, "Zimini" )
	End method

	
	Method OnRender( canvas:Canvas ) Override
		canvas.DrawText( _solarSystem[0].Name, 10, 10 )
		canvas.DrawText( " x:"+_solarSystem[0].XPos, 20, 30 ) 
		canvas.DrawText( " z:"+_solarSystem[0].ZPos, 20, 50 )
		canvas.DrawText( " y:"+_solarSystem[0].YPos, 20, 70 )
		canvas.DrawText( _solarSystem[0].Planets+" planets", 10, 90 )
		
		canvas.DrawText( _solarSystem[1].Name, 210, 10 )
		canvas.DrawText( " x:"+_solarSystem[1].XPos, 220, 30 ) 
		canvas.DrawText( " z:"+_solarSystem[1].ZPos, 220, 50 )
		canvas.DrawText( " y:"+_solarSystem[1].YPos, 220, 70 )
		canvas.DrawText( _solarSystem[1].Planets+" planets", 210, 90 )

		canvas.DrawText( _solarSystem[2].Name, 410, 10 )
		canvas.DrawText( " x:"+_solarSystem[2].XPos, 420, 30 ) 
		canvas.DrawText( " z:"+_solarSystem[2].ZPos, 420, 50 )
		canvas.DrawText( " y:"+_solarSystem[2].YPos, 420, 70 )
		canvas.DrawText( _solarSystem[2].Planets+" planets", 410, 90 )
	End
	
private
	'set up an array of SolorSystems. This is just setting then up. we will need to new each one into existance as well
	'but note how the array works. if the variables are ints or ools and not classes. using this will create them
	' but classes need to be New() into existance as well
	field _solarSystem:SolarSystem[] = New SolarSystem[10]
	
	'here is how we do a multiple array. it's not quite like Basic,  and is a bit fiddly. but heres the code for you
'	field _map:int[, ] = New int[10, 10]
End

</textarea><br><br>have a good look over the code. there are lots of comments removed so you should be starting to feel a bit happier.<br><br>This really introduces use to arrays and classes. and how to have arrays of classes<br>in this case solarsytems and planets. a solar system can have 2 to 12 planets. we are using the solarsytems position to create a unique seed, which we will use heavily to create planets in the next step <br><br></td></tr></table><br>
<a name="1339108"></a>

<a name="1339168"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#59">[#59]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok lets have a picture<br><img src="https://vjointeractive.files.wordpress.com/2017/04/screen-shot-2017-04-21-at-08-48-15.png"><br><br>and now the code:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Namespace myMojoApp

#Import "&lt;std&gt;"
#Import "&lt;mojo&gt;"

Using std..
Using mojo..

Const Size := New Vec2i( 950,720 )

Function Main()
	New AppInstance
	
	New MyWindow
	
	App.Run()
End



'Assumptions:
'planets revolve around a center point,  so planet[0] is the center
'Using this we could deem that moons revolve around planets,  and if a planet exists,  then it has a number,
'so evey planet revolves around a planet
'E.G.
'planet 0,  revolves around nothing - it is special
'planet 1,  revolves around planet 0 at a certain distance
'planet 2,  revolves around planet 0 (but further away)
'planet 3,  revolves around planet 2,  so it is a moon of planet 2
' - I was up a few hours last night coming up with that simplification
'ok lets build the class (I was up a few hours last night coming up with that)
class Planet
	method New( parent:int, size:float, distance:float, name:string )
		_parent = parent
		_size = size
		_distance = distance
		_name = name
	End method

	Property Name:string()
		Return _name
	End

	Property Parent:string()
		Return _parent
	End

	Property Size:float()
		Return _size
	End

	Property Distance:float()
		Return _distance
	End

private
	field _name:string
	
	'how big is the planet
	field _size:float
	
	'how far is it from the center
	field _distance:float
	
	'revolves around...
	field _parent:int
End Class



'lets assume that x, z cordinates are a flat plane and go from 0 to 512. with 256 being the center
'And lets assume that y goes from 0 to 128 with 64 being the center
'we now have a box 512x512x128 with 256, 64, 256 as the center point
'lets also assume that is difficult to remember and have 0, 0, 0 as the center and correct the offsets in the class itself
class SolarSystem
	method New( x:float, y:float, z:float, name:string )
		'first we must to our internal correction
		_xPos = x + 256
		_zPos = z + 256
		
		_yPos = y + 64
		
		_name = name
		
		CreatePlanets()
	End method
	
	
	Property Name:string()
		Return _name
	Setter( name:string )
		_name = name
	End

	'note the additon of data processing in the property.
	' to us (outside the class), positons are centered around 0, 0, 0,  inside they are really centered at 256, 64, 256
	' so we will need to alter the internals when being inspected from outside the class
	Property XPos:float()
		Return _xPos - 256
	End

	Property ZPos:float()
		Return _zPos - 256
	End

	Property YPos:float()
		Return _yPos - 64
	End

	'note the different variables names and also we dont need a setter
	Property Planets:int()
		Return _planetCount
	End
	
protected

	method CreatePlanets()
		'we are going to do something odd but amazing here
		_seed = _xPos + (_zPos * 512) + (_yPos * 300000)
		'what this has done is created a unique uint (long int) for each solar system
		'we can then pass this to seedrnd and always get the same results for random numbers
		
		SeedRnd( _seed )
		
		_planetCount = Rnd( 2, 12 )
		Local k:int
		Local dist:int = 0
		'ok ,  heres a new command 'until' its just like for from to,  but doesnt reach the last element
		'so 'For k = 0 to 3 would give 0, 1, 2, 3.   for k = 0 until 3 would give 0, 1, 2
		' saves you using for k = 0 to _planetCount-1
		For k = 0 until _planetCount
			'make new planets 	method New( parent:int, size:float, distance:float, name:string )

			Local size:int = Rnd(10, 150)
			_planets[k] = New Planet( 0, size, dist, "Planet "+k )
			
			dist += Rnd(80, 120)
		Next 
	End method
	
private
	field _xPos:float
	field _yPos:float
	field _zPos:float
	
	field _name:string
	
	field _seed:uint
	
	'a solar system has planets
	field _planetCount:int = 0
	field _planets:Planet[] = New Planet[13]
End Class




Class MyWindow Extends Window

	method New()
		Super.New( "My Window", Size.X, Size.Y, WindowFlags.Resizable )
		ClearColor = Color.Black

		'Create a solar system.... Magic
		_solarSystem[0] = New SolarSystem( 0, 0, 0, "Galactic Center" )

		'And now 2 more
		'beware of floats. they lie
		_solarSystem[1] = New SolarSystem( 12.4, 15, 6.1, "Ceti" )
		_solarSystem[2] = New SolarSystem( - 5, 8.3, -3, "Zimini" )
	End method

	
	Method OnRender( canvas:Canvas ) Override
		'note how we have changed the display from step 1 to using a loop and an x position
		Local solar:int
		Local xpos:int = 0
		For solar = 0 To 2
			canvas.DrawText( _solarSystem[solar].Name, xpos + 10, 10 )
			canvas.DrawText( " x:"+_solarSystem[solar].XPos, xpos +20, 30 ) 
			canvas.DrawText( " z:"+_solarSystem[solar].ZPos, xpos +20, 50 )
			canvas.DrawText( " y:"+_solarSystem[solar].YPos, xpos +20, 70 )
			canvas.DrawText( _solarSystem[solar].Planets+" planets", xpos +10, 90 )
			
			xpos += 200
		Next

		'now draw the planets
		Local ypos:int = 200
		Local planet:int
		Local size:float
		For solar = 0 To 2
			xpos = 100
			canvas.Color = Color.DarkGrey
			canvas.DrawLine( 200, ypos, Width, ypos )
			
			For planet = 0 until _solarSystem[solar].Planets
				size = _solarSystem[solar]._planets[planet].Size / 2
				canvas.Color = Color.White
				canvas.DrawCircle( xpos,  ypos, size )
				canvas.Color = Color.DarkGrey
				canvas.DrawCircle( xpos,  ypos, size-2 )
				xpos = 200 + _solarSystem[solar]._planets[planet]._distance
			Next
			ypos += 200
		Next
	End
	
private
	'set up an array of SolorSystems. This is just setting then up. we will need to new each one into existance as well
	'but note how the array works. if the variables are ints or ools and not classes. using this will create them
	' but classes need to be New() into existance as well
	field _solarSystem:SolarSystem[] = New SolarSystem[10]
	
	'here is how we do a multiple array. it's not quite like Basic,  and is a bit fiddly. but heres the code for you
'	field _map:int[, ] = New int[10, 10]
End


</textarea><br><br>Now.... If all my calculations and saying do this works correct. When you run the code you should see the above pic? <br><br></td></tr></table><br>
<a name="1339125"></a>

<a name="1339127"></a>

<a name="1339128"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >skidracer</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#60">[#60]</a></td></tr></table></td></tr><tr ><td class="posttext"> Loving this thread. <br><br>Here is a picture of Earth and Moon taken from Saturn by <a href="https://saturn.jpl.nasa.gov/news/2499/nasa-releases-images-of-earth-taken-by-distant-spacecraft/" target="_blank">Cassini</a> yesterday, not sure if it is relevant :)<br><br><img src="https://saturn.jpl.nasa.gov/system/resources/detail_files/5869_PIA17170.jpg"> <br><br></td></tr></table><br>
<a name="1339129"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#61">[#61]</a></td></tr></table></td></tr><tr ><td class="posttext"> the blue planet with the grey moon - loving it... <br><br></td></tr></table><br>
<a name="1339132"></a>

<a name="1339133"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#62">[#62]</a></td></tr></table></td></tr><tr ><td class="posttext"> @ codes<br>Please consider using "codebox" instead of "code" so they become scrollable and limited in their initial size/dimension.<br><br><br>@ skid<br>A pity you did not add a jscript-syntax-highlighter yet bigger sources are harder to read with "comments" being in the same color than "code".<br><br><br>@ case sensitive variables<br>Oh... did not know that. For me that is nearly to a "no go" as it relies on "superstrict" to catch mistakes (multiple variables because of UC/LC-errors) - and on an IDE which does autocomplete so you do not misspell things each time.<br>I know it is just a matter of "getting used to" but somehow I think this is nearly as "arghhh" as python's tab-intend with a meaning.<br><br><br>@ underscore<br>This is common for languages with no "private" statement - just to say to 3rd party developers: hands off! this is something you should not access directly.<br>EG. BlitzMax does not have "private" for non-module-code so "_" helps in that regards.<br><br>So if you want to read more about Adam's coding style: Wikipedia "lowerCamelCase" might be of interest.<br>So you will see most likely this:<br>Const UPPER_CASE_WITH_UNDERSCORES:int = 1<br>Local myVariable:int = 1<br>Method GetMyVariable:int()<br><br>For Classes and Types you often prepend them with "C" or "T" so you distinguish them from variables (eg. a global instance "Game" of type "TGame").<br>As you see monkey2 uses classes like "window" and not "TWindow" while BlitzMax has all these "TGraphics", "TImage" ... so maybe Mark already moved away from that "agreement".<br><br><br><br>@ Adam<br>Is there a reason to use "arrays" for the solar systems and not "lists" or similar things (with added "convenience")? Step-by-step learning?<br><br><br>Some things I saw by having a quick glance:<br><br>_planets is of fixed size (13) but you fill it with a random amount <br>-&gt; replace _planetCount = Rnd( 2, 12 ) with "12" being equal to _planets.length (or how the property for the array-length is called in monkey2)<br>-&gt; alternatively create a _planets-array corresponding to the random _planetCount<br><br><br>field _parent:int<br>versus<br>Property Parent:string()<br>int -&gt; string ? <br><br><br>Property Planets:int()<br>-&gt; you should really call it "PlanetCount" as "Planets" implies (for me) that it returns a list, stack, array or something "iterateable". I understand that you want to teach him that you can name it differently, but you should not forget to change that back later on.<br><br><br><br>Back to talking about "dynamically filled solar systems" - do not forget to replace your "for 0 to 2"-loops with a simple "eachin" iterating over all available systems (or loop over all indices of the solarsystem-array and "continue" if there is no valid system stored there).<br><br><br><br>Sorry if that interrupts your "tutorial flow" :-)<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1339134"></a>

<a name="1339167"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#63">[#63]</a></td></tr></table></td></tr><tr ><td class="posttext"> universe step 3 - kinds of planets<br><br>lets have a picture<br><img src="https://vjointeractive.files.wordpress.com/2017/04/screen-shot-2017-04-21-at-10-39-05.png"><br><br>and some code:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Namespace myMojoApp

#Import "&lt;std&gt;"
#Import "&lt;mojo&gt;"

Using std..
Using mojo..

Const Size := New Vec2i( 950,720 )

Function Main()
	New AppInstance
	
	New MyWindow
	
	App.Run()
End


const PLANETKIND_BLACKHOLE:int = 0
const PLANETKIND_STAR:int = 1
const PLANETKIND_GASGIANT:int = 2
const PLANETKIND_PLANET:int = 3
const PLANETKIND_MOON:int = 4
const PLANETKIND_ASTEROID:int = 5
const PLANETKIND_ASTEROIDBELT:int = 6
const PLANETKIND_DUSTBELT:int = 7
const PLANETKIND_NEBULAE:int = 8
const PLANETKIND_RADIATIONBELT:int = 9
'if we use the last one as a max variable we can use it in our program for counting purposes
const PLANETKIND_MAX:int = 10

'Assumptions:
'planets revolve around a center point,  so planet[0] is the center
'Using this we could deem that moons revolve around planets,  and if a planet exists,  then it has a number,
'so evey planet revolves around a planet
'E.G.
'planet 0,  revolves around nothing - it is special
'planet 1,  revolves around planet 0 at a certain distance
'planet 2,  revolves around planet 0 (but further away)
'planet 3,  revolves around planet 2,  so it is a moon of planet 2
' - I was up a few hours last night coming up with that simplification
'ok lets build the class (I was up a few hours last night coming up with that)
class Planet
	method New( parent:int, kind:int, size:float, distance:float, name:string )
		_parent = parent
		_kind = kind
		_size = size
		_distance = distance
		_name = name
	End method

	Property Name:string()
		Return _name
	End

	Property NameKind:string()
		Select _kind
			Case PLANETKIND_STAR Return "Star"
			Case PLANETKIND_BLACKHOLE Return "BlackHole"
			Case PLANETKIND_GASGIANT Return "GasGiant"
			Case PLANETKIND_PLANET Return "Planet"
			Case PLANETKIND_MOON Return "Moon"
			Case PLANETKIND_ASTEROID Return "Asteroid"
			Case PLANETKIND_ASTEROIDBELT Return "AsteroidBelt"
			Case PLANETKIND_DUSTBELT Return "DustBelt"
			Case PLANETKIND_NEBULAE Return "Nebulae"
			Case PLANETKIND_RADIATIONBELT Return "RadiationBelt"
		End Select
		
		Return ""
	End

	Property Kind:string()
		Return _kind
	End

	Property Parent:string()
		Return _parent
	End

	Property Size:float()
		Return _size
	End

	Property Distance:float()
		Return _distance
	End

private
	field _name:string

	'what sort of planet or solar object is the planet
	field _kind:int
	
	'how big is the planet
	field _size:float
	
	'how far is it from the center
	field _distance:float
	
	'revolves around...
	field _parent:int
End Class



'lets assume that x, z cordinates are a flat plane and go from 0 to 512. with 256 being the center
'And lets assume that y goes from 0 to 128 with 64 being the center
'we now have a box 512x512x128 with 256, 64, 256 as the center point
'lets also assume that is difficult to remember and have 0, 0, 0 as the center and correct the offsets in the class itself
class SolarSystem
	method New( x:float, y:float, z:float, name:string )
		'first we must to our internal correction
		_xPos = x + 256
		_zPos = z + 256
		
		_yPos = y + 64
		
		_name = name
		
		CreatePlanets()
	End method
	
	
	Property Name:string()
		Return _name
	Setter( name:string )
		_name = name
	End

	'note the additon of data processing in the property.
	' to us (outside the class), positons are centered around 0, 0, 0,  inside they are really centered at 256, 64, 256
	' so we will need to alter the internals when being inspected from outside the class
	Property XPos:float()
		Return _xPos - 256
	End

	Property ZPos:float()
		Return _zPos - 256
	End

	Property YPos:float()
		Return _yPos - 64
	End

	'note the different variables names and also we dont need a setter
	Property Planets:int()
		Return _planetCount
	End
	
protected

	method CreatePlanets()
		'we are going to do something odd but amazing here
		_seed = _xPos + (_zPos * 512) + (_yPos * 300000)
		'what this has done is created a unique uint (long int) for each solar system
		'we can then pass this to seedrnd and always get the same results for random numbers
		
		SeedRnd( _seed )
		
		_planetCount = Rnd( 2, 12 )
		Local k:int
		Local dist:int = 0
		'ok ,  heres a new command 'until' its just like for from to,  but doesnt reach the last element
		'so 'For k = 0 to 3 would give 0, 1, 2, 3.   for k = 0 until 3 would give 0, 1, 2
		' saves you using for k = 0 to _planetCount-1
		For k = 0 until _planetCount
			'make new planets 	method New( parent:int, size:float, distance:float, name:string )

			Local size:int = Rnd(5, 150)
			local kind:int = Rnd( 1, PLANETKIND_MAX )
			Local parent:int = 0
			
			'ok the first 'planet will always be a sun, blackhole, gasgiant or planet
			If k = 0 Then
				'note Rnd will never reach the max number,  so always give it one extra!
				kind = Rnd( 0, 4 )
			Else
				'make sure their aren't too many gasgiants
				If kind = PLANETKIND_GASGIANT And Rnd( 100 ) &lt; 50 Then
					kind = PLANETKIND_PLANET
				End If
				
				'check if the new planet is a moon
				If _planets[k-1].Kind &lt; PLANETKIND_MOON Then
					'and make sure it's not too big
					If size &lt; _planets[k-1].Size / 1.5 Then
						If size &gt; _planets[k-1].Size / 3 Then
							'ok this is a new command as such /=. it is the same as saying x = x / num
							'there are a number so += -= /= *= are all valid. but it's best to keep things simple for reading ;)
							size /= 3
						End if
						
						kind = PLANETKIND_MOON
						
						'lastly we want the new moon to revolve around the previous planet,  so we set its parent
						parent = k-1
					End If
				End If
			End If
			
			'ok,  now we have a planet kind,  and a correct parent
			_planets[k] = New Planet( parent, kind, size, dist, "Planet "+k )
			
			dist += Rnd(80, 120)
		Next 
	End method
	
private
	field _xPos:float
	field _yPos:float
	field _zPos:float
	
	field _name:string
	
	field _seed:uint
	
	'a solar system has planets
	field _planetCount:int = 0
	field _planets:Planet[] = New Planet[13]
End Class




Class MyWindow Extends Window

	method New()
		Super.New( "My Window", Size.X, Size.Y, WindowFlags.Resizable )
		ClearColor = Color.Black

		'Create a solar system.... Magic
		_solarSystem[0] = New SolarSystem( 0, 0, 0, "Galactic Center" )

		'And now 2 more
		'beware of floats. they lie
		_solarSystem[1] = New SolarSystem( 12.4, 15, 6.1, "Ceti" )
		_solarSystem[2] = New SolarSystem( - 5, 8.3, -3, "Zimini" )
	End method

	
	Method OnRender( canvas:Canvas ) Override
		'note how we have changed the display from step 1 to using a loop and an x position
		Local solar:int
		Local xpos:int = 0
		For solar = 0 To 2
			canvas.DrawText( _solarSystem[solar].Name, xpos + 10, 10 )
			canvas.DrawText( " x:"+_solarSystem[solar].XPos, xpos +20, 30 ) 
			canvas.DrawText( " z:"+_solarSystem[solar].ZPos, xpos +20, 50 )
			canvas.DrawText( " y:"+_solarSystem[solar].YPos, xpos +20, 70 )
			canvas.DrawText( _solarSystem[solar].Planets+" planets", xpos +10, 90 )
			
			xpos += 200
		Next

		'now draw the planets
		Local ypos:int = 200
		Local planet:int
		Local size:float
		Local prevXPos:float
		For solar = 0 To 2
			xpos = 100
			canvas.Color = Color.DarkGrey
			canvas.DrawLine( 100, ypos, Width, ypos )
			
			For planet = 0 until _solarSystem[solar].Planets
				size = _solarSystem[solar]._planets[planet].Size / 2
				
				If _solarSystem[solar]._planets[planet].Kind = PLANETKIND_MOON Then
					canvas.Color = Color.White
					canvas.DrawCircle( xpos,  ypos+20, size )
					canvas.Color = Color.DarkGrey
					canvas.DrawCircle( xpos,  ypos+20, size-2 )
					
					canvas.Color = Color.Red
					canvas.DrawLine( prevXPos,  ypos, xpos,  ypos+20 )
				Else
					canvas.Color = Color.White
					canvas.DrawCircle( xpos,  ypos, size )
					canvas.Color = Color.DarkGrey
					canvas.DrawCircle( xpos,  ypos, size-2 )
				End If

				canvas.Color = Color.White
				canvas.DrawText( _solarSystem[solar]._planets[planet].NameKind,  xpos, ypos+80+(20 * (planet Mod 2) ) )

				prevXPos = xpos
				xpos = 200 + _solarSystem[solar]._planets[planet]._distance
			Next
			ypos += 200
		Next
	End
	
private
	'set up an array of SolorSystems. This is just setting then up. we will need to new each one into existance as well
	'but note how the array works. if the variables are ints or ools and not classes. using this will create them
	' but classes need to be New() into existance as well
	field _solarSystem:SolarSystem[] = New SolarSystem[10]
	
	'here is how we do a multiple array. it's not quite like Basic,  and is a bit fiddly. but heres the code for you
'	field _map:int[, ] = New int[10, 10]
End

</textarea><br><br>ok so what had happened here then?<br>Basically some planet kinds have been defined as consts<br>as planets don't know anything about other planets, we reference them in the solar system when they are created. and here we do some simple checks just to give us something nice to play with (there is no magic, I'm not using NASA data or anything)<br>We also track the size and decide if it is small then possible make it a moon. and lastly we make sure that there aren't too many gasgiants<br><br>moons are denoted as moons and given a red link to show the orbit around a planet<br><br>Finally we draw the new data so it can be simply visualized. NOTE belts and nebulae are currently being drawn as planets. we can change this next time around... <br><br></td></tr></table><br>
<a name="1339135"></a>

<a name="1339136"></a>

<a name="1339137"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >skidracer</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#64">[#64]</a></td></tr></table></td></tr><tr ><td class="posttext"> Woot, frontpage news! <br><br></td></tr></table><br>
<a name="1339144"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#65">[#65]</a></td></tr></table></td></tr><tr ><td class="posttext"> i'de wait for the next one first... Adding some graphics. just finishing it <br><br></td></tr></table><br>
<a name="1339145"></a>

<a name="1339147"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#66">[#66]</a></td></tr></table></td></tr><tr ><td class="posttext"> just about followed ok, it worked fine, diff pic slightly because my rand would be diff, <br><br>there is a lot of looping code in classes, one references another that references another, but it does make sence if built bit by bit.<br><br>whats the importance of protected vs private?<br><br>just seen more code added looking at it now. <br><br></td></tr></table><br>
<a name="1339149"></a>

<a name="1339166"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#67">[#67]</a></td></tr></table></td></tr><tr ><td class="posttext"> last post for the day<br>Universe Step 4 - pretty pictures<br><img src="https://vjointeractive.files.wordpress.com/2017/04/screen-shot-2017-04-21-at-11-42-43.png"><br><br>and the code.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Namespace myMojoApp

#Import "&lt;std&gt;"
#Import "&lt;mojo&gt;"

Using std..
Using mojo..

Const Size := New Vec2i( 950,720 )

Function Main()
	New AppInstance
	
	New MyWindow
	
	App.Run()
End


const PLANETKIND_BLACKHOLE:int = 0
const PLANETKIND_STAR:int = 1
const PLANETKIND_GASGIANT:int = 2
const PLANETKIND_PLANET:int = 3
const PLANETKIND_MOON:int = 4
const PLANETKIND_ASTEROID:int = 5
const PLANETKIND_ASTEROIDBELT:int = 6
const PLANETKIND_DUSTBELT:int = 7
const PLANETKIND_NEBULAE:int = 8
const PLANETKIND_RADIATIONBELT:int = 9
'if we use the last one as a max variable we can use it in our program for counting purposes
const PLANETKIND_MAX:int = 10

'Assumptions:
'planets revolve around a center point,  so planet[0] is the center
'Using this we could deem that moons revolve around planets,  and if a planet exists,  then it has a number,
'so evey planet revolves around a planet
'E.G.
'planet 0,  revolves around nothing - it is special
'planet 1,  revolves around planet 0 at a certain distance
'planet 2,  revolves around planet 0 (but further away)
'planet 3,  revolves around planet 2,  so it is a moon of planet 2
' - I was up a few hours last night coming up with that simplification
'ok lets build the class (I was up a few hours last night coming up with that)
class Planet
	method New( parent:int, kind:int, size:float, distance:float, name:string )
		_parent = parent
		_kind = kind
		_size = size
		_distance = distance
		_name = name
		
		_planetColor = New Color( Rnd(0.5, 1), Rnd(0.5, 1), Rnd(0.5, 1) )
	End method

	Property Name:string()
		Return _name
	End

	Property NameKind:string()
		Select _kind
			Case PLANETKIND_STAR Return "Star"
			Case PLANETKIND_BLACKHOLE Return "BlackHole"
			Case PLANETKIND_GASGIANT Return "GasGiant"
			Case PLANETKIND_PLANET Return "Planet"
			Case PLANETKIND_MOON Return "Moon"
			Case PLANETKIND_ASTEROID Return "Asteroid"
			Case PLANETKIND_ASTEROIDBELT Return "AsteroidBelt"
			Case PLANETKIND_DUSTBELT Return "DustBelt"
			Case PLANETKIND_NEBULAE Return "Nebulae"
			Case PLANETKIND_RADIATIONBELT Return "RadiationBelt"
		End Select
		
		Return ""
	End

	Property Kind:string()
		Return _kind
	End

	Property Parent:string()
		Return _parent
	End

	Property Size:float()
		Return _size
	End

	Property Distance:float()
		Return _distance
	End

	Property PlanetColor:Color()
		Return _planetColor
	End

private
	field _name:string

	'what sort of planet or solar object is the planet
	field _kind:int
	
	'how big is the planet
	field _size:float
	
	'how far is it from the center
	field _distance:float
	
	'revolves around...
	field _parent:int
	
	'what color is it?
	field _planetColor:Color
End Class



'lets assume that x, z cordinates are a flat plane and go from 0 to 512. with 256 being the center
'And lets assume that y goes from 0 to 128 with 64 being the center
'we now have a box 512x512x128 with 256, 64, 256 as the center point
'lets also assume that is difficult to remember and have 0, 0, 0 as the center and correct the offsets in the class itself
class SolarSystem
	method New( x:float, y:float, z:float, name:string )
		'first we must to our internal correction
		_xPos = x + 256
		_zPos = z + 256
		
		_yPos = y + 64
		
		_name = name
		
		CreatePlanets()
	End method
	
	
	Property Name:string()
		Return _name
	Setter( name:string )
		_name = name
	End

	'note the additon of data processing in the property.
	' to us (outside the class), positons are centered around 0, 0, 0,  inside they are really centered at 256, 64, 256
	' so we will need to alter the internals when being inspected from outside the class
	Property XPos:float()
		Return _xPos - 256
	End

	Property ZPos:float()
		Return _zPos - 256
	End

	Property YPos:float()
		Return _yPos - 64
	End

	'note the different variables names and also we dont need a setter
	Property Planets:int()
		Return _planetCount
	End
	
protected

	method CreatePlanets()
		'we are going to do something odd but amazing here
		_seed = _xPos + (_zPos * 512) + (_yPos * 300000)
		'what this has done is created a unique uint (long int) for each solar system
		'we can then pass this to seedrnd and always get the same results for random numbers
		
		SeedRnd( _seed )
		
		_planetCount = Rnd( 2, 12 )
		Local k:int
		Local dist:int = 0
		'ok ,  heres a new command 'until' its just like for from to,  but doesnt reach the last element
		'so 'For k = 0 to 3 would give 0, 1, 2, 3.   for k = 0 until 3 would give 0, 1, 2
		' saves you using for k = 0 to _planetCount-1
		For k = 0 until _planetCount
			'make new planets 	method New( parent:int, size:float, distance:float, name:string )

			Local size:int = Rnd(5, 150)
			local kind:int = Rnd( 1, PLANETKIND_MAX )
			Local parent:int = 0
			
			'ok the first 'planet will always be a sun, blackhole, gasgiant or planet
			If k = 0 Then
				'note Rnd will never reach the max number,  so always give it one extra!
				kind = Rnd( 0, 4 )
			Else
				'make sure their aren't too many gasgiants
				If kind = PLANETKIND_GASGIANT And Rnd( 100 ) &lt; 50 Then
					kind = PLANETKIND_PLANET
				End If
				
				'check if the new planet is a moon
				If _planets[k-1].Kind &lt; PLANETKIND_MOON Then
					'and make sure it's not too big
					If size &lt; _planets[k-1].Size / 1.5 Then
						If size &gt; _planets[k-1].Size / 3 Then
							'ok this is a new command as such /=. it is the same as saying x = x / num
							'there are a number so += -= /= *= are all valid. but it's best to keep things simple for reading ;)
							size /= 3
						End if
						
						kind = PLANETKIND_MOON
						
						'lastly we want the new moon to revolve around the previous planet,  so we set its parent
						parent = k-1
					End If
				End If
				
				'make sure that asteroids arent big things
				If kind = PLANETKIND_ASTEROID Then
					size = Clamp( size, 2, 10 )
				End if
			End If
			
			'ok,  now we have a planet kind,  and a correct parent
			_planets[k] = New Planet( parent, kind, size, dist, "Planet "+k )
			
			dist += Rnd(80, 120)
		Next 
	End method
	
private
	field _xPos:float
	field _yPos:float
	field _zPos:float
	
	field _name:string
	
	field _seed:uint
	
	'a solar system has planets
	field _planetCount:int = 0
	field _planets:Planet[] = New Planet[13]
End Class




Class MyWindow Extends Window

	method New()
		Super.New( "My Window", Size.X, Size.Y, WindowFlags.Resizable )
		ClearColor = Color.Black

		'Create a solar system.... Magic
		_solarSystem[0] = New SolarSystem( 0, 0, 0, "Galactic Center" )

		'And now 2 more
		'beware of floats. they lie
		_solarSystem[1] = New SolarSystem( 12.4, 15, 6.1, "Ceti" )
		_solarSystem[2] = New SolarSystem( - 5, 8.3, -3, "Zimini" )
	End method

	
	Method OnRender( canvas:Canvas ) Override
		'note how we have changed the display from step 1 to using a loop and an x position
		Local solar:int
		Local xpos:int = 0
		For solar = 0 To 2
			canvas.DrawText( _solarSystem[solar].Name, xpos + 10, 10 )
			canvas.DrawText( " x:"+_solarSystem[solar].XPos, xpos +20, 30 ) 
			canvas.DrawText( " z:"+_solarSystem[solar].ZPos, xpos +20, 50 )
			canvas.DrawText( " y:"+_solarSystem[solar].YPos, xpos +20, 70 )
			canvas.DrawText( _solarSystem[solar].Planets+" planets", xpos +10, 90 )
			
			xpos += 200
		Next

		'now draw the planets
		Local ypos:int = 200
		Local planet:int
		Local size:float
		Local prevXPos:float
		For solar = 0 To 2
			xpos = 100
			canvas.Color = Color.DarkGrey
			canvas.DrawLine( 100, ypos, Width, ypos )
			
			For planet = 0 until _solarSystem[solar].Planets
'				size = _solarSystem[solar]._planets[planet].Size / 2
				
				If _solarSystem[solar]._planets[planet].Kind = PLANETKIND_MOON Then
					DrawPlanet( canvas, solar, planet, xpos,  ypos+40 )
					
					canvas.Color = Color.Red
					canvas.DrawLine( prevXPos,  ypos, xpos,  ypos+40 )
				Else
					DrawPlanet( canvas, solar, planet, xpos,  ypos )
				End If

				canvas.Color = Color.White
				canvas.DrawText( _solarSystem[solar]._planets[planet].NameKind,  xpos, ypos+80+(20 * (planet Mod 2) ) )

				prevXPos = xpos
				xpos = 200 + _solarSystem[solar]._planets[planet]._distance
			Next
			ypos += 200
		Next
	End
	
	method DrawPlanet( canvas:Canvas, solar:int, planet:int, xpos:int,  ypos:int )
		local size:int = _solarSystem[solar]._planets[planet].Size / 2
		
		canvas.Color = Color.White

		Select _solarSystem[solar]._planets[planet].Kind
			Case PLANETKIND_STAR
				canvas.Color = Color.White
				canvas.Alpha = 0.1
				canvas.DrawEllipse( xpos,  ypos, size*2, 3 )
				canvas.DrawEllipse( xpos,  ypos, 3, size* 2 )

				Local k:int
				'this is the frist time we have encountered Alpha. and guess what it does???
				canvas.Alpha = 0.075
				canvas.Color = _solarSystem[solar]._planets[planet].PlanetColor
				For k = size To 5 Step -4
					canvas.DrawCircle( xpos,  ypos, k )
				Next

			Case PLANETKIND_BLACKHOLE
				canvas.Color = Color.DarkGrey
				canvas.DrawCircle( xpos,  ypos, size )
				canvas.Color = Color.Black
				canvas.DrawCircle( xpos,  ypos, size-1 )

			Case PLANETKIND_GASGIANT
				canvas.Color = Color.Black
				canvas.DrawCircle( xpos,  ypos, size-2 )
				canvas.Alpha = 0.1
				canvas.Color = _solarSystem[solar]._planets[planet].PlanetColor
				canvas.DrawCircle( xpos,  ypos, size-2 )
				
				canvas.DrawEllipse( xpos,  ypos, size-2, 5 )
				canvas.DrawEllipse( xpos,  ypos-size/2, size/1.5, 5 )
				canvas.DrawEllipse( xpos,  ypos+size/2, size/1.5, 5 )

				canvas.Alpha = 0.05
				Local k:int
				Local offset:int = 0
				For k = size To 5 Step -3
					canvas.DrawCircle( xpos-offset,  ypos-offset, k )
					offset += 1
				Next

			Case PLANETKIND_PLANET
				canvas.Color = _solarSystem[solar]._planets[planet].PlanetColor
				canvas.DrawCircle( xpos,  ypos, size-2 )

				canvas.Alpha = 0.05
				canvas.Color = Color.White
				Local k:int
				Local offset:int = 0
				For k = size To 5 Step -3
					canvas.DrawCircle( xpos-offset,  ypos-offset, k )
					offset += 1
				Next
			Case PLANETKIND_MOON
				canvas.Color = Color.DarkGrey
				canvas.Alpha = 0.15
				canvas.Color = _solarSystem[solar]._planets[planet].PlanetColor
				canvas.DrawCircle( xpos,  ypos, size )
				canvas.DrawEllipse( xpos-5,  ypos, size-5, size )
				canvas.DrawEllipse( xpos+5,  ypos, size-5, size )
				
			Case PLANETKIND_ASTEROID
				canvas.Color = _solarSystem[solar]._planets[planet].PlanetColor
				canvas.DrawCircle( xpos,  ypos, size )

			Case PLANETKIND_ASTEROIDBELT
				Local k:int
				Local pos:int = 0
				For k = 0 To 100 Step (size*5)
					canvas.DrawCircle( xpos + (pos Mod 2) * size,  (ypos-50) + k, size )
					
					pos += 1
				next
				
			Case PLANETKIND_DUSTBELT
				Local k:int
				Local pos:int = 0
				For k = 0 To 100 Step 4
					canvas.DrawPoint( xpos + (k*11) Mod size,  (ypos-50) + k )
					
					pos += size
				next

			Case PLANETKIND_NEBULAE
			Case PLANETKIND_RADIATIONBELT
				canvas.Alpha = 0.05
				canvas.Color = Color.Red
				Local k:int
				Local offset:int = 0
				For k = size To 5 Step -3
					canvas.DrawRect( xpos+offset,  ypos+offset-50, size, 100-offset-offset )
					offset += 1
				Next
		End Select

		'make sure the Alpha is set back to 1
		canvas.Alpha = 1

	End method

private
	'set up an array of SolorSystems. This is just setting then up. we will need to new each one into existance as well
	'but note how the array works. if the variables are ints or ools and not classes. using this will create them
	' but classes need to be New() into existance as well
	field _solarSystem:SolarSystem[] = New SolarSystem[10]
	
	'here is how we do a multiple array. it's not quite like Basic,  and is a bit fiddly. but heres the code for you
'	field _map:int[, ] = New int[10, 10]
End


</textarea><br><br>couple of changes to make asteroids always small<br>and the Planet Class has now got a color<br><br>big change in the OnRender where we draw the planets. this has a new method to draw pretty things.<br><br>But note that this has nothing to do with the actual planet class. it is just holding the data. <br><br></td></tr></table><br>
<a name="1339150"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#68">[#68]</a></td></tr></table></td></tr><tr ><td class="posttext"> @ Mainsworthy<br><br>anything in the private section can ONLY be accessed from the class itself<br>So... in the main program<br>You can't use planet[ref]._kind<br>try it and see what happens<br><br>That is why we have setters and getters.<br><br>Now we could make another class that is derived from Planets - just accept that you can - wav are not doing this<br>anything in protected and private wouldn't be available to a deprived class<br><br>the top level, is usually called 'public', but we don't need to specify it directly<br>anything that is in public can be accessed from anything else<br><br>It's all a bit odd and strange to get your head around<br>Think of a class as your trousers (pants for the us)<br>anyone can touch them - the public part<br>Your mom can put her hands in your pocket, cause she's protected, but the public cant<br>Your other half can put their hands down the front - it's private. but your mom and the public can't...<br><br>Stop laughing right now! <br><br></td></tr></table><br>
<a name="1339151"></a>

<a name="1339153"></a>

<a name="1339156"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#69">[#69]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think I just saw a moon orbiting a moon. looked through code dosnt seem this is possible<br><br>going to look through next code now.<br><br>thanks for the class descriptive<br><br>thx Derron too <br><br></td></tr></table><br>
<a name="1339158"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#70">[#70]</a></td></tr></table></td></tr><tr ><td class="posttext"> clamp( Ive never even heard of , if you go over does it shrink it back to max? and if you go under increases it to min, I will look it up. <br><br></td></tr></table><br>
<a name="1339159"></a>

<a name="1339160"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#71">[#71]</a></td></tr></table></td></tr><tr ><td class="posttext"> properties, fields and methods are now very clear<br><br>curious how to go full screen &amp; what the command is to rotate riound midpoints, but I will look out for these.<br><br>a gamesave would be tricky looking, loading private arrays to different classes, I suppose it would be a setter code. <br><br></td></tr></table><br>
<a name="1339162"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#72">[#72]</a></td></tr></table></td></tr><tr ><td class="posttext"> can I just say Adam, this code your doing is realy good, thx so much for this. I know your doing a lot of design here aswell . <br><br></td></tr></table><br>
<a name="1339163"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#73">[#73]</a></td></tr></table></td></tr><tr ><td class="posttext"> Think my post above got lost in the shuffle:<br><br>please use {codebox} rather than {code} to store your sources here... as it leads to easier scrollable threads (textarea with size constraints rather than a "show all"-code-area).<br><br><br>@ clamp<br>Yes, it limits values to be between min and max.<br>It is similar to writing (in BlitzMax):<br>myVar = Max(minValue, Min(maxValue, myVar))<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1339172"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#74">[#74]</a></td></tr></table></td></tr><tr ><td class="posttext"> thx Derron.<br><br>I can see the magic of classes New MyGameLvl1() New MyGameLvl2() very easy to setup a whole structure. organised is the word I would use for class extending a class sounds fun. <br><br></td></tr></table><br>
<a name="1339177"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#75">[#75]</a></td></tr></table></td></tr><tr ><td class="posttext"> Adam we need a RingPlanet Property, not to important , just an observation :) <br><br></td></tr></table><br>
<a name="1339178"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#76">[#76]</a></td></tr></table></td></tr><tr ><td class="posttext"> The 1Bit clicker result is in about 9 hrs, hope you do well :) <br><br></td></tr></table><br>
<a name="1339179"></a>

<a name="1339180"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#77">[#77]</a></td></tr></table></td></tr><tr ><td class="posttext"> just found Fullscreen :) , and a lovly little help feature F1 displays a line at the bottom of the editor telling you where in the help files the info is, its easily missed, but once spotted :) <br><br></td></tr></table><br>
<a name="1339181"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#78">[#78]</a></td></tr></table></td></tr><tr ><td class="posttext"> step 5 bug hunting<br><br>first a pic<br><img src="https://vjointeractive.files.wordpress.com/2017/04/screen-shot-2017-04-21-at-14-53-38.png"><br><br>now the code (in a box)<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Namespace myMojoApp

#Import "&lt;std&gt;"
#Import "&lt;mojo&gt;"

Using std..
Using mojo..

Const Size := New Vec2i( 950,720 )

Function Main()
	New AppInstance
	
	New MyWindow
	
	App.Run()
End


const PLANETKIND_BLACKHOLE:int = 0
const PLANETKIND_STAR:int = 1
const PLANETKIND_GASGIANT:int = 2
const PLANETKIND_PLANET:int = 3
const PLANETKIND_MOON:int = 4
const PLANETKIND_ASTEROIDMOON:int = 5
const PLANETKIND_ASTEROID:int = 6
const PLANETKIND_ASTEROIDBELT:int = 7
const PLANETKIND_DUSTBELT:int = 8
const PLANETKIND_NEBULAE:int = 9
const PLANETKIND_RADIATIONBELT:int = 10
'if we use the last one as a max variable we can use it in our program for counting purposes
const PLANETKIND_MAX:int = 11

'Assumptions:
'planets revolve around a center point,  so planet[0] is the center
'Using this we could deem that moons revolve around planets,  and if a planet exists,  then it has a number,
'so evey planet revolves around a planet
'E.G.
'planet 0,  revolves around nothing - it is special
'planet 1,  revolves around planet 0 at a certain distance
'planet 2,  revolves around planet 0 (but further away)
'planet 3,  revolves around planet 2,  so it is a moon of planet 2
' - I was up a few hours last night coming up with that simplification
'ok lets build the class (I was up a few hours last night coming up with that)
class Planet
	method New( parent:int, kind:int, size:float, distance:float, name:string )
		_parent = parent
		_kind = kind
		_size = size
		_distance = distance
		_name = name
		
		Select kind
			Case PLANETKIND_GASGIANT
				_size = Clamp( size, 75.0, 200.0 )
			Case PLANETKIND_STAR
				_size = Clamp( size, 75.0, 200.0 )
		End Select
		
		_planetColor = New Color( Rnd(0.5, 1), Rnd(0.5, 1), Rnd(0.5, 1) )
	End method

	Property Name:string()
		Return _name
	End

	Property NameKind:string()
		Select _kind
			Case PLANETKIND_STAR Return "Star"
			Case PLANETKIND_BLACKHOLE Return "BlackHole"
			Case PLANETKIND_GASGIANT Return "GasGiant"
			Case PLANETKIND_PLANET Return "Planet"
			Case PLANETKIND_MOON Return "Moon"
			Case PLANETKIND_ASTEROIDMOON Return "Asteroidm"
			Case PLANETKIND_ASTEROID Return "Asteroid"
			Case PLANETKIND_ASTEROIDBELT Return "AsteroidBelt"
			Case PLANETKIND_DUSTBELT Return "DustBelt"
			Case PLANETKIND_NEBULAE Return "Nebulae"
			Case PLANETKIND_RADIATIONBELT Return "RadiationBelt"
		End Select
		
		Return ""
	End

	Property Kind:int()
		Return _kind
	End

	Property Parent:string()
		Return _parent
	End

	Property Size:float()
		Return _size
	End

	Property Distance:float()
		Return _distance
	End

	Property PlanetColor:Color()
		Return _planetColor
	End

private
	field _name:string

	'what sort of planet or solar object is the planet
	field _kind:int
	
	'how big is the planet
	field _size:float
	
	'how far is it from the center
	field _distance:float
	
	'revolves around...
	field _parent:int
	
	'what color is it?
	field _planetColor:Color
End Class



'lets assume that x, z cordinates are a flat plane and go from 0 to 512. with 256 being the center
'And lets assume that y goes from 0 to 128 with 64 being the center
'we now have a box 512x512x128 with 256, 64, 256 as the center point
'lets also assume that is difficult to remember and have 0, 0, 0 as the center and correct the offsets in the class itself
class SolarSystem
	method New( x:float, y:float, z:float, name:string )
		'first we must to our internal correction
		_xPos = x + 256
		_zPos = z + 256
		
		_yPos = y + 64
		
		_name = name
		
		CreatePlanets()
	End method
	
	
	Property Name:string()
		Return _name
	Setter( name:string )
		_name = name
	End

	'note the additon of data processing in the property.
	' to us (outside the class), positons are centered around 0, 0, 0,  inside they are really centered at 256, 64, 256
	' so we will need to alter the internals when being inspected from outside the class
	Property XPos:float()
		Return _xPos - 256
	End

	Property ZPos:float()
		Return _zPos - 256
	End

	Property YPos:float()
		Return _yPos - 64
	End

	'note the different variables names and also we dont need a setter
	Property Planets:int()
		Return _planetCount
	End
	
	
	'ok this is a nice addition,  but be carefull. It is called operater overloading
	' We now have 2 CreatePlanets.
	' one with no variables,  and this new one with 3 floats
	'When CreatePlantets() occurs. The compiler will pick the correct one depending on the data you've given it
	' in this new version we are going to set a new position for the solar system
	' this will force the createPlanets to restart with new seeds,  etc
	method CreatePlanets( x:float, y:float, z:float )
		_xPos = x + 256
		_zPos = z + 256
		_yPos = y + 64
		CreatePlanets()
	End method
	
	
	method CreatePlanets()
		'we are going to do something odd but amazing here
		_seed = _xPos + (_zPos * 512) + (_yPos * 300000)
		'what this has done is created a unique uint (long int) for each solar system
		'we can then pass this to seedrnd and always get the same results for random numbers
		
		SeedRnd( _seed )
		
		_planetCount = Rnd( 4, 16 )
		Local k:int
		Local dist:int = 0
		'ok ,  heres a new command 'until' its just like for from to,  but doesnt reach the last element
		'so 'For k = 0 to 3 would give 0, 1, 2, 3.   for k = 0 until 3 would give 0, 1, 2
		' saves you using for k = 0 to _planetCount-1
		For k = 0 until _planetCount
			'make new planets 	method New( parent:int, size:float, distance:float, name:string )

			Local size:int = Rnd(5, 150)
			local kind:int = Rnd( 1, PLANETKIND_MAX )
			Local parent:int = 0
			
			'ok the first 'planet will always be a sun, blackhole, gasgiant or planet
			If k = 0 Then
				'note Rnd will never reach the max number,  so always give it one extra!
				kind = Rnd( 0, 4 )
			Else
				'make sure their aren't too many gasgiants
				If kind = PLANETKIND_GASGIANT Then
					if Rnd( 100 ) &lt; 50 Then
						kind = PLANETKIND_PLANET
					Else
						size = Clamp( size, 20, 200 )
					End If
				End If
				
				If kind = PLANETKIND_MOON or kind = PLANETKIND_ASTEROIDMOON Then
					If _planets[k-1].Kind &gt; PLANETKIND_ASTEROID Then
						kind = PLANETKIND_PLANET
					Else
						size = Clamp( size, 3, int(_planets[k-1].Size * 0.5 ) )

						'lastly we want the new moon to revolve around the previous planet,  so we set its parent
						parent = k-1
					End If
				End If

				'make sure that asteroids arent big things
				Select kind 
					Case PLANETKIND_ASTEROID,  PLANETKIND_ASTEROIDMOON
						size = Clamp( size, 2, 10 )
				End select
			End If
			
			'ok,  now we have a planet kind,  and a correct parent
			_planets[k] = New Planet( parent, kind, size, dist, "Planet "+k )
			
			dist += Rnd(80, 120)
		Next 
	End method

protected

	
private
	field _xPos:float
	field _yPos:float
	field _zPos:float
	
	field _name:string
	
	field _seed:uint
	
	'a solar system has planets
	field _planetCount:int = 0
	field _planets:Planet[] = New Planet[16]
End Class




Class MyWindow Extends Window

	method New()
		Super.New( "My Window", Size.X, Size.Y, WindowFlags.Resizable )
		ClearColor = Color.Black

		'Create a solar system.... Magic
		_solarSystem[0] = New SolarSystem( 0, 0, 0, "Galactic Center" )

		'And now 2 more
		'beware of floats. they lie
		_solarSystem[1] = New SolarSystem( 12.4, 15, 6.1, "Ceti" )
		_solarSystem[2] = New SolarSystem( - 5, 8.3, -3, "Zimini" )
	End method

	
	Method OnRender( canvas:Canvas ) Override
		'note how we have changed the display from step 1 to using a loop and an x position
		Local solar:int
		Local xpos:int = 0
		For solar = 0 To 2
			canvas.DrawText( _solarSystem[solar].Name, xpos + 10, 10 )
			canvas.DrawText( " x:"+_solarSystem[solar].XPos, xpos +20, 30 ) 
			canvas.DrawText( " z:"+_solarSystem[solar].ZPos, xpos +20, 50 )
			canvas.DrawText( " y:"+_solarSystem[solar].YPos, xpos +20, 70 )
			canvas.DrawText( _solarSystem[solar].Planets+" planets", xpos +10, 90 )
			
			xpos += 200
		Next

		'now draw the planets
		Local ypos:int = 200
		Local planet:int
		Local size:float
		Local prevXPos:float
		Local prevYPos:float
		Local scale:float = 0.4
		Local moon:float = 80 * scale
		For solar = 0 To 2
			xpos = 100
			canvas.Color = Color.DarkGrey
			canvas.DrawLine( 100, ypos, Width, ypos )
			
			For planet = 0 until _solarSystem[solar].Planets

				'this has now changed form a single if to a select
				Select _solarSystem[solar]._planets[planet].Kind
					' note that you can use more than one test per case
					Case PLANETKIND_MOON, PLANETKIND_ASTEROIDMOON
						DrawPlanet( canvas, solar, planet, xpos,  ypos+moon, scale )
						
						canvas.Color = Color.Red
						canvas.DrawLine( prevXPos,  prevYPos, xpos,  ypos+moon )
						
						prevYPos = ypos + moon
						
					'default is run when there is no match. you don't need to have it
					Default
						DrawPlanet( canvas, solar, planet, xpos,  ypos, scale )
						prevYPos = ypos
				End Select

				canvas.Color = Color.White
				canvas.DrawText( _solarSystem[solar]._planets[planet].NameKind,  xpos, ypos + (160+(40 * (planet Mod 2) ) ) *scale )

				prevXPos = xpos
				xpos = (400 + (_solarSystem[solar]._planets[planet]._distance*2)) * scale
			Next
			ypos += 400 * scale
		Next
	End
	
	method DrawPlanet( canvas:Canvas, solar:int, planet:int, xpos:int,  ypos:int, scale:float )
		local size:int = _solarSystem[solar]._planets[planet].Size * scale
		
		canvas.Color = Color.White

		Select _solarSystem[solar]._planets[planet].Kind
			Case PLANETKIND_STAR
				canvas.Color = Color.White
				canvas.Alpha = 0.1
				canvas.DrawEllipse( xpos,  ypos, size*2, 3 )
				canvas.DrawEllipse( xpos,  ypos, 3, size* 2 )

				Local k:int
				'this is the frist time we have encountered Alpha. and guess what it does???
				canvas.Alpha = 0.075
				canvas.Color = _solarSystem[solar]._planets[planet].PlanetColor
				For k = size To 5 Step -4
					canvas.DrawCircle( xpos,  ypos, k )
				Next

			Case PLANETKIND_BLACKHOLE
				canvas.Color = Color.DarkGrey
				canvas.DrawCircle( xpos,  ypos, size )
				canvas.Color = Color.Black
				canvas.DrawCircle( xpos,  ypos, size-1 )

			Case PLANETKIND_GASGIANT
				canvas.Color = Color.Black
				canvas.DrawCircle( xpos,  ypos, size-2 )
				canvas.Alpha = 0.1
				canvas.Color = _solarSystem[solar]._planets[planet].PlanetColor
				canvas.DrawCircle( xpos,  ypos, size-2 )
				
				canvas.DrawEllipse( xpos,  ypos, size-2, 5 )
				canvas.DrawEllipse( xpos,  ypos-size/2, size/1.5, 5 )
				canvas.DrawEllipse( xpos,  ypos+size/2, size/1.5, 5 )

				canvas.Alpha = 0.05
				Local k:int
				Local offset:int = 0
				For k = size To 5 Step -3
					canvas.DrawCircle( xpos-offset,  ypos-offset, k )
					offset += 1
				Next

			Case PLANETKIND_PLANET
				canvas.Color = Color.DarkGrey
				canvas.DrawCircle( xpos,  ypos, size )
				canvas.Alpha = 0.5
				canvas.Color = _solarSystem[solar]._planets[planet].PlanetColor
				canvas.DrawCircle( xpos,  ypos, size )

				canvas.Alpha = 0.05
				canvas.Color = Color.White
				Local k:int
				Local offset:int = 0
				For k = size To 5 Step -3
					canvas.DrawCircle( xpos-offset,  ypos-offset, k )
					offset += 1
				Next
			Case PLANETKIND_MOON
				canvas.Color = Color.DarkGrey
				canvas.DrawCircle( xpos,  ypos, size-2 )

				canvas.Alpha = 0.15
				canvas.Color = _solarSystem[solar]._planets[planet].PlanetColor
				canvas.DrawCircle( xpos,  ypos, size )
				canvas.DrawEllipse( xpos-5,  ypos, size-5, size )
				canvas.DrawEllipse( xpos+5,  ypos, size-5, size )
				canvas.Alpha = 0.2
				canvas.DrawCircle( xpos-3,  ypos-3, size-5 )
				canvas.DrawCircle( xpos-3,  ypos-3, size-8 )
				canvas.DrawCircle( xpos-3,  ypos-3, size-12 )
				
			Case PLANETKIND_ASTEROIDMOON
				canvas.Color = _solarSystem[solar]._planets[planet].PlanetColor
				canvas.DrawCircle( xpos,  ypos, size )

			Case PLANETKIND_ASTEROID
				canvas.Color = _solarSystem[solar]._planets[planet].PlanetColor
				canvas.DrawCircle( xpos,  ypos, size )

			Case PLANETKIND_ASTEROIDBELT
				Local k:int
				Local pos:int = 0
				canvas.Color = Color.DarkGrey
				For k = 0 To 100 Step 15
					canvas.DrawCircle( xpos+pos,  (ypos-50) + k, 8 )
					
					pos += 20
					If pos &gt; size then pos = 0
					
				next
				
			Case PLANETKIND_DUSTBELT
				Local k:int
				Local pos:int = 0
				For k = 0 To 100 Step 4
					canvas.DrawPoint( xpos + (k*11) Mod size,  (ypos-50) + k )
					
					pos += size
				next

			Case PLANETKIND_NEBULAE
				canvas.Color = _solarSystem[solar]._planets[planet].PlanetColor
				canvas.Alpha = 0.1
				Local k:int
				Local pos:int = 0
				For k = 0 To 100 Step 15
					canvas.DrawCircle( xpos + pos,  (ypos-50) + k, 30 )
					
					pos += 15
					If pos &gt; size then pos = 0
				Next
				canvas.Alpha = 0.8
				For k = 0 To 100 Step 4
					canvas.DrawPoint( xpos + (k*11) Mod size,  (ypos-50) + k )
					
					pos += size
				next

			Case PLANETKIND_RADIATIONBELT
				canvas.Alpha = 0.05
				canvas.Color = Color.Red
				Local k:int
				Local offset:int = 0
				For k = size To 5 Step -3
					canvas.DrawRect( xpos+offset,  ypos+offset-50, size, 100-offset-offset )
					offset += 1
				Next
		End Select

		'make sure the Alpha is set back to 1
		canvas.Alpha = 1

	End method

protected

	'respond to any key presses
	Method OnKeyEvent( event:KeyEvent ) Override

		Select event.Type
			case EventType.KeyDown
			
				Select event.Key
					Case Key.Space
						_solarSystem[1].CreatePlanets( Rnd(-256, 256), Rnd(-64, 64), Rnd(-256, 256) )
						_solarSystem[2].CreatePlanets( Rnd(-256, 256), Rnd(-64, 64), Rnd(-256, 256) )
						'this next command is uber important
						'it basically says GIVE ME A NEW RENDER
						'you can think of it similar to Flip in blitzmax
						RequestRender()
				End Select
		End Select
	End method

private
	'set up an array of SolorSystems. This is just setting then up. we will need to new each one into existance as well
	'but note how the array works. if the variables are ints or ools and not classes. using this will create them
	' but classes need to be New() into existance as well
	field _solarSystem:SolarSystem[] = New SolarSystem[10]
	
	'here is how we do a multiple array. it's not quite like Basic,  and is a bit fiddly. but heres the code for you
'	field _map:int[, ] = New int[10, 10]
End


</textarea><br><br>so what's new?<br>well, I went on a bug hunt and edited some code to do with the planets.<br><br>I added the ability to press space and the last 2 systems are given new positions, and therefore new planets. so you can see lots of different kinds.<br><br>Tidied up some display code<br><br>in the keypress method you will find RequestRender() this is sorta like flip. It refreshes the screen<br><br>nebulae now has graphics, stars and gasgiants have minimum sizes<br><br>moons and asteroids can also have the same. but all corrected<br><br>orbiting objects show correct redline to their parent &lt;- all of this is mostly visual<br><br>@ Mainsworthy I'll get onto rings next... <br><br></td></tr></table><br>
<a name="1339182"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#79">[#79]</a></td></tr></table></td></tr><tr ><td class="posttext"> cant find any way to rotate on the midpoint, does this exist in monkey2, in blitz it was AutoMidHandle( enable ) <br><br></td></tr></table><br>
<a name="1339184"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#80">[#80]</a></td></tr></table></td></tr><tr ><td class="posttext"> that looks spectacular! still looking at code, the flip &amp; keypress has learned me a lot. <br><br></td></tr></table><br>
<a name="1339185"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#81">[#81]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok, last one of the day<br><img src="https://vjointeractive.files.wordpress.com/2017/04/screen-shot-2017-04-21-at-15-14-49.png"><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Namespace myMojoApp

#Import "&lt;std&gt;"
#Import "&lt;mojo&gt;"

Using std..
Using mojo..

Const Size := New Vec2i( 950,720 )

Function Main()
	New AppInstance
	
	New MyWindow
	
	App.Run()
End


const PLANETKIND_BLACKHOLE:int = 0
const PLANETKIND_STAR:int = 1
const PLANETKIND_GASGIANT:int = 2
const PLANETKIND_PLANET:int = 3
const PLANETKIND_MOON:int = 4
const PLANETKIND_ASTEROIDMOON:int = 5
const PLANETKIND_ASTEROID:int = 6
const PLANETKIND_ASTEROIDBELT:int = 7
const PLANETKIND_DUSTBELT:int = 8
const PLANETKIND_NEBULAE:int = 9
const PLANETKIND_RADIATIONBELT:int = 10
'if we use the last one as a max variable we can use it in our program for counting purposes
const PLANETKIND_MAX:int = 11

'Assumptions:
'planets revolve around a center point,  so planet[0] is the center
'Using this we could deem that moons revolve around planets,  and if a planet exists,  then it has a number,
'so evey planet revolves around a planet
'E.G.
'planet 0,  revolves around nothing - it is special
'planet 1,  revolves around planet 0 at a certain distance
'planet 2,  revolves around planet 0 (but further away)
'planet 3,  revolves around planet 2,  so it is a moon of planet 2
' - I was up a few hours last night coming up with that simplification
'ok lets build the class (I was up a few hours last night coming up with that)
class Planet
	method New( parent:int, kind:int, size:float, distance:float, name:string )
		_parent = parent
		_kind = kind
		_size = size
		_distance = distance
		_name = name
		_rings = false
		
		Select kind
			Case PLANETKIND_PLANET
				If Rnd( 100 ) &lt; 15 Then _rings = true
			Case PLANETKIND_GASGIANT
				_size = Clamp( size, 75.0, 200.0 )
				If Rnd( 100 ) &lt; 20 Then _rings = true
			Case PLANETKIND_STAR
				_size = Clamp( size, 75.0, 200.0 )
				If Rnd( 100 ) &lt; 10 Then _rings = True
			Case PLANETKIND_MOON
				If Rnd( 100 ) &lt; 10 Then _rings = true
		End Select
		
		_planetColor = New Color( Rnd(0.5, 1), Rnd(0.5, 1), Rnd(0.5, 1) )
	End method

	Property Name:string()
		Return _name
	End

	Property NameKind:string()
		Select _kind
			Case PLANETKIND_STAR Return "Star"
			Case PLANETKIND_BLACKHOLE Return "BlackHole"
			Case PLANETKIND_GASGIANT Return "GasGiant"
			Case PLANETKIND_PLANET Return "Planet"
			Case PLANETKIND_MOON Return "Moon"
			Case PLANETKIND_ASTEROIDMOON Return "Asteroidm"
			Case PLANETKIND_ASTEROID Return "Asteroid"
			Case PLANETKIND_ASTEROIDBELT Return "AsteroidBelt"
			Case PLANETKIND_DUSTBELT Return "DustBelt"
			Case PLANETKIND_NEBULAE Return "Nebulae"
			Case PLANETKIND_RADIATIONBELT Return "RadiationBelt"
		End Select
		
		Return ""
	End

	Property Kind:int()
		Return _kind
	End

	Property Rings:bool()
		Return _rings
	End

	Property Parent:string()
		Return _parent
	End

	Property Size:float()
		Return _size
	End

	Property Distance:float()
		Return _distance
	End

	Property PlanetColor:Color()
		Return _planetColor
	End

private
	field _name:string

	'what sort of planet or solar object is the planet
	field _kind:int
	
	'does it have rings
	field _rings:bool
	
	'how big is the planet
	field _size:float
	
	'how far is it from the center
	field _distance:float
	
	'revolves around...
	field _parent:int
	
	'what color is it?
	field _planetColor:Color
End Class



'lets assume that x, z cordinates are a flat plane and go from 0 to 512. with 256 being the center
'And lets assume that y goes from 0 to 128 with 64 being the center
'we now have a box 512x512x128 with 256, 64, 256 as the center point
'lets also assume that is difficult to remember and have 0, 0, 0 as the center and correct the offsets in the class itself
class SolarSystem
	method New( x:float, y:float, z:float, name:string )
		'first we must to our internal correction
		_xPos = x + 256
		_zPos = z + 256
		
		_yPos = y + 64
		
		_name = name
		
		CreatePlanets()
	End method
	
	
	Property Name:string()
		Return _name
	Setter( name:string )
		_name = name
	End

	'note the additon of data processing in the property.
	' to us (outside the class), positons are centered around 0, 0, 0,  inside they are really centered at 256, 64, 256
	' so we will need to alter the internals when being inspected from outside the class
	Property XPos:float()
		Return _xPos - 256
	End

	Property ZPos:float()
		Return _zPos - 256
	End

	Property YPos:float()
		Return _yPos - 64
	End

	'note the different variables names and also we dont need a setter
	Property Planets:int()
		Return _planetCount
	End
	
	
	'ok this is a nice addition,  but be carefull. It is called operater overloading
	' We now have 2 CreatePlanets.
	' one with no variables,  and this new one with 3 floats
	'When CreatePlantets() occurs. The compiler will pick the correct one depending on the data you've given it
	' in this new version we are going to set a new position for the solar system
	' this will force the createPlanets to restart with new seeds,  etc
	method CreatePlanets( x:float, y:float, z:float )
		_xPos = x + 256
		_zPos = z + 256
		_yPos = y + 64
		CreatePlanets()
	End method
	
	
	method CreatePlanets()
		'we are going to do something odd but amazing here
		_seed = _xPos + (_zPos * 512) + (_yPos * 300000)
		'what this has done is created a unique uint (long int) for each solar system
		'we can then pass this to seedrnd and always get the same results for random numbers
		
		SeedRnd( _seed )
		
		_planetCount = Rnd( 4, 16 )
		Local k:int
		Local dist:int = 0
		'ok ,  heres a new command 'until' its just like for from to,  but doesnt reach the last element
		'so 'For k = 0 to 3 would give 0, 1, 2, 3.   for k = 0 until 3 would give 0, 1, 2
		' saves you using for k = 0 to _planetCount-1
		For k = 0 until _planetCount
			'make new planets 	method New( parent:int, size:float, distance:float, name:string )

			Local size:int = Rnd(5, 150)
			local kind:int = Rnd( 1, PLANETKIND_MAX )
			Local parent:int = 0
			
			'ok the first 'planet will always be a sun, blackhole, gasgiant or planet
			If k = 0 Then
				'note Rnd will never reach the max number,  so always give it one extra!
				kind = Rnd( 0, 4 )
			Else
				'make sure their aren't too many gasgiants
				If kind = PLANETKIND_GASGIANT Then
					if Rnd( 100 ) &lt; 50 Then
						kind = PLANETKIND_PLANET
					Else
						size = Clamp( size, 20, 200 )
					End If
				End If
				
				If kind = PLANETKIND_MOON or kind = PLANETKIND_ASTEROIDMOON Then
					If _planets[k-1].Kind &gt; PLANETKIND_ASTEROID Then
						kind = PLANETKIND_PLANET
					Else
						size = Clamp( size, 3, int(_planets[k-1].Size * 0.5 ) )

						'lastly we want the new moon to revolve around the previous planet,  so we set its parent
						parent = k-1
					End If
				End If

				'make sure that asteroids arent big things
				Select kind 
					Case PLANETKIND_ASTEROID,  PLANETKIND_ASTEROIDMOON
						size = Clamp( size, 2, 10 )
				End select
			End If
			
			'ok,  now we have a planet kind,  and a correct parent
			_planets[k] = New Planet( parent, kind, size, dist, "Planet "+k )
			
			dist += Rnd(80, 120)
		Next 
	End method

protected

	
private
	field _xPos:float
	field _yPos:float
	field _zPos:float
	
	field _name:string
	
	field _seed:uint
	
	'a solar system has planets
	field _planetCount:int = 0
	field _planets:Planet[] = New Planet[16]
End Class




Class MyWindow Extends Window

	method New()
		Super.New( "My Window", Size.X, Size.Y, WindowFlags.Resizable )
		ClearColor = Color.Black

		'Create a solar system.... Magic
		_solarSystem[0] = New SolarSystem( 0, 0, 0, "Galactic Center" )

		'And now 2 more
		'beware of floats. they lie
		_solarSystem[1] = New SolarSystem( 12.4, 15, 6.1, "Ceti" )
		_solarSystem[2] = New SolarSystem( - 5, 8.3, -3, "Zimini" )
	End method

	
	Method OnRender( canvas:Canvas ) Override
		'note how we have changed the display from step 1 to using a loop and an x position
		Local solar:int
		Local xpos:int = 0
		For solar = 0 To 2
			canvas.DrawText( _solarSystem[solar].Name, xpos + 10, 10 )
			canvas.DrawText( " x:"+_solarSystem[solar].XPos, xpos +20, 30 ) 
			canvas.DrawText( " z:"+_solarSystem[solar].ZPos, xpos +20, 50 )
			canvas.DrawText( " y:"+_solarSystem[solar].YPos, xpos +20, 70 )
			canvas.DrawText( _solarSystem[solar].Planets+" planets", xpos +10, 90 )
			
			xpos += 200
		Next

		'now draw the planets
		Local ypos:int = 200
		Local planet:int
		Local size:float
		Local prevXPos:float
		Local prevYPos:float
		Local scale:float = 0.4
		Local moon:float = 80 * scale
		For solar = 0 To 2
			xpos = 100
			canvas.Color = Color.DarkGrey
			canvas.DrawLine( 100, ypos, Width, ypos )
			
			For planet = 0 until _solarSystem[solar].Planets

				'this has now changed form a single if to a select
				Select _solarSystem[solar]._planets[planet].Kind
					' note that you can use more than one test per case
					Case PLANETKIND_MOON, PLANETKIND_ASTEROIDMOON
						DrawPlanet( canvas, solar, planet, xpos,  ypos+moon, scale )
						
						canvas.Color = Color.Red
						canvas.DrawLine( prevXPos,  prevYPos, xpos,  ypos+moon )
						
						prevYPos = ypos + moon
						
					'default is run when there is no match. you don't need to have it
					Default
						DrawPlanet( canvas, solar, planet, xpos,  ypos, scale )
						prevYPos = ypos
				End Select

				canvas.Color = Color.White
				canvas.DrawText( _solarSystem[solar]._planets[planet].NameKind,  xpos, ypos + (160+(40 * (planet Mod 2) ) ) *scale )

				prevXPos = xpos
				xpos = (400 + (_solarSystem[solar]._planets[planet]._distance*2)) * scale
			Next
			ypos += 400 * scale
		Next
	End
	
	method DrawPlanet( canvas:Canvas, solar:int, planet:int, xpos:int,  ypos:int, scale:float )
		local size:int = _solarSystem[solar]._planets[planet].Size * scale
		
		canvas.Color = Color.White

		Select _solarSystem[solar]._planets[planet].Kind
			Case PLANETKIND_STAR
				canvas.Color = Color.White
				canvas.Alpha = 0.1

				canvas.DrawEllipse( xpos,  ypos, size*2, 3 )
				canvas.DrawEllipse( xpos,  ypos, 3, size* 2 )

				Local k:int
				'this is the frist time we have encountered Alpha. and guess what it does???
				canvas.Alpha = 0.075
				canvas.Color = _solarSystem[solar]._planets[planet].PlanetColor
				For k = size To 5 Step -4
					canvas.DrawCircle( xpos,  ypos, k )
				Next

			Case PLANETKIND_BLACKHOLE
				canvas.Color = Color.DarkGrey
				canvas.DrawCircle( xpos,  ypos, size )
				canvas.Color = Color.Black
				canvas.DrawCircle( xpos,  ypos, size-1 )

			Case PLANETKIND_GASGIANT
				canvas.Color = Color.Black
				canvas.DrawCircle( xpos,  ypos, size-2 )
				canvas.Alpha = 0.1
				canvas.Color = _solarSystem[solar]._planets[planet].PlanetColor
				canvas.DrawCircle( xpos,  ypos, size-2 )
				
				canvas.DrawEllipse( xpos,  ypos, size-2, 5 )
				canvas.DrawEllipse( xpos,  ypos-size/2, size/1.5, 5 )
				canvas.DrawEllipse( xpos,  ypos+size/2, size/1.5, 5 )

				canvas.Alpha = 0.05
				Local k:int
				Local offset:int = 0
				For k = size To 5 Step -3
					canvas.DrawCircle( xpos-offset,  ypos-offset, k )
					offset += 1
				Next

			Case PLANETKIND_PLANET
				canvas.Color = Color.DarkGrey
				canvas.DrawCircle( xpos,  ypos, size )
				canvas.Alpha = 0.5
				canvas.Color = _solarSystem[solar]._planets[planet].PlanetColor
				canvas.DrawCircle( xpos,  ypos, size )

				canvas.Alpha = 0.05
				canvas.Color = Color.White
				Local k:int
				Local offset:int = 0
				For k = size To 5 Step -3
					canvas.DrawCircle( xpos-offset,  ypos-offset, k )
					offset += 1
				Next
				
			Case PLANETKIND_MOON
				canvas.Color = Color.DarkGrey
				canvas.DrawCircle( xpos,  ypos, size-2 )

				canvas.Alpha = 0.15
				canvas.Color = _solarSystem[solar]._planets[planet].PlanetColor
				canvas.DrawCircle( xpos,  ypos, size )
				canvas.DrawEllipse( xpos-5,  ypos, size-5, size )
				canvas.DrawEllipse( xpos+5,  ypos, size-5, size )
				canvas.Alpha = 0.2
				canvas.DrawCircle( xpos-3,  ypos-3, size-5 )
				canvas.DrawCircle( xpos-3,  ypos-3, size-8 )
				canvas.DrawCircle( xpos-3,  ypos-3, size-12 )
				
			Case PLANETKIND_ASTEROIDMOON
				canvas.Color = _solarSystem[solar]._planets[planet].PlanetColor
				canvas.DrawCircle( xpos,  ypos, size )

			Case PLANETKIND_ASTEROID
				canvas.Color = _solarSystem[solar]._planets[planet].PlanetColor
				canvas.DrawCircle( xpos,  ypos, size )

			Case PLANETKIND_ASTEROIDBELT
				Local k:int
				Local pos:int = 0
				canvas.Color = Color.DarkGrey
				For k = 0 To 100 Step 15
					canvas.DrawCircle( xpos+pos,  (ypos-50) + k, 8 )
					
					pos += 20
					If pos &gt; size then pos = 0
					
				next
				
			Case PLANETKIND_DUSTBELT
				Local k:int
				Local pos:int = 0
				For k = 0 To 100 Step 4
					canvas.DrawPoint( xpos + (k*11) Mod size,  (ypos-50) + k )
					
					pos += size
				next

			Case PLANETKIND_NEBULAE
				canvas.Color = _solarSystem[solar]._planets[planet].PlanetColor
				canvas.Alpha = 0.1
				Local k:int
				Local pos:int = 0
				For k = 0 To 100 Step 15
					canvas.DrawCircle( xpos + pos,  (ypos-50) + k, 30 )
					
					pos += 15
					If pos &gt; size then pos = 0
				Next
				canvas.Alpha = 0.8
				For k = 0 To 100 Step 4
					canvas.DrawPoint( xpos + (k*11) Mod size,  (ypos-50) + k )
					
					pos += size
				next

			Case PLANETKIND_RADIATIONBELT
				canvas.Alpha = 0.05
				canvas.Color = Color.Red
				Local k:int
				Local offset:int = 0
				For k = size To 5 Step -3
					canvas.DrawRect( xpos+offset,  ypos+offset-50, size, 100-offset-offset )
					offset += 1
				Next
		End Select
		
		If _solarSystem[solar]._planets[planet].Rings Then
			canvas.Alpha = 0.5
			canvas.Color = _solarSystem[solar]._planets[planet].PlanetColor
			canvas.LineWidth = 10
			canvas.DrawLine( xpos-(size*1.75), ypos+(size* 0.25), xpos + (size*1.75), ypos - (size* 0.25) )
			canvas.LineWidth = 1
		End if

		'make sure the Alpha is set back to 1
		canvas.Alpha = 1

	End method

protected

	'respond to any key presses
	Method OnKeyEvent( event:KeyEvent ) Override

		Select event.Type
			case EventType.KeyDown
			
				Select event.Key
					Case Key.Space
						_solarSystem[1].CreatePlanets( Rnd(-256, 256), Rnd(-64, 64), Rnd(-256, 256) )
						_solarSystem[2].CreatePlanets( Rnd(-256, 256), Rnd(-64, 64), Rnd(-256, 256) )
						'this next command is uber important
						'it basically says GIVE ME A NEW RENDER
						'you can think of it similar to Flip in blitzmax
						RequestRender()
				End Select
		End Select
	End method

private
	'set up an array of SolorSystems. This is just setting then up. we will need to new each one into existance as well
	'but note how the array works. if the variables are ints or ools and not classes. using this will create them
	' but classes need to be New() into existance as well
	field _solarSystem:SolarSystem[] = New SolarSystem[10]
	
	'here is how we do a multiple array. it's not quite like Basic,  and is a bit fiddly. but heres the code for you
'	field _map:int[, ] = New int[10, 10]
End


</textarea><br><br>more tidying and added rings for Mainsworthy.<br><br>I think (generally) we are done here. <br><br></td></tr></table><br>
<a name="1339187"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#82">[#82]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok. now we have to think about how next to progress<br><br>My thoughts are:<br>for each planet - decide what it has to offer and what it wants<br><br>you have nothing to start with, but money.<br><br>money buys a ship within certain parameters. E.G. cargo ore hold, slow light drive, no armaments. that sort of thing?<br><br>You could then setup a star route. goto planet A: collect ore from mine, goto planet C, deliver ore, repeat<br><br>Sort of Galactic tycoon... See Transport tycoon for general game play.<br><br>Start ship handoff things go.<br><br>on each game tick it travels a certain amount. Of course there may be problems along the way. engine overheat, raider, passenger eaten by cargo.<br><br>each time you deliver something you get money. more money means upgrade the ship, etc.<br><br>Lets assume that you start with a single 'known' star system. You could do space research that would reveal other star systems. you would need to travel to that system to start more research etc.<br><br>And on it could go...<br><br>You could have a set of quests as in Rogue3 which on completion give you more money than usual, but with greater risks.<br><br>Maybe several star systems have grouped together to form an alliance. maybe they don't like you trading in their territory. I don't know I'm just winging this one, but in essence it has some very nice legs attached to it... <br><br></td></tr></table><br>
<a name="1339189"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#83">[#83]</a></td></tr></table></td></tr><tr ><td class="posttext"> first off I think this will set it apart from any game of this type , is multiEvents on a single mission, if you think about it in a real space world travelling vast distancies the time and cargo and everything like delivering secret plans - mapping a space worms trajectory - refuel - photos for art buffs - cloneing all the sorts of things that would not take cargo space BUT instead would add to a single mission, the mission would need to be random &amp; be comparable to all other random missions - or you would just keep generating until a good one popped up. <br><br>rewards don't just have to be gold, it can be life extension, land, trade route manooly for regular rent or goods, passwords to secret locations, time travel, I think this would set the game apart from others.<br><br>you could join military, or traders, or pirates, or minors, or ship builders, or weapons makers, or monks,  all for different game winning goals - so again the game wont be all about credits. <br><br></td></tr></table><br>
<a name="1339192"></a>

<a name="1339193"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#84">[#84]</a></td></tr></table></td></tr><tr ><td class="posttext"> Adam I cant find any way to rotate on the midpoint, does this exist in monkey2, in blitz it was AutoMidHandle( enable ) <br><br>This really would help me with a side app I'm planning, but I don't know what I'm doing yet , I have looked and looked but cant seem to locate this. don't worry Adam if your busy with above, just niggleing me l was going to experiment as we went along with the space one, but an interesting app is hard to think up, and right now I want a midpoint :) <br><br></td></tr></table><br>
<a name="1339194"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#85">[#85]</a></td></tr></table></td></tr><tr ><td class="posttext"> its amazing what you've done without asset art <br><br></td></tr></table><br>
<a name="1339195"></a>

<a name="1339196"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#86">[#86]</a></td></tr></table></td></tr><tr ><td class="posttext"> image.Handle=New Vec2f( .5,.5 )<br><br>hey found it :)<br><br>I'm going on about daft stuff because I'm a noob at OOP, but its finally sunk in, I can find my way around a bit. <br><br>I'm going to experiment with a side app to try out commands I come across, and to learn a bit, <br><br></td></tr></table><br>
<a name="1339210"></a>

<a name="1339211"></a>

<a name="1339212"></a>

<a name="1339213"></a>

<a name="1339220"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#87">[#87]</a></td></tr></table></td></tr><tr ><td class="posttext"> <textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Namespace myLetterboxApp

#Import "&lt;std&gt;"
#Import "&lt;mojo&gt;"

Using std..
Using mojo..

#Import "assets/map.png"
#Import "assets/chit1.png"
#Import "assets/chit2.png"
Const Size := New Vec2i( 950,720 )

Const GAMEMODE_INTRO:Int = 1
Const GAMEMODE_GAME:int = 2


Function Main()
	New AppInstance
	
	New MyWindow
	
	App.Run()
End


'this will be the base class for all chits, anything can be a chit
Class Chit
	'this is called when any new thing is derrived from this class
	Method New()
	End Method

	
	'we can now have a different new which can be fed with an int which becomes the energy
	' so New(67) would give you a Chit with 67 rotation
	Method New( twist:Int,chx:Int,chy:int )
		_twist = twist
		_chitx = chx 'just a var to initialise starting posision of chit
		_chity = chy 
	End Method


	'because _twist is private,  we need a property and setter
	' we only then need to access by _chit.Twist = 40,  or twist = _chit.Twist
	'Property Twist:int()
	'	Return _twist
	'Setter( twist:int )
	'	_twist = twist
	'End

    Field _chitx:int = 600
	Field _chity:int = 600
	Field _twist:int = 0
Private
	'how much rotation does the chit start with 0  but we could change this with a different New
	'Field _twist:int = 0
	

	
End Class


Class MyWindow Extends Window

	Method New()
		Super.New( "My Window", Size.X, Size.Y, WindowFlags.Resizable )
	    
		'if you want a constant canvas size use this
'		Layout = "letterbox"
		'or If you want the canvas to always fill the window use this
		Layout = "fill"

		'this is a timer. it will 'tick' 60 times a second. calling OnUpdate
		_timer = New Timer( 60, OnUpdate )
		_maped = Image.Load( "asset::map.png" ) 'I used a 2000x2000 pixel PNG
		_unit1 = Image.Load( "asset::chit1.png" ) 'I used a 50x50 pixel PNG
		_unit2 = Image.Load( "asset::chit2.png" ) 'I used a 50x50 pixel PNG
        'provide a PNG and variables for every chit on the map
		_chit = New Chit(0,650,650) ' rotatio,X,Y (x,y in relation to the map
		_chit2 = New Chit(68,701,780) ' the map you see starts at -x500 y-500
	End

Protected
	Method OnUpdate()
		RequestRender()
	End Method
	
	
	Method OnRender( canvas:Canvas ) Override

		'fill the screen canvas with a color
		canvas.Color = Color.Black
		canvas.DrawRect( 0, 0, Width, Height )

		Select _gameMode
			Case GAMEMODE_INTRO
				DrawTheIntro( canvas )
			Case GAMEMODE_GAME
				DrawTheGame( canvas )
		End Select
	End


	Method DrawTheGame( canvas:Canvas )
		canvas.Color = Color.White
		'draw the map
		canvas.DrawImage( _maped, _mX, _mY )		
		'draw the chits with a twist
		' debug _twist = _twist + 1
		'If _twisted &gt; 360 Then _twisted = _twisted - 360
        canvas.DrawCircle(800+_mX,  800+_mY,30 ) 'draw	800x800 plus map offset	
		canvas.DrawImage (_unit1, _chit._chitx +_mX, _chit._chity + _mY,_chit._twist )
		canvas.DrawImage (_unit2, _chit2._chitx +_mX, _chit2._chity + _mY,_chit2._twist)
	End Method
	
	
	Method DrawTheIntro( canvas:Canvas )
		canvas.Color = Color.White
	
		canvas.DrawText( " Scroller Map' First App By Mark Ainsworth ref 210665",200,20 )
		canvas.DrawText( " How To Scroll The Map Right Click To Pickup Board, Then Drag it Release to Drop it. ",200,60 )
		canvas.DrawText( " You can Move around the Map By Only RightClicking and Dragging.",200,80 )
		canvas.DrawText("- PRESS ENTER OR LRFT-CLICK MOUSE TO START MAP --&gt;",200,670)
		
	End Method

	
	'respond to any key presses
	Method OnKeyEvent( event:KeyEvent ) Override
		'heres the best way to check for shift keys etc
		Local command:Bool = event.Modifiers &amp; Modifier.Gui
		Local shift:Bool = event.Modifiers &amp; Modifier.Shift
		Local alt:bool = event.Modifiers &amp; Modifier.Alt
		
		Select event.Type
			case EventType.KeyDown
			
				Select event.Key
					Case Key.Enter
						Select _gameMode
							Case GAMEMODE_INTRO
								_gameMode = GAMEMODE_GAME
						End Select
							
				End Select
				
			Case EventType.KeyUp
			
				Select event.Key
					Case Key.Enter
				End Select
				
		End Select
	End

	'here we track the mouse and all mouse related stuff
	Method OnMouseEvent( event:MouseEvent ) Override
		'set up some global mouse cars so we can use these throught to program
		_mouseX = event.Location.X
		_mouseY = event.Location.Y

		'here are the baci mouse events we are interested in
		Select event.Type
			Case EventType.MouseRightClick
				_movemap = 1
				If _movemap = 1 'if you right click record current mouse location
				_oldX = _mX +  -_mouseX 'plus map location
				_oldY = _mY + -_mouseY
				
				Endif

			Case EventType.MouseClick
				Select _gameMode
					Case GAMEMODE_INTRO
						_gameMode = GAMEMODE_GAME
				End Select	
			Case EventType.MouseUp
				_movemap = 0 'if you move the mouse while dragging
				If _movemap = 0 'the map x,y is updated untill you Mouseup
				_oldX = _mX 
				_oldY = _mY 
		
				Endif
			Case EventType.MouseEnter
			Case EventType.MouseLeave
			Case EventType.MouseMove
				If _movemap = 1
					_mX = _mouseX + _oldX - 0
					_mY = _mouseY + _oldY - 0
				Endif	
				End Select					
		
	End Method
	
		Field _mY:Int = -500 'position of map -500 so we start 500 in from top
	    Field _mX:Int = -500 'position of map -500 so we start 500 in from left
		Field _twist:Int  'rotate
		Field _oldX:Int 'used to store map location before you drag
		Field _oldY:Int 'used to store map location before you drag
		Field _movemap:Int 'switch to on to dragmap in conjuction with old position

	'this is needed to allow the Size to be correct. this is called automatically
	Method OnMeasure:Vec2i() Override
		Return Size
	End
Private
	'the timer ticks 60 times a second and handles the screen update
	Field _timer:Timer
	
	'what mode is the game in, showing the intro, playing, ended, etc
	Field _gameMode:Int = GAMEMODE_INTRO
	
	'global mouse vars
	Field _mouseX:Int
	Field _mouseY:Int

	'image assets
	Field _maped:Image ' this is the map png
	Field _unit1:Image ' this is the chit1 png
	Field _unit2:Image ' this is the chit2 png
	'set up some classes' these will need to be newed
	field _chit:Chit ' these are the chits
	field _chit2:Chit ' A secon chit
End
</textarea><br>'================================<br><br><br>I don't know how to do a code box , please advise?<br><br>I didn't want to say what I was working on until I knew what I was doing, but I have made a large scrollable map that your planets and ships can be drawn on. you will have to provide a 2000x2000 png map.png file, and chit1.png and chit2.png 50x50 pixels, but the sizes are not strict.<br><br>this will be of use I'm sure, you could add the map offsets 800+_mX 800+_mY   to your planet displays as an example I did a circle in the code,<br><br>I also think it will serve as a local map for all kinds of things, you just rightclick and drag to move the map ships and planets move with the map, I havnt put code to dynamically move the ships, you do that in the program, but I think its great for my first app. I also included a rotation variable for each ship <br><br></td></tr></table><br>
<a name="1339214"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#88">[#88]</a></td></tr></table></td></tr><tr ><td class="posttext"> forgot to do the midpoint handle, will do it. <br><br></td></tr></table><br>
<a name="1339215"></a>

<a name="1339216"></a>

<a name="1339218"></a>

<a name="1339219"></a>

<a name="1339224"></a>

<a name="1339225"></a>

<a name="1339226"></a>

<a name="1339227"></a>

<a name="1339228"></a>

<a name="1339229"></a>

<a name="1339230"></a>

<a name="1339232"></a>

<a name="1339233"></a>

<a name="1339256"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#89">[#89]</a></td></tr></table></td></tr><tr ><td class="posttext"> <textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Namespace myLetterboxApp

#Import "&lt;std&gt;"
#Import "&lt;mojo&gt;"

Using std..
Using mojo..

#Import "assets/map.png"
#Import "assets/chit1.png"
#Import "assets/chit2.png"
Const Size := New Vec2i( 950,720 )

Const GAMEMODE_INTRO:Int = 1
Const GAMEMODE_GAME:int = 2


Function Main()
	New AppInstance
	
	New MyWindow
	
	App.Run()
End


'this will be the base class for all chits, anything can be a chit
Class Chit
	'this is called when any new thing is derrived from this class
	Method New()
	End Method

	
	'we can now have a different new which can be fed with an int which becomes the energy
	' so New(67) would give you a Chit with 67 rotation
	Method New( twist:Int,chx:Int,chy:int )
		_twist = twist
		_chitx = chx 'just a var to initialise starting posision of chit
		_chity = chy 
	End Method


	'because _twist is private,  we need a property and setter
	' we only then need to access by _chit.Twist = 40,  or twist = _chit.Twist
	'Property Twist:int()
	'	Return _twist
	'Setter( twist:int )
	'	_twist = twist
	'End

    Field _chitx:int = 600
	Field _chity:int = 600
	Field _twist:int = 0
Private
	'how much rotation does the chit start with 0  but we could change this with a different New
	'Field _twist:int = 0
	

	
End Class


Class MyWindow Extends Window

	Method New()
		Super.New( "My Window", Size.X, Size.Y, WindowFlags.Resizable )
	    
		'if you want a constant canvas size use this
'		Layout = "letterbox"
		'or If you want the canvas to always fill the window use this
		Layout = "fill"

		'this is a timer. it will 'tick' 60 times a second. calling OnUpdate
		_timer = New Timer( 60, OnUpdate )
		_maped = Image.Load( "asset::map.png" ) 'I used a 2000x2000 pixel PNG
	
		_unit1 = Image.Load( "asset::chit1.png" ) 'I used a 50x50 pixel PNG
		_unit1.Handle=New Vec2f( .5,.5 )
		_unit2 = Image.Load( "asset::chit2.png" ) 'I used a 50x50 pixel PNG
		_unit2.Handle=New Vec2f( .5,.5 )
        'provide a PNG and variables for every chit on the map
		_chit = New Chit(0,650,650) ' rotatio,X,Y (x,y in relation to the map
		_chit2 = New Chit(68,701,780) ' the map you see starts at -x500 y-500
	End

Protected
	Method OnUpdate()
		RequestRender()
	End Method
	
	
	Method OnRender( canvas:Canvas ) Override

		'fill the screen canvas with a color
		canvas.Color = Color.Black
		canvas.DrawRect( 0, 0, Width, Height )

		Select _gameMode
			Case GAMEMODE_INTRO
				DrawTheIntro( canvas )
			Case GAMEMODE_GAME
				DrawTheGame( canvas )
		End Select
	End


	Method DrawTheGame( canvas:Canvas )
		canvas.Color = Color.White
		'draw the map
		canvas.DrawImage( _maped, _mX, _mY )		
		'draw the chits with a twist
		' debug _twist = _twist + 1
		'If _twisted &gt; 360 Then _twisted = _twisted - 360
        canvas.DrawCircle(800+_mX,  800+_mY,30 ) 'draw	800x800 plus map offset	
		canvas.DrawImage (_unit1, _chit._chitx +_mX, _chit._chity + _mY,_chit._twist )
		canvas.DrawImage (_unit2, _chit2._chitx +_mX, _chit2._chity + _mY,_chit2._twist)
	End Method
	
	
	Method DrawTheIntro( canvas:Canvas )
		canvas.Color = Color.White
	
		canvas.DrawText( " Scroller Map' First App By Mark Ainsworth ref 210665",200,20 )
		canvas.DrawText( " How To Scroll The Map Right Click To Pickup Board, Then Drag it Release to Drop it. ",200,60 )
		canvas.DrawText( " You can Move around the Map By Only RightClicking and Dragging.",200,80 )
		canvas.DrawText("- PRESS ENTER OR LRFT-CLICK MOUSE TO START MAP --&gt;",200,670)
		
	End Method

	
	'respond to any key presses
	Method OnKeyEvent( event:KeyEvent ) Override
		'heres the best way to check for shift keys etc
		Local command:Bool = event.Modifiers &amp; Modifier.Gui
		Local shift:Bool = event.Modifiers &amp; Modifier.Shift
		Local alt:bool = event.Modifiers &amp; Modifier.Alt
		
		Select event.Type
			case EventType.KeyDown
			
				Select event.Key
					Case Key.Enter
						Select _gameMode
							Case GAMEMODE_INTRO
								_gameMode = GAMEMODE_GAME
						End Select
							
				End Select
				
			Case EventType.KeyUp
			
				Select event.Key
					Case Key.Enter
				End Select
				
		End Select
	End

	'here we track the mouse and all mouse related stuff
	Method OnMouseEvent( event:MouseEvent ) Override
		'set up some global mouse cars so we can use these throught to program
		_mouseX = event.Location.X
		_mouseY = event.Location.Y

		'here are the baci mouse events we are interested in
		Select event.Type
			Case EventType.MouseRightClick
				_movemap = 1
				If _movemap = 1 'if you right click record current mouse location
				_oldX = _mX +  -_mouseX 'plus map location
				_oldY = _mY + -_mouseY
				
				Endif

			Case EventType.MouseClick
				Select _gameMode
					Case GAMEMODE_INTRO
						_gameMode = GAMEMODE_GAME
				End Select	
			Case EventType.MouseUp
				_movemap = 0 'if you move the mouse while dragging
				If _movemap = 0 'the map x,y is updated untill you Mouseup
				_oldX = _mX 
				_oldY = _mY 
		
				Endif
			Case EventType.MouseEnter
			Case EventType.MouseLeave
			Case EventType.MouseMove
				If _movemap = 1
					_mX = _mouseX + _oldX - 0
					_mY = _mouseY + _oldY - 0
				Endif	
				End Select					
		
	End Method
	
		Field _mY:Int = -500 'position of map -500 so we start 500 in from top
	    Field _mX:Int = -500 'position of map -500 so we start 500 in from left
		Field _twist:Int  'rotate
		Field _oldX:Int 'used to store map location before you drag
		Field _oldY:Int 'used to store map location before you drag
		Field _movemap:Int 'switch to on to dragmap in conjuction with old position

	'this is needed to allow the Size to be correct. this is called automatically
	Method OnMeasure:Vec2i() Override
		Return Size
	End
Private
	'the timer ticks 60 times a second and handles the screen update
	Field _timer:Timer
	
	'what mode is the game in, showing the intro, playing, ended, etc
	Field _gameMode:Int = GAMEMODE_INTRO
	
	'global mouse vars
	Field _mouseX:Int
	Field _mouseY:Int

	'image assets
	Field _maped:Image ' this is the map png
	Field _unit1:Image ' this is the chit1 png
	Field _unit2:Image ' this is the chit2 png
	'set up some classes' these will need to be newed
	field _chit:Chit ' these are the chits
	field _chit2:Chit ' A secon chit
End

</textarea><br><br><b><br><br><br>I don't know how to do a code box , please advise?<br><br>I didn't want to say what I was working on until I knew what I was doing, but I have made a large scrollable map that your planets and ships can be drawn on. you will have to provide a 2000x2000 png map.png file, and chit1.png and chit2.png 50x50 pixels, but the sizes are not strict.<br><br>this will be of use I'm sure, you could add the map offsets 800+_mX 800+_mY to your planet displays as an example I did a circle in the code, feel free to edit or streamline into the code, its upto you. the code for a mouseclick would just be a test for _mX + _mouseX , _mY + _mouseY<br><br>I also think it will serve as a local map for all kinds of things, you just rightclick and drag to move the map ships and planets move with the map, I havnt put code to dynamically move the ships, you do that in the program, but I think its great for my first app. I also included a rotation variable for each ship<br><br>I think the ships HUD could go on this, it would give a big display area for all kinds of things too. a vast display of cargo &amp; ship or realy big display of onboard weapons, or a really big terminal, honestly Adam its great, just make a class and throw big diplays up all over<br><br>'ok done the midpoint rotation, an easy round button could be turned on the HUD of the big display.<br><br>ADAM IF YOU PUT THIS DISPLAY IN THE CODE AS A CLASS OR SOMETHING I WILL BE HOOKED ON DEVELOPING THIS APP? IT DOSNT HAVE TO USE YOUR PLANETS I'D LIKE IT IF THEY WAS, BUT IF YOU COULD INTERGRATE IT AS A FEATURE TO BE USED IN THE APP<br><br>This large map scrolling was not possible in blitzmax, wow its great, worth upgrading to monkey2 for this </b> <br><br></td></tr></table><br>
<a name="1339217"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#90">[#90]</a></td></tr></table></td></tr><tr ><td class="posttext"> click on "forum codes"<br><img src="http://imgur.com/SqZwNtj.png"><br><br>There will be something like this:<br><img src="http://imgur.com/2NwaI3il.png"><br><br><br>So before you paste your code in the reply box write<br>{codebox}<br>and afterwards<br>{/codebox}<br><br>(of course with the right kind of brackets).<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1339221"></a>

<a name="1339222"></a>

<a name="1339223"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#91">[#91]</a></td></tr></table></td></tr><tr ><td class="posttext"> thx Derron :)<br><br>Adam, if you have seen the app Zun Tzu my App replicates that, and isn't much off being the complete equivalent, except ZunTzu isn't very easy to put your own maps and chits in as this app <br><br></td></tr></table><br>
<a name="1339267"></a>

<a name="1339268"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#92">[#92]</a></td></tr></table></td></tr><tr ><td class="posttext"> Brilliant!!!!!!!!<br><br>ok. I made some changes - DONT BE WORRIED. IT'S ALL GOOD<br><br>changed the chit class to Unit as it just made a bit more sense<br>the unit class now has the drawing stuff moved into it<br><br>Monkey2 uses radians for rotation not degrees, so I added those functions for you<br>mouse right is generally not used, so I moved it to mouse left<br><br>like the concept. a system has finite bounds of 2000x2000 centred at 0,0<br>I have made adjustments to the unit code to support this for you<br><br>I have commented out your old code so you can see how the changes have affected things. Look over the code and get a feel for what I have done ;)<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Namespace myLetterboxApp

#Import "&lt;std&gt;"
#Import "&lt;mojo&gt;"

Using std..
Using mojo..

#Import "assets/map.png"
#Import "assets/chit1.png"
#Import "assets/chit2.png"
Const Size := New Vec2i( 950,720 )

Const GAMEMODE_INTRO:Int = 1
Const GAMEMODE_GAME:int = 2

'ok blitzmax rotations were in degrees - simple ;)
'monkey2 reverts back to radians,  so we need a conversion
'so here is the best and quickest conversion I could come up with ;)
const Pi180:double = Pi / 180
function DegreesToRadian:float( degrees:float )
	return degrees * Pi180
End function
'and we will need another to revrse the process
function RadianToDegrees:float( radian:float )
	return radian / Pi180
End function


Function Main()
	New AppInstance
	
	New MyWindow
	
	App.Run()
End



'lets have some const vars to make me happy
'ive dragged over the const from the universe just so we are talking the same language
const UNIT_BLACKHOLE:int = 0
const UNIT_STAR:int = 1
const UNIT_GASGIANT:int = 2
const UNIT_PLANET:int = 3
const UNIT_MOON:int = 4
const UNIT_ASTEROIDMOON:int = 5
const UNIT_ASTEROID:int = 6
const UNIT_ASTEROIDBELT:int = 7
const UNIT_DUSTBELT:int = 8
const UNIT_NEBULAE:int = 9
const UNIT_RADIATIONBELT:int = 10

'so lets say a ship starts at 100
const UNIT_SHIP:int = 100

'this will be the base class for all chits, anything can be a chit
'ok chit it is - unit would possibly be a better choice though?
'I have converted all int's to floats - this has already bourn fruit with the rotation
'sorry converted chit to unit
Class Unit
	'this is called when any new thing is derrived from this class
	Method New()
	End Method

	
	' so New(67) would give you a Chit with 67 rotation
	Method New( kind:int, chitImage:Image, rotate:float, x:float, y:float )
		'monkey2 uses radians,  so convert from degrees to radian
		_rotate = DegreesToRadian( rotate )

		_x = x+1000 'just a var to initialise starting position of chit
		_y = 1000-y 'remember center 0, 0 is reallt 1000, 1000
		'so we must correct for it
		'AND y is revesed because monkey2 display is from topleft= 0, 0
		'And we want is To be bottom left,  so up means up the sceen And Not down the screen - I know tell me about it!!!!
		
		_kind = kind
		
		_image = chitImage
		_image.Handle = New Vec2f( .5,.5 )
	End Method

	Method New( kind:int, rotate:float, x:float, y:float )
		'monkey2 uses radians,  so convert from degrees to radian
		_rotate = DegreesToRadian( rotate )

		_x = x+1000 'just a var to initialise starting position of chit
		_y = 1000-y 'remember center 0, 0 is reallt 1000, 1000
		'so we must correct for it
		
		_kind = kind

	End Method

	'because _twist is private,  we need a property and setter
	' we only then need to access by _chit.Twist = 40,  or twist = _chit.Twist
	'you can now see here that directly accessing the variables would have caused us a bit more hasslle (in the long term)
	'but using a property/setter,  means the nasty degrees radian stuff lives inside,  and doesn't bother us now
	Property Rotate:float()
		Return RadianToDegrees( _rotate )
	Setter( rotate:float )
		_rotate = DegreesToRadian( rotate )
	End

	Property X:float()
		Return _x-1000
	Setter( x:float )
		_x = x+1000
	End

	Property Y:float()
		Return 1000-_y
	Setter( y:float )
		_y = 1000+y
	End

	Property Kind:int()
		Return _kind
	Setter( kind:int )
		_kind = kind
	End

	
protected
	'ok we now have a draw method that is completely separate from the rest of the app
	'it will need the canvas to draw onto
	method Draw( canvas:Canvas, x:float, y:float )
		'ok lets assume that the unit will draw different things
		'there are two ways of doing it
		'first is the siple way - we'll be doing it this way to begin with
		Select _kind
			Case UNIT_SHIP
				canvas.DrawImage( _image, _x +x, _y + y, _rotate )
				
			Case UNIT_STAR
		        canvas.DrawCircle( _x +x, _y + y, 30 )
		End select
	End method
	
Private
	'this is any image we might be drawing
	field _image:Image
	
	'this is the kind of thing the unit is
	field _kind:int
	
	'and here are some vars to tell us where and what way it's facing
	Field _x:float = 600
	Field _y:float = 600
	Field _rotate:float = 0
End Class


Class MyWindow Extends Window

	Method New()
		Super.New( "My Window", Size.X, Size.Y, WindowFlags.Resizable )
	    
		'if you want a constant canvas size use this
'		Layout = "letterbox"
		'or If you want the canvas to always fill the window use this
		Layout = "fill"

		'this is a timer. it will 'tick' 60 times a second. calling OnUpdate
		_timer = New Timer( 60, OnUpdate )
		_maped = Image.Load( "asset::map.png" ) 'I used a 2000x2000 pixel PNG
	
		'lets now assign these to each chit
		'monkey2 will use internal referenceing systems,  so don't bother about resources
		' we will also deal with the image handle in the chit as well ;)
		Local chitImage1:Image = Image.Load( "asset::chit1.png" )
		Local chitImage2:Image = Image.Load( "asset::chit2.png" )
'		_unit1 = Image.Load( "asset::chit1.png" ) 'I used a 50x50 pixel PNG
'		_unit1.Handle=New Vec2f( .5,.5 )
'		_unit2 = Image.Load( "asset::chit2.png" ) 'I used a 50x50 pixel PNG
'		_unit2.Handle=New Vec2f( .5,.5 )
		
		'just so you feel happy about rotation...
		'0 - shows normal bitmap the right way up points east
		'90 is north, 180 points west, 270 south
		'so. lets assume that chit1 is a ship. to have it point the correct way. the bitmap MUST face EAST!
		
		
        'provide a PNG and variables for every chit on the map
		_chit1 = New Unit( UNIT_SHIP, chitImage1, 0, 150, 150) ' rotation,X,Y (x,y in relation to the map)
		_chit2 = New Unit( UNIT_SHIP, chitImage2, 45, -51, -80) ' the map you see starts at -x500 y-500
		
		'And the star
		_star = New Unit( UNIT_STAR, 45, 0, 0) ' the map you see starts at -x0 y-0
	End

Protected
	Method OnUpdate()
		RequestRender()
	End Method
	
	
	Method OnRender( canvas:Canvas ) Override

		'fill the screen canvas with a color
		canvas.Color = Color.Black
		canvas.DrawRect( 0, 0, Width, Height )

		Select _gameMode
			Case GAMEMODE_INTRO
				DrawTheIntro( canvas )
			Case GAMEMODE_GAME
				DrawTheGame( canvas )
		End Select
	End


	Method DrawTheGame( canvas:Canvas )
		canvas.Color = Color.White
		canvas.Alpha = 1
		
		'draw the map
		canvas.DrawImage( _maped, _mX, _mY )
		'draw the chits with a twist
		' debug _twist = _twist + 1
		'If _twisted &gt; 360 Then _twisted = _twisted - 360
'        canvas.DrawCircle( 800+_mX,  800+_mY,30 ) 'draw	800x800 plus map offset
        
        'lets move these into the chit class
        _star.Draw( canvas, _mX, _mY )
        _chit1.Draw( canvas, _mX, _mY )
        _chit2.Draw( canvas, _mX, _mY )
'		canvas.DrawImage( _unit1, _chit.X +_mX, _chit.Y + _mY,_chit.Rotate )
'		canvas.DrawImage( _unit2, _chit2.X +_mX, _chit2.Y + _mY,_chit2.Rotate )
	End Method
	
	
	Method DrawTheIntro( canvas:Canvas )
		canvas.Color = Color.White
	
		canvas.DrawText( " Scroller Map' First App By Mark Ainsworth ref 210665",200,20 )
		canvas.DrawText( " How To Scroll The Map Right Click To Pickup Board, Then Drag it Release to Drop it. ",200,60 )
		canvas.DrawText( " You can Move around the Map By Only RightClicking and Dragging.",200,80 )
		canvas.DrawText("- PRESS ENTER OR LRFT-CLICK MOUSE TO START MAP --&gt;",200,670)
		
	End Method

	
	'respond to any key presses
	Method OnKeyEvent( event:KeyEvent ) Override
		'heres the best way to check for shift keys etc
		Local command:Bool = event.Modifiers &amp; Modifier.Gui
		Local shift:Bool = event.Modifiers &amp; Modifier.Shift
		Local alt:bool = event.Modifiers &amp; Modifier.Alt
		
		Select event.Type
			case EventType.KeyDown
			
				Select event.Key
					Case Key.Enter
						Select _gameMode
							Case GAMEMODE_INTRO
								_gameMode = GAMEMODE_GAME
						End Select
							
				End Select
				
			Case EventType.KeyUp
			
				Select event.Key
					Case Key.Enter
				End Select
				
		End Select
	End

	'here we track the mouse and all mouse related stuff
	Method OnMouseEvent( event:MouseEvent ) Override
		'set up some global mouse cars so we can use these throught to program
		_mouseX = event.Location.X
		_mouseY = event.Location.Y

		'here are the baci mouse events we are interested in
		Select event.Type
			'removed - avoid using right click. use left click (MouseClick) 
'			Case EventType.MouseLeftClick
'				_movemap = 1
'				If _movemap = 1 'if you right click record current mouse location
'				_oldX = _mX +  -_mouseX 'plus map location
'				_oldY = _mY + -_mouseY
'				
'				Endif

			Case EventType.MouseClick
				Select _gameMode
					Case GAMEMODE_INTRO
						_gameMode = GAMEMODE_GAME
						
					Case GAMEMODE_GAME
						_movemap = 1
						If _movemap = 1 'if you left click record current mouse location
							_oldX = _mX + -_mouseX 'plus map location
							_oldY = _mY + -_mouseY
						Endif
				End Select	
				
			Case EventType.MouseUp
				_movemap = 0 'if you move the mouse while dragging
				If _movemap = 0 'the map x,y is updated untill you Mouseup
					_oldX = _mX 
					_oldY = _mY 
				Endif
			Case EventType.MouseEnter
			Case EventType.MouseLeave
			Case EventType.MouseMove
				If _movemap = 1
					_mX = _mouseX + _oldX - 0
					_mY = _mouseY + _oldY - 0
				Endif
		End Select
		
	End Method
	
		Field _mY:Int = -500 'position of map -500 so we start 500 in from top
		Field _mX:Int = -500 'position of map -500 so we start 500 in from left
		Field _twist:Int  'rotate
		Field _oldX:Int 'used to store map location before you drag
		Field _oldY:Int 'used to store map location before you drag
		Field _movemap:Int 'switch to on to dragmap in conjuction with old position

	'this is needed to allow the Size to be correct. this is called automatically
	Method OnMeasure:Vec2i() Override
		Return Size
	End
Private
	'the timer ticks 60 times a second and handles the screen update
	Field _timer:Timer
	
	'what mode is the game in, showing the intro, playing, ended, etc
	Field _gameMode:Int = GAMEMODE_GAME'INTRO
	
	'global mouse vars
	Field _mouseX:Int
	Field _mouseY:Int

	'image assets
	Field _maped:Image ' this is the map png ' lets say the center is 0, 0
'	Field _unit1:Image ' this is the chit1 png
'	Field _unit2:Image ' this is the chit2 png

	'set up some classes' these will need to be newed
	field _star:Unit 'this is going to be a star
	field _chit1:Unit ' these are the chits
	field _chit2:Unit ' A second chit
End


</textarea> <br><br></td></tr></table><br>
<a name="1339278"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#93">[#93]</a></td></tr></table></td></tr><tr ><td class="posttext"> @ mouse right<br>of course you could use mouse right ... there is no reason for a normal PC user to not use it :-)<br><br>But - if you are on a non "desktop pc" (linux windows) you should consider doing it differently.<br><br>left mouse button + modifier key (left ctrl + left mouse button click = right mouse button click)<br><br>or - do it as Adam suggested and make everything possible with one button. Benefit is then: the Mac users enjoy it (with their onebutton-mouse) and tablet users are able to use it without much hassle (like "two finger hit detection").<br><br><br><br>@ Adam<br>I think you should introduce multiple files - so the "basic" could stay as it is and does not have to get posted here again and again. <br>Also it makes it easier to keep track of what was changed (without doing manual "diffs").<br><br><br>Think if you make that planet drawing "modifyable" people could jump in creating some random planets (with continents etc).<br><br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1339279"></a>

<a name="1339280"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#94">[#94]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok second version.<br><br>What I have done is gone over the code and added 100 'spatial' interval lines, and 0,0 centre lines<br><br>I have added scale/zoom working on the mouse wheel<br><br>I have corrected the map display for this as well as correcting all other display routines<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Namespace myLetterboxApp

#Import "&lt;std&gt;"
#Import "&lt;mojo&gt;"

Using std..
Using mojo..

#Import "assets/map.png"
#Import "assets/chit1.png"
#Import "assets/chit2.png"
Const Size := New Vec2i( 950,720 )

Const GAMEMODE_INTRO:Int = 1
Const GAMEMODE_GAME:int = 2

'ok blitzmax rotations were in degrees - simple ;)
'monkey2 reverts back to radians,  so we need a conversion
'so here is the best and quickest conversion I could come up with ;)
const Pi180:double = Pi / 180
function DegreesToRadian:float( degrees:float )
	return degrees * Pi180
End function
'and we will need another to revrse the process
function RadianToDegrees:float( radian:float )
	return radian / Pi180
End function


Function Main()
	New AppInstance
	
	New MyWindow
	
	App.Run()
End



'lets have some const vars to make me happy
'ive dragged over the const from the universe just so we are talking the same language
const UNIT_BLACKHOLE:int = 0
const UNIT_STAR:int = 1
const UNIT_GASGIANT:int = 2
const UNIT_PLANET:int = 3
const UNIT_MOON:int = 4
const UNIT_ASTEROIDMOON:int = 5
const UNIT_ASTEROID:int = 6
const UNIT_ASTEROIDBELT:int = 7
const UNIT_DUSTBELT:int = 8
const UNIT_NEBULAE:int = 9
const UNIT_RADIATIONBELT:int = 10

'so lets say a ship starts at 100
const UNIT_SHIP:int = 100

'this will be the base class for all chits, anything can be a chit
'ok chit it is - unit would possibly be a better choice though?
'I have converted all int's to floats - this has already bourn fruit with the rotation
'sorry converted chit to unit
Class Unit
	'this is called when any new thing is derrived from this class
	Method New()
	End Method

	
	' so New(67) would give you a Chit with 67 rotation
	Method New( kind:int, chitImage:Image, rotate:float, x:float, y:float )
		'monkey2 uses radians,  so convert from degrees to radian
		_rotate = DegreesToRadian( rotate )

		_x = x 'just a var to initialise starting position of chit
		_y = y
		
		_kind = kind
		
		_image = chitImage
		_image.Handle = New Vec2f( .5,.5 )
	End Method

	Method New( kind:int, rotate:float, x:float, y:float )
		'monkey2 uses radians,  so convert from degrees to radian
		_rotate = DegreesToRadian( rotate )

		_x = x 'just a var to initialise starting position of chit
		_y = y
		
		_kind = kind

	End Method

	'because _twist is private,  we need a property and setter
	' we only then need to access by _chit.Twist = 40,  or twist = _chit.Twist
	'you can now see here that directly accessing the variables would have caused us a bit more hasslle (in the long term)
	'but using a property/setter,  means the nasty degrees radian stuff lives inside,  and doesn't bother us now
	Property Rotate:float()
		Return RadianToDegrees( _rotate )
	Setter( rotate:float )
		_rotate = DegreesToRadian( rotate )
	End

	Property X:float()
		Return _x
	Setter( x:float )
		_x = x
	End

	Property Y:float()
		Return _y
	Setter( y:float )
		_y = y
	End

	Property Kind:int()
		Return _kind
	Setter( kind:int )
		_kind = kind
	End

	
protected
	'ok we now have a draw method that is completely separate from the rest of the app
	'it will need the canvas to draw onto
	method Draw( canvas:Canvas, x:float, y:float, scale:float )
		'ok lets assume that the unit will draw different things
		'there are two ways of doing it
		'first is the siple way - we'll be doing it this way to begin with
		local xx:float = (_x * scale) + x
		local yy:float = y - (_y * scale) 'this is inverted!!!!
		Select _kind
			Case UNIT_SHIP
				canvas.DrawImage( _image, xx, yy, _rotate, scale, scale )
				
			Case UNIT_STAR
		        canvas.DrawCircle( xx, yy, 30*scale )
		End select
	End method
	
Private
	'this is any image we might be drawing
	field _image:Image
	
	'this is the kind of thing the unit is
	field _kind:int
	
	'and here are some vars to tell us where and what way it's facing
	Field _x:float = 600
	Field _y:float = 600
	Field _rotate:float = 0
End Class



Class MyWindow Extends Window

	Method New()
		Super.New( "My Window", Size.X, Size.Y, WindowFlags.Resizable )
	    
		'if you want a constant canvas size use this
'		Layout = "letterbox"
		'or If you want the canvas to always fill the window use this
		Layout = "fill"

		'this is a timer. it will 'tick' 60 times a second. calling OnUpdate
		_timer = New Timer( 60, OnUpdate )
		_maped = Image.Load( "asset::map.png" ) 'I used a 2000x2000 pixel PNG
		_maped.Handle=New Vec2f( .5,.5 )
	
		'lets now assign these to each chit
		'monkey2 will use internal referenceing systems,  so don't bother about resources
		' we will also deal with the image handle in the chit as well ;)
		Local chitImage1:Image = Image.Load( "asset::chit1.png" )
		Local chitImage2:Image = Image.Load( "asset::chit2.png" )
		
		'just so you feel happy about rotation...
		'0 - shows normal bitmap the right way up points east
		'90 is north, 180 points west, 270 south
		'so. lets assume that chit1 is a ship. to have it point the correct way. the bitmap MUST face EAST!
		
        'provide a PNG and variables for every chit on the map
		_chit1 = New Unit( UNIT_SHIP, chitImage1, 0, 150, 150) ' rotation,X,Y (x,y in relation to the map)
		_chit2 = New Unit( UNIT_SHIP, chitImage2, 45, -51, -80) ' the map you see starts at -x500 y-500
		
		'And the star
		_star = New Unit( UNIT_STAR, 45, 0, 0) ' the map you see starts at -x0 y-0
	End

Protected
	Method OnUpdate()
		RequestRender()
	End Method
	
	
	Method OnRender( canvas:Canvas ) Override

		'fill the screen canvas with a color
		canvas.Color = Color.Black
		canvas.DrawRect( 0, 0, Width, Height )

		Select _gameMode
			Case GAMEMODE_INTRO
				DrawTheIntro( canvas )
			Case GAMEMODE_GAME
				DrawTheGame( canvas )
		End Select
	End


	Method DrawTheGame( canvas:Canvas )
		'find the midpoint from where all drawing is based
		Local midX:float = (Width * 0.5) + _mX
		Local midY:float = (Height * 0.5) + _mY
		
		'draw the mapimage
		canvas.Alpha = 1
		canvas.Color = Color.Grey
		canvas.DrawImage( _maped, midX, midY, 0, _scale, _scale )
		
		'draw the 100 lines (100 spatial positions)
		Local k:float
		Local sc:float
		canvas.Color = Color.DarkGrey
		canvas.Alpha = 0.3
		Local xoffset:float = midX Mod (100 * _scale)
		Local yoffset:float = midY Mod (100 * _scale)
		For k = xoffset To Width Step (100 * _scale)
			canvas.DrawLine( k,  0, k, Height )
		Next
		For k = yoffset To Height Step (100 * _scale)
			canvas.DrawLine( 0, k, Width, k )
		Next
		
		'draw the center of the map lines
		canvas.Color = Color.Grey
		canvas.DrawLine( midX, 0, midX, Height )
		canvas.DrawLine( 0, midY, Width, midY )
		
		
        'lets move these into the unit class
		canvas.Color = Color.White
		canvas.Alpha = 1
		
		canvas.DrawText( _scale, 10, 10 )
		canvas.DrawText( _mX+" "+_mY, 10, 30 )

        _star.Draw( canvas, midX, midY, _scale )
        _chit1.Draw( canvas, midX, midY, _scale )
        _chit2.Draw( canvas, midX, midY, _scale )
	End Method
	
	
	Method DrawTheIntro( canvas:Canvas )
		canvas.Color = Color.White
	
		canvas.DrawText( " Scroller Map' First App By Mark Ainsworth ref 210665",200,20 )
		canvas.DrawText( " How To Scroll The Map Right Click To Pickup Board, Then Drag it Release to Drop it. ",200,60 )
		canvas.DrawText( " You can Move around the Map By Only RightClicking and Dragging.",200,80 )
		canvas.DrawText("- PRESS ENTER OR LRFT-CLICK MOUSE TO START MAP --&gt;",200,670)
		
	End Method

	
	'respond to any key presses
	Method OnKeyEvent( event:KeyEvent ) Override
		'heres the best way to check for shift keys etc
		Local command:Bool = event.Modifiers &amp; Modifier.Gui
		Local shift:Bool = event.Modifiers &amp; Modifier.Shift
		Local alt:bool = event.Modifiers &amp; Modifier.Alt
		
		Select event.Type
			case EventType.KeyDown
			
				Select event.Key
					Case Key.Enter
						Select _gameMode
							Case GAMEMODE_INTRO
								_gameMode = GAMEMODE_GAME
						End Select
							
				End Select
				
			Case EventType.KeyUp
			
				Select event.Key
					Case Key.Enter
				End Select
				
		End Select
	End

	'here we track the mouse and all mouse related stuff
	Method OnMouseEvent( event:MouseEvent ) Override
		'set up some global mouse cars so we can use these throught to program
		_mouseX = event.Location.X
		_mouseY = event.Location.Y

		'here are the baci mouse events we are interested in
		Select event.Type
			Case EventType.MouseClick
				Select _gameMode
					Case GAMEMODE_INTRO
						_gameMode = GAMEMODE_GAME
						
					Case GAMEMODE_GAME
						_movemap = 1
						If _movemap = 1 'if you left click record current mouse location
							_oldX = _mX + -_mouseX 'plus map location
							_oldY = _mY + -_mouseY
						Endif
				End Select	
				
			Case EventType.MouseUp
				_movemap = 0 'if you move the mouse while dragging
				If _movemap = 0 'the map x,y is updated untill you Mouseup
					_oldX = _mX 
					_oldY = _mY 
				Endif
			Case EventType.MouseEnter
			Case EventType.MouseLeave
			case EventType.MouseWheel
				If event.Wheel.Y &lt;&gt; 0 Then
					_scale = Clamp( _scale + event.Wheel.Y * 0.01, 0.25, 4.0 )
				End If
			Case EventType.MouseMove
				If _movemap = 1
					_mX = _mouseX + _oldX - 0
					_mY = _mouseY + _oldY - 0
				Endif
		End Select
		
	End Method
	
		Field _mY:Int = 0 'position of map -500 so we start 500 in from top
		Field _mX:Int = 0 'position of map -500 so we start 500 in from left
		Field _twist:Int  'rotate
		Field _oldX:Int 'used to store map location before you drag
		Field _oldY:Int 'used to store map location before you drag
		Field _movemap:Int 'switch to on to dragmap in conjuction with old position

	'this is needed to allow the Size to be correct. this is called automatically
	Method OnMeasure:Vec2i() Override
		Return Size
	End
Private
	'the timer ticks 60 times a second and handles the screen update
	Field _timer:Timer
	
	'what mode is the game in, showing the intro, playing, ended, etc
	Field _gameMode:Int = GAMEMODE_GAME'INTRO
	
	'global mouse vars
	Field _mouseX:Int
	Field _mouseY:Int
	
	field _scale:float = 1

	'image assets
	Field _maped:Image ' this is the map png ' lets say the center is 0, 0

	'set up some classes' these will need to be newed
	field _star:Unit 'this is going to be a star
	field _chit1:Unit ' these are the chits
	field _chit2:Unit ' A second chit
End


</textarea><br><br>NOTE<br>I have used some nice but weird code to get correct x/y offsets for the spatial lines<br><br>I have updated the unit drawing routines so the image/items are also drawn properly scaled<br><br>All scaling is operated from the 0,0 centre point <br><br></td></tr></table><br>
<a name="1339281"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#95">[#95]</a></td></tr></table></td></tr><tr ><td class="posttext"> here's the images I knocked quickly and am using:<br>chit 1/2 - the ships<br><img src="https://vjointeractive.files.wordpress.com/2017/04/chit1.png"><br><img src="https://vjointeractive.files.wordpress.com/2017/04/chit2.png"><br><br>and the starmap background<br><img src="https://vjointeractive.files.wordpress.com/2017/04/map.png"><br><br>I am not a fan of the big 2000x2000 image, but it will do currently and is good for testing. I do have a though on how this can be done, so we''l just keep it at the moment :) <br><br></td></tr></table><br>
<a name="1339282"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#96">[#96]</a></td></tr></table></td></tr><tr ><td class="posttext"> next version. removed the chits and star and replaced with an array _units[]<br><br>I will make a new class that will manage these for us next<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Namespace myLetterboxApp

#Import "&lt;std&gt;"
#Import "&lt;mojo&gt;"

Using std..
Using mojo..

#Import "assets/map.png"
#Import "assets/chit1.png"
#Import "assets/chit2.png"
Const Size := New Vec2i( 950,720 )

Const GAMEMODE_INTRO:Int = 1
Const GAMEMODE_GAME:int = 2

'ok blitzmax rotations were in degrees - simple ;)
'monkey2 reverts back to radians,  so we need a conversion
'so here is the best and quickest conversion I could come up with ;)
const Pi180:double = Pi / 180
function DegreesToRadian:float( degrees:float )
	return degrees * Pi180
End function
'and we will need another to revrse the process
function RadianToDegrees:float( radian:float )
	return radian / Pi180
End function


Function Main()
	New AppInstance
	
	New MyWindow
	
	App.Run()
End

'what will be the maximum number of units avaialable
' a unit is anything like a planet or ship,  so we need 16 for the base planets stuff and...
' lets say 100 other units
' a missile could be classed as a unit as well,  so lets have 256 units
const MAX_UNITS:int = 256


'lets have some const vars to make me happy
'ive dragged over the const from the universe just so we are talking the same language
const UNIT_BLACKHOLE:int = 0
const UNIT_STAR:int = 1
const UNIT_GASGIANT:int = 2
const UNIT_PLANET:int = 3
const UNIT_MOON:int = 4
const UNIT_ASTEROIDMOON:int = 5
const UNIT_ASTEROID:int = 6
const UNIT_ASTEROIDBELT:int = 7
const UNIT_DUSTBELT:int = 8
const UNIT_NEBULAE:int = 9
const UNIT_RADIATIONBELT:int = 10

'so lets say a ship starts at 100
const UNIT_SHIP:int = 100

'this will be the base class for all chits, anything can be a chit
'ok chit it is - unit would possibly be a better choice though?
'I have converted all int's to floats - this has already bourn fruit with the rotation
'sorry converted chit to unit
Class Unit
	'this is called when any new thing is derrived from this class
	Method New()
	End Method

	
	' so New(67) would give you a Chit with 67 rotation
	Method New( kind:int, chitImage:Image, rotate:float, x:float, y:float )
		'monkey2 uses radians,  so convert from degrees to radian
		_rotate = DegreesToRadian( rotate )

		_x = x 'just a var to initialise starting position of chit
		_y = y
		
		_kind = kind
		
		_image = chitImage
		_image.Handle = New Vec2f( .5,.5 )
	End Method

	Method New( kind:int, rotate:float, x:float, y:float )
		'monkey2 uses radians,  so convert from degrees to radian
		_rotate = DegreesToRadian( rotate )

		_x = x 'just a var to initialise starting position of chit
		_y = y
		
		_kind = kind

	End Method

	'because _twist is private,  we need a property and setter
	' we only then need to access by _chit.Twist = 40,  or twist = _chit.Twist
	'you can now see here that directly accessing the variables would have caused us a bit more hasslle (in the long term)
	'but using a property/setter,  means the nasty degrees radian stuff lives inside,  and doesn't bother us now
	Property Rotate:float()
		Return RadianToDegrees( _rotate )
	Setter( rotate:float )
		_rotate = DegreesToRadian( rotate )
	End

	Property X:float()
		Return _x
	Setter( x:float )
		_x = x
	End

	Property Y:float()
		Return _y
	Setter( y:float )
		_y = y
	End

	Property Kind:int()
		Return _kind
	Setter( kind:int )
		_kind = kind
	End

	
protected
	'ok we now have a draw method that is completely separate from the rest of the app
	'it will need the canvas to draw onto
	method Draw( canvas:Canvas, x:float, y:float, scale:float )
		'ok lets assume that the unit will draw different things
		'there are two ways of doing it
		'first is the siple way - we'll be doing it this way to begin with
		local xx:float = (_x * scale) + x
		local yy:float = y - (_y * scale) 'this is inverted!!!!
		Select _kind
			Case UNIT_SHIP
				canvas.DrawImage( _image, xx, yy, _rotate, scale, scale )
				
			Case UNIT_STAR
		        canvas.DrawCircle( xx, yy, 30*scale )
		End select
	End method
	
Private
	'this is any image we might be drawing
	field _image:Image
	
	'this is the kind of thing the unit is
	field _kind:int
	
	'and here are some vars to tell us where and what way it's facing
	Field _x:float = 600
	Field _y:float = 600
	Field _rotate:float = 0
End Class



Class MyWindow Extends Window

	Method New()
		Super.New( "My Window", Size.X, Size.Y, WindowFlags.Resizable )
	    
		'if you want a constant canvas size use this
'		Layout = "letterbox"
		'or If you want the canvas to always fill the window use this
		Layout = "fill"

		'this is a timer. it will 'tick' 60 times a second. calling OnUpdate
		_timer = New Timer( 60, OnUpdate )
		_maped = Image.Load( "asset::map.png" ) 'I used a 2000x2000 pixel PNG
		_maped.Handle=New Vec2f( .5,.5 )
	
		'lets now assign these to each chit
		'monkey2 will use internal referenceing systems,  so don't bother about resources
		' we will also deal with the image handle in the chit as well ;)
		Local chitImage1:Image = Image.Load( "asset::chit1.png" )
		Local chitImage2:Image = Image.Load( "asset::chit2.png" )
		
		'just so you feel happy about rotation...
		'0 - shows normal bitmap the right way up points east
		'90 is north, 180 points west, 270 south
		'so. lets assume that chit1 is a ship. to have it point the correct way. the bitmap MUST face EAST!
		
        'provide a PNG and variables for every chit on the map
		_unit[0] = New Unit( UNIT_SHIP, chitImage1, 0, 150, 150) ' rotation,X,Y (x,y in relation to the map)
		_unit[1] = New Unit( UNIT_SHIP, chitImage2, 45, -51, -80) ' the map you see starts at -x500 y-500
		
		'And the star
		_unit[2] = New Unit( UNIT_STAR, 45, 0, 0) ' the map you see starts at -x0 y-0
	End

Protected
	Method OnUpdate()
		RequestRender()
	End Method
	
	
	Method OnRender( canvas:Canvas ) Override

		'fill the screen canvas with a color
		canvas.Color = Color.Black
		canvas.DrawRect( 0, 0, Width, Height )

		Select _gameMode
			Case GAMEMODE_INTRO
				DrawTheIntro( canvas )
			Case GAMEMODE_GAME
				DrawTheGame( canvas )
		End Select
	End


	method DrawMap( canvas:Canvas, midX:float, midY:float )
		'draw the mapimage
		canvas.Alpha = 1
		canvas.Color = Color.Grey
		canvas.DrawImage( _maped, midX, midY, 0, _scale, _scale )
		
		'draw the 100 lines (100 spatial positions)
		Local k:float
		Local sc:float
		canvas.Color = Color.DarkGrey
		canvas.Alpha = 0.3
		Local xoffset:float = midX Mod (100 * _scale)
		Local yoffset:float = midY Mod (100 * _scale)
		For k = xoffset To Width Step (100 * _scale)
			canvas.DrawLine( k,  0, k, Height )
		Next
		For k = yoffset To Height Step (100 * _scale)
			canvas.DrawLine( 0, k, Width, k )
		Next
		
		'draw the center of the map lines
		canvas.Color = Color.Grey
		canvas.DrawLine( midX, 0, midX, Height )
		canvas.DrawLine( 0, midY, Width, midY )
	End method
	
	
	Method DrawTheGame( canvas:Canvas )
		'find the midpoint from where all drawing is based
		Local midX:float = (Width * 0.5) + _mX
		Local midY:float = (Height * 0.5) + _mY
		
		
		'draw the map in a seperate method
		DrawMap( canvas, midX, midY )
		
        'lets move these into the unit class
		canvas.Color = Color.White
		canvas.Alpha = 1
		
        _unit[0].Draw( canvas, midX, midY, _scale )
        _unit[1].Draw( canvas, midX, midY, _scale )
        _unit[2].Draw( canvas, midX, midY, _scale )
	End Method
	
	
	Method DrawTheIntro( canvas:Canvas )
		canvas.Color = Color.White
	
		canvas.DrawText( " Scroller Map' First App By Mark Ainsworth ref 210665",200,20 )
		canvas.DrawText( " How To Scroll The Map Right Click To Pickup Board, Then Drag it Release to Drop it. ",200,60 )
		canvas.DrawText( " You can Move around the Map By Only RightClicking and Dragging.",200,80 )
		canvas.DrawText("- PRESS ENTER OR LRFT-CLICK MOUSE TO START MAP --&gt;",200,670)
		
	End Method

	
	'respond to any key presses
	Method OnKeyEvent( event:KeyEvent ) Override
		'heres the best way to check for shift keys etc
		Local command:Bool = event.Modifiers &amp; Modifier.Gui
		Local shift:Bool = event.Modifiers &amp; Modifier.Shift
		Local alt:bool = event.Modifiers &amp; Modifier.Alt
		
		Select event.Type
			case EventType.KeyDown
			
				Select event.Key
					Case Key.Enter
						Select _gameMode
							Case GAMEMODE_INTRO
								_gameMode = GAMEMODE_GAME
						End Select
							
				End Select
				
			Case EventType.KeyUp
			
				Select event.Key
					Case Key.Enter
				End Select
				
		End Select
	End

	'here we track the mouse and all mouse related stuff
	Method OnMouseEvent( event:MouseEvent ) Override
		'set up some global mouse cars so we can use these throught to program
		_mouseX = event.Location.X
		_mouseY = event.Location.Y

		'here are the baci mouse events we are interested in
		Select event.Type
			Case EventType.MouseClick
				Select _gameMode
					Case GAMEMODE_INTRO
						_gameMode = GAMEMODE_GAME
						
					Case GAMEMODE_GAME
						_movemap = 1
						If _movemap = 1 'if you left click record current mouse location
							_oldX = _mX + -_mouseX 'plus map location
							_oldY = _mY + -_mouseY
						Endif
				End Select	
				
			Case EventType.MouseUp
				_movemap = 0 'if you move the mouse while dragging
				If _movemap = 0 'the map x,y is updated untill you Mouseup
					_oldX = _mX 
					_oldY = _mY 
				Endif
			Case EventType.MouseEnter
			Case EventType.MouseLeave
			case EventType.MouseWheel
				If event.Wheel.Y &lt;&gt; 0 Then
					_scale = Clamp( _scale + event.Wheel.Y * 0.01, 0.25, 4.0 )
				End If
			Case EventType.MouseMove
				If _movemap = 1
					_mX = _mouseX + _oldX - 0
					_mY = _mouseY + _oldY - 0
				Endif
		End Select
		
	End Method
	
	'this is needed to allow the Size to be correct. this is called automatically
	Method OnMeasure:Vec2i() Override
		Return Size
	End
Private
	'the timer ticks 60 times a second and handles the screen update
	Field _timer:Timer
	
	'what mode is the game in, showing the intro, playing, ended, etc
	Field _gameMode:Int = GAMEMODE_GAME'INTRO
	
	'global mouse vars
	Field _mouseX:Int
	Field _mouseY:Int
	
	field _scale:float = 1

	Field _mY:Int = 0 'position of map -500 so we start 500 in from top
	Field _mX:Int = 0 'position of map -500 so we start 500 in from left
'	Field _twist:Int  'rotate
	Field _oldX:Int 'used to store map location before you drag
	Field _oldY:Int 'used to store map location before you drag
	Field _movemap:Int 'switch to on to dragmap in conjuction with old position


	'image assets
	Field _maped:Image ' this is the map png ' lets say the center is 0, 0

	'set up some classes' these will need to be newed
	field _unit:Unit[] = New Unit[ MAX_UNITS ]
End


</textarea> <br><br></td></tr></table><br>
<a name="1339286"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#97">[#97]</a></td></tr></table></td></tr><tr ><td class="posttext"> next version introducing a unitmanager<br><br>basically all the units are now added to the manager,<br>when we come to draw them, we let the manager deal with it.<br><br>What this means is the unit class and manager are now separate from the main program. later we will start splitting up the main text file into smaller ones (modules if you want to call them that...)<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Namespace myLetterboxApp

#Import "&lt;std&gt;"
#Import "&lt;mojo&gt;"

Using std..
Using mojo..

#Import "assets/map.png"
#Import "assets/chit1.png"
#Import "assets/chit2.png"
Const Size := New Vec2i( 950,720 )

Const GAMEMODE_INTRO:Int = 1
Const GAMEMODE_GAME:int = 2

'ok blitzmax rotations were in degrees - simple ;)
'monkey2 reverts back to radians,  so we need a conversion
'so here is the best and quickest conversion I could come up with ;)
const Pi180:double = Pi / 180
function DegreesToRadian:float( degrees:float )
	return degrees * Pi180
End function
'and we will need another to revrse the process
function RadianToDegrees:float( radian:float )
	return radian / Pi180
End function


Function Main()
	New AppInstance
	
	New MyWindow
	
	App.Run()
End

'this is now moved into the unit manager
'what will be the maximum number of units avaialable
' a unit is anything like a planet or ship,  so we need 16 for the base planets stuff and...
' lets say 100 other units
' a missile could be classed as a unit as well,  so lets have 256 units
'const MAX_UNITS:int = 256


'lets have some const vars to make me happy
'ive dragged over the const from the universe just so we are talking the same language
const UNIT_BLACKHOLE:int = 0
const UNIT_STAR:int = 1
const UNIT_GASGIANT:int = 2
const UNIT_PLANET:int = 3
const UNIT_MOON:int = 4
const UNIT_ASTEROIDMOON:int = 5
const UNIT_ASTEROID:int = 6
const UNIT_ASTEROIDBELT:int = 7
const UNIT_DUSTBELT:int = 8
const UNIT_NEBULAE:int = 9
const UNIT_RADIATIONBELT:int = 10

'so lets say a ship starts at 100
const UNIT_SHIP:int = 100

'this will be the base class for all chits, anything can be a chit
'ok chit it is - unit would possibly be a better choice though?
'I have converted all int's to floats - this has already bourn fruit with the rotation
'sorry converted chit to unit
Class Unit
	'this is called when any new thing is derrived from this class
	Method New()
	End Method

	
	' so New(67) would give you a Chit with 67 rotation
	Method New( kind:int, chitImage:Image, rotate:float, x:float, y:float )
		'monkey2 uses radians,  so convert from degrees to radian
		_rotate = DegreesToRadian( rotate )

		_x = x 'just a var to initialise starting position of chit
		_y = y
		
		_kind = kind
		
		_image = chitImage
		_image.Handle = New Vec2f( .5,.5 )
	End Method

	Method New( kind:int, rotate:float, x:float, y:float )
		'monkey2 uses radians,  so convert from degrees to radian
		_rotate = DegreesToRadian( rotate )

		_x = x 'just a var to initialise starting position of chit
		_y = y
		
		_kind = kind

	End Method

	'because _twist is private,  we need a property and setter
	' we only then need to access by _chit.Twist = 40,  or twist = _chit.Twist
	'you can now see here that directly accessing the variables would have caused us a bit more hasslle (in the long term)
	'but using a property/setter,  means the nasty degrees radian stuff lives inside,  and doesn't bother us now
	Property Rotate:float()
		Return RadianToDegrees( _rotate )
	Setter( rotate:float )
		_rotate = DegreesToRadian( rotate )
	End

	Property X:float()
		Return _x
	Setter( x:float )
		_x = x
	End

	Property Y:float()
		Return _y
	Setter( y:float )
		_y = y
	End

	Property Kind:int()
		Return _kind
	Setter( kind:int )
		_kind = kind
	End

	
protected
	'ok we now have a draw method that is completely separate from the rest of the app
	'it will need the canvas to draw onto
	method Draw( canvas:Canvas, x:float, y:float, scale:float )
		'ok lets assume that the unit will draw different things
		'there are two ways of doing it
		'first is the siple way - we'll be doing it this way to begin with
		local xx:float = (_x * scale) + x
		local yy:float = y - (_y * scale) 'this is inverted!!!!
		Select _kind
			Case UNIT_SHIP
				canvas.DrawImage( _image, xx, yy, _rotate, scale, scale )
				
			Case UNIT_STAR
		        canvas.DrawCircle( xx, yy, 30*scale )
		End select
	End method
	
Private
	'this is any image we might be drawing
	field _image:Image
	
	'this is the kind of thing the unit is
	field _kind:int
	
	'and here are some vars to tell us where and what way it's facing
	Field _x:float = 600
	Field _y:float = 600
	Field _rotate:float = 0
End Class



class UnitManager
	'what will be the maximum number of units avaialable
	' a unit is anything like a planet or ship,  so we need 16 for the base planets stuff and...
	' lets say 100 other units
	' a missile could be classed as a unit as well,  so lets have 256 units
	const MAX_UNITS:int = 256

	method New()
	End method
	
	method AddShip( kind:int, chitImage:Image, rotate:float, x:float, y:float )
		_unit[ _count ] = New Unit( kind, chitImage, rotate, x, y)
		_count += 1
	End method

	method AddPlanet( kind:int, rotate:float, x:float, y:float )
		_unit[ _count ] = New Unit( kind, rotate, x, y)
		_count += 1
	End method
	
	method Draw( canvas:Canvas, midX:float, midY:float, scale:float )
		Local k:int
		For k = 0 Until _count
			_unit[k].Draw( canvas, midX, midY, scale )
		Next
	End method
	
private
	'the units we have
	field _unit:Unit[] = New Unit[ MAX_UNITS ]
	
	'how many units we have got
	field _count:int = 0

End Class



Class MyWindow Extends Window

	Method New()
		Super.New( "My Window", Size.X, Size.Y, WindowFlags.Resizable )
	    
		'if you want a constant canvas size use this
'		Layout = "letterbox"
		'or If you want the canvas to always fill the window use this
		Layout = "fill"

		'this is a timer. it will 'tick' 60 times a second. calling OnUpdate
		_timer = New Timer( 60, OnUpdate )
		_maped = Image.Load( "asset::map.png" ) 'I used a 2000x2000 pixel PNG
		_maped.Handle=New Vec2f( .5,.5 )
	
		'lets now assign these to each chit
		'monkey2 will use internal referenceing systems,  so don't bother about resources
		' we will also deal with the image handle in the chit as well ;)
		Local chitImage1:Image = Image.Load( "asset::chit1.png" )
		Local chitImage2:Image = Image.Load( "asset::chit2.png" )
		
		'just so you feel happy about rotation...
		'0 - shows normal bitmap the right way up points east
		'90 is north, 180 points west, 270 south
		'so. lets assume that chit1 is a ship. to have it point the correct way. the bitmap MUST face EAST!
		
        'provide a PNG and variables for every chit on the map
        _unitManager.AddShip( UNIT_SHIP, chitImage1, 0, 150, 150 )
        _unitManager.AddShip( UNIT_SHIP, chitImage2, 45, -51, -80 )
'		_unit[0] = New Unit( UNIT_SHIP, chitImage1, 0, 150, 150) ' rotation,X,Y (x,y in relation to the map)
'		_unit[1] = New Unit( UNIT_SHIP, chitImage2, 45, -51, -80) ' the map you see starts at -x500 y-500
		
		'And the star
        _unitManager.AddPlanet( UNIT_STAR, 45, 0, 0 )
'		_unit[2] = New Unit( UNIT_STAR, 45, 0, 0) ' the map you see starts at -x0 y-0
	End

Protected
	Method OnUpdate()
		RequestRender()
	End Method
	
	
	Method OnRender( canvas:Canvas ) Override

		'fill the screen canvas with a color
		canvas.Color = Color.Black
		canvas.DrawRect( 0, 0, Width, Height )

		Select _gameMode
			Case GAMEMODE_INTRO
				DrawTheIntro( canvas )
			Case GAMEMODE_GAME
				DrawTheGame( canvas )
		End Select
	End


	method DrawMap( canvas:Canvas, midX:float, midY:float )
		'draw the mapimage
		canvas.Alpha = 1
		canvas.Color = Color.Grey
		canvas.DrawImage( _maped, midX, midY, 0, _scale, _scale )
		
		'draw the 100 lines (100 spatial positions)
		Local k:float
		Local sc:float
		canvas.Color = Color.DarkGrey
		canvas.Alpha = 0.3
		Local xoffset:float = midX Mod (100 * _scale)
		Local yoffset:float = midY Mod (100 * _scale)
		For k = xoffset To Width Step (100 * _scale)
			canvas.DrawLine( k,  0, k, Height )
		Next
		For k = yoffset To Height Step (100 * _scale)
			canvas.DrawLine( 0, k, Width, k )
		Next
		
		'draw the center of the map lines
		canvas.Color = Color.Grey
		canvas.DrawLine( midX, 0, midX, Height )
		canvas.DrawLine( 0, midY, Width, midY )
	End method
	
	
	Method DrawTheGame( canvas:Canvas )
		'find the midpoint from where all drawing is based
		Local midX:float = (Width * 0.5) + _mX
		Local midY:float = (Height * 0.5) + _mY
		
		
		'draw the map in a seperate method
		DrawMap( canvas, midX, midY )
		
        'lets move these into the unit class
		canvas.Color = Color.White
		canvas.Alpha = 1
		
		'we now have a unitmanager to handle all the units,  so just one call to it's draw rotine
		' will allow it to do the rest
		_unitManager.Draw( canvas, midX, midY, _scale )
'        _unit[1].Draw( canvas, midX, midY, _scale )
'       _unit[2].Draw( canvas, midX, midY, _scale )
	End Method
	
	
	Method DrawTheIntro( canvas:Canvas )
		canvas.Color = Color.White
	
		canvas.DrawText( " Scroller Map' First App By Mark Ainsworth ref 210665",200,20 )
		canvas.DrawText( " How To Scroll The Map Right Click To Pickup Board, Then Drag it Release to Drop it. ",200,60 )
		canvas.DrawText( " You can Move around the Map By Only RightClicking and Dragging.",200,80 )
		canvas.DrawText("- PRESS ENTER OR LRFT-CLICK MOUSE TO START MAP --&gt;",200,670)
		
	End Method

	
	'respond to any key presses
	Method OnKeyEvent( event:KeyEvent ) Override
		'heres the best way to check for shift keys etc
		Local command:Bool = event.Modifiers &amp; Modifier.Gui
		Local shift:Bool = event.Modifiers &amp; Modifier.Shift
		Local alt:bool = event.Modifiers &amp; Modifier.Alt
		
		Select event.Type
			case EventType.KeyDown
			
				Select event.Key
					Case Key.Enter
						Select _gameMode
							Case GAMEMODE_INTRO
								_gameMode = GAMEMODE_GAME
						End Select
							
				End Select
				
			Case EventType.KeyUp
			
				Select event.Key
					Case Key.Enter
				End Select
				
		End Select
	End

	'here we track the mouse and all mouse related stuff
	Method OnMouseEvent( event:MouseEvent ) Override
		'set up some global mouse cars so we can use these throught to program
		_mouseX = event.Location.X
		_mouseY = event.Location.Y

		'here are the baci mouse events we are interested in
		Select event.Type
			Case EventType.MouseClick
				Select _gameMode
					Case GAMEMODE_INTRO
						_gameMode = GAMEMODE_GAME
						
					Case GAMEMODE_GAME
						_movemap = 1
						If _movemap = 1 'if you left click record current mouse location
							_oldX = _mX + -_mouseX 'plus map location
							_oldY = _mY + -_mouseY
						Endif
				End Select	
				
			Case EventType.MouseUp
				_movemap = 0 'if you move the mouse while dragging
				If _movemap = 0 'the map x,y is updated untill you Mouseup
					_oldX = _mX 
					_oldY = _mY 
				Endif
			Case EventType.MouseEnter
			Case EventType.MouseLeave
			case EventType.MouseWheel
				If event.Wheel.Y &lt;&gt; 0 Then
					_scale = Clamp( _scale + event.Wheel.Y * 0.01, 0.25, 4.0 )
				End If
			Case EventType.MouseMove
				If _movemap = 1
					_mX = _mouseX + _oldX - 0
					_mY = _mouseY + _oldY - 0
				Endif
		End Select
		
	End Method
	
	'this is needed to allow the Size to be correct. this is called automatically
	Method OnMeasure:Vec2i() Override
		Return Size
	End
Private
	'the timer ticks 60 times a second and handles the screen update
	Field _timer:Timer
	
	'what mode is the game in, showing the intro, playing, ended, etc
	Field _gameMode:Int = GAMEMODE_GAME'INTRO
	
	'global mouse vars
	Field _mouseX:Int
	Field _mouseY:Int
	
	field _scale:float = 1

	Field _mY:Int = 0 'position of map -500 so we start 500 in from top
	Field _mX:Int = 0 'position of map -500 so we start 500 in from left
'	Field _twist:Int  'rotate
	Field _oldX:Int 'used to store map location before you drag
	Field _oldY:Int 'used to store map location before you drag
	Field _movemap:Int 'switch to on to dragmap in conjuction with old position


	'image assets
	Field _maped:Image ' this is the map png ' lets say the center is 0, 0

	'set up some classes' these will need to be newed
	field _unitManager:UnitManager =  New UnitManager()
End


</textarea><br><br>I am going to do one more version to add some magic about getting the mouse location... <br><br></td></tr></table><br>
<a name="1339287"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#98">[#98]</a></td></tr></table></td></tr><tr ><td class="posttext"> @ Background<br>Use a DrawBackground() and it is up to the people what and how they draw it (talking about some parallax animation effects or "living" nebulaes/fogs).<br><br><br>Talking about "managers" - maybe it is nice to have "move to" commands for the map so it moves to a certain cell/point. There are surely similar convenience things a "Map"-class would handle well (GetShipsInArea(x,y,radius) or such things).<br><br><br>PS: thanks for the codebox (makes scrolling a breeze).<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1339288"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#99">[#99]</a></td></tr></table></td></tr><tr ><td class="posttext"> here's the last one for a bit.<br><br>Basically you now have resolution independent mouse checking of units. is the mouse over a unit or not<br><br>You will need to run the code and play with it first then have a look at how it was done.<br><br>It's very cheap to do as half of it was already being done with the drawing, we are just adding a few mouse bits into it...<br><br>the colors have changed slightly, light grey is normal, white is when the mouse is over. This is really just so you get a feel for what is gong on at this stage.<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Namespace myLetterboxApp

#Import "&lt;std&gt;"
#Import "&lt;mojo&gt;"

Using std..
Using mojo..

#Import "assets/map.png"
#Import "assets/chit1.png"
#Import "assets/chit2.png"
Const Size := New Vec2i( 950,720 )

Const GAMEMODE_INTRO:Int = 1
Const GAMEMODE_GAME:int = 2

'ok blitzmax rotations were in degrees - simple ;)
'monkey2 reverts back to radians,  so we need a conversion
'so here is the best and quickest conversion I could come up with ;)
const Pi180:double = Pi / 180
function DegreesToRadian:float( degrees:float )
	return degrees * Pi180
End function
'and we will need another to revrse the process
function RadianToDegrees:float( radian:float )
	return radian / Pi180
End function


Function Main()
	New AppInstance
	
	New MyWindow
	
	App.Run()
End

'this is now moved into the unit manager
'what will be the maximum number of units avaialable
' a unit is anything like a planet or ship,  so we need 16 for the base planets stuff and...
' lets say 100 other units
' a missile could be classed as a unit as well,  so lets have 256 units
'const MAX_UNITS:int = 256


'lets have some const vars to make me happy
'ive dragged over the const from the universe just so we are talking the same language
const UNIT_BLACKHOLE:int = 0
const UNIT_STAR:int = 1
const UNIT_GASGIANT:int = 2
const UNIT_PLANET:int = 3
const UNIT_MOON:int = 4
const UNIT_ASTEROIDMOON:int = 5
const UNIT_ASTEROID:int = 6
const UNIT_ASTEROIDBELT:int = 7
const UNIT_DUSTBELT:int = 8
const UNIT_NEBULAE:int = 9
const UNIT_RADIATIONBELT:int = 10

'so lets say a ship starts at 100
const UNIT_SHIP:int = 100

'this will be the base class for all chits, anything can be a chit
'ok chit it is - unit would possibly be a better choice though?
'I have converted all int's to floats - this has already bourn fruit with the rotation
'sorry converted chit to unit
Class Unit
	'this is called when any new thing is derrived from this class
	Method New()
	End Method

	
	' so New(67) would give you a Chit with 67 rotation
	Method New( kind:int, chitImage:Image, rotate:float, x:float, y:float )
		'monkey2 uses radians,  so convert from degrees to radian
		_rotate = DegreesToRadian( rotate )

		_x = x 'just a var to initialise starting position of chit
		_y = y
		
		_kind = kind
		
		_image = chitImage
		_image.Handle = New Vec2f( .5,.5 )
	End Method

	Method New( kind:int, rotate:float, x:float, y:float )
		'monkey2 uses radians,  so convert from degrees to radian
		_rotate = DegreesToRadian( rotate )

		_x = x 'just a var to initialise starting position of chit
		_y = y
		
		_kind = kind

	End Method

	'because _twist is private,  we need a property and setter
	' we only then need to access by _chit.Twist = 40,  or twist = _chit.Twist
	'you can now see here that directly accessing the variables would have caused us a bit more hasslle (in the long term)
	'but using a property/setter,  means the nasty degrees radian stuff lives inside,  and doesn't bother us now
	Property Rotate:float()
		Return RadianToDegrees( _rotate )
	Setter( rotate:float )
		_rotate = DegreesToRadian( rotate )
	End

	Property X:float()
		Return _x
	Setter( x:float )
		_x = x
	End

	Property Y:float()
		Return _y
	Setter( y:float )
		_y = y
	End

	Property Kind:int()
		Return _kind
	Setter( kind:int )
		_kind = kind
	End

	
protected
	'ok we now have a draw method that is completely separate from the rest of the app
	'it will need the canvas to draw onto
	method Draw:bool( canvas:Canvas, mouseX:int, mouseY:int, x:float, y:float, scale:float )
		'ok lets assume that the unit will draw different things
		'there are two ways of doing it
		'first is the siple way - we'll be doing it this way to begin with
		local xx:float = (_x * scale) + x
		local yy:float = y - (_y * scale) 'this is inverted!!!!
		
		'get the actual drawing locations
		Local sc:float = scale * 25
		Local x0:int = xx - sc
		Local x1:int = x0 + (scale * 50)
		Local y0:int = yy - sc
		Local y1:int = y0 + (scale * 50)
		
		'check if the mouse is over it
		Local over:bool = True
		If mouseX &lt; x0 Then over = false
		If mouseX &gt; x1 Then over = false
		If mouseY &lt; y0 Then over = false
		If mouseY &gt; y1 Then over = False
		
		'change the color of the drawing depending on if the mouse is over it
		If over Then
			canvas.Color = Color.White
		Else
			canvas.Color = Color.LightGrey
		End If

		'draw the unit
		Select _kind
			Case UNIT_SHIP
				canvas.DrawImage( _image, xx, yy, _rotate, scale, scale )
				
			Case UNIT_STAR
		        canvas.DrawCircle( xx, yy, 30*scale )
		End Select

		Return over
	End method
	
Private
	'this is any image we might be drawing
	field _image:Image
	
	'this is the kind of thing the unit is
	field _kind:int
	
	'and here are some vars to tell us where and what way it's facing
	Field _x:float = 600
	Field _y:float = 600
	Field _rotate:float = 0
End Class



class UnitManager
	'what will be the maximum number of units avaialable
	' a unit is anything like a planet or ship,  so we need 16 for the base planets stuff and...
	' lets say 100 other units
	' a missile could be classed as a unit as well,  so lets have 256 units
	const MAX_UNITS:int = 256

	method New()
	End method
	
	method AddShip( kind:int, chitImage:Image, rotate:float, x:float, y:float )
		_unit[ _count ] = New Unit( kind, chitImage, rotate, x, y)
		_count += 1
	End method

	method AddPlanet( kind:int, rotate:float, x:float, y:float )
		_unit[ _count ] = New Unit( kind, rotate, x, y)
		_count += 1
	End method
	
	method Draw( canvas:Canvas, mouseX:int, mouseY:int, midX:float, midY:float, scale:float )
		Local k:int
		_over = -1
		For k = 0 Until _count
			if _unit[k].Draw( canvas, mouseX, mouseY, midX, midY, scale ) Then
				_over = k
			End if
		Next
	End method
	
private
	'the units we have
	field _unit:Unit[] = New Unit[ MAX_UNITS ]
	
	'how many units we have got
	field _count:int = 0
	
	'is the mouse over a unit? if so what is it's number
	field _over:int = -1

End Class



Class MyWindow Extends Window

	Method New()
		Super.New( "My Window", Size.X, Size.Y, WindowFlags.Resizable )
	    
		'if you want a constant canvas size use this
'		Layout = "letterbox"
		'or If you want the canvas to always fill the window use this
		Layout = "fill"

		'this is a timer. it will 'tick' 60 times a second. calling OnUpdate
		_timer = New Timer( 60, OnUpdate )
		_maped = Image.Load( "asset::map.png" ) 'I used a 2000x2000 pixel PNG
		_maped.Handle=New Vec2f( .5,.5 )
	
		'lets now assign these to each chit
		'monkey2 will use internal referenceing systems,  so don't bother about resources
		' we will also deal with the image handle in the chit as well ;)
		Local chitImage1:Image = Image.Load( "asset::chit1.png" )
		Local chitImage2:Image = Image.Load( "asset::chit2.png" )
		
		'just so you feel happy about rotation...
		'0 - shows normal bitmap the right way up points east
		'90 is north, 180 points west, 270 south
		'so. lets assume that chit1 is a ship. to have it point the correct way. the bitmap MUST face EAST!
		
        'provide a PNG and variables for every chit on the map
        _unitManager.AddShip( UNIT_SHIP, chitImage1, 0, 150, 150 )
        _unitManager.AddShip( UNIT_SHIP, chitImage2, 45, -51, -80 )
'		_unit[0] = New Unit( UNIT_SHIP, chitImage1, 0, 150, 150) ' rotation,X,Y (x,y in relation to the map)
'		_unit[1] = New Unit( UNIT_SHIP, chitImage2, 45, -51, -80) ' the map you see starts at -x500 y-500
		
		'And the star
        _unitManager.AddPlanet( UNIT_STAR, 45, 0, 0 )
'		_unit[2] = New Unit( UNIT_STAR, 45, 0, 0) ' the map you see starts at -x0 y-0
	End

Protected
	Method OnUpdate()
		RequestRender()
	End Method
	
	
	Method OnRender( canvas:Canvas ) Override

		'fill the screen canvas with a color
		canvas.Color = Color.Black
		canvas.DrawRect( 0, 0, Width, Height )

		Select _gameMode
			Case GAMEMODE_INTRO
				DrawTheIntro( canvas )
			Case GAMEMODE_GAME
				DrawTheGame( canvas )
		End Select
	End


	method DrawMap( canvas:Canvas, midX:float, midY:float )
		'draw the mapimage
		canvas.Alpha = 1
		canvas.Color = Color.Grey
		canvas.DrawImage( _maped, midX, midY, 0, _scale, _scale )
		
		'draw the 100 lines (100 spatial positions)
		Local k:float
		Local sc:float
		canvas.Color = Color.DarkGrey
		canvas.Alpha = 0.3
		Local xoffset:float = midX Mod (100 * _scale)
		Local yoffset:float = midY Mod (100 * _scale)
		For k = xoffset To Width Step (100 * _scale)
			canvas.DrawLine( k,  0, k, Height )
		Next
		For k = yoffset To Height Step (100 * _scale)
			canvas.DrawLine( 0, k, Width, k )
		Next
		
		'draw the center of the map lines
		canvas.Color = Color.Grey
		canvas.DrawLine( midX, 0, midX, Height )
		canvas.DrawLine( 0, midY, Width, midY )
	End method
	
	
	Method DrawTheGame( canvas:Canvas )
		'find the midpoint from where all drawing is based
		Local midX:float = (Width * 0.5) + _mX
		Local midY:float = (Height * 0.5) + _mY
		
		
		'draw the map in a seperate method
		DrawMap( canvas, midX, midY )
		
        'lets move these into the unit class
		canvas.Color = Color.White
		canvas.Alpha = 1
		
'		canvas.DrawText( midX+" "+midY+"  "+(_mouseX-midX)+" "+(_mouseY-midY), 10, 10 )

		'we now have a unitmanager to handle all the units,  so just one call to it's draw rotine
		' will allow it to do the rest
		_unitManager.Draw( canvas, _mouseX, _mouseY, midX, midY, _scale )
	End Method
	
	
	Method DrawTheIntro( canvas:Canvas )
		canvas.Color = Color.White
	
		canvas.DrawText( " Scroller Map' First App By Mark Ainsworth ref 210665",200,20 )
		canvas.DrawText( " How To Scroll The Map Right Click To Pickup Board, Then Drag it Release to Drop it. ",200,60 )
		canvas.DrawText( " You can Move around the Map By Only RightClicking and Dragging.",200,80 )
		canvas.DrawText("- PRESS ENTER OR LRFT-CLICK MOUSE TO START MAP --&gt;",200,670)
		
	End Method

	
	'respond to any key presses
	Method OnKeyEvent( event:KeyEvent ) Override
		'heres the best way to check for shift keys etc
		Local command:Bool = event.Modifiers &amp; Modifier.Gui
		Local shift:Bool = event.Modifiers &amp; Modifier.Shift
		Local alt:bool = event.Modifiers &amp; Modifier.Alt
		
		Select event.Type
			case EventType.KeyDown
			
				Select event.Key
					Case Key.Enter
						Select _gameMode
							Case GAMEMODE_INTRO
								_gameMode = GAMEMODE_GAME
						End Select
							
				End Select
				
			Case EventType.KeyUp
			
				Select event.Key
					Case Key.Enter
				End Select
				
		End Select
	End

	'here we track the mouse and all mouse related stuff
	Method OnMouseEvent( event:MouseEvent ) Override
		'set up some global mouse cars so we can use these throught to program
		_mouseX = event.Location.X
		_mouseY = event.Location.Y

		'here are the baci mouse events we are interested in
		Select event.Type
			Case EventType.MouseClick
				Select _gameMode
					Case GAMEMODE_INTRO
						_gameMode = GAMEMODE_GAME
						
					Case GAMEMODE_GAME
						_movemap = 1
						If _movemap = 1 'if you left click record current mouse location
							_oldX = _mX + -_mouseX 'plus map location
							_oldY = _mY + -_mouseY
						Endif
				End Select	
				
			Case EventType.MouseUp
				_movemap = 0 'if you move the mouse while dragging
				If _movemap = 0 'the map x,y is updated untill you Mouseup
					_oldX = _mX 
					_oldY = _mY 
				Endif
			Case EventType.MouseEnter
			Case EventType.MouseLeave
			case EventType.MouseWheel
				If event.Wheel.Y &lt;&gt; 0 Then
					_scale = Clamp( _scale + event.Wheel.Y * 0.01, 0.25, 4.0 )
				End If
			Case EventType.MouseMove
				If _movemap = 1
					_mX = _mouseX + _oldX - 0
					_mY = _mouseY + _oldY - 0
				Endif
		End Select
		
	End Method
	
	'this is needed to allow the Size to be correct. this is called automatically
	Method OnMeasure:Vec2i() Override
		Return Size
	End
Private
	'the timer ticks 60 times a second and handles the screen update
	Field _timer:Timer
	
	'what mode is the game in, showing the intro, playing, ended, etc
	Field _gameMode:Int = GAMEMODE_GAME'INTRO
	
	'global mouse vars
	Field _mouseX:Int
	Field _mouseY:Int
	
	field _scale:float = 1

	Field _mY:Int = 0 'position of map -500 so we start 500 in from top
	Field _mX:Int = 0 'position of map -500 so we start 500 in from left
'	Field _twist:Int  'rotate
	Field _oldX:Int 'used to store map location before you drag
	Field _oldY:Int 'used to store map location before you drag
	Field _movemap:Int 'switch to on to dragmap in conjuction with old position


	'image assets
	Field _maped:Image ' this is the map png ' lets say the center is 0, 0

	'set up some classes' these will need to be newed
	field _unitManager:UnitManager =  New UnitManager()
End

</textarea> <br><br></td></tr></table><br>
<a name="1339303"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#100">[#100]</a></td></tr></table></td></tr><tr ><td class="posttext"> when will my last one be my last one?<br><br>ok, new bits added functions for drawing circles - yep monkey2 doesn't have these<br><br>Added a global - the only one to act as a timer<br><br>unit drawing updated to show when mouse is over with pulsing circle and blue color<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Namespace myLetterboxApp

#Import "&lt;std&gt;"
#Import "&lt;mojo&gt;"

Using std..
Using mojo..

#Import "assets/map.png"
#Import "assets/chit1.png"
#Import "assets/chit2.png"


'here is a single global,  for tracking game time
'it is set by Millisecs(),  but if we use a global,  we only need to use Millisecs once when it is set.
'repeatedly calling stuff like mouse and timers may cause slowdowns
'so once it is set,  we just need to read it
'it is a global as everything will need to access it and drawing functions can use it as well
global _gameTime:long




Const Size := New Vec2i( 950,720 )

Const GAMEMODE_INTRO:Int = 1
Const GAMEMODE_GAME:int = 2

'ok blitzmax rotations were in degrees - simple ;)
'monkey2 reverts back to radians,  so we need a conversion
'so here is the best and quickest conversion I could come up with ;)
const Pi180:double = Pi / 180
function DegreesToRadian:float( degrees:float )
	return degrees * Pi180
End function
'and we will need another to revrse the process
function RadianToDegrees:float( radian:float )
	return radian / Pi180
End function


'monkey does not have any circle drawing routines,  so here is a basic one
function DrawCircle( canvas:Canvas, xc:float, yc:float, radius:float )
	Local div:float = DegreesToRadian( 5 )
	
	Local angle:float = div
	Local xp0:float
	Local yp0:float
	Local xp1:float = xc + radius
	Local yp1:float = yc
	Local k:int
	
	For k = 5 To 360 Step 5
		xp0 = xc + Cos( angle ) * radius
		yp0 = yc + Sin( angle ) * radius
		canvas.DrawLine( xp0, yp0, xp1, yp1 )
		
		xp1 = xp0
		yp1 = yp0
		angle += div
	Next
End function

'monkey does not have any circle drawing routines.
'here is one that draws dashed lines
function DrawCircleDash( canvas:Canvas, xc:float, yc:float, radius:float )
	Local div:float = DegreesToRadian( 5 )
	
	Local angle:float = div
	Local xp0:float
	Local yp0:float
	Local xp1:float = xc + radius
	Local yp1:float = yc
	Local k:int
	
	For k = 5 To 360 Step 5
		xp0 = xc + Cos( angle ) * radius
		yp0 = yc + Sin( angle ) * radius
		If k Mod 10 = 0 Then
			canvas.DrawLine( xp0, yp0, xp1, yp1 )
		End If
		
		xp1 = xp0
		yp1 = yp0
		angle += div
	Next
End function

Function Main()
	New AppInstance
	
	New MyWindow
	
	App.Run()
End

'this is now moved into the unit manager
'what will be the maximum number of units avaialable
' a unit is anything like a planet or ship,  so we need 16 for the base planets stuff and...
' lets say 100 other units
' a missile could be classed as a unit as well,  so lets have 256 units
'const MAX_UNITS:int = 256


'lets have some const vars to make me happy
'ive dragged over the const from the universe just so we are talking the same language
const UNIT_BLACKHOLE:int = 0
const UNIT_STAR:int = 1
const UNIT_GASGIANT:int = 2
const UNIT_PLANET:int = 3
const UNIT_MOON:int = 4
const UNIT_ASTEROIDMOON:int = 5
const UNIT_ASTEROID:int = 6
const UNIT_ASTEROIDBELT:int = 7
const UNIT_DUSTBELT:int = 8
const UNIT_NEBULAE:int = 9
const UNIT_RADIATIONBELT:int = 10

'so lets say a ship starts at 100
const UNIT_SHIP:int = 100

'this will be the base class for all chits, anything can be a chit
'ok chit it is - unit would possibly be a better choice though?
'I have converted all int's to floats - this has already bourn fruit with the rotation
'sorry converted chit to unit
Class Unit
	'this is called when any new thing is derrived from this class
	Method New()
	End Method

	
	' so New(67) would give you a Chit with 67 rotation
	Method New( kind:int, chitImage:Image, rotate:float, x:float, y:float )
		'monkey2 uses radians,  so convert from degrees to radian
		_rotate = DegreesToRadian( rotate )

		_x = x 'just a var to initialise starting position of chit
		_y = y
		
		_kind = kind
		
		_size = 25
		
		_image = chitImage
		_image.Handle = New Vec2f( .5,.5 )
	End Method

	Method New( kind:int, rotate:float, x:float, y:float )
		'monkey2 uses radians,  so convert from degrees to radian
		_rotate = DegreesToRadian( rotate )

		_x = x 'just a var to initialise starting position of chit
		_y = y
		
		_kind = kind

		_size = 30

	End Method

	'because _twist is private,  we need a property and setter
	' we only then need to access by _chit.Twist = 40,  or twist = _chit.Twist
	'you can now see here that directly accessing the variables would have caused us a bit more hasslle (in the long term)
	'but using a property/setter,  means the nasty degrees radian stuff lives inside,  and doesn't bother us now
	Property Rotate:float()
		Return RadianToDegrees( _rotate )
	Setter( rotate:float )
		_rotate = DegreesToRadian( rotate )
	End

	Property X:float()
		Return _x
	Setter( x:float )
		_x = x
	End

	Property Y:float()
		Return _y
	Setter( y:float )
		_y = y
	End

	Property Kind:int()
		Return _kind
	Setter( kind:int )
		_kind = kind
	End

	
protected
	'ok we now have a draw method that is completely separate from the rest of the app
	'it will need the canvas to draw onto
	method Draw:bool( canvas:Canvas, mouseX:int, mouseY:int, x:float, y:float, scale:float )
		'ok lets assume that the unit will draw different things
		'there are two ways of doing it
		'first is the siple way - we'll be doing it this way to begin with
		local xx:float = (_x * scale) + x
		local yy:float = y - (_y * scale) 'this is inverted!!!!
		
		'get the actual drawing locations
		Local sc:float = scale * _size
		Local sc2:float = sc * 2
		Local x0:int = xx - sc
		Local x1:int = x0 + sc2
		Local y0:int = yy - sc
		Local y1:int = y0 + sc2
		
		'check if the mouse is over it
		Local over:bool = True
		If mouseX &lt; x0 Then over = false
		If mouseX &gt; x1 Then over = false
		If mouseY &lt; y0 Then over = false
		If mouseY &gt; y1 Then over = False
		
		'change the color of the drawing depending on if the mouse is over it
		If over Then
			canvas.Color = Color.Sky
	        DrawCircle( canvas, xx, yy, scale*(_size+(Sin(_gameTime * 0.01)*5 )+5) )
		Else
			canvas.Color = Color.White
		End If

		'draw the unit
		Select _kind
			Case UNIT_SHIP
				canvas.DrawImage( _image, xx, yy, _rotate, scale, scale )
				
			Case UNIT_STAR
		        canvas.DrawCircle( xx, yy, sc )
		End Select

		Return over
	End method
	
Private
	'this is any image we might be drawing
	field _image:Image
	
	'this is the kind of thing the unit is
	field _kind:int

	'size is the drawing size radius,  so we could have different sizes for stuff
	'currently there is 25 for the ships (50 width) and 30 radius for the planets
	field _size:float
	
	'and here are some vars to tell us where and what way it's facing
	Field _x:float = 600
	Field _y:float = 600
	Field _rotate:float = 0
End Class



class UnitManager
	'what will be the maximum number of units avaialable
	' a unit is anything like a planet or ship,  so we need 16 for the base planets stuff and...
	' lets say 100 other units
	' a missile could be classed as a unit as well,  so lets have 256 units
	const MAX_UNITS:int = 256

	method New()
	End method
	
	method AddShip( kind:int, chitImage:Image, rotate:float, x:float, y:float )
		_unit[ _count ] = New Unit( kind, chitImage, rotate, x, y)
		_count += 1
	End method

	method AddPlanet( kind:int, rotate:float, x:float, y:float )
		_unit[ _count ] = New Unit( kind, rotate, x, y)
		_count += 1
	End method
	
	method Draw( canvas:Canvas, mouseX:int, mouseY:int, midX:float, midY:float, scale:float )
		Local k:int
		_over = -1
		For k = 0 Until _count
			if _unit[k].Draw( canvas, mouseX, mouseY, midX, midY, scale ) Then
				_over = k
			End if
		Next
	End method
	
private
	'the units we have
	field _unit:Unit[] = New Unit[ MAX_UNITS ]
	
	'how many units we have got
	field _count:int = 0
	
	'is the mouse over a unit? if so what is it's number
	field _over:int = -1

End Class



Class MyWindow Extends Window

	Method New()
		Super.New( "My Window", Size.X, Size.Y, WindowFlags.Resizable )
	    
		'if you want a constant canvas size use this
'		Layout = "letterbox"
		'or If you want the canvas to always fill the window use this
		Layout = "fill"

		'this is a timer. it will 'tick' 60 times a second. calling OnUpdate
		_timer = New Timer( 60, OnUpdate )
		_maped = Image.Load( "asset::map.png" ) 'I used a 2000x2000 pixel PNG
		_maped.Handle=New Vec2f( .5,.5 )
	
		'lets now assign these to each chit
		'monkey2 will use internal referenceing systems,  so don't bother about resources
		' we will also deal with the image handle in the chit as well ;)
		Local chitImage1:Image = Image.Load( "asset::chit1.png" )
		Local chitImage2:Image = Image.Load( "asset::chit2.png" )
		
		'just so you feel happy about rotation...
		'0 - shows normal bitmap the right way up points east
		'90 is north, 180 points west, 270 south
		'so. lets assume that chit1 is a ship. to have it point the correct way. the bitmap MUST face EAST!
		
        'provide a PNG and variables for every chit on the map
        _unitManager.AddShip( UNIT_SHIP, chitImage1, 0, 150, 150 )
        _unitManager.AddShip( UNIT_SHIP, chitImage2, 45, -51, -80 )
'		_unit[0] = New Unit( UNIT_SHIP, chitImage1, 0, 150, 150) ' rotation,X,Y (x,y in relation to the map)
'		_unit[1] = New Unit( UNIT_SHIP, chitImage2, 45, -51, -80) ' the map you see starts at -x500 y-500
		
		'And the star
        _unitManager.AddPlanet( UNIT_STAR, 45, 0, 0 )
'		_unit[2] = New Unit( UNIT_STAR, 45, 0, 0) ' the map you see starts at -x0 y-0
	End

Protected
	Method OnUpdate()
		_gameTime = Millisecs()
		
		RequestRender()
	End Method
	
	
	Method OnRender( canvas:Canvas ) Override

		'fill the screen canvas with a color
		canvas.Color = Color.Black
		canvas.DrawRect( 0, 0, Width, Height )

		Select _gameMode
			Case GAMEMODE_INTRO
				DrawTheIntro( canvas )
			Case GAMEMODE_GAME
				DrawTheGame( canvas )
		End Select
	End


	method DrawMap( canvas:Canvas, midX:float, midY:float )
		'draw the mapimage
		canvas.Alpha = 1
		canvas.Color = Color.Grey
		canvas.DrawImage( _maped, midX, midY, 0, _scale, _scale )
		
		DrawCircleDash( canvas, midX, midY, 100 * _scale )
		
		'draw the 100 lines (100 spatial positions)
		Local k:float
		Local sc:float
		canvas.Color = Color.DarkGrey
		canvas.Alpha = 0.3
		Local xoffset:float = midX Mod (100 * _scale)
		Local yoffset:float = midY Mod (100 * _scale)
		For k = xoffset To Width Step (100 * _scale)
			canvas.DrawLine( k,  0, k, Height )
		Next
		For k = yoffset To Height Step (100 * _scale)
			canvas.DrawLine( 0, k, Width, k )
		Next
		
		'draw the center of the map lines
		canvas.Color = Color.Grey
		canvas.DrawLine( midX, 0, midX, Height )
		canvas.DrawLine( 0, midY, Width, midY )
	End method
	
	
	Method DrawTheGame( canvas:Canvas )
		'find the midpoint from where all drawing is based
		Local midX:float = (Width * 0.5) + _mX
		Local midY:float = (Height * 0.5) + _mY
		
		
		'draw the map in a seperate method
		DrawMap( canvas, midX, midY )
		
        'lets move these into the unit class
		canvas.Color = Color.White
		canvas.Alpha = 1
		
'		canvas.DrawText( midX+" "+midY+"  "+(_mouseX-midX)+" "+(_mouseY-midY), 10, 10 )

		'we now have a unitmanager to handle all the units,  so just one call to it's draw rotine
		' will allow it to do the rest
		_unitManager.Draw( canvas, _mouseX, _mouseY, midX, midY, _scale )
	End Method
	
	
	Method DrawTheIntro( canvas:Canvas )
		canvas.Color = Color.White
	
		canvas.DrawText( " Scroller Map' First App By Mark Ainsworth ref 210665",200,20 )
		canvas.DrawText( " How To Scroll The Map Right Click To Pickup Board, Then Drag it Release to Drop it. ",200,60 )
		canvas.DrawText( " You can Move around the Map By Only RightClicking and Dragging.",200,80 )
		canvas.DrawText("- PRESS ENTER OR LRFT-CLICK MOUSE TO START MAP --&gt;",200,670)
		
	End Method

	
	'respond to any key presses
	Method OnKeyEvent( event:KeyEvent ) Override
		'heres the best way to check for shift keys etc
		Local command:Bool = event.Modifiers &amp; Modifier.Gui
		Local shift:Bool = event.Modifiers &amp; Modifier.Shift
		Local alt:bool = event.Modifiers &amp; Modifier.Alt
		
		Select event.Type
			case EventType.KeyDown
			
				Select event.Key
					Case Key.Enter
						Select _gameMode
							Case GAMEMODE_INTRO
								_gameMode = GAMEMODE_GAME
						End Select
							
				End Select
				
			Case EventType.KeyUp
			
				Select event.Key
					Case Key.Enter
				End Select
				
		End Select
	End

	'here we track the mouse and all mouse related stuff
	Method OnMouseEvent( event:MouseEvent ) Override
		'set up some global mouse cars so we can use these throught to program
		_mouseX = event.Location.X
		_mouseY = event.Location.Y

		'here are the baci mouse events we are interested in
		Select event.Type
			Case EventType.MouseClick
				Select _gameMode
					Case GAMEMODE_INTRO
						_gameMode = GAMEMODE_GAME
						
					Case GAMEMODE_GAME
						_movemap = 1
						If _movemap = 1 'if you left click record current mouse location
							_oldX = _mX + -_mouseX 'plus map location
							_oldY = _mY + -_mouseY
						Endif
				End Select	
				
			Case EventType.MouseUp
				_movemap = 0 'if you move the mouse while dragging
				If _movemap = 0 'the map x,y is updated untill you Mouseup
					_oldX = _mX 
					_oldY = _mY 
				Endif
			Case EventType.MouseEnter
			Case EventType.MouseLeave
			case EventType.MouseWheel
				If event.Wheel.Y &lt;&gt; 0 Then
					_scale = Clamp( _scale + event.Wheel.Y * 0.01, 0.25, 4.0 )
				End If
			Case EventType.MouseMove
				If _movemap = 1
					_mX = _mouseX + _oldX - 0
					_mY = _mouseY + _oldY - 0
				Endif
		End Select
		
	End Method
	
	'this is needed to allow the Size to be correct. this is called automatically
	Method OnMeasure:Vec2i() Override
		Return Size
	End
Private
	'the timer ticks 60 times a second and handles the screen update
	Field _timer:Timer
	
	'what mode is the game in, showing the intro, playing, ended, etc
	Field _gameMode:Int = GAMEMODE_GAME'INTRO
	
	'global mouse vars
	Field _mouseX:Int
	Field _mouseY:Int
	
	field _scale:float = 1

	Field _mY:Int = 0 'position of map -500 so we start 500 in from top
	Field _mX:Int = 0 'position of map -500 so we start 500 in from left
'	Field _twist:Int  'rotate
	Field _oldX:Int 'used to store map location before you drag
	Field _oldY:Int 'used to store map location before you drag
	Field _movemap:Int 'switch to on to dragmap in conjuction with old position


	'image assets
	Field _maped:Image ' this is the map png ' lets say the center is 0, 0

	'set up some classes' these will need to be newed
	field _unitManager:UnitManager =  New UnitManager()
End


</textarea> <br><br></td></tr></table><br>
<a name="1339304"></a>

<a name="1339305"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#101">[#101]</a></td></tr></table></td></tr><tr ><td class="posttext"> YES! Wow, you've really done magic with that :) I can see all kinds of clever bits to it. the scalling great aswell.<br><br>Thanks so much Adam, you've shown me worlds of stuff. lighting up the unit Wow is all I will say :) <br><br></td></tr></table><br>
<a name="1339306"></a>

<a name="1339307"></a>

<a name="1339308"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#102">[#102]</a></td></tr></table></td></tr><tr ><td class="posttext"> Adam, please keep the function to allow for a any background and units to be drawn by new functions, I'm planning a cockpit on a big mapscreen and a ships internal display of all rooms and stuff. It works as is, just don't contrict it into just maps if that's ok. I know class stuff does what I'm asking already, just remember I'm still a noob at MX2,<br><br>But my god this looks great, and your right Mac only has one click, didn't remember <br><br></td></tr></table><br>
<a name="1339309"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#103">[#103]</a></td></tr></table></td></tr><tr ><td class="posttext"> hehehehehe...<br>oh your thinking of ships with rooms? I was just thinking about classing them as ships with settings...<br><br>But no worries. I am trying to do stuff that won't break any other stuff.<br><br>I do have some really interesting stuff to test. but very technical in the visuals department. I'll keep you posted - you will like the results. but i need to do lots of tests... <br><br></td></tr></table><br>
<a name="1339310"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#104">[#104]</a></td></tr></table></td></tr><tr ><td class="posttext"> I promised something visual and cool. Here's a peek:<br><img src="https://vjointeractive.files.wordpress.com/2017/04/screen-shot-2017-04-22-at-14-21-371.png"><br><br>Nothin special here, just a blurred shot from the universe.<br>But wait, monkey2 doesn't have blur?<br><br>It does now - based on a GLSL shader concept, and still the same code...<br><br>so.... lets say you had a ui that needed to display on top of the current screen, Maybe sell stuff or setting, whatever.<br><br>Using this, the screen could be blurred and the ui shown on top of it<br><br>Further to this... You liked the way the planets looked. How about shaders dealing directly with the surface, that show cracks, sun spots, moving liquid, etc. without writing any new code (in the app)? <br><br></td></tr></table><br>
<a name="1339312"></a>

<a name="1339313"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Blitzplotter</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#105">[#105]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> last post for the day<br>Universe Step 4 - pretty picture <br></div><br><br>+1 from me - pretty pics indeed - sweet ;) <br><br></td></tr></table><br>
<a name="1339314"></a>

<a name="1339315"></a>

<a name="1339316"></a>

<a name="1339317"></a>

<a name="1339318"></a>

<a name="1339319"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#106">[#106]</a></td></tr></table></td></tr><tr ><td class="posttext"> the rooms are just big units, and things in the rooms like rockets are too, so no problems, I just don't want the flexibility to disappear with a map orientated flow, but they can coexist . the rooms can have there own class or drawn straight onto the map , probably a class for each function of the backdrop like cockpit<br><br>even combat could be done on a local map, and the galactic stack market listings could all fit on a big backdrop, <br><br>that blur looks like a telescope view :) I'm into Monkey2 now and class programing, phew never thought Id say that :) but its been an easy transition because of this <br><br></td></tr></table><br>
<a name="1339323"></a>

<a name="1339327"></a>

<a name="1339329"></a>

<a name="1339330"></a>

<a name="1339331"></a>

<a name="1339332"></a>

<a name="1339333"></a>

<a name="1339339"></a>

<a name="1339345"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#107">[#107]</a></td></tr></table></td></tr><tr ><td class="posttext"> I love how you dynamically assign chit images, my question is why are you using lots of setters, its a lot easier to just use a normal propery, I know private properties are safer from unwanted changes, are you doing it for good programing or is it nessasay, why I'm asking is if I want lots of properties for a chit do I need to make them all setters and getters?<br><br>a few little things, your code is very clever, but the map units need to be drawn from left to right and top to bottom , or the units will all overlap oddly if they are close together, also the lightingup a chit is fantastic, but if I want to select it to change a property all overlapping chits would be hard to select, it actualy may work in practice , but if you had a room with cargo and rockets ontop of each other or near if rotated then selecting a single unit would be hard. I would use a for next loop to start at the centre of a units x,y and progressively expand to say 100 pixels in all 4 directions, the first one it finds it then exits the loop with the units number and x,y.  . <br><br><br><br>I'm not saying to do this, I'm just sharing what I think may help, were not at a point its to important yet,. and we may not need it if everything never overlaps<br><br>don't forget to rest Adam, your doing wonders <br><br></td></tr></table><br>
<a name="1339351"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#108">[#108]</a></td></tr></table></td></tr><tr ><td class="posttext"> Setters allow for custom things or further checks.<br><br>So setting the name of a planet might invalidate a cached image so a prebuild image is regenerated automatically.<br><br>Every "indirection" allows to hook in and modify behaviour or extend it.<br><br>Eg. A unit has a setHealth() method. Normal units just assign health to health. But there is a spirit-connected healer. He gives 50 of the health to connected spirits in its setHealth imementation.<br><br><br>Bye<br>Ron <br><br></td></tr></table><br>
<a name="1339379"></a>

<a name="1339380"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#109">[#109]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks Derron, <br><br></td></tr></table><br>
<a name="1339386"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#110">[#110]</a></td></tr></table></td></tr><tr ><td class="posttext"> I played all night with your code Adam, I didn't achieve anything except a good understanding of whats what, I love the array of class's , and you centred the map around zero, I spent some time with the wrong coordinates until I realised what you did. I love class's now cant never go back :) <br><br></td></tr></table><br>
<a name="1339397"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#111">[#111]</a></td></tr></table></td></tr><tr ><td class="posttext"> lol<br>Classes are brilliant,that van bite, but brilliant.<br><br>A good way to think about them is small programs.<br>Each class is really a small program. the main app, tells other smaller bits (classes) what to do. so you main app becomes the place that has the entire overview of everything. the classes don't need to know about other classes -unless you want them to... <br><br></td></tr></table><br>
<a name="1339415"></a>

<a name="1339416"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#112">[#112]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok heres a pic of what I'm working on - the planet code<br><img src="https://vjointeractive.files.wordpress.com/2017/04/screen-shot-2017-04-23-at-08-40-171.png"><br><br>I've needed to make some changes to monkey2 itself, so can't (currently) post the code for you.<br><br>But. And here it is....<br>These new planets are dynamic! You are not looking at a static picture they are a seething mass of swirling, ever-changing patterns.<br>They are based on shader code, very cool and completely 2d<br><br>I should also add that the design of the new planets comes directly from Space 1999 <br><br></td></tr></table><br>
<a name="1339426"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#113">[#113]</a></td></tr></table></td></tr><tr ><td class="posttext"> Next pic<br><img src="https://vjointeractive.files.wordpress.com/2017/04/screen-shot-2017-04-23-at-11-46-51.png"><br><br>gas giants now have horizontal stripes, stars now have flames, planet rings now rings the different orientations.<br><br>Nearly finished with the planets, and stuff. Just nebulae, blackholesand stuff to do<br><br>contrast this with the initial concept:<br><img src="https://vjointeractive.files.wordpress.com/2017/04/screen-shot-2017-04-21-at-08-48-15.png"><br><br>it's really only the addition of some sneaky shaders <br><br></td></tr></table><br>
<a name="1339431"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#114">[#114]</a></td></tr></table></td></tr><tr ><td class="posttext"> Adam, they look fantastic, they really do look like amazing, but changing M2 code is scary, I don't think people would join in a project if they had to change the compiler.<br><br>When you say the classes don't know about other classes unless you want them to, what do you mean, I found you can make a variable of type class, and you can set public vars, and you can send class in the calling paramiters is there any other way Ive missed <br><br></td></tr></table><br>
<a name="1339432"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#115">[#115]</a></td></tr></table></td></tr><tr ><td class="posttext"> last shot of the day.<br><img src="https://vjointeractive.files.wordpress.com/2017/04/screen-shot-2017-04-23-at-12-57-43.png"><br><br>two classes A and B<br>A doesn't know anything about B.<br>E.G.<br>A can't access vars from B <br><br></td></tr></table><br>
<a name="1339433"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#116">[#116]</a></td></tr></table></td></tr><tr ><td class="posttext"> Your blazing light years. I see the stations are moons too. <br><br></td></tr></table><br>
<a name="1339434"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#117">[#117]</a></td></tr></table></td></tr><tr ><td class="posttext"> two classes A and B<br>A doesn't know anything about B.<br>E.G.<br>A can't access vars from B <br><br>WHAT iM REALY ASKING IS HOW DO I CHANGE VARS FROM A DIFFERENT CLASS? <br><br></td></tr></table><br>
<a name="1339435"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#118">[#118]</a></td></tr></table></td></tr><tr ><td class="posttext"> the app is the bridge<br><br>it created A and B and can pass and inspect variables of both A and B.<br><br>so...<br>All this A and B stuff is not helping.<br><br>What do you want to do?<br>E.G. 4 ships and a map<br>The ships each have a position, but don't know anything about the other ships<br><br>but the app knows all about the ships and the map, so you do all the interesting stuff like checking ship positions, in the app and not in the ship class<br><br>lets say each ship has a position<br>in the manager you do the checking for each ship there. the manager knows all about each ship<br><br>it's a bit like an inverted tree with the app at the top, and lots of classes underneath. if the classes need access to each others data. go up the level 1 to the caller(creator), it should be the one that has access to the things it's created.<br><br>This might all sound like bull. But... if you tell me what you want to do. then I can see about getting you the best (simplest) way of doing it without confusing you ;)<br><br><div class="quote"> HOW DO I CHANGE VARS FROM A DIFFERENT CLASS? <br></div><br>Directly, you shouldn't. The class should say Hi I want to do something and it's parent does it for it. The parent knows all and sees all <br><br></td></tr></table><br>
<a name="1339436"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#119">[#119]</a></td></tr></table></td></tr><tr ><td class="posttext"> To have classes not know each other has also the benefit of increased "re-useability".<br><br>While it is not waht Adam explained it is good to have "TEnemyWithSound" being the only one knowing "TSoundEngine" while "TEnemyBase" does not know it (and therefor does not need to include the soundengine (and its systemlibraries etc.).<br><br>The only thing other classed need to know about a class could be defined in the "base class" (or in an "interface"). it defines the in- and out-going data/methods the extending classes have in common. So all have a "DrawBackground()" "GetSpeed()" and so on.<br><br><br>What Adam suggested does not necessarily do the above thing. There might be hard wired connections between classes.<br><br>So this might be troublesome:<br>otherShipsSpeed = GetManager().GetShip(123).GetSpeed()<br><br>because you then need to know the class returned by "GetShip(123)". It works, if that class is the same (or a parental class - or if you imported the definition/class-file too).<br>To make it really "independend" from the real implementation you would need a base manager class (or interface or so) which has "GetShipSpeed(id)" and it returns eg. "0" in all cases, as it does not know about ships. <br>Then you add a new manager class extending the base manager. And there you override "GetShipSpeed()" to return the speed of the actual requested ship.<br>Then you eg. add a global variable "manager" which is defined as being of type "base manager" while the content is created with type "manager" (this is possible as the ladder extends the base manager).<br><br>This allows to import just the base manager (without further dependencies) and ask the base manager for a ship's speed without knowing about "ship classes".<br><br>Similar things could be done by having "GetShip()" returning a "base ship" class object which of course might be a "ship" class object and every call to "GetSpeed()" is doing what I have written in the start of this post.<br><br><br>Also something to annotate: if A does not know B's details but want to know something about B then of course you need to ask someone who knows it - and this is the parental container or a manager. Benefit is also something like "access control".<br><br>If a ship could directly request "GetSecretCargo()" then you might run into trouble. You could extend "GetSecretCargo()" to accept "askingShip" as parameter but then you end up having no "centralized" method for restricting such accesses.<br>A Manager knows where a ship is, and eg. if there is a "holo warp tunnel" near them, so their scans could check the other ship. It also could check if the owner of the ship is the same and they have access to the same "ship cargo database".<br>You redirect these checks to a class which knows more about the universe, which could ask other classes, classes the ships do not need to know about.<br>Nonetheless you end up to add "GetSecretCargo()" to a ship - that way the ship class itself is able to override what it returns as answer (eg. if there is a spy on the ship it might fake the data...).<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1339437"></a>

<a name="1339439"></a>

<a name="1339440"></a>

<a name="1339441"></a>

<a name="1339442"></a>

<a name="1339443"></a>

<a name="1339444"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#120">[#120]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok here is what I was trying to change the display of ships, not from midX and middy but from the real x,y because they need a priority from left to right and top to bottom, if units are overlapping it will matter if there are lots of ships rockets etc..<br><br>second I wanted to select a ship without selecting the ships its overlapping. _over lightsup all ships even overlapping, so if you wanted to move a ship you need a way to select just top ship.<br><br>I also want to have more variable for each ship I can change when selected, like health armor. I'm not going to be doing this from unit or unitmanager I will be doing it from a control class (the bridge)<br><br>this is what I was messing with last night, I found I was running around looking for the source of the variables, but I'm getting the hang of it, but I'm trying to stay away from globals etc... I was trying to give a priority here is the code I was doing, it had an effect but didn't work right, its probably not correct way to do it, it is a testing code I was working on it has a double loop not correct I was testing<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
method Draw( canvas:Canvas, mouseX:int, mouseY:int, midX:float, midY:float, scale:float )
		Local k:Int
		Local k2:Int
		_over = -1
		Local _oldex:Int = -3000
		Local _oldwhy:Int = -3000
				
		If _unit[k]._kind = UNIT_STAR
		
		For k2 = 0 Until _count

		For k = 0 Until _count
		If _unit[k].X  &gt; _oldex

			If _unit[k].Draw( canvas, mouseX, mouseY, midX, midY, scale ) Then
				_over = k
			End If
		_oldex = _unit[k].X 

		Endif	
		Next
		Next
		
		For k2 = 0 Until _count

		For k = 0 Until _count	
		If _unit[k].Y  &gt; _oldwhy

			If _unit[k].Draw( canvas, mouseX, mouseY, midX, midY, scale ) Then
				_over = k
			End If
		_oldwhy = _unit[k].Y 

		Endif
		Next
		Next
	
		Endif
		
		_oldwhy = -3000
		_oldex = -3000
				
		If _unit[k]._kind = UNIT_SHIP
		
			
    	For k2 = 0 Until _count

		For k = 0 Until _count
		If _unit[k].X  &gt; _oldex

			If _unit[k].Draw( canvas, mouseX, mouseY, midX, midY, scale ) Then
				_over = k
			End If
		_oldex = _unit[k].X

		Endif	
		Next
		Next
		
		For k2 = 0 Until _count

		For k = 0 Until _count	
		If _unit[k].Y &gt; _oldwhy

			If _unit[k].Draw( canvas, mouseX, mouseY, midX, midY, scale ) Then
				_over = k
			End If
		_oldwhy = _unit[k].Y 

		Endif
		Next
		Next	
	
		
		
		
		
		
		
		
		Endif
	End Method

</textarea> <br><br></td></tr></table><br>
<a name="1339445"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#121">[#121]</a></td></tr></table></td></tr><tr ><td class="posttext"> . ok the first bit about the ordering and display priority.<br>There is a really nice way to do it. at this stage don't worry about it. it is a display issue and we can look at that later - but it's sorted ;)<br><br>second the selection.<br>yep, this is a problem. but a good one.<br>the selection will not be 'top one', but whatever is closest to the start of the array of units<br>basically we introduce some counters.<br>The manager counts how many units are selected (some units like bombs or missiles can't be selected so that will need to be thought of)<br>you then have a second counter which decides which of the selected units to show.<br>Either this could be done automatically, or done when the user presses a key (like shift) and clicks.<br>I can write an update to deal with this for you.<br>So... Don't worry too much about that one<br><br>this point - no problem, just add some more to the base unit class.<br><br>Here's something to consider. if the base unit class knows about lots of things. E.G. how big the hold is, what cargo is has, what it wants, etc<br><br>the only different between a planet and a ship, is the planet doesn't move, and has a big 'hold', etc. When you come into contact with the planet. decrements what it has and increments them into your ship (space allowing)<br><br>I think I should do some work on the solar system and movement. get one thing finished and then move on to the next thing.<br><br>Mainworthy - I know you move fast and on to the next thing. But you are going reap many rewards by taking a step back and having a quick think about the What, How, and Why's of the game.<br><br>We can certainly replicate Elite at a basic level and concept now.... <br><br></td></tr></table><br>
<a name="1339446"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#122">[#122]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok Adam, I'm Happy to learn from this, I will definatly enjoy it, thanks for this, <br><br></td></tr></table><br>
<a name="1339447"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#123">[#123]</a></td></tr></table></td></tr><tr ><td class="posttext"> &gt;the only different between a planet and a ship, is the planet doesn't move, and has a big 'hold'<br><br><br>This is what "components" are made for. You end up having basic entity classes and add components. This way you could add things like "cargo/hold" or "weapons" (which have upgraded and so on).<br><br>But even without an entity-system you could do what I described (think so at least) in a post way earlier in this thread.<br>The idea is to not have a "list of cargos" in a ship, but a whole object "cargo:TCargo". Cargo has its own methods (GetCapacity(), Unload(), Seal(), UnSeal() ...).<br>That way even planets could get their own cargo / holds ...<br><br>It even allows to "steal" the whole cargo-module from a ship :-)<br><br>Weapon-components could come in handy too as you could upgrade weapons - eg. add a "homing missile-radar"-tech-upgrade to your basic rocket launcher. Of course you could keep it easy and just create another weapon type (HomingMissileRocketLauncher extends RocketLauncher) but this is less "dynamic/versatile".<br><br><br>Think this "component-like" approach will be something you like once you understood the benefits. But let's first follow what Adam is doing "in collaboration with himself" ;-)<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1339449"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#124">[#124]</a></td></tr></table></td></tr><tr ><td class="posttext"> wow a class has a variable of a cargo class , did I say wow. :) <br><br></td></tr></table><br>
<a name="1339461"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#125">[#125]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Adam if you create a display priority, then selecting a unit is done too, just use the highest priority unit selected. I look forward to the next class :) <br><br></td></tr></table><br>
<a name="1339473"></a>

<a name="1339474"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#126">[#126]</a></td></tr></table></td></tr><tr ><td class="posttext"> Woah! I totally missed this thread! Some top stuff in it! <br><br></td></tr></table><br>
<a name="1339481"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#127">[#127]</a></td></tr></table></td></tr><tr ><td class="posttext"> therevills, feel free to join-in with us? <br><br></td></tr></table><br>
<a name="1339490"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#128">[#128]</a></td></tr></table></td></tr><tr ><td class="posttext"> just woke up.<br>@Mainsworthy Indenting. ifs are indented. so are for. it's about clarity.<br>I've not checked what the code does, but I have reformatted it with correct indenting. .. ;/<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
	method Draw( canvas:Canvas, mouseX:int, mouseY:int, midX:float, midY:float, scale:float )
		Local k:Int
		Local k2:Int
		_over = -1
		Local _oldex:Int = -3000
		Local _oldwhy:Int = -3000
				
		If _unit[k]._kind = UNIT_STAR
		
			For k2 = 0 Until _count

				For k = 0 Until _count
					If _unit[k].X  &gt; _oldex

						If _unit[k].Draw( canvas, mouseX, mouseY, midX, midY, scale ) Then
							_over = k
						End If
						_oldex = _unit[k].X 

					Endif
				Next
			Next
		
			For k2 = 0 Until _count

				For k = 0 Until _count
					If _unit[k].Y  &gt; _oldwhy

						If _unit[k].Draw( canvas, mouseX, mouseY, midX, midY, scale ) Then
							_over = k
						End If
						_oldwhy = _unit[k].Y 

					Endif
				Next
			Next
	
		Endif
		
		_oldwhy = -3000
		_oldex = -3000
				
		If _unit[k]._kind = UNIT_SHIP
			For k2 = 0 Until _count
	
				For k = 0 Until _count
					If _unit[k].X  &gt; _oldex
	
						If _unit[k].Draw( canvas, mouseX, mouseY, midX, midY, scale ) Then
							_over = k
						End If
						_oldex = _unit[k].X
	
					Endif
				Next
			Next
		
			For k2 = 0 Until _count
	
				For k = 0 Until _count	
					If _unit[k].Y &gt; _oldwhy
	
						If _unit[k].Draw( canvas, mouseX, mouseY, midX, midY, scale ) Then
							_over = k
						End If
						_oldwhy = _unit[k].Y 
	
					Endif
				Next
			Next
	
		Endif
	End Method

</textarea><br><br>Yep. I'm being a bit pedantic here. But once you get into the habit, it will make you life sooo much simpler ;) <br><br></td></tr></table><br>
<a name="1339491"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#129">[#129]</a></td></tr></table></td></tr><tr ><td class="posttext"> checked the code, didn't work only one ship displayed and no planets.<br>but I can see what you are trying to do.<br><br>I'll get a working version back to you... <br><br></td></tr></table><br>
<a name="1339500"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#130">[#130]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok Here's the latest with multiple planets and planetary rotation.<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Namespace myLetterboxApp

#Import "&lt;std&gt;"
#Import "&lt;mojo&gt;"

Using std..
Using mojo..

#Import "assets/map.png"
#Import "assets/chit1.png"
#Import "assets/chit2.png"


'here is a single global,  for tracking game time
'it is set by Millisecs(),  but if we use a global,  we only need to use Millisecs once when it is set.
'repeatedly calling stuff like mouse and timers may cause slowdowns
'so once it is set,  we just need to read it
'it is a global as everything will need to access it and drawing functions can use it as well
global _gameTime:long




Const Size := New Vec2i( 950,720 )

Const GAMEMODE_INTRO:Int = 1
Const GAMEMODE_GAME:int = 2

'used by the units to assign a none parent
const PARENT_NONE:int = -1


'ok blitzmax rotations were in degrees - simple ;)
'monkey2 reverts back to radians,  so we need a conversion
'so here is the best and quickest conversion I could come up with ;)
const Pi180:double = Pi / 180
function DegreesToRadian:float( degrees:float )
	return degrees * Pi180
End function
'and we will need another to revrse the process
function RadianToDegrees:float( radian:float )
	return radian / Pi180
End function


'monkey does not have any circle drawing routines,  so here is a basic one
function DrawCircle( canvas:Canvas, xc:float, yc:float, radius:float )
	Local div:float = DegreesToRadian( 5 )
	
	Local angle:float = div
	Local xp0:float
	Local yp0:float
	Local xp1:float = xc + radius
	Local yp1:float = yc
	Local k:int
	
	For k = 5 To 360 Step 5
		xp0 = xc + Cos( angle ) * radius
		yp0 = yc + Sin( angle ) * radius
		canvas.DrawLine( xp0, yp0, xp1, yp1 )
		
		xp1 = xp0
		yp1 = yp0
		angle += div
	Next
End function

'monkey does not have any circle drawing routines.
'here is one that draws dashed lines
function DrawCircleDash( canvas:Canvas, xc:float, yc:float, radius:float )
	Local div:float = DegreesToRadian( 5 )
	
	Local angle:float = div
	Local xp0:float
	Local yp0:float
	Local xp1:float = xc + radius
	Local yp1:float = yc
	Local k:int
	
	For k = 5 To 360 Step 5
		xp0 = xc + Cos( angle ) * radius
		yp0 = yc + Sin( angle ) * radius
		If k Mod 10 = 0 Then
			canvas.DrawLine( xp0, yp0, xp1, yp1 )
		End If
		
		xp1 = xp0
		yp1 = yp0
		angle += div
	Next
End function

Function Main()
	New AppInstance
	
	New MyWindow
	
	App.Run()
End

'this is now moved into the unit manager
'what will be the maximum number of units avaialable
' a unit is anything like a planet or ship,  so we need 16 for the base planets stuff and...
' lets say 100 other units
' a missile could be classed as a unit as well,  so lets have 256 units
'const MAX_UNITS:int = 256


'lets have some const vars to make me happy
'ive dragged over the const from the universe just so we are talking the same language
const UNIT_BLACKHOLE:int = 0
const UNIT_STAR:int = 1
const UNIT_GASGIANT:int = 2
const UNIT_PLANET:int = 3
const UNIT_MOON:int = 4
const UNIT_ASTEROIDMOON:int = 5
const UNIT_ASTEROID:int = 6
const UNIT_ASTEROIDBELT:int = 7
const UNIT_DUSTBELT:int = 8
const UNIT_NEBULAE:int = 9
const UNIT_RADIATIONBELT:int = 10

'so lets say a ship starts at 100
const UNIT_SHIP:int = 100

'this will be the base class for all chits, anything can be a chit
'ok chit it is - unit would possibly be a better choice though?
'I have converted all int's to floats - this has already bourn fruit with the rotation
'sorry converted chit to unit
Class Unit
	'this is called when any new thing is derrived from this class
	Method New()
	End Method

	
	' so New(67) would give you a Chit with 67 rotation
	Method New( kind:int, chitImage:Image, rotate:float, x:float, y:float )
		'monkey2 uses radians,  so convert from degrees to radian
		_rotate = DegreesToRadian( rotate )

		_x = x 'just a var to initialise starting position of chit
		_y = y
		
		_kind = kind
		
		_size = 25
		
		_image = chitImage
		_image.Handle = New Vec2f( .5,.5 )
	End Method


	Method New( kind:int, rotate:float, x:float, y:float )
		'monkey2 uses radians,  so convert from degrees to radian
		_rotate = DegreesToRadian( rotate )

		_x = x 'just a var to initialise starting position of chit
		_y = y
		
		_kind = kind

		_size = 30
	End Method


	'because _twist is private,  we need a property and setter
	' we only then need to access by _chit.Twist = 40,  or twist = _chit.Twist
	'you can now see here that directly accessing the variables would have caused us a bit more hasslle (in the long term)
	'but using a property/setter,  means the nasty degrees radian stuff lives inside,  and doesn't bother us now
	Property Rotate:float()
		Return RadianToDegrees( _rotate )
	Setter( rotate:float )
		_rotate = DegreesToRadian( rotate )
	End

	Property X:float()
		Return _x
	Setter( x:float )
		_x = x
	End

	Property Y:float()
		Return _y
	Setter( y:float )
		_y = y
	End

	Property OrbitX:float()
		Return _orbitX
	Setter( orbitX:float )
		_orbitX = orbitX
	End

	Property OrbitY:float()
		Return _orbitY
	Setter( orbitY:float )
		_orbitY = orbitY
	End

	Property Kind:int()
		Return _kind
	Setter( kind:int )
		_kind = kind
	End

	Property Size:float()
		Return _size
	Setter( size:float )
		_size = size
	End
	
	Property Velocity:float()
		Return _velocity
	Setter( velocity:float )
		_velocity = velocity
	End

	Property OrbitDistance:float()
		Return _orbitDistance
	Setter( orbitDistance:float )
		_orbitDistance = orbitDistance
	End

	Property Parent:int()
		Return _parent
	Setter( parent:int )
		_parent = parent
	End

protected
	'ok we now have a draw method that is completely separate from the rest of the app
	'it will need the canvas to draw onto
	method Draw:bool( canvas:Canvas, mouseX:int, mouseY:int, x:float, y:float, scale:float )
		local xx:float = (_x * scale) + x
		local yy:float = y - (_y * scale) 'this is inverted!!!!
		
		'draw the orbit
		If _orbitDistance &gt; 0 Then
			canvas.Color = Color.Orange
			canvas.Alpha = 0.4

			DrawCircleDash( canvas, xx, yy, _orbitDistance * scale )
			'and modify then xx
			Local rad:float = _orbitDistance
			_orbitX = Cos( _rotate ) * rad
			_orbitY = Sin( _rotate ) * rad

			xx += _orbitX * scale
			yy -= _orbitY * scale
			_rotate += _velocity

			'make sure that the orbit vars are correctly offset
			_orbitX += _x
			_orbitY += _y

			canvas.Alpha = 1
		End If

		canvas.Alpha = 0.5
		
		'get the actual drawing locations
		Local sc:float = scale * _size
		Local sc2:float = sc * 2
		Local x0:int = xx - sc
		Local x1:int = x0 + sc2
		Local y0:int = yy - sc
		Local y1:int = y0 + sc2

		'debug. draw the parent top right of the drawn unit
'		canvas.DrawText( _parent, x0, y0-10 )
'		canvas.DrawText( _x, x0, y0-10 )
		
		'check if the mouse is over it
		Local over:bool = True
		If mouseX &lt; x0 Then over = false
		If mouseX &gt; x1 Then over = false
		If mouseY &lt; y0 Then over = false
		If mouseY &gt; y1 Then over = False

		'change the color of the drawing depending on if the mouse is over it
		If over Then
			canvas.Color = Color.Sky
	        DrawCircle( canvas, xx, yy, scale*(_size+(Sin(_gameTime * 0.01)*5 )+5) )
		Else
			canvas.Color = Color.White
		End If

		
		'draw the unit
		Select _kind
			Case UNIT_SHIP
				canvas.DrawImage( _image, xx, yy, _rotate, scale, scale )
				
			Case UNIT_STAR
		        canvas.DrawCircle( xx, yy, sc )
		End Select


		Return over
	End method
	
Private
	'this is any image we might be drawing
	field _image:Image
	
	'this is the kind of thing the unit is
	field _kind:int

	'size is the drawing size radius,  so we could have different sizes for stuff
	'currently there is 25 for the ships (50 width) and 30 radius for the planets
	field _size:float

	'the distance the unit orbits around
	field _orbitDistance:float = 0
	field _orbitX:float
	field _orbitY:float
	
	'does this unit have a parent. -1 (PARENT_NONE) means it does not
	field _parent:int = PARENT_NONE
	
	'and here are some vars to tell us where and what way it's facing
	Field _x:float = 600
	Field _y:float = 600
	Field _rotate:float = 0
	
	'how fast is the unit moving
	field _velocity:float = 0
End Class


class UnitManager
	'what will be the maximum number of units avaialable
	' a unit is anything like a planet or ship,  so we need 16 for the base planets stuff and...
	' lets say 100 other units
	' a missile could be classed as a unit as well,  so lets have 256 units
	const MAX_UNITS:int = 256

	method New()
	End method
	
	
	'ok change here is the method now returns an int.
	'the int is the actual count/position in the array
	method AddShip:int( kind:int, parent:int, chitImage:Image, rotate:float, x:float, y:float )
		Local this:int = _count
		_unit[ _count ] = New Unit( kind, chitImage, rotate, x, y)
		_unit[ _count ].Parent = parent

		_count += 1
		
		Return this
	End method


	method AddPlanet:int( kind:int, parent:int, size:float, x:float, y:float, distance:float, velocity:float= 0 )
		Local this:int = _count

		_unit[ _count ] = New Unit( kind, 0, x, y)
		_unit[ _count ].Size = size
		_unit[ _count ].OrbitDistance = distance
		_unit[ _count ].Parent = parent
		_unit[ _count ].Rotate = Rnd( 360 )
		
		'moake sure that a planet at the center does not move
		If distance &lt; 2 Then velocity = 0
		
		'lets slow things down a bit
		velocity *= 0.001
		
		'we have got a parent,  we now need to do lots of fun things
		If parent &gt; -1 Then
			_unit[ _count ].OrbitDistance += _unit[ _count ].OrbitDistance
		End If
		
		_unit[ _count ].Velocity = velocity
		
		_count += 1
		
		Return this
	End method
	
	
	method DrawUnits( canvas:Canvas, mouseX:int, mouseY:int, midX:float, midY:float, scale:float )
		Local k:int
		_over = -1
		For k = 0 Until _count
			If _unit[k].Parent &gt; -1 Then
				_unit[k].X = _unit[_unit[k].Parent].OrbitX
				_unit[k].Y = _unit[_unit[k].Parent].OrbitY
			End If
			
			if _unit[k].Draw( canvas, mouseX, mouseY, midX, midY, scale ) Then
				_over = k
			End If
		Next
	End method
	
private
	'the units we have
	field _unit:Unit[] = New Unit[ MAX_UNITS ]
	
	'how many units we have got
	field _count:int = 0
	
	'is the mouse over a unit? if so what is it's number
	field _over:int = -1

End Class



Class MyWindow Extends Window

	Method New()
		Super.New( "My Window", Size.X, Size.Y, WindowFlags.Resizable )
	    
		'if you want a constant canvas size use this
'		Layout = "letterbox"
		'or If you want the canvas to always fill the window use this
		Layout = "fill"

		'this is a timer. it will 'tick' 60 times a second. calling OnUpdate
		_timer = New Timer( 60, OnUpdate )
		
		'initial rndseed
		SeedRnd( 747 )

		_maped = Image.Load( "asset::map.png" ) 'I used a 2000x2000 pixel PNG
		_maped.Handle=New Vec2f( .5,.5 )
	
		'lets now assign these to each chit
		'monkey2 will use internal referenceing systems,  so don't bother about resources
		' we will also deal with the image handle in the chit as well ;)
		Local chitImage1:Image = Image.Load( "asset::chit1.png" )
		Local chitImage2:Image = Image.Load( "asset::chit2.png" )
		
		'just so you feel happy about rotation...
		'0 - shows normal bitmap the right way up points east
		'90 is north, 180 points west, 270 south
		'so. lets assume that chit1 is a ship. to have it point the correct way. the bitmap MUST face EAST!
		
        'provide a PNG and variables for every chit on the map
		_unitManager.AddShip( UNIT_SHIP, PARENT_NONE, chitImage1, 0, 150, 150 )
		_unitManager.AddShip( UNIT_SHIP, PARENT_NONE, chitImage2, 45, -51, -80 )
		
		'And the star
		Local parent:int
		_unitManager.AddPlanet( UNIT_STAR, PARENT_NONE, 60, 0,0, 0 )
		'the addPlanet now returns a parent
		parent = _unitManager.AddPlanet( UNIT_STAR, PARENT_NONE, 20, 0,0, 170, 0.2 )
		'we now feed the parentinto the next addplanet
		
		_unitManager.AddPlanet( UNIT_STAR, parent, 10, 0,0, 30, 0.6 )
		
		_unitManager.AddPlanet( UNIT_STAR, parent, 5, 0,0, 40, -0.7 )
	End

Protected
	Method OnUpdate()
		_gameTime = Millisecs()
		
		RequestRender()
	End Method
	
	
	Method OnRender( canvas:Canvas ) Override

		'fill the screen canvas with a color
		canvas.Color = Color.Black
		canvas.DrawRect( 0, 0, Width, Height )

		Select _gameMode
			Case GAMEMODE_INTRO
				DrawTheIntro( canvas )
			Case GAMEMODE_GAME
				DrawTheGame( canvas )
		End Select
	End


	method DrawMap( canvas:Canvas, midX:float, midY:float )
		'draw the mapimage
		canvas.Alpha = 1
		canvas.Color = Color.Grey
		canvas.DrawImage( _maped, midX, midY, 0, _scale, _scale )
		
'		DrawCircleDash( canvas, midX, midY, 100 * _scale )
		
		'draw the 100 lines (100 spatial positions)
		Local k:float
		Local sc:float
		canvas.Color = Color.DarkGrey
		canvas.Alpha = 0.3
		Local xoffset:float = midX Mod (100 * _scale)
		Local yoffset:float = midY Mod (100 * _scale)
		For k = xoffset To Width Step (100 * _scale)
			canvas.DrawLine( k,  0, k, Height )
		Next
		For k = yoffset To Height Step (100 * _scale)
			canvas.DrawLine( 0, k, Width, k )
		Next
		
		'draw the center of the map lines
		canvas.Color = Color.Grey
		canvas.DrawLine( midX, 0, midX, Height )
		canvas.DrawLine( 0, midY, Width, midY )
	End method
	
	
	Method DrawTheGame( canvas:Canvas )
		'find the midpoint from where all drawing is based
		Local midX:float = (Width * 0.5) + _mX
		Local midY:float = (Height * 0.5) + _mY
		
		
		'draw the map in a seperate method
		DrawMap( canvas, midX, midY )
		
        'lets move these into the unit class
		canvas.Color = Color.White
		canvas.Alpha = 1
		
'		canvas.DrawText( midX+" "+midY+"  "+(_mouseX-midX)+" "+(_mouseY-midY), 10, 10 )

		'we now have a unitmanager to handle all the units,  so just one call to it's draw rotine
		' will allow it to do the rest
		_unitManager.DrawUnits( canvas, _mouseX, _mouseY, midX, midY, _scale )
	End Method
	
	
	Method DrawTheIntro( canvas:Canvas )
		canvas.Color = Color.White
	
		canvas.DrawText( " Scroller Map' First App By Mark Ainsworth ref 210665",200,20 )
		canvas.DrawText( " How To Scroll The Map Right Click To Pickup Board, Then Drag it Release to Drop it. ",200,60 )
		canvas.DrawText( " You can Move around the Map By Only RightClicking and Dragging.",200,80 )
		canvas.DrawText("- PRESS ENTER OR LRFT-CLICK MOUSE TO START MAP --&gt;",200,670)
		
	End Method

	
	'respond to any key presses
	Method OnKeyEvent( event:KeyEvent ) Override
		'heres the best way to check for shift keys etc
		Local command:Bool = event.Modifiers &amp; Modifier.Gui
		Local shift:Bool = event.Modifiers &amp; Modifier.Shift
		Local alt:bool = event.Modifiers &amp; Modifier.Alt
		
		Select event.Type
			case EventType.KeyDown
			
				Select event.Key
					Case Key.Enter
						Select _gameMode
							Case GAMEMODE_INTRO
								_gameMode = GAMEMODE_GAME
						End Select
							
				End Select
				
			Case EventType.KeyUp
			
				Select event.Key
					Case Key.Enter
				End Select
				
		End Select
	End

	'here we track the mouse and all mouse related stuff
	Method OnMouseEvent( event:MouseEvent ) Override
		'set up some global mouse cars so we can use these throught to program
		_mouseX = event.Location.X
		_mouseY = event.Location.Y

		'here are the baci mouse events we are interested in
		Select event.Type
			Case EventType.MouseClick
				Select _gameMode
					Case GAMEMODE_INTRO
						_gameMode = GAMEMODE_GAME
						
					Case GAMEMODE_GAME
						_movemap = 1
						If _movemap = 1 'if you left click record current mouse location
							_oldX = _mX + -_mouseX 'plus map location
							_oldY = _mY + -_mouseY
						Endif
				End Select	
				
			Case EventType.MouseUp
				_movemap = 0 'if you move the mouse while dragging
				If _movemap = 0 'the map x,y is updated untill you Mouseup
					_oldX = _mX 
					_oldY = _mY 
				Endif
			Case EventType.MouseEnter
			Case EventType.MouseLeave
			case EventType.MouseWheel
				If event.Wheel.Y &lt;&gt; 0 Then
					_scale = Clamp( _scale + event.Wheel.Y * 0.01, 0.25, 4.0 )
				End If
			Case EventType.MouseMove
				If _movemap = 1
					_mX = _mouseX + _oldX - 0
					_mY = _mouseY + _oldY - 0
				Endif
		End Select
		
	End Method
	
	'this is needed to allow the Size to be correct. this is called automatically
	Method OnMeasure:Vec2i() Override
		Return Size
	End
Private
	'the timer ticks 60 times a second and handles the screen update
	Field _timer:Timer
	
	'what mode is the game in, showing the intro, playing, ended, etc
	Field _gameMode:Int = GAMEMODE_GAME'INTRO
	
	'global mouse vars
	Field _mouseX:Int
	Field _mouseY:Int
	
	field _scale:float = 1

	Field _mY:Int = 0 'position of map -500 so we start 500 in from top
	Field _mX:Int = 0 'position of map -500 so we start 500 in from left
'	Field _twist:Int  'rotate
	Field _oldX:Int 'used to store map location before you drag
	Field _oldY:Int 'used to store map location before you drag
	Field _movemap:Int 'switch to on to dragmap in conjuction with old position


	'image assets
	Field _maped:Image ' this is the map png ' lets say the center is 0, 0

	'set up some classes' these will need to be newed
	field _unitManager:UnitManager =  New UnitManager()
End

</textarea><br><br>basically some minor changes within the manager and drawing routines. and now with added parents. so planets can rotate around a parent.<br>quite mesmerising and very simple.<br><br>OK next up will be the corrected display.<br>YES IM WORKING ON IT. Shut up and eat your breakfast! <br><br></td></tr></table><br>
<a name="1339509"></a>

<a name="1339510"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#131">[#131]</a></td></tr></table></td></tr><tr ><td class="posttext"> we're on a roll now - a ham roll!<br>This is the new version with the unit sorting.<br><br>there has been a bit of shifting around of stuff and modifying code. but as you are starting to know the code. it won't be all alien to you.<br><br>Basically we pre find the screen locations of any units. What we really want is the actual y locations.<br><br>we don't need to deal with left to right (on top of each other X) as it's not really that useful.<br>But For any top down map, the further away the Y is, it must be drawn first.<br>This works even if we change our eye position and look at it from the side!<br><br>Guess what, it even works in 3d and 2d and brilliant for sprite sorting too.<br><br>So... We do a quick bubble sort on the screen y locations (we only change the int references, so the data stays exactly where it was placed and not moved around) &lt;- moving data around is costly, so we only move a single int around.<br><br>I've also split the dashed line in two, so we can draw the back and front separately.<br><br>The 'select only the top thing' is not yet implemented<br><br>heres the code:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Namespace myLetterboxApp

#Import "&lt;std&gt;"
#Import "&lt;mojo&gt;"

Using std..
Using mojo..

#Import "assets/map.png"
#Import "assets/chit1.png"
#Import "assets/chit2.png"


'here is a single global,  for tracking game time
'it is set by Millisecs(),  but if we use a global,  we only need to use Millisecs once when it is set.
'repeatedly calling stuff like mouse and timers may cause slowdowns
'so once it is set,  we just need to read it
'it is a global as everything will need to access it and drawing functions can use it as well
global _gameTime:long




Const Size := New Vec2i( 950,720 )

Const GAMEMODE_INTRO:Int = 1
Const GAMEMODE_GAME:int = 2

'used by the units to assign a none parent
const PARENT_NONE:int = -1


'ok blitzmax rotations were in degrees - simple ;)
'monkey2 reverts back to radians,  so we need a conversion
'so here is the best and quickest conversion I could come up with ;)
const Pi180:double = Pi / 180
function DegreesToRadian:float( degrees:float )
	return degrees * Pi180
End function
'and we will need another to revrse the process
function RadianToDegrees:float( radian:float )
	return radian / Pi180
End function


'monkey does not have any circle drawing routines,  so here is a basic one
function DrawCircle( canvas:Canvas, xc:float, yc:float, radiusX:float, radiusY:float )
	Local div:float = DegreesToRadian( 5 )
	
	Local angle:float = div
	Local xp0:float
	Local yp0:float
	Local xp1:float = xc + radiusX
	Local yp1:float = yc
	Local k:int
	
	For k = 5 To 360 Step 5
		xp0 = xc + Cos( angle ) * radiusX
		yp0 = yc + Sin( angle ) * radiusY
		canvas.DrawLine( xp0, yp0, xp1, yp1 )
		
		xp1 = xp0
		yp1 = yp0
		angle += div
	Next
End function

'monkey does not have any circle drawing routines.
'here is one that draws dashed lines
function DrawCircleDash( canvas:Canvas, xc:float, yc:float, radiusX:float, radiusY:float )
	Local div:float = DegreesToRadian( 5 )
	
	Local angle:float = div
	Local xp0:float
	Local yp0:float
	Local xp1:float = xc + radiusX
	Local yp1:float = yc
	Local k:int
	
	For k = 5 To 360 Step 5
		xp0 = xc + Cos( angle ) * radiusX
		yp0 = yc + Sin( angle ) * radiusY
		If k Mod 10 = 0 Then
			canvas.DrawLine( xp0, yp0, xp1, yp1 )
		End If
		
		xp1 = xp0
		yp1 = yp0
		angle += div
	Next
End function

'now we have seperated the front from the back drawing,  we can use these with the new depth sorting
function DrawCircleDashFront( canvas:Canvas, xc:float, yc:float, radiusX:float, radiusY:float )
	Local div:float = DegreesToRadian( 5 )
	
	Local angle:float = div
	Local xp0:float
	Local yp0:float
	Local xp1:float = xc + radiusX
	Local yp1:float = yc
	Local k:int
	
	For k = 5 To 180 Step 5
		xp0 = xc + Cos( angle ) * radiusX
		yp0 = yc + Sin( angle ) * radiusY
		If k Mod 10 = 0 Then
			canvas.DrawLine( xp0, yp0, xp1, yp1 )
		End If
		
		xp1 = xp0
		yp1 = yp0
		angle += div
	Next
End function

function DrawCircleDashBack( canvas:Canvas, xc:float, yc:float, radiusX:float, radiusY:float )
	Local div:float = DegreesToRadian( 5 )
	
	Local angle:float = DegreesToRadian( 185 )
	Local xp0:float
	Local yp0:float
	Local xp1:float = xc + Cos( 180 ) * radiusX
	Local yp1:float = yc + Sin( 180 ) * radiusY
	Local k:int
	
	For k = 185 To 360 Step 5
		xp0 = xc + Cos( angle ) * radiusX
		yp0 = yc + Sin( angle ) * radiusY
		If k Mod 10 = 0 Then
			canvas.DrawLine( xp0, yp0, xp1, yp1 )
		End If
		
		xp1 = xp0
		yp1 = yp0
		angle += div
	Next
End function

Function Main()
	New AppInstance
	
	New MyWindow
	
	App.Run()
End

'this is now moved into the unit manager
'what will be the maximum number of units avaialable
' a unit is anything like a planet or ship,  so we need 16 for the base planets stuff and...
' lets say 100 other units
' a missile could be classed as a unit as well,  so lets have 256 units
'const MAX_UNITS:int = 256


'lets have some const vars to make me happy
'ive dragged over the const from the universe just so we are talking the same language
const UNIT_BLACKHOLE:int = 0
const UNIT_STAR:int = 1
const UNIT_GASGIANT:int = 2
const UNIT_PLANET:int = 3
const UNIT_MOON:int = 4
const UNIT_ASTEROIDMOON:int = 5
const UNIT_ASTEROID:int = 6
const UNIT_ASTEROIDBELT:int = 7
const UNIT_DUSTBELT:int = 8
const UNIT_NEBULAE:int = 9
const UNIT_RADIATIONBELT:int = 10

'so lets say a ship starts at 100
const UNIT_SHIP:int = 100

'this will be the base class for all chits, anything can be a chit
'ok chit it is - unit would possibly be a better choice though?
'I have converted all int's to floats - this has already bourn fruit with the rotation
'sorry converted chit to unit
Class Unit
	'this is called when any new thing is derrived from this class
	Method New()
	End Method

	
	' so New(67) would give you a Chit with 67 rotation
	Method New( kind:int, chitImage:Image, rotate:float, x:float, y:float )
		'monkey2 uses radians,  so convert from degrees to radian
		_rotate = DegreesToRadian( rotate )

		_x = x 'just a var to initialise starting position of chit
		_y = y
		
		_kind = kind
		
		_size = 25
		
		_image = chitImage
		_image.Handle = New Vec2f( .5,.5 )
	End Method


	Method New( kind:int, rotate:float, x:float, y:float )
		'monkey2 uses radians,  so convert from degrees to radian
		_rotate = DegreesToRadian( rotate )

		_x = x 'just a var to initialise starting position of chit
		_y = y
		
		_kind = kind

		_size = 30
	End Method


	'because _twist is private,  we need a property and setter
	' we only then need to access by _chit.Twist = 40,  or twist = _chit.Twist
	'you can now see here that directly accessing the variables would have caused us a bit more hasslle (in the long term)
	'but using a property/setter,  means the nasty degrees radian stuff lives inside,  and doesn't bother us now
	Property Rotate:float()
		Return RadianToDegrees( _rotate )
	Setter( rotate:float )
		_rotate = DegreesToRadian( rotate )
	End

	'the eye is our watch position. 1 is above,  0 is from the side and -1 is from below
	Property Eye:float()
		Return _eye
	Setter( eye:float )
		_eye = Clamp( eye, -1.0, 1.0 )
	End

	Property X:float()
		Return _x
	Setter( x:float )
		_x = x
	End

	Property Y:float()
		Return _y
	Setter( y:float )
		_y = y
	End

	Property DrawY:float()
		Return _drawY
	End
	
	Property DrawOrbitY:float()
		Return _drawOrbitY
	End

	Property OrbitX:float()
		Return _orbitX
	Setter( orbitX:float )
		_orbitX = orbitX
	End

	Property OrbitY:float()
		Return _orbitY
	Setter( orbitY:float )
		_orbitY = orbitY
	End

	Property Reference:int()
		Return _reference
	Setter( reference:int )
		_reference = reference
	End

	Property Kind:int()
		Return _kind
	Setter( kind:int )
		_kind = kind
	End

	Property Size:float()
		Return _size
	Setter( size:float )
		_size = size
	End
	
	Property Velocity:float()
		Return _velocity
	Setter( velocity:float )
		_velocity = velocity
	End

	Property OrbitDistance:float()
		Return _orbitDistance
	Setter( orbitDistance:float )
		_orbitDistance = orbitDistance
	End

	Property Parent:int()
		Return _parent
	Setter( parent:int )
		_parent = parent
	End

protected
	'this is the new update draw routine. it is basically the old draw with all the drawing removed
	' so it sets everything up for a nice quick draw later.
	' what we really need is the final y draw location. this will be fed into our new sorting stuff
	method UpdateDraw( reference:int, mouseX:int, mouseY:int, x:float, y:float, scale:float )
		_reference = reference
		
		_drawX = (_x * scale) + x
		_drawY = y - (_y * scale) 'this is inverted!!!!
		
		If _orbitDistance &gt; 0 Then
'			canvas.Color = Color.Orange
'			canvas.Alpha = 0.4

			_drawOrbitX = _drawX
			_drawOrbitY = _drawY

'			DrawCircleDash( canvas, xx, yy, _orbitDistance * scale, _orbitDistance * scale * _eye )
			'and modify then xx
			Local rad:float = _orbitDistance
			_orbitX = Cos( _rotate ) * rad
			_orbitY = Sin( _rotate ) * rad * _eye

			_drawX += _orbitX * scale
			_drawY -= _orbitY * scale
			_rotate += _velocity

			'make sure that the orbit vars are correctly offset
			_orbitX += _x
			_orbitY += _y
		else	
			_drawY =  y - ((_y * scale)* _eye)
		End If

		'get the actual drawing locations
		Local sc:float = scale * _size
		Local sc2:float = sc * 2
		Local x0:int = _drawX - sc
		Local x1:int = x0 + sc2
		Local y0:int = _drawY - sc
		Local y1:int = y0 + sc2

		'check if the mouse is over it
		_over = True
		If mouseX &lt; x0 Then _over = false
		If mouseX &gt; x1 Then _over = false
		If mouseY &lt; y0 Then _over = false
		If mouseY &gt; y1 Then _over = False
		
	End method

	
	method DrawBackOrbit( canvas:Canvas, scale:Float )
		canvas.Color = Color.Orange
		canvas.Alpha = 0.4

		DrawCircleDashBack( canvas, _drawOrbitX, _drawOrbitY, _orbitDistance * scale, _orbitDistance * scale * _eye )
		canvas.Alpha = 1
	End method

	method Draw( canvas:Canvas, scale:Float )
		If _orbitDistance &gt; 0 Then
			canvas.Color = Color.Orange
			canvas.Alpha = 0.2

			DrawCircleDashBack( canvas, _drawOrbitX, _drawOrbitY, _orbitDistance * scale, _orbitDistance * scale * _eye )
			canvas.Alpha = 1
		End If

		If _over Then
			canvas.Color = Color.Sky
			Local sc:float = scale*(_size+(Sin(_gameTime * 0.01)*5 )+5)
	        DrawCircle( canvas, _drawX, _drawY, sc, sc )
		Else
			canvas.Color = Color.White
		End If

		
		'draw the unit
		Select _kind
			Case UNIT_SHIP
				canvas.DrawImage( _image, _drawX, _drawY, _rotate, scale, scale )
				
			Case UNIT_STAR
				Local sc:float = scale * _size
		        canvas.DrawCircle( _drawX, _drawY, sc )
		        canvas.Color = Color.DarkGrey
		        canvas.DrawCircle( _drawX, _drawY, sc-2 )
		End Select
		
		'and any front orbit
		If _orbitDistance &gt; 0 Then
			canvas.Color = Color.Orange
			canvas.Alpha = 0.2
			DrawCircleDashFront( canvas, _drawOrbitX, _drawOrbitY, _orbitDistance * scale, _orbitDistance * scale * _eye )
			canvas.Alpha = 1
		End if
	End method
	
Private
	'this is any image we might be drawing
	field _image:Image
	
	'this is the kind of thing the unit is
	field _kind:int

	'size is the drawing size radius,  so we could have different sizes for stuff
	'currently there is 25 for the ships (50 width) and 30 radius for the planets
	field _size:float

	'the distance the unit orbits around
	field _orbitDistance:float = 0
	field _orbitX:float
	field _orbitY:float
	field _drawOrbitX:float
	field _drawOrbitY:float
	
	'is the mouse over it
	field _over:bool = False
	
	'this is our view position
	field _eye:float = 1
	
	'does this unit have a parent. -1 (PARENT_NONE) means it does not
	field _parent:int = PARENT_NONE
	'ok and now we need a sort reference position. this is going to become very important
	field _reference:int
	
	'and here are some vars to tell us where and what way it's facing
	Field _x:float = 600
	Field _y:float = 600
	Field _rotate:float = 0
	
	'the actual drawing positions
	field _drawX:float
	field _drawY:float
	
	'how fast is the unit moving
	field _velocity:float = 0
End Class


class UnitManager
	'what will be the maximum number of units avaialable
	' a unit is anything like a planet or ship,  so we need 16 for the base planets stuff and...
	' lets say 100 other units
	' a missile could be classed as a unit as well,  so lets have 256 units
	const MAX_UNITS:int = 256

	method New()
	End method
	

	'the eye is our watch position. 1 is above,  0 is from the side and -1 is from below. we wont be going below 0.1!
	Property Eye:float()
		Return _eye
	Setter( eye:float )
		_eye = Clamp( eye, 0.1, 1.0 )

		'update all the units eye positions
		Local k:int
		For k = 0 Until _count
			_unit[k].Eye = _eye
		Next
	End

	'ok change here is the method now returns an int.
	'the int is the actual count/position in the array
	method AddShip:int( kind:int, parent:int, chitImage:Image, rotate:float, x:float, y:float )
		Local this:int = _count
		_unit[ _count ] = New Unit( kind, chitImage, rotate, x, y)
		_unit[ _count ].Parent = parent

		_count += 1
		
		Return this
	End method


	method AddPlanet:int( kind:int, parent:int, size:float, x:float, y:float, distance:float, velocity:float= 0 )
		Local this:int = _count

		_unit[ _count ] = New Unit( kind, 0, x, y)
		_unit[ _count ].Size = size
		_unit[ _count ].OrbitDistance = distance
		_unit[ _count ].Parent = parent
		_unit[ _count ].Rotate = Rnd( 360 )
		
		'moake sure that a planet at the center does not move
		If distance &lt; 2 Then velocity = 0
		
		'lets slow things down a bit
		velocity *= 0.01'01
		
		'we have got a parent,  we now need to do lots of fun things
		If parent &gt; -1 Then
			_unit[ _count ].OrbitDistance += _unit[ _count ].OrbitDistance
		End If
		
		_unit[ _count ].Velocity = velocity
		
		_count += 1
		
		Return this
	End method
	
	
	'new method update to keep everything where it makes more sense
	method UpdateUnits()
		Local k:int
		For k = 0 Until _count
		
			'only planets 'should' have parents. and we need to update their positions
			If _unit[k].Parent &gt; -1 Then
				_unit[k].X = _unit[_unit[k].Parent].OrbitX
				_unit[k].Y = _unit[_unit[k].Parent].OrbitY
			End If
			
		Next
	End method
	
	'we now need some form of sorting so that everything is displayed from the furthest to the nearest
	'if you look down on a map, table, game or whatever. any object with a low y is closer to you
	'so... throw out the x (not interested in that)
	'and do a simple (not the best) sort on the y values.
	'we will improve the sort later. lets just get it working first
	method SortUnits( mouseX:int, mouseY:int, midX:float, midY:float, scale:float )
		'this is a 2 step process.
		'first we reset the sort references
		Local k:int
		For k = 0 Until _count
			'first update the drawing and the sort references
			_unit[k].UpdateDraw( k, mouseX, mouseY, midX, midY, scale )
		Next
		
		'next we do the sort' this is a slow bubble sort. we can use other faster sorts later
		Local l:int
		Local tmp:int
		For k = 0 To _count-2
			For l = k+1 To _count-1
				If _unit[ _unit[ k ].Reference ].DrawY &gt; _unit[ _unit[ l ].Reference ].DrawY Then
					tmp = _unit[ k ].Reference
					_unit[ k ].Reference = _unit[ l ].Reference
					_unit[ l ].Reference = tmp
				End If
			Next
		Next
	End method
	
	
	'and now draw them correctly
	method DrawUnits( canvas:Canvas, mouseX:int, mouseY:int, midX:float, midY:float, scale:float )
		SortUnits( mouseX, mouseY, midX, midY, scale )
		
		'and not the front facing units plus orbits
		local k:int
		For k = 0 Until _count

			'ok. this will draw the units just like before. uncomment it and comment out the other line to see it
'			_unit[ k ].Draw( canvas, scale )

			'but here is the magic version
			'We draw using the sort reference instead. sorted from back to front
			_unit[ _unit[k].Reference ].Draw( canvas, scale )
		Next
	End method

private
	'the units we have
	field _unit:Unit[] = New Unit[ MAX_UNITS ]
	
	'how many units we have got
	field _count:int = 0
	
	'is the mouse over a unit? if so what is it's number
	field _over:int = -1
	
	'where are we looking from
	field _eye:float = 1

End Class



Class MyWindow Extends Window

	Method New()
		Super.New( "My Window", Size.X, Size.Y, WindowFlags.Resizable )
	    
		'if you want a constant canvas size use this
'		Layout = "letterbox"
		'or If you want the canvas to always fill the window use this
		Layout = "fill"

		'this is a timer. it will 'tick' 60 times a second. calling OnUpdate
		_timer = New Timer( 60, OnUpdate )
		
		'initial rndseed
		SeedRnd( 747 )

		_maped = Image.Load( "asset::map.png" ) 'I used a 2000x2000 pixel PNG
		_maped.Handle=New Vec2f( .5,.5 )
	
		'lets now assign these to each chit
		'monkey2 will use internal referenceing systems,  so don't bother about resources
		' we will also deal with the image handle in the chit as well ;)
		Local chitImage1:Image = Image.Load( "asset::chit1.png" )
		Local chitImage2:Image = Image.Load( "asset::chit2.png" )
		
		'just so you feel happy about rotation...
		'0 - shows normal bitmap the right way up points east
		'90 is north, 180 points west, 270 south
		'so. lets assume that chit1 is a ship. to have it point the correct way. the bitmap MUST face EAST!
		
        'provide a PNG and variables for every chit on the map
		_unitManager.AddShip( UNIT_SHIP, PARENT_NONE, chitImage1, 0, 150, 150 )
		_unitManager.AddShip( UNIT_SHIP, PARENT_NONE, chitImage2, 45, -51, -80 )
		
		'And the star
		Local parent:int
		_unitManager.AddPlanet( UNIT_STAR, PARENT_NONE, 60, 0,0, 0 )
		'the addPlanet now returns a parent
		parent = _unitManager.AddPlanet( UNIT_STAR, PARENT_NONE, 20, 0,0, 170, 0.2 )
		'we now feed the parentinto the next addplanet
		
		Local parent2:int
		parent2 = _unitManager.AddPlanet( UNIT_STAR, parent, 10, 0,0, 30, 0.6 )
		_unitManager.AddPlanet( UNIT_STAR, parent2, 5, 0,0, 15, 6 )
		
		_unitManager.AddPlanet( UNIT_STAR, parent, 5, 0,0, 50, -0.7 )
		
		'last we want to set an eye poition the eye goes from 1 (from above),  to 0.1 (from the side)
		' 0.5 is about isometric view
		_unitManager.Eye = 0.25
	End

Protected
	Method OnUpdate()
		_gameTime = Millisecs()
		
		_unitManager.UpdateUnits()
		
		RequestRender()
	End Method
	
	
	Method OnRender( canvas:Canvas ) Override

		'fill the screen canvas with a color
		canvas.Color = Color.Black
		canvas.DrawRect( 0, 0, Width, Height )

		Select _gameMode
			Case GAMEMODE_INTRO
				DrawTheIntro( canvas )
			Case GAMEMODE_GAME
				DrawTheGame( canvas )
		End Select
	End


	method DrawMap( canvas:Canvas, midX:float, midY:float )
		'draw the mapimage
		canvas.Alpha = 1
		canvas.Color = Color.Grey
		canvas.DrawImage( _maped, midX, midY, 0, _scale, _scale )
		
'		DrawCircleDash( canvas, midX, midY, 100 * _scale )
		
		'draw the 100 lines (100 spatial positions)
		Local k:float
		Local sc:float
		canvas.Color = Color.DarkGrey
		canvas.Alpha = 0.3
		Local xoffset:float = midX Mod (100 * _scale)
		Local yoffset:float = midY Mod (100 * _scale)
		For k = xoffset To Width Step (100 * _scale)
			canvas.DrawLine( k,  0, k, Height )
		Next
		For k = yoffset To Height Step (100 * _scale * _unitManager.Eye)
			canvas.DrawLine( 0, k, Width, k )
		Next
		
		'draw the center of the map lines
		canvas.Color = Color.Grey
		canvas.DrawLine( midX, 0, midX, Height )
		canvas.DrawLine( 0, midY, Width, midY )
	End method
	
	
	Method DrawTheGame( canvas:Canvas )
		'find the midpoint from where all drawing is based
		Local midX:float = (Width * 0.5) + _mX
		Local midY:float = (Height * 0.5) + _mY
		
		
		'draw the map in a seperate method
		DrawMap( canvas, midX, midY )
		
        'lets move these into the unit class
		canvas.Color = Color.White
		canvas.Alpha = 1
		
'		canvas.DrawText( midX+" "+midY+"  "+(_mouseX-midX)+" "+(_mouseY-midY), 10, 10 )

		'we now have a unitmanager to handle all the units,  so just one call to it's draw routine
		' will allow it to do the rest
		_unitManager.DrawUnits( canvas, _mouseX, _mouseY, midX, midY, _scale )
	End Method
	
	
	Method DrawTheIntro( canvas:Canvas )
		canvas.Color = Color.White
	
		canvas.DrawText( " Scroller Map' First App By Mark Ainsworth ref 210665",200,20 )
		canvas.DrawText( " How To Scroll The Map Right Click To Pickup Board, Then Drag it Release to Drop it. ",200,60 )
		canvas.DrawText( " You can Move around the Map By Only RightClicking and Dragging.",200,80 )
		canvas.DrawText("- PRESS ENTER OR LRFT-CLICK MOUSE TO START MAP --&gt;",200,670)
		
	End Method

	
	'respond to any key presses
	Method OnKeyEvent( event:KeyEvent ) Override
		'heres the best way to check for shift keys etc
		Local command:Bool = event.Modifiers &amp; Modifier.Gui
		Local shift:Bool = event.Modifiers &amp; Modifier.Shift
		Local alt:bool = event.Modifiers &amp; Modifier.Alt
		
		Select event.Type
			case EventType.KeyDown
			
				Select event.Key
					Case Key.Enter
						Select _gameMode
							Case GAMEMODE_INTRO
								_gameMode = GAMEMODE_GAME
						End Select
							
				End Select
				
			Case EventType.KeyUp
			
				Select event.Key
					Case Key.Enter
				End Select
				
		End Select
	End

	'here we track the mouse and all mouse related stuff
	Method OnMouseEvent( event:MouseEvent ) Override
		'set up some global mouse cars so we can use these throught to program
		_mouseX = event.Location.X
		_mouseY = event.Location.Y

		'here are the baci mouse events we are interested in
		Select event.Type
			Case EventType.MouseClick
				Select _gameMode
					Case GAMEMODE_INTRO
						_gameMode = GAMEMODE_GAME
						
					Case GAMEMODE_GAME
						_movemap = 1
						If _movemap = 1 'if you left click record current mouse location
							_oldX = _mX + -_mouseX 'plus map location
							_oldY = _mY + -_mouseY
						Endif
				End Select	
				
			Case EventType.MouseUp
				_movemap = 0 'if you move the mouse while dragging
				If _movemap = 0 'the map x,y is updated untill you Mouseup
					_oldX = _mX 
					_oldY = _mY 
				Endif
			Case EventType.MouseEnter
			Case EventType.MouseLeave
			case EventType.MouseWheel
				If event.Wheel.Y &lt;&gt; 0 Then
					_scale = Clamp( _scale + event.Wheel.Y * 0.01, 0.25, 4.0 )
				End If
			Case EventType.MouseMove
				If _movemap = 1
					_mX = _mouseX + _oldX - 0
					_mY = _mouseY + _oldY - 0
				Endif
		End Select
		
	End Method
	
	'this is needed to allow the Size to be correct. this is called automatically
	Method OnMeasure:Vec2i() Override
		Return Size
	End
Private
	'the timer ticks 60 times a second and handles the screen update
	Field _timer:Timer
	
	'what mode is the game in, showing the intro, playing, ended, etc
	Field _gameMode:Int = GAMEMODE_GAME'INTRO
	
	'global mouse vars
	Field _mouseX:Int
	Field _mouseY:Int
	
	field _scale:float = 1

	Field _mY:Int = 0 'position of map -500 so we start 500 in from top
	Field _mX:Int = 0 'position of map -500 so we start 500 in from left
'	Field _twist:Int  'rotate
	Field _oldX:Int 'used to store map location before you drag
	Field _oldY:Int 'used to store map location before you drag
	Field _movemap:Int 'switch to on to dragmap in conjuction with old position

	'image assets
	Field _maped:Image ' this is the map png ' lets say the center is 0, 0

	'set up some classes' these will need to be newed
	field _unitManager:UnitManager =  New UnitManager()
End

</textarea> <br><br></td></tr></table><br>
<a name="1339511"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Matty</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#132">[#132]</a></td></tr></table></td></tr><tr ><td class="posttext"> This is quite good. I like this. <br><br></td></tr></table><br>
<a name="1339512"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#133">[#133]</a></td></tr></table></td></tr><tr ><td class="posttext"> latest<br>I know you are gonna love the one Mainsworthy<br>It's got logical picking. so the top most item is the one selected<br><br>the basic premise is a few lines added to the update manager routine which reverse finds the first thing we are over and then turns off anything else<br><br>here's the code<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Namespace myLetterboxApp

#Import "&lt;std&gt;"
#Import "&lt;mojo&gt;"

Using std..
Using mojo..

#Import "assets/map.png"
#Import "assets/chit1.png"
#Import "assets/chit2.png"


'here is a single global,  for tracking game time
'it is set by Millisecs(),  but if we use a global,  we only need to use Millisecs once when it is set.
'repeatedly calling stuff like mouse and timers may cause slowdowns
'so once it is set,  we just need to read it
'it is a global as everything will need to access it and drawing functions can use it as well
global _gameTime:long




Const Size := New Vec2i( 950,720 )

Const GAMEMODE_INTRO:Int = 1
Const GAMEMODE_GAME:int = 2

'used by the units to assign a none parent
const PARENT_NONE:int = -1


'ok blitzmax rotations were in degrees - simple ;)
'monkey2 reverts back to radians,  so we need a conversion
'so here is the best and quickest conversion I could come up with ;)
const Pi180:double = Pi / 180
function DegreesToRadian:float( degrees:float )
	return degrees * Pi180
End function
'and we will need another to revrse the process
function RadianToDegrees:float( radian:float )
	return radian / Pi180
End function


'monkey does not have any circle drawing routines,  so here is a basic one
function DrawCircle( canvas:Canvas, xc:float, yc:float, radiusX:float, radiusY:float )
	Local div:float = DegreesToRadian( 5 )
	
	Local angle:float = div
	Local xp0:float
	Local yp0:float
	Local xp1:float = xc + radiusX
	Local yp1:float = yc
	Local k:int
	
	For k = 5 To 360 Step 5
		xp0 = xc + Cos( angle ) * radiusX
		yp0 = yc + Sin( angle ) * radiusY
		canvas.DrawLine( xp0, yp0, xp1, yp1 )
		
		xp1 = xp0
		yp1 = yp0
		angle += div
	Next
End function

'monkey does not have any circle drawing routines.
'here is one that draws dashed lines
function DrawCircleDash( canvas:Canvas, xc:float, yc:float, radiusX:float, radiusY:float )
	Local div:float = DegreesToRadian( 5 )
	
	Local angle:float = div
	Local xp0:float
	Local yp0:float
	Local xp1:float = xc + radiusX
	Local yp1:float = yc
	Local k:int
	
	For k = 5 To 360 Step 5
		xp0 = xc + Cos( angle ) * radiusX
		yp0 = yc + Sin( angle ) * radiusY
		If k Mod 10 = 0 Then
			canvas.DrawLine( xp0, yp0, xp1, yp1 )
		End If
		
		xp1 = xp0
		yp1 = yp0
		angle += div
	Next
End function

'now we have seperated the front from the back drawing,  we can use these with the new depth sorting
function DrawCircleDashFront( canvas:Canvas, xc:float, yc:float, radiusX:float, radiusY:float )
	Local div:float = DegreesToRadian( 5 )
	
	Local angle:float = div
	Local xp0:float
	Local yp0:float
	Local xp1:float = xc + radiusX
	Local yp1:float = yc
	Local k:int
	
	For k = 5 To 180 Step 5
		xp0 = xc + Cos( angle ) * radiusX
		yp0 = yc + Sin( angle ) * radiusY
		If k Mod 10 = 0 Then
			canvas.DrawLine( xp0, yp0, xp1, yp1 )
		End If
		
		xp1 = xp0
		yp1 = yp0
		angle += div
	Next
End function

function DrawCircleDashBack( canvas:Canvas, xc:float, yc:float, radiusX:float, radiusY:float )
	Local div:float = DegreesToRadian( 5 )
	
	Local angle:float = DegreesToRadian( 185 )
	Local xp0:float
	Local yp0:float
	Local xp1:float = xc + Cos( 180 ) * radiusX
	Local yp1:float = yc + Sin( 180 ) * radiusY
	Local k:int
	
	For k = 185 To 360 Step 5
		xp0 = xc + Cos( angle ) * radiusX
		yp0 = yc + Sin( angle ) * radiusY
		If k Mod 10 = 0 Then
			canvas.DrawLine( xp0, yp0, xp1, yp1 )
		End If
		
		xp1 = xp0
		yp1 = yp0
		angle += div
	Next
End function

Function Main()
	New AppInstance
	
	New MyWindow
	
	App.Run()
End

'this is now moved into the unit manager
'what will be the maximum number of units avaialable
' a unit is anything like a planet or ship,  so we need 16 for the base planets stuff and...
' lets say 100 other units
' a missile could be classed as a unit as well,  so lets have 256 units
'const MAX_UNITS:int = 256


'lets have some const vars to make me happy
'ive dragged over the const from the universe just so we are talking the same language
const UNIT_BLACKHOLE:int = 0
const UNIT_STAR:int = 1
const UNIT_GASGIANT:int = 2
const UNIT_PLANET:int = 3
const UNIT_MOON:int = 4
const UNIT_ASTEROIDMOON:int = 5
const UNIT_ASTEROID:int = 6
const UNIT_ASTEROIDBELT:int = 7
const UNIT_DUSTBELT:int = 8
const UNIT_NEBULAE:int = 9
const UNIT_RADIATIONBELT:int = 10

'so lets say a ship starts at 100
const UNIT_SHIP:int = 100

'this will be the base class for all chits, anything can be a chit
'ok chit it is - unit would possibly be a better choice though?
'I have converted all int's to floats - this has already bourn fruit with the rotation
'sorry converted chit to unit
Class Unit
	'this is called when any new thing is derrived from this class
	Method New()
	End Method

	
	' so New(67) would give you a Chit with 67 rotation
	Method New( kind:int, chitImage:Image, rotate:float, x:float, y:float )
		'monkey2 uses radians,  so convert from degrees to radian
		_rotate = DegreesToRadian( rotate )

		_x = x 'just a var to initialise starting position of chit
		_y = y
		
		_kind = kind
		
		_size = 25
		
		_image = chitImage
		_image.Handle = New Vec2f( .5,.5 )
	End Method


	Method New( kind:int, rotate:float, x:float, y:float )
		'monkey2 uses radians,  so convert from degrees to radian
		_rotate = DegreesToRadian( rotate )

		_x = x 'just a var to initialise starting position of chit
		_y = y
		
		_kind = kind

		_size = 30
	End Method


	'because _twist is private,  we need a property and setter
	' we only then need to access by _chit.Twist = 40,  or twist = _chit.Twist
	'you can now see here that directly accessing the variables would have caused us a bit more hasslle (in the long term)
	'but using a property/setter,  means the nasty degrees radian stuff lives inside,  and doesn't bother us now
	Property Rotate:float()
		Return RadianToDegrees( _rotate )
	Setter( rotate:float )
		_rotate = DegreesToRadian( rotate )
	End

	'the eye is our watch position. 1 is above,  0 is from the side and -1 is from below
	Property Eye:float()
		Return _eye
	Setter( eye:float )
		_eye = Clamp( eye, -1.0, 1.0 )
	End

	Property X:float()
		Return _x
	Setter( x:float )
		_x = x
	End

	Property Y:float()
		Return _y
	Setter( y:float )
		_y = y
	End

	Property DrawY:float()
		Return _drawY
	End
	
	Property DrawOrbitY:float()
		Return _drawOrbitY
	End

	Property OrbitX:float()
		Return _orbitX
	Setter( orbitX:float )
		_orbitX = orbitX
	End

	Property OrbitY:float()
		Return _orbitY
	Setter( orbitY:float )
		_orbitY = orbitY
	End

	Property Reference:int()
		Return _reference
	Setter( reference:int )
		_reference = reference
	End

	Property Kind:int()
		Return _kind
	Setter( kind:int )
		_kind = kind
	End

	Property Size:float()
		Return _size
	Setter( size:float )
		_size = size
	End
	
	Property Over:bool()
		Return _over
	Setter( over:bool )
		_over = over
	End

	Property Velocity:float()
		Return _velocity
	Setter( velocity:float )
		_velocity = velocity
	End

	Property OrbitDistance:float()
		Return _orbitDistance
	Setter( orbitDistance:float )
		_orbitDistance = orbitDistance
	End

	Property Parent:int()
		Return _parent
	Setter( parent:int )
		_parent = parent
	End

protected
	'this is the new update draw routine. it is basically the old draw with all the drawing removed
	' so it sets everything up for a nice quick draw later.
	' what we really need is the final y draw location. this will be fed into our new sorting stuff
	method UpdateDraw( reference:int, mouseX:int, mouseY:int, x:float, y:float, scale:float )
		_reference = reference
		
		_drawX = (_x * scale) + x
		_drawY = y - (_y * scale) 'this is inverted!!!!
		
		If _orbitDistance &gt; 0 Then
'			canvas.Color = Color.Orange
'			canvas.Alpha = 0.4

			_drawOrbitX = _drawX
			_drawOrbitY = _drawY

'			DrawCircleDash( canvas, xx, yy, _orbitDistance * scale, _orbitDistance * scale * _eye )
			'and modify then xx
			Local rad:float = _orbitDistance
			_orbitX = Cos( _rotate ) * rad
			_orbitY = Sin( _rotate ) * rad * _eye

			_drawX += _orbitX * scale
			_drawY -= _orbitY * scale
			_rotate += _velocity

			'make sure that the orbit vars are correctly offset
			_orbitX += _x
			_orbitY += _y
		else	
			_drawY =  y - ((_y * scale)* _eye)
		End If

		'get the actual drawing locations
		Local sc:float = scale * _size
		Local sc2:float = sc * 2
		Local x0:int = _drawX - sc
		Local x1:int = x0 + sc2
		Local y0:int = _drawY - sc
		Local y1:int = y0 + sc2

		'check if the mouse is over it
		_over = True
		If mouseX &lt; x0 Then _over = false
		If mouseX &gt; x1 Then _over = false
		If mouseY &lt; y0 Then _over = false
		If mouseY &gt; y1 Then _over = False
		
	End method

	
	method DrawBackOrbit( canvas:Canvas, scale:Float )
		canvas.Color = Color.Orange
		canvas.Alpha = 0.4

		DrawCircleDashBack( canvas, _drawOrbitX, _drawOrbitY, _orbitDistance * scale, _orbitDistance * scale * _eye )
		canvas.Alpha = 1
	End method

	method Draw( canvas:Canvas, scale:Float )
		If _orbitDistance &gt; 0 Then
			canvas.Color = Color.Orange
			canvas.Alpha = 0.2

			DrawCircleDashBack( canvas, _drawOrbitX, _drawOrbitY, _orbitDistance * scale, _orbitDistance * scale * _eye )
			canvas.Alpha = 1
		End If

		If _over Then
			canvas.Color = Color.Sky
			Local sc:float = scale*(_size+(Sin(_gameTime * 0.01)*5 )+5)
	        DrawCircle( canvas, _drawX, _drawY, sc, sc )
		Else
			canvas.Color = Color.White
		End If

		
		'draw the unit
		Select _kind
			Case UNIT_SHIP
				canvas.DrawImage( _image, _drawX, _drawY, _rotate, scale, scale )
				
			Case UNIT_STAR
				Local sc:float = scale * _size
		        canvas.DrawCircle( _drawX, _drawY, sc )
		        canvas.Color = Color.DarkGrey
		        canvas.DrawCircle( _drawX, _drawY, sc-2 )
		End Select
		
		'and any front orbit
		If _orbitDistance &gt; 0 Then
			canvas.Color = Color.Orange
			canvas.Alpha = 0.2
			DrawCircleDashFront( canvas, _drawOrbitX, _drawOrbitY, _orbitDistance * scale, _orbitDistance * scale * _eye )
			canvas.Alpha = 1
		End if
	End method
	
Private
	'this is any image we might be drawing
	field _image:Image
	
	'this is the kind of thing the unit is
	field _kind:int

	'size is the drawing size radius,  so we could have different sizes for stuff
	'currently there is 25 for the ships (50 width) and 30 radius for the planets
	field _size:float

	'the distance the unit orbits around
	field _orbitDistance:float = 0
	field _orbitX:float
	field _orbitY:float
	field _drawOrbitX:float
	field _drawOrbitY:float
	
	'is the mouse over it
	field _over:bool = False
	
	'this is our view position
	field _eye:float = 1
	
	'does this unit have a parent. -1 (PARENT_NONE) means it does not
	field _parent:int = PARENT_NONE
	'ok and now we need a sort reference position. this is going to become very important
	field _reference:int
	
	'and here are some vars to tell us where and what way it's facing
	Field _x:float = 600
	Field _y:float = 600
	Field _rotate:float = 0
	
	'the actual drawing positions
	field _drawX:float
	field _drawY:float
	
	'how fast is the unit moving
	field _velocity:float = 0
End Class


class UnitManager
	'what will be the maximum number of units avaialable
	' a unit is anything like a planet or ship,  so we need 16 for the base planets stuff and...
	' lets say 100 other units
	' a missile could be classed as a unit as well,  so lets have 256 units
	const MAX_UNITS:int = 256

	method New()
	End method
	

	'the eye is our watch position. 1 is above,  0 is from the side and -1 is from below. we wont be going below 0.1!
	Property Eye:float()
		Return _eye
	Setter( eye:float )
		_eye = Clamp( eye, 0.1, 1.0 )

		'update all the units eye positions
		Local k:int
		For k = 0 Until _count
			_unit[k].Eye = _eye
		Next
	End

	'ok change here is the method now returns an int.
	'the int is the actual count/position in the array
	method AddShip:int( kind:int, parent:int, chitImage:Image, rotate:float, x:float, y:float )
		Local this:int = _count
		_unit[ _count ] = New Unit( kind, chitImage, rotate, x, y)
		_unit[ _count ].Parent = parent

		_count += 1
		
		Return this
	End method


	method AddPlanet:int( kind:int, parent:int, size:float, x:float, y:float, distance:float, velocity:float= 0 )
		Local this:int = _count

		_unit[ _count ] = New Unit( kind, 0, x, y)
		_unit[ _count ].Size = size
		_unit[ _count ].OrbitDistance = distance
		_unit[ _count ].Parent = parent
		_unit[ _count ].Rotate = Rnd( 360 )
		
		'moake sure that a planet at the center does not move
		If distance &lt; 2 Then velocity = 0
		
		'lets slow things down a bit
		velocity *= 0.001
		
		'we have got a parent,  we now need to do lots of fun things
		If parent &gt; -1 Then
			_unit[ _count ].OrbitDistance += _unit[ _count ].OrbitDistance
		End If
		
		_unit[ _count ].Velocity = velocity
		
		_count += 1
		
		Return this
	End method
	
	
	'new method update to keep everything where it makes more sense
	method UpdateUnits()
		Local k:int
		For k = 0 Until _count
		
			'only planets 'should' have parents. and we need to update their positions
			If _unit[k].Parent &gt; -1 Then
				_unit[k].X = _unit[_unit[k].Parent].OrbitX
				_unit[k].Y = _unit[_unit[k].Parent].OrbitY
			End If
			
		Next
	End method
	
	'we now need some form of sorting so that everything is displayed from the furthest to the nearest
	'if you look down on a map, table, game or whatever. any object with a low y is closer to you
	'so... throw out the x (not interested in that)
	'and do a simple (not the best) sort on the y values.
	'we will improve the sort later. lets just get it working first
	method SortUnits( mouseX:int, mouseY:int, midX:float, midY:float, scale:float )
		'this is a 2 step process.
		'first we reset the sort references
		Local k:int
		For k = 0 Until _count
			'first update the drawing and the sort references
			_unit[k].UpdateDraw( k, mouseX, mouseY, midX, midY, scale )
		Next
		
		'next we do the sort' this is a slow bubble sort. we can use other faster sorts later
		Local l:int
		Local tmp:int
		For k = 0 To _count-2
			For l = k+1 To _count-1
				If _unit[ _unit[ k ].Reference ].DrawY &gt; _unit[ _unit[ l ].Reference ].DrawY Then
					tmp = _unit[ k ].Reference
					_unit[ k ].Reference = _unit[ l ].Reference
					_unit[ l ].Reference = tmp
				End If
			Next
		Next

		'and now reverse search and pick the top most thing we are over
		k = _count-1
		Local over:int = -1
		While k &gt; -1
			If over = -1 then
				if _unit[ _unit[ k ].Reference ].Over Then over = k
			Else
				_unit[ _unit[ k ].Reference ].Over = false
			End If
			k -= 1
		Wend
'		Print over
		
	End method
	
	
	'and now draw them correctly
	method DrawUnits( canvas:Canvas, mouseX:int, mouseY:int, midX:float, midY:float, scale:float )
		SortUnits( mouseX, mouseY, midX, midY, scale )
		
		'and not the front facing units plus orbits
		local k:int
		For k = 0 Until _count

			'ok. this will draw the units just like before. uncomment it and comment out the other line to see it
'			_unit[ k ].Draw( canvas, scale )

			'but here is the magic version
			'We draw using the sort reference instead. sorted from back to front
			_unit[ _unit[k].Reference ].Draw( canvas, scale )
		Next
	End method

private
	'the units we have
	field _unit:Unit[] = New Unit[ MAX_UNITS ]
	
	'how many units we have got
	field _count:int = 0
	
	'is the mouse over a unit? if so what is it's number
	field _over:int = -1
	
	'where are we looking from
	field _eye:float = 1

End Class



Class MyWindow Extends Window

	Method New()
		Super.New( "My Window", Size.X, Size.Y, WindowFlags.Resizable )
	    
		'if you want a constant canvas size use this
'		Layout = "letterbox"
		'or If you want the canvas to always fill the window use this
		Layout = "fill"

		'this is a timer. it will 'tick' 60 times a second. calling OnUpdate
		_timer = New Timer( 60, OnUpdate )
		
		'initial rndseed
		SeedRnd( 747 )

		_maped = Image.Load( "asset::map.png" ) 'I used a 2000x2000 pixel PNG
		_maped.Handle=New Vec2f( .5,.5 )
	
		'lets now assign these to each chit
		'monkey2 will use internal referenceing systems,  so don't bother about resources
		' we will also deal with the image handle in the chit as well ;)
		Local chitImage1:Image = Image.Load( "asset::chit1.png" )
		Local chitImage2:Image = Image.Load( "asset::chit2.png" )
		
		'just so you feel happy about rotation...
		'0 - shows normal bitmap the right way up points east
		'90 is north, 180 points west, 270 south
		'so. lets assume that chit1 is a ship. to have it point the correct way. the bitmap MUST face EAST!
		
        'provide a PNG and variables for every chit on the map
		_unitManager.AddShip( UNIT_SHIP, PARENT_NONE, chitImage1, 0, 150, 150 )
		_unitManager.AddShip( UNIT_SHIP, PARENT_NONE, chitImage2, 45, -51, -80 )
		
		'And the star
		Local parent:int
		_unitManager.AddPlanet( UNIT_STAR, PARENT_NONE, 60, 0,0, 0 )
		'the addPlanet now returns a parent
		parent = _unitManager.AddPlanet( UNIT_STAR, PARENT_NONE, 20, 0,0, 170, 0.2 )
		'we now feed the parentinto the next addplanet
		
		Local parent2:int
		parent2 = _unitManager.AddPlanet( UNIT_STAR, parent, 10, 0,0, 30, 0.6 )
		_unitManager.AddPlanet( UNIT_STAR, parent2, 5, 0,0, 15, 6 )
		
		_unitManager.AddPlanet( UNIT_STAR, parent, 5, 0,0, 50, -0.7 )
		
		'last we want to set an eye poition the eye goes from 1 (from above),  to 0.1 (from the side)
		' 0.5 is about isometric view
		_unitManager.Eye = 0.25
	End

Protected
	Method OnUpdate()
		_gameTime = Millisecs()
		
		_unitManager.UpdateUnits()
		
		RequestRender()
	End Method
	
	
	Method OnRender( canvas:Canvas ) Override

		'fill the screen canvas with a color
		canvas.Color = Color.Black
		canvas.DrawRect( 0, 0, Width, Height )

		Select _gameMode
			Case GAMEMODE_INTRO
				DrawTheIntro( canvas )
			Case GAMEMODE_GAME
				DrawTheGame( canvas )
		End Select
	End


	method DrawMap( canvas:Canvas, midX:float, midY:float )
		'draw the mapimage
		canvas.Alpha = 1
		canvas.Color = Color.Grey
		canvas.DrawImage( _maped, midX, midY, 0, _scale, _scale )
		
'		DrawCircleDash( canvas, midX, midY, 100 * _scale )
		
		'draw the 100 lines (100 spatial positions)
		Local k:float
		Local sc:float
		canvas.Color = Color.DarkGrey
		canvas.Alpha = 0.3
		Local xoffset:float = midX Mod (100 * _scale)
		Local yoffset:float = midY Mod (100 * _scale)
		For k = xoffset To Width Step (100 * _scale)
			canvas.DrawLine( k,  0, k, Height )
		Next
		For k = yoffset To Height Step (100 * _scale * _unitManager.Eye)
			canvas.DrawLine( 0, k, Width, k )
		Next
		
		'draw the center of the map lines
		canvas.Color = Color.Grey
		canvas.DrawLine( midX, 0, midX, Height )
		canvas.DrawLine( 0, midY, Width, midY )
	End method
	
	
	Method DrawTheGame( canvas:Canvas )
		'find the midpoint from where all drawing is based
		Local midX:float = (Width * 0.5) + _mX
		Local midY:float = (Height * 0.5) + _mY
		
		
		'draw the map in a seperate method
		DrawMap( canvas, midX, midY )
		
        'lets move these into the unit class
		canvas.Color = Color.White
		canvas.Alpha = 1
		
'		canvas.DrawText( midX+" "+midY+"  "+(_mouseX-midX)+" "+(_mouseY-midY), 10, 10 )

		'we now have a unitmanager to handle all the units,  so just one call to it's draw routine
		' will allow it to do the rest
		_unitManager.DrawUnits( canvas, _mouseX, _mouseY, midX, midY, _scale )
	End Method
	
	
	Method DrawTheIntro( canvas:Canvas )
		canvas.Color = Color.White
	
		canvas.DrawText( " Scroller Map' First App By Mark Ainsworth ref 210665",200,20 )
		canvas.DrawText( " How To Scroll The Map Right Click To Pickup Board, Then Drag it Release to Drop it. ",200,60 )
		canvas.DrawText( " You can Move around the Map By Only RightClicking and Dragging.",200,80 )
		canvas.DrawText("- PRESS ENTER OR LRFT-CLICK MOUSE TO START MAP --&gt;",200,670)
		
	End Method

	
	'respond to any key presses
	Method OnKeyEvent( event:KeyEvent ) Override
		'heres the best way to check for shift keys etc
		Local command:Bool = event.Modifiers &amp; Modifier.Gui
		Local shift:Bool = event.Modifiers &amp; Modifier.Shift
		Local alt:bool = event.Modifiers &amp; Modifier.Alt
		
		Select event.Type
			case EventType.KeyDown
			
				Select event.Key
					Case Key.Enter
						Select _gameMode
							Case GAMEMODE_INTRO
								_gameMode = GAMEMODE_GAME
						End Select
							
				End Select
				
			Case EventType.KeyUp
			
				Select event.Key
					Case Key.Enter
				End Select
				
		End Select
	End

	'here we track the mouse and all mouse related stuff
	Method OnMouseEvent( event:MouseEvent ) Override
		'set up some global mouse cars so we can use these throught to program
		_mouseX = event.Location.X
		_mouseY = event.Location.Y

		'here are the baci mouse events we are interested in
		Select event.Type
			Case EventType.MouseClick
				Select _gameMode
					Case GAMEMODE_INTRO
						_gameMode = GAMEMODE_GAME
						
					Case GAMEMODE_GAME
						_movemap = 1
						If _movemap = 1 'if you left click record current mouse location
							_oldX = _mX + -_mouseX 'plus map location
							_oldY = _mY + -_mouseY
						Endif
				End Select	
				
			Case EventType.MouseUp
				_movemap = 0 'if you move the mouse while dragging
				If _movemap = 0 'the map x,y is updated untill you Mouseup
					_oldX = _mX 
					_oldY = _mY 
				Endif
			Case EventType.MouseEnter
			Case EventType.MouseLeave
			case EventType.MouseWheel
				If event.Wheel.Y &lt;&gt; 0 Then
					_scale = Clamp( _scale + event.Wheel.Y * 0.01, 0.25, 4.0 )
				End If
			Case EventType.MouseMove
				If _movemap = 1
					_mX = _mouseX + _oldX - 0
					_mY = _mouseY + _oldY - 0
				Endif
		End Select
		
	End Method
	
	'this is needed to allow the Size to be correct. this is called automatically
	Method OnMeasure:Vec2i() Override
		Return Size
	End
Private
	'the timer ticks 60 times a second and handles the screen update
	Field _timer:Timer
	
	'what mode is the game in, showing the intro, playing, ended, etc
	Field _gameMode:Int = GAMEMODE_GAME'INTRO
	
	'global mouse vars
	Field _mouseX:Int
	Field _mouseY:Int
	
	field _scale:float = 1

	Field _mY:Int = 0 'position of map -500 so we start 500 in from top
	Field _mX:Int = 0 'position of map -500 so we start 500 in from left
'	Field _twist:Int  'rotate
	Field _oldX:Int 'used to store map location before you drag
	Field _oldY:Int 'used to store map location before you drag
	Field _movemap:Int 'switch to on to dragmap in conjuction with old position

	'image assets
	Field _maped:Image ' this is the map png ' lets say the center is 0, 0

	'set up some classes' these will need to be newed
	field _unitManager:UnitManager =  New UnitManager()
End

</textarea> <br><br></td></tr></table><br>
<a name="1339516"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#134">[#134]</a></td></tr></table></td></tr><tr ><td class="posttext"> That's is a galactic App, the velocity and eye, and top selection , this is superman stuff. <br><br>I am going to have to look at this overnight and figure everything out, it is clearer seeing it as your updating. <br><br></td></tr></table><br>
<a name="1339520"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#135">[#135]</a></td></tr></table></td></tr><tr ><td class="posttext"> yep. I'm trying to do it all in little steps as there is a lot to get your head around - especially moving to a new language.<br><br>As I said before - I'm here to help - I might not describe thing in the best way, but hopefully you'll get most from the code.<br><br>The YDraw sorting is kinda magic, but works really well. now it's written you don't even have to understand it, it just works...<br><br>I'm sorta looking at UI, bringing the planet stuff over, etc. nothing will be updated till tomorrow now... <br><br></td></tr></table><br>
<a name="1339564"></a>

<a name="1339588"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#136">[#136]</a></td></tr></table></td></tr><tr ><td class="posttext"> I must say this is incredible , the little rotating moons are great. selection is great. I really like my own enthusiasm to read your code and play around with it, you progress with it at a blazing rate for it to all be correct as well. its is allowing me to progress with learning far faster than I could on myself and that's if I ever would of moved to class's, sorry GOTO ! old friend , your use is gone:) <br><br></td></tr></table><br>
<a name="1339598"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#137">[#137]</a></td></tr></table></td></tr><tr ><td class="posttext"> thanks. Let's call it a learning project<br><br>But i'm ve mindful of the initial premise of based on rogue3 with quests, and missions and am not forgetting about that. either <br><br></td></tr></table><br>
<a name="1339599"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#138">[#138]</a></td></tr></table></td></tr><tr ><td class="posttext"> OK. just updating so you know what's going on.<br>I'm writing a UI system. This will be something new and very nice and will be the main way of communicating with buttons, etc.<br><br>It's not a simple thing, but I already have all the code written. I am stripping a lot of stuff to make it simple to understand and build it one step at a time ;)<br><br>You will thank me for this one... <br><br></td></tr></table><br>
<a name="1339601"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#139">[#139]</a></td></tr></table></td></tr><tr ><td class="posttext"> this is the big one (007)....<br><br>basically I have created to new classes UXPageView and UXControl<br>the page is the manager, it handles all the controls<br>the controls will be a new thing that will do all the nice stuff and be very extendable and simple<br>But. the nasty part is this bit - the setting up.<br><br>We need a page and controls. and make sure we track the window sizes and feed them to the page. <br>then we simply tell the page to do the drawing and off it goes<br><br>Here's the base code. you should see an blue grid with orange bits on the left...<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Namespace myLetterboxApp

#Import "&lt;std&gt;"
#Import "&lt;mojo&gt;"

Using std..
Using mojo..

#Import "assets/map.png"
#Import "assets/chit1.png"
#Import "assets/chit2.png"

#Import "assets/hex1.png"
#Import "assets/hex2.png"


'here is a single global,  for tracking game time
'it is set by Millisecs(),  but if we use a global,  we only need to use Millisecs once when it is set.
'repeatedly calling stuff like mouse and timers may cause slowdowns
'so once it is set,  we just need to read it
'it is a global as everything will need to access it and drawing functions can use it as well
global _gameTime:long




Const Size := New Vec2i( 950,720 )

Const GAMEMODE_INTRO:Int = 1
Const GAMEMODE_GAME:int = 2

'used by the units to assign a none parent
const PARENT_NONE:int = -1


'ok blitzmax rotations were in degrees - simple ;)
'monkey2 reverts back to radians,  so we need a conversion
'so here is the best and quickest conversion I could come up with ;)
const Pi180:double = Pi / 180
function DegreesToRadian:float( degrees:float )
	return degrees * Pi180
End function
'and we will need another to revrse the process
function RadianToDegrees:float( radian:float )
	return radian / Pi180
End function


'monkey does not have any circle drawing routines,  so here is a basic one
function DrawCircle( canvas:Canvas, xc:float, yc:float, radiusX:float, radiusY:float )
	Local div:float = DegreesToRadian( 5 )
	
	Local angle:float = div
	Local xp0:float
	Local yp0:float
	Local xp1:float = xc + radiusX
	Local yp1:float = yc
	Local k:int
	
	For k = 5 To 360 Step 5
		xp0 = xc + Cos( angle ) * radiusX
		yp0 = yc + Sin( angle ) * radiusY
		canvas.DrawLine( xp0, yp0, xp1, yp1 )
		
		xp1 = xp0
		yp1 = yp0
		angle += div
	Next
End function

'monkey does not have any circle drawing routines.
'here is one that draws dashed lines
function DrawCircleDash( canvas:Canvas, xc:float, yc:float, radiusX:float, radiusY:float )
	Local div:float = DegreesToRadian( 5 )
	
	Local angle:float = div
	Local xp0:float
	Local yp0:float
	Local xp1:float = xc + radiusX
	Local yp1:float = yc
	Local k:int
	
	For k = 5 To 360 Step 5
		xp0 = xc + Cos( angle ) * radiusX
		yp0 = yc + Sin( angle ) * radiusY
		If k Mod 10 = 0 Then
			canvas.DrawLine( xp0, yp0, xp1, yp1 )
		End If
		
		xp1 = xp0
		yp1 = yp0
		angle += div
	Next
End function

'now we have seperated the front from the back drawing,  we can use these with the new depth sorting
function DrawCircleDashFront( canvas:Canvas, xc:float, yc:float, radiusX:float, radiusY:float )
	Local div:float = DegreesToRadian( 5 )
	
	Local angle:float = div
	Local xp0:float
	Local yp0:float
	Local xp1:float = xc + radiusX
	Local yp1:float = yc
	Local k:int
	
	For k = 5 To 180 Step 5
		xp0 = xc + Cos( angle ) * radiusX
		yp0 = yc + Sin( angle ) * radiusY
		If k Mod 10 = 0 Then
			canvas.DrawLine( xp0, yp0, xp1, yp1 )
		End If
		
		xp1 = xp0
		yp1 = yp0
		angle += div
	Next
End function

function DrawCircleDashBack( canvas:Canvas, xc:float, yc:float, radiusX:float, radiusY:float )
	Local div:float = DegreesToRadian( 5 )
	
	Local angle:float = DegreesToRadian( 185 )
	Local xp0:float
	Local yp0:float
	Local xp1:float = xc + Cos( 180 ) * radiusX
	Local yp1:float = yc + Sin( 180 ) * radiusY
	Local k:int
	
	For k = 185 To 360 Step 5
		xp0 = xc + Cos( angle ) * radiusX
		yp0 = yc + Sin( angle ) * radiusY
		If k Mod 10 = 0 Then
			canvas.DrawLine( xp0, yp0, xp1, yp1 )
		End If
		
		xp1 = xp0
		yp1 = yp0
		angle += div
	Next
End function

Function Main()
	New AppInstance
	
	New MyWindow
	
	App.Run()
End

'this is now moved into the unit manager
'what will be the maximum number of units avaialable
' a unit is anything like a planet or ship,  so we need 16 for the base planets stuff and...
' lets say 100 other units
' a missile could be classed as a unit as well,  so lets have 256 units
'const MAX_UNITS:int = 256


'lets have some const vars to make me happy
'ive dragged over the const from the universe just so we are talking the same language
const UNIT_BLACKHOLE:int = 0
const UNIT_STAR:int = 1
const UNIT_GASGIANT:int = 2
const UNIT_PLANET:int = 3
const UNIT_MOON:int = 4
const UNIT_ASTEROIDMOON:int = 5
const UNIT_ASTEROID:int = 6
const UNIT_ASTEROIDBELT:int = 7
const UNIT_DUSTBELT:int = 8
const UNIT_NEBULAE:int = 9
const UNIT_RADIATIONBELT:int = 10

'so lets say a ship starts at 100
const UNIT_SHIP:int = 100

'this will be the base class for all chits, anything can be a chit
'ok chit it is - unit would possibly be a better choice though?
'I have converted all int's to floats - this has already bourn fruit with the rotation
'sorry converted chit to unit
Class Unit
	'this is called when any new thing is derrived from this class
	Method New()
	End Method

	
	' so New(67) would give you a Chit with 67 rotation
	Method New( kind:int, chitImage:Image, rotate:float, x:float, y:float )
		'monkey2 uses radians,  so convert from degrees to radian
		_rotate = DegreesToRadian( rotate )

		_x = x 'just a var to initialise starting position of chit
		_y = y
		
		_kind = kind
		
		_size = 25
		
		_image = chitImage
		_image.Handle = New Vec2f( .5,.5 )
	End Method


	Method New( kind:int, rotate:float, x:float, y:float )
		'monkey2 uses radians,  so convert from degrees to radian
		_rotate = DegreesToRadian( rotate )

		_x = x 'just a var to initialise starting position of chit
		_y = y
		
		_kind = kind

		_size = 30
	End Method


	'because _twist is private,  we need a property and setter
	' we only then need to access by _chit.Twist = 40,  or twist = _chit.Twist
	'you can now see here that directly accessing the variables would have caused us a bit more hasslle (in the long term)
	'but using a property/setter,  means the nasty degrees radian stuff lives inside,  and doesn't bother us now
	Property Rotate:float()
		Return RadianToDegrees( _rotate )
	Setter( rotate:float )
		_rotate = DegreesToRadian( rotate )
	End

	'the eye is our watch position. 1 is above,  0 is from the side and -1 is from below
	Property Eye:float()
		Return _eye
	Setter( eye:float )
		_eye = Clamp( eye, -1.0, 1.0 )
	End

	Property X:float()
		Return _x
	Setter( x:float )
		_x = x
	End

	Property Y:float()
		Return _y
	Setter( y:float )
		_y = y
	End

	Property DrawY:float()
		Return _drawY
	End
	
	Property DrawOrbitY:float()
		Return _drawOrbitY
	End

	Property OrbitX:float()
		Return _orbitX
	Setter( orbitX:float )
		_orbitX = orbitX
	End

	Property OrbitY:float()
		Return _orbitY
	Setter( orbitY:float )
		_orbitY = orbitY
	End

	Property Reference:int()
		Return _reference
	Setter( reference:int )
		_reference = reference
	End

	Property Kind:int()
		Return _kind
	Setter( kind:int )
		_kind = kind
	End

	Property Size:float()
		Return _size
	Setter( size:float )
		_size = size
	End
	
	Property Over:bool()
		Return _over
	Setter( over:bool )
		_over = over
	End

	Property Velocity:float()
		Return _velocity
	Setter( velocity:float )
		_velocity = velocity
	End

	Property OrbitDistance:float()
		Return _orbitDistance
	Setter( orbitDistance:float )
		_orbitDistance = orbitDistance
	End

	Property Parent:int()
		Return _parent
	Setter( parent:int )
		_parent = parent
	End

protected
	'this is the new update draw routine. it is basically the old draw with all the drawing removed
	' so it sets everything up for a nice quick draw later.
	' what we really need is the final y draw location. this will be fed into our new sorting stuff
	method UpdateDraw( reference:int, mouseX:int, mouseY:int, x:float, y:float, scale:float )
		_reference = reference
		
		_drawX = (_x * scale) + x
		_drawY = y - (_y * scale) 'this is inverted!!!!
		
		If _orbitDistance &gt; 0 Then
'			canvas.Color = Color.Orange
'			canvas.Alpha = 0.4

			_drawOrbitX = _drawX
			_drawOrbitY = _drawY

'			DrawCircleDash( canvas, xx, yy, _orbitDistance * scale, _orbitDistance * scale * _eye )
			'and modify then xx
			Local rad:float = _orbitDistance
			_orbitX = Cos( _rotate ) * rad
			_orbitY = Sin( _rotate ) * rad * _eye

			_drawX += _orbitX * scale
			_drawY -= _orbitY * scale
			_rotate += _velocity

			'make sure that the orbit vars are correctly offset
			_orbitX += _x
			_orbitY += _y
		else	
			_drawY =  y - ((_y * scale)* _eye)
		End If

		'get the actual drawing locations
		Local sc:float = scale * _size
		Local sc2:float = sc * 2
		Local x0:int = _drawX - sc
		Local x1:int = x0 + sc2
		Local y0:int = _drawY - sc
		Local y1:int = y0 + sc2

		'check if the mouse is over it
		_over = True
		If mouseX &lt; x0 Then _over = false
		If mouseX &gt; x1 Then _over = false
		If mouseY &lt; y0 Then _over = false
		If mouseY &gt; y1 Then _over = False
		
	End method

	
	method DrawBackOrbit( canvas:Canvas, scale:Float )
		canvas.Color = Color.Orange
		canvas.Alpha = 0.4

		DrawCircleDashBack( canvas, _drawOrbitX, _drawOrbitY, _orbitDistance * scale, _orbitDistance * scale * _eye )
		canvas.Alpha = 1
	End method

	method Draw( canvas:Canvas, scale:Float )
		If _orbitDistance &gt; 0 Then
			If _over Then
				canvas.Color = Color.Sky
				canvas.Alpha = 0.35
			Else
				canvas.Color = Color.Orange
				canvas.Alpha = 0.15
			End If

			DrawCircleDashBack( canvas, _drawOrbitX, _drawOrbitY, _orbitDistance * scale, _orbitDistance * scale * _eye )
			canvas.Alpha = 1
		End If

		If _over Then
			canvas.Color = Color.Sky
			Local sc:float = scale*(_size+(Sin(_gameTime * 0.01)*5 )+5)
			canvas.LineWidth = 10 * scale
	        DrawCircle( canvas, _drawX, _drawY, sc, sc )
			canvas.LineWidth = 1
		Else
			canvas.Color = Color.White
		End If

		'draw the unit
		Select _kind
			Case UNIT_SHIP
				canvas.DrawImage( _image, _drawX, _drawY, _rotate, scale, scale )
				
			Case UNIT_STAR
				Local sc:float = scale * _size
		        canvas.DrawCircle( _drawX, _drawY, sc )
		        canvas.Color = Color.DarkGrey
		        canvas.DrawCircle( _drawX, _drawY, sc-2 )
		End Select
		
		'and any front orbit
		If _orbitDistance &gt; 0 Then
			If _over Then
				canvas.Color = Color.Sky
				canvas.Alpha = 0.8
			Else
				canvas.Color = Color.Orange
				canvas.Alpha = 0.3
			End If
			DrawCircleDashFront( canvas, _drawOrbitX, _drawOrbitY, _orbitDistance * scale, _orbitDistance * scale * _eye )
			canvas.Alpha = 1
		End if
	End method
	
Private
	'this is any image we might be drawing
	field _image:Image
	
	'this is the kind of thing the unit is
	field _kind:int

	'size is the drawing size radius,  so we could have different sizes for stuff
	'currently there is 25 for the ships (50 width) and 30 radius for the planets
	field _size:float

	'the distance the unit orbits around
	field _orbitDistance:float = 0
	field _orbitX:float
	field _orbitY:float
	field _drawOrbitX:float
	field _drawOrbitY:float
	
	'is the mouse over it
	field _over:bool = False
	
	'this is our view position
	field _eye:float = 1
	
	'does this unit have a parent. -1 (PARENT_NONE) means it does not
	field _parent:int = PARENT_NONE
	'ok and now we need a sort reference position. this is going to become very important
	field _reference:int
	
	'and here are some vars to tell us where and what way it's facing
	Field _x:float = 600
	Field _y:float = 600
	Field _rotate:float = 0
	
	'the actual drawing positions
	field _drawX:float
	field _drawY:float
	
	'how fast is the unit moving
	field _velocity:float = 0
End Class


class UnitManager
	'what will be the maximum number of units avaialable
	' a unit is anything like a planet or ship,  so we need 16 for the base planets stuff and...
	' lets say 100 other units
	' a missile could be classed as a unit as well,  so lets have 256 units
	const MAX_UNITS:int = 256

	method New()
	End method
	

	'the eye is our watch position. 1 is above,  0 is from the side and -1 is from below. we wont be going below 0.1!
	Property Eye:float()
		Return _eye
	Setter( eye:float )
		_eye = Clamp( eye, 0.1, 1.0 )

		'update all the units eye positions
		Local k:int
		For k = 0 Until _count
			_unit[k].Eye = _eye
		Next
	End

	'ok change here is the method now returns an int.
	'the int is the actual count/position in the array
	method AddShip:int( kind:int, parent:int, chitImage:Image, rotate:float, x:float, y:float )
		Local this:int = _count
		_unit[ _count ] = New Unit( kind, chitImage, rotate, x, y)
		_unit[ _count ].Parent = parent

		_count += 1
		
		Return this
	End method


	method AddPlanet:int( kind:int, parent:int, size:float, x:float, y:float, distance:float, velocity:float= 0 )
		Local this:int = _count

		_unit[ _count ] = New Unit( kind, 0, x, y)
		_unit[ _count ].Size = size
		_unit[ _count ].OrbitDistance = distance
		_unit[ _count ].Parent = parent
		_unit[ _count ].Rotate = Rnd( 360 )
		
		'moake sure that a planet at the center does not move
		If distance &lt; 2 Then velocity = 0
		
		'lets slow things down a bit
		velocity *= 0.001
		
		'we have got a parent,  we now need to do lots of fun things
		If parent &gt; -1 Then
			_unit[ _count ].OrbitDistance += _unit[ _count ].OrbitDistance
		End If
		
		_unit[ _count ].Velocity = velocity
		
		_count += 1
		
		Return this
	End method
	
	
	'new method update to keep everything where it makes more sense
	method UpdateUnits()
		Local k:int
		For k = 0 Until _count
		
			'only planets 'should' have parents. and we need to update their positions
			If _unit[k].Parent &gt; -1 Then
				_unit[k].X = _unit[_unit[k].Parent].OrbitX
				_unit[k].Y = _unit[_unit[k].Parent].OrbitY
			End If
			
		Next
	End method
	
	'we now need some form of sorting so that everything is displayed from the furthest to the nearest
	'if you look down on a map, table, game or whatever. any object with a low y is closer to you
	'so... throw out the x (not interested in that)
	'and do a simple (not the best) sort on the y values.
	'we will improve the sort later. lets just get it working first
	method SortUnits( mouseX:int, mouseY:int, midX:float, midY:float, scale:float )
		'this is a 2 step process.
		'first we reset the sort references
		Local k:int
		For k = 0 Until _count
			'first update the drawing and the sort references
			_unit[k].UpdateDraw( k, mouseX, mouseY, midX, midY, scale )
		Next
		
		'next we do the sort' this is a slow bubble sort. we can use other faster sorts later
		Local l:int
		Local tmp:int
		For k = 0 To _count-2
			For l = k+1 To _count-1
				If _unit[ _unit[ k ].Reference ].DrawY &gt; _unit[ _unit[ l ].Reference ].DrawY Then
					tmp = _unit[ k ].Reference
					_unit[ k ].Reference = _unit[ l ].Reference
					_unit[ l ].Reference = tmp
				End If
			Next
		Next

		'and now reverse search and pick the top most thing we are over
		k = _count-1
		Local over:int = -1
		While k &gt; -1
			If over = -1 then
				if _unit[ _unit[ k ].Reference ].Over Then over = k
			Else
				_unit[ _unit[ k ].Reference ].Over = false
			End If
			k -= 1
		Wend
'		Print over
		
	End method
	
	
	'and now draw them correctly
	method DrawUnits( canvas:Canvas, mouseX:int, mouseY:int, midX:float, midY:float, scale:float )
		SortUnits( mouseX, mouseY, midX, midY, scale )
		
		'and not the front facing units plus orbits
		local k:int
		For k = 0 Until _count

			'ok. this will draw the units just like before. uncomment it and comment out the other line to see it
'			_unit[ k ].Draw( canvas, scale )

			'but here is the magic version
			'We draw using the sort reference instead. sorted from back to front
			_unit[ _unit[k].Reference ].Draw( canvas, scale )
		Next
	End method

private
	'the units we have
	field _unit:Unit[] = New Unit[ MAX_UNITS ]
	
	'how many units we have got
	field _count:int = 0
	
	'is the mouse over a unit? if so what is it's number
	field _over:int = -1
	
	'where are we looking from
	field _eye:float = 1

End Class

'lets create a control class for all our ui elements
'we will call it a page and its called UXPageView. it will manage everything for us
'we are going to do this step by step

Class UXPageView
	Method New( title:string )
		_title = title
	End

	Property Title:string()
		Return _title
	Setter( title:string )
		_title = title
	End

	Property GridX:int()
		Return _gridX
	Setter( gridX:int )
		_gridX = gridX
	End

	Property GridY:int()
		Return _gridY
	Setter( gridY:int )
		_gridY = gridY
	End

	Property ShowGrid:bool()
		Return _showGrid
	Setter( showGrid:bool )
		_showGrid = showGrid
	End

	method SetGrid( x:int,  y:int )
		If x &lt; 1 or y &lt; 1 Then Return
		
		_gridX = x
		_gridY = y
	End method

	'these next three methods give us the power to add and remove things from the stack
	method AddControl( control:UXControl )
		If Not control Then Return
		
		_controls.Add( control )
	End method
	
	method RemoveControl( control:UXControl )
		If Not control Then return

		_controls.Remove( control )
	End method

	method RemoveAllControls()
		For Local control := Eachin _controls
			RemoveControl( control )
		Next
	End method
	
protected
	'we have come across OnRender before,  so lets use exact the same format
	'we draw the title of the page just for debug purposes
	method OnRender( canvas:Canvas )

		For Local control := Eachin _controls
			If control.Visible Then
				control.OnRender( canvas )
			End If
		Next

		If _showGrid Then
			RenderGrid( canvas, _x, _y, _width, _height )
			canvas.DrawText( _title, _x, _y )
		End If
	End method

	
	'render the grid which control align to
	method RenderGrid( canvas:Canvas, x:int, y:int, width:int, height:int )
		canvas.Color = Color.Sky
		
		Local xx:float
		Local yy:float
		
		xx = x + _gridDivX
		Repeat
			canvas.DrawLine( xx, y, xx, height )
			xx += _gridDivX
		Until xx &gt;= width

		yy = y + _gridDivY
		Repeat
			canvas.DrawLine( x, yy, width, yy )
			yy += _gridDivY
		Until yy &gt;= height
	End method


	'when the main window is resized we will need to tell the page it has changed
	method OnRecalcLayout( x:int, y:int, width:int, height:int )
		'set up the position of the page
		_x = x
		_x1 = x + width -1
		_y = y
		_y1 = y + height -1
		_width = width
		_height = height
		
		'set up the grid divisions
		_gridDivX = float(width) / _gridX
		_gridDivY = float(height) / _gridY
		_gridDivXHalf = _gridDivX * 0.5
		_gridDivYHalf = _gridDivY * 0.5
		'And the ui scaling
		_uiScale = _gridDivY / 80

		'go through each control and reset its position correctly
		LayoutControls()
	End method
	
	
	'this goes through each control and reset its position correctly
	method LayoutControls()
		For Local control := Eachin _controls
			If control.Visible Then
				'send the control the page size information
				control.OnRecalcLayout( _x, _y, _width, _height, _gridDivX, _gridDivY )
			End If
		Next
	End method
	
private
	'the title of the page
	field _title:string
	
	'the position of the page. this is recalculated by using OnRecalLayout
	field _x:int
	field _y:int
	field _x1:int
	field _y1:int
	field _width:int
	field _height:int

	'the grid sizes for the page
	field _gridX:int = 12
	field _gridY:int = 8
	'and show the grid or not
	field _showGrid:bool = false

	'internal grid division calculated when screen resized. controls use grids for quick alignment
	field _gridDivX:float
	field _gridDivY:float
	field _gridDivXHalf:float
	field _gridDivYHalf:float
	field _uiScale:float

	'dont worry what a stack is. think of it as a collection of things. in this case UXControl
	Field _controls := New Stack&lt;UXControl&gt;
End Class

'And then we need a button. lets call it UXControl &lt; this will became clear a bit later
class UXControl
	Method New()
	End

	Property Visible:bool()
		Return _visible
	Setter( visible:bool )
		_visible = visible
	End

	'set the position of the control in grid steps
	method SetGridLayout( x:float, y:float, width:float, height:float )
		_gridX = x
		_gridY = y
		_gridWidth = Clamp( width, 1.0, 512.0 )
		_gridHeight = Clamp( height, 1.0, 512.0 )
	End method
	

	method OnRender( canvas:Canvas ) virtual
		canvas.Color = Color.Orange
		canvas.DrawRect( _x, _y, _width, _height )
	End method

protected	
	method OnRecalcLayout( x:float, y:float, width:float, height:float, gridDivX:float, gridDivY:float )
		_x = x + ( _gridX * gridDivY )
		_y = y + ( _gridY * gridDivY )
		_width = _gridWidth * gridDivY
		_height = _gridHeight * gridDivY
		_x1 = _x + _width
		_y1 = _y + _height
	End method

private
	'is the control shown. is it visible or not
	field _visible:bool = True

	field _x:float
	field _y:float
	field _x1:float
	field _y1:float
	field _width:float
	field _height:float
	field _xMid:float
	field _yMid:float

	field _gridX:float
	field _gridY:float
	field _gridWidth:float
	field _gridHeight:float
	
End Class


Class MyWindow Extends Window

	Method New()
		Super.New( "My Window", Size.X, Size.Y, WindowFlags.Resizable )
	    
		'if you want a constant canvas size use this
'		Layout = "letterbox"
		'or If you want the canvas to always fill the window use this
		Layout = "fill"

		'this is a timer. it will 'tick' 60 times a second. calling OnUpdate
		_timer = New Timer( 60, OnUpdate )
		
		'initial rndseed
		SeedRnd( 747 )

		_maped = Image.Load( "asset::map.png" ) 'I used a 2000x2000 pixel PNG
		_maped.Handle=New Vec2f( .5,.5 )
	
		'lets now assign these to each chit
		'monkey2 will use internal referenceing systems,  so don't bother about resources
		' we will also deal with the image handle in the chit as well ;)
		Local chitImage1:Image = Image.Load( "asset::chit1.png" )
		Local chitImage2:Image = Image.Load( "asset::chit2.png" )

		'first we need a Page
		' the page MUST have it's layout called when the size of the window changes
		' this is done in OnRender
		Page = new UXPageView( "The page wot I created" )
		'set a grid size 16, 12 seems good. bit is terribly flexible
		Page.SetGrid( 16, 12 )
		' and show the pages grid. try commenting this out
		Page.ShowGrid = True
		
		'now we need a button 'it doesn't do anything yet...
			local button1 := New UXControl()
			button1.SetGridLayout( 0, 2, 1, 1 )
			Page.AddControl( button1 )
		'And another
			local button2 := New UXControl()
			button2.SetGridLayout( 0, 3, 1, 1 )
			Page.AddControl( button2 )
		'And another
			local button3 := New UXControl()
			button3.SetGridLayout( 0, 4, 1, 1 )
			Page.AddControl( button3 )
		
		'just so you feel happy about rotation...
		'0 - shows normal bitmap the right way up points east
		'90 is north, 180 points west, 270 south
		'so. lets assume that chit1 is a ship. to have it point the correct way. the bitmap MUST face EAST!
		
        'provide a PNG and variables for every chit on the map
		_unitManager.AddShip( UNIT_SHIP, PARENT_NONE, chitImage1, 0, 150, 150 )
		_unitManager.AddShip( UNIT_SHIP, PARENT_NONE, chitImage2, 45, -51, -80 )
		
		'And the star
		Local parent:int
		_unitManager.AddPlanet( UNIT_STAR, PARENT_NONE, 60, 0,0, 0 )
		'the addPlanet now returns a parent
		parent = _unitManager.AddPlanet( UNIT_STAR, PARENT_NONE, 20, 0,0, 170, 0.2 )
		'we now feed the parentinto the next addplanet
		
		Local parent2:int
		parent2 = _unitManager.AddPlanet( UNIT_STAR, parent, 10, 0,0, 30, 0.6 )
		_unitManager.AddPlanet( UNIT_STAR, parent2, 5, 0,0, 15, 6 )
		
		_unitManager.AddPlanet( UNIT_STAR, parent, 5, 0,0, 50, -0.7 )
		
		'last we want to set an eye poition the eye goes from 1 (from above),  to 0.1 (from the side)
		' 0.5 is about isometric view
		_unitManager.Eye = 0.25
	End

Protected
	Method OnUpdate()
		_gameTime = Millisecs()
		
		_unitManager.UpdateUnits()
		
		RequestRender()
	End Method
	
	
	Method OnRender( canvas:Canvas ) Override
		'set up a measure that will recalculate if the window is resized
		If _width &lt;&gt; Width or _height &lt;&gt; Height Then
			'The Page Must be laid out
			Page.OnRecalcLayout( 0, 0, Width, Height )
			
			_width = Width
			_height = Height
		End if

		'fill the screen canvas with a color
		canvas.Color = Color.Black
		canvas.DrawRect( 0, 0, Width, Height )

		Select _gameMode
			Case GAMEMODE_INTRO
				DrawTheIntro( canvas )
			Case GAMEMODE_GAME
				DrawTheGame( canvas )
		End Select
	End


	method DrawMap( canvas:Canvas, midX:float, midY:float )
		'draw the mapimage
		canvas.Alpha = 1
		canvas.Color = Color.Grey
		canvas.DrawImage( _maped, midX, midY, 0, _scale, _scale )
		
'		DrawCircleDash( canvas, midX, midY, 100 * _scale )
		
		'draw the 100 lines (100 spatial positions)
		Local k:float
		Local sc:float
		canvas.Color = Color.DarkGrey
		canvas.Alpha = 0.3
		Local xoffset:float = midX Mod (100 * _scale)
		Local yoffset:float = midY Mod (100 * _scale)
		For k = xoffset To Width Step (100 * _scale)
			canvas.DrawLine( k,  0, k, Height )
		Next
		For k = yoffset To Height Step (100 * _scale * _unitManager.Eye)
			canvas.DrawLine( 0, k, Width, k )
		Next
		
		'draw the center of the map lines
		canvas.Color = Color.Grey
		canvas.DrawLine( midX, 0, midX, Height )
		canvas.DrawLine( 0, midY, Width, midY )
	End method
	
	
	method DrawUI( canvas:Canvas )
		'draw the page. currently this is just showing the page grid
		Page.OnRender( canvas )
	End method
	
	
	Method DrawTheGame( canvas:Canvas )
		'find the midpoint from where all drawing is based
		Local midX:float = (Width * 0.5) + _mX
		Local midY:float = (Height * 0.5) + _mY
		
		
		'draw the map in a seperate method
		DrawMap( canvas, midX, midY )
		
        'lets move these into the unit class
		canvas.Color = Color.White
		canvas.Alpha = 1
		
'		canvas.DrawText( midX+" "+midY+"  "+(_mouseX-midX)+" "+(_mouseY-midY), 10, 10 )

		'we now have a unitmanager to handle all the units,  so just one call to it's draw routine
		' will allow it to do the rest
		_unitManager.DrawUnits( canvas, _mouseX, _mouseY, midX, midY, _scale )
		
		DrawUI( canvas )
	End Method
	
	
	Method DrawTheIntro( canvas:Canvas )
		canvas.Color = Color.White
	
		canvas.DrawText( " Scroller Map' First App By Mark Ainsworth ref 210665",200,20 )
		canvas.DrawText( " How To Scroll The Map Right Click To Pickup Board, Then Drag it Release to Drop it. ",200,60 )
		canvas.DrawText( " You can Move around the Map By Only RightClicking and Dragging.",200,80 )
		canvas.DrawText("- PRESS ENTER OR LRFT-CLICK MOUSE TO START MAP --&gt;",200,670)
		
	End Method

	
	'respond to any key presses
	Method OnKeyEvent( event:KeyEvent ) Override
		'heres the best way to check for shift keys etc
		Local command:Bool = event.Modifiers &amp; Modifier.Gui
		Local shift:Bool = event.Modifiers &amp; Modifier.Shift
		Local alt:bool = event.Modifiers &amp; Modifier.Alt
		
		Select event.Type
			case EventType.KeyDown
			
				Select event.Key
					Case Key.Enter
						Select _gameMode
							Case GAMEMODE_INTRO
								_gameMode = GAMEMODE_GAME
						End Select
							
				End Select
				
			Case EventType.KeyUp
			
				Select event.Key
					Case Key.Enter
				End Select
				
		End Select
	End

	'here we track the mouse and all mouse related stuff
	Method OnMouseEvent( event:MouseEvent ) Override
		'set up some global mouse cars so we can use these throught to program
		_mouseX = event.Location.X
		_mouseY = event.Location.Y

		'here are the baci mouse events we are interested in
		Select event.Type
			Case EventType.MouseClick
				Select _gameMode
					Case GAMEMODE_INTRO
						_gameMode = GAMEMODE_GAME
						
					Case GAMEMODE_GAME
						_movemap = 1
						If _movemap = 1 'if you left click record current mouse location
							_oldX = _mX + -_mouseX 'plus map location
							_oldY = _mY + -_mouseY
						Endif
				End Select	
				
			Case EventType.MouseUp
				_movemap = 0 'if you move the mouse while dragging
				If _movemap = 0 'the map x,y is updated untill you Mouseup
					_oldX = _mX 
					_oldY = _mY 
				Endif
			Case EventType.MouseEnter
			Case EventType.MouseLeave
			case EventType.MouseWheel
				If event.Wheel.Y &lt;&gt; 0 Then
				
					'macs use inverted scroll wheels, so lets make it mac friendly
#If __TARGET__="macos"
					_scale = Clamp( _scale - event.Wheel.Y * 0.01, 0.25, 4.0 )
#else
					_scale = Clamp( _scale + event.Wheel.Y * 0.01, 0.25, 4.0 )
#end				
				End If
			Case EventType.MouseMove
				If _movemap = 1
					_mX = _mouseX + _oldX - 0
					_mY = _mouseY + _oldY - 0
				Endif
		End Select
		
	End Method
	
	'this is needed to allow the Size to be correct. this is called automatically
	Method OnMeasure:Vec2i() Override
		Return Size
	End
Private
	'the timer ticks 60 times a second and handles the screen update
	Field _timer:Timer
	
	'what mode is the game in, showing the intro, playing, ended, etc
	Field _gameMode:Int = GAMEMODE_GAME'INTRO
	
	'global mouse vars
	Field _mouseX:Int
	Field _mouseY:Int
	
	field _scale:float = 1

	'global window size to track when window has changed
	field _width:int = 0
	field _height:int = 0
	
	'and some control buttons
	field _myButton:UXControl

	'map location vars
	Field _mY:Int = 0
	Field _mX:Int = 0
	Field _oldX:Int 'used to store map location before you drag
	Field _oldY:Int 'used to store map location before you drag
	Field _movemap:Int 'switch to on to dragmap in conjuction with old position

	'image assets
	Field _maped:Image ' this is the map png ' lets say the center is 0, 0

	'set up some classes' these will need to be newed
	field _unitManager:UnitManager =  New UnitManager()

	'set up the page to hold our controls
	field Page:UXPageView
	'UI image and stuff
'	field _imageHex1:Image
'	field _imageHex2:Image
End

</textarea> <br><br></td></tr></table><br>
<a name="1339609"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#140">[#140]</a></td></tr></table></td></tr><tr ><td class="posttext"> and now...<br>The finished nasty version with a lot more controls stuff going on inside.<br>The mouse is hooked up correctly and the control now highlight and clicks correctly<br><br>Finally we introduce Lambdas. In this versions we are using them to signal from each button back to the main app that it has been clicked.<br>We then print some text in the console so you know a click has happened.<br><br>in it's purest form the page and Control system is complete. we will tinker with it here are there to add little bits. but in essence complete.<br><br>We could push it out to a separate file, but I think it works best all together (at the moment)<br><br>So...<br>Here's the code<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Namespace myLetterboxApp

#Import "&lt;std&gt;"
#Import "&lt;mojo&gt;"

Using std..
Using mojo..

#Import "assets/map.png"
#Import "assets/chit1.png"
#Import "assets/chit2.png"

#Import "assets/hex1.png"
#Import "assets/hex2.png"


'here is a single global,  for tracking game time
'it is set by Millisecs(),  but if we use a global,  we only need to use Millisecs once when it is set.
'repeatedly calling stuff like mouse and timers may cause slowdowns
'so once it is set,  we just need to read it
'it is a global as everything will need to access it and drawing functions can use it as well
global _gameTime:long




Const Size := New Vec2i( 950,720 )

Const GAMEMODE_INTRO:Int = 1
Const GAMEMODE_GAME:int = 2

'used by the units to assign a none parent
const PARENT_NONE:int = -1


'ok blitzmax rotations were in degrees - simple ;)
'monkey2 reverts back to radians,  so we need a conversion
'so here is the best and quickest conversion I could come up with ;)
const Pi180:double = Pi / 180
function DegreesToRadian:float( degrees:float )
	return degrees * Pi180
End function
'and we will need another to revrse the process
function RadianToDegrees:float( radian:float )
	return radian / Pi180
End function


'monkey does not have any circle drawing routines,  so here is a basic one
function DrawCircle( canvas:Canvas, xc:float, yc:float, radiusX:float, radiusY:float )
	Local div:float = DegreesToRadian( 5 )
	
	Local angle:float = div
	Local xp0:float
	Local yp0:float
	Local xp1:float = xc + radiusX
	Local yp1:float = yc
	Local k:int
	
	For k = 5 To 360 Step 5
		xp0 = xc + Cos( angle ) * radiusX
		yp0 = yc + Sin( angle ) * radiusY
		canvas.DrawLine( xp0, yp0, xp1, yp1 )
		
		xp1 = xp0
		yp1 = yp0
		angle += div
	Next
End function

'monkey does not have any circle drawing routines.
'here is one that draws dashed lines
function DrawCircleDash( canvas:Canvas, xc:float, yc:float, radiusX:float, radiusY:float )
	Local div:float = DegreesToRadian( 5 )
	
	Local angle:float = div
	Local xp0:float
	Local yp0:float
	Local xp1:float = xc + radiusX
	Local yp1:float = yc
	Local k:int
	
	For k = 5 To 360 Step 5
		xp0 = xc + Cos( angle ) * radiusX
		yp0 = yc + Sin( angle ) * radiusY
		If k Mod 10 = 0 Then
			canvas.DrawLine( xp0, yp0, xp1, yp1 )
		End If
		
		xp1 = xp0
		yp1 = yp0
		angle += div
	Next
End function

'now we have seperated the front from the back drawing,  we can use these with the new depth sorting
function DrawCircleDashFront( canvas:Canvas, xc:float, yc:float, radiusX:float, radiusY:float )
	Local div:float = DegreesToRadian( 5 )
	
	Local angle:float = div
	Local xp0:float
	Local yp0:float
	Local xp1:float = xc + radiusX
	Local yp1:float = yc
	Local k:int
	
	For k = 5 To 180 Step 5
		xp0 = xc + Cos( angle ) * radiusX
		yp0 = yc + Sin( angle ) * radiusY
		If k Mod 10 = 0 Then
			canvas.DrawLine( xp0, yp0, xp1, yp1 )
		End If
		
		xp1 = xp0
		yp1 = yp0
		angle += div
	Next
End function

function DrawCircleDashBack( canvas:Canvas, xc:float, yc:float, radiusX:float, radiusY:float )
	Local div:float = DegreesToRadian( 5 )
	
	Local angle:float = DegreesToRadian( 185 )
	Local xp0:float
	Local yp0:float
	Local xp1:float = xc + Cos( 180 ) * radiusX
	Local yp1:float = yc + Sin( 180 ) * radiusY
	Local k:int
	
	For k = 185 To 360 Step 5
		xp0 = xc + Cos( angle ) * radiusX
		yp0 = yc + Sin( angle ) * radiusY
		If k Mod 10 = 0 Then
			canvas.DrawLine( xp0, yp0, xp1, yp1 )
		End If
		
		xp1 = xp0
		yp1 = yp0
		angle += div
	Next
End function

function DrawFrame( canvas:Canvas, x:Float,y:Float,w:Float,h:Float )
	Local x0 := x
	Local y0 := y
	Local x1 := x+w-1
	Local y1 := y+h-1
		
	canvas.DrawLine( x0, y0, x1, y0 )
	canvas.DrawLine( x1, y0, x1, y1 )
	canvas.DrawLine( x1, y1, x0, y1 )
	canvas.DrawLine( x0, y1, x0, y0 )
End

Function Main()
	New AppInstance
	
	New MyWindow
	
	App.Run()
End

'this is now moved into the unit manager
'what will be the maximum number of units avaialable
' a unit is anything like a planet or ship,  so we need 16 for the base planets stuff and...
' lets say 100 other units
' a missile could be classed as a unit as well,  so lets have 256 units
'const MAX_UNITS:int = 256


'lets have some const vars to make me happy
'ive dragged over the const from the universe just so we are talking the same language
const UNIT_BLACKHOLE:int = 0
const UNIT_STAR:int = 1
const UNIT_GASGIANT:int = 2
const UNIT_PLANET:int = 3
const UNIT_MOON:int = 4
const UNIT_ASTEROIDMOON:int = 5
const UNIT_ASTEROID:int = 6
const UNIT_ASTEROIDBELT:int = 7
const UNIT_DUSTBELT:int = 8
const UNIT_NEBULAE:int = 9
const UNIT_RADIATIONBELT:int = 10

'so lets say a ship starts at 100
const UNIT_SHIP:int = 100

'this will be the base class for all chits, anything can be a chit
'ok chit it is - unit would possibly be a better choice though?
'I have converted all int's to floats - this has already bourn fruit with the rotation
'sorry converted chit to unit
Class Unit
	'this is called when any new thing is derrived from this class
	Method New()
	End Method

	
	' so New(67) would give you a Chit with 67 rotation
	Method New( kind:int, chitImage:Image, rotate:float, x:float, y:float )
		'monkey2 uses radians,  so convert from degrees to radian
		_rotate = DegreesToRadian( rotate )

		_x = x 'just a var to initialise starting position of chit
		_y = y
		
		_kind = kind
		
		_size = 25
		
		_image = chitImage
		_image.Handle = New Vec2f( .5,.5 )
	End Method


	Method New( kind:int, rotate:float, x:float, y:float )
		'monkey2 uses radians,  so convert from degrees to radian
		_rotate = DegreesToRadian( rotate )

		_x = x 'just a var to initialise starting position of chit
		_y = y
		
		_kind = kind

		_size = 30
	End Method


	'because _twist is private,  we need a property and setter
	' we only then need to access by _chit.Twist = 40,  or twist = _chit.Twist
	'you can now see here that directly accessing the variables would have caused us a bit more hasslle (in the long term)
	'but using a property/setter,  means the nasty degrees radian stuff lives inside,  and doesn't bother us now
	Property Rotate:float()
		Return RadianToDegrees( _rotate )
	Setter( rotate:float )
		_rotate = DegreesToRadian( rotate )
	End

	'the eye is our watch position. 1 is above,  0 is from the side and -1 is from below
	Property Eye:float()
		Return _eye
	Setter( eye:float )
		_eye = Clamp( eye, -1.0, 1.0 )
	End

	Property X:float()
		Return _x
	Setter( x:float )
		_x = x
	End

	Property Y:float()
		Return _y
	Setter( y:float )
		_y = y
	End

	Property DrawY:float()
		Return _drawY
	End
	
	Property DrawOrbitY:float()
		Return _drawOrbitY
	End

	Property OrbitX:float()
		Return _orbitX
	Setter( orbitX:float )
		_orbitX = orbitX
	End

	Property OrbitY:float()
		Return _orbitY
	Setter( orbitY:float )
		_orbitY = orbitY
	End

	Property Reference:int()
		Return _reference
	Setter( reference:int )
		_reference = reference
	End

	Property Kind:int()
		Return _kind
	Setter( kind:int )
		_kind = kind
	End

	Property Size:float()
		Return _size
	Setter( size:float )
		_size = size
	End
	
	Property Over:bool()
		Return _over
	Setter( over:bool )
		_over = over
	End

	Property Velocity:float()
		Return _velocity
	Setter( velocity:float )
		_velocity = velocity
	End

	Property OrbitDistance:float()
		Return _orbitDistance
	Setter( orbitDistance:float )
		_orbitDistance = orbitDistance
	End

	Property Parent:int()
		Return _parent
	Setter( parent:int )
		_parent = parent
	End

protected
	'this is the new update draw routine. it is basically the old draw with all the drawing removed
	' so it sets everything up for a nice quick draw later.
	' what we really need is the final y draw location. this will be fed into our new sorting stuff
	method UpdateDraw( reference:int, mouseX:int, mouseY:int, x:float, y:float, scale:float )
		_reference = reference
		
		_drawX = (_x * scale) + x
		_drawY = y - (_y * scale) 'this is inverted!!!!
		
		If _orbitDistance &gt; 0 Then
'			canvas.Color = Color.Orange
'			canvas.Alpha = 0.4

			_drawOrbitX = _drawX
			_drawOrbitY = _drawY

'			DrawCircleDash( canvas, xx, yy, _orbitDistance * scale, _orbitDistance * scale * _eye )
			'and modify then xx
			Local rad:float = _orbitDistance
			_orbitX = Cos( _rotate ) * rad
			_orbitY = Sin( _rotate ) * rad * _eye

			_drawX += _orbitX * scale
			_drawY -= _orbitY * scale
			_rotate += _velocity

			'make sure that the orbit vars are correctly offset
			_orbitX += _x
			_orbitY += _y
		else	
			_drawY =  y - ((_y * scale)* _eye)
		End If

		'get the actual drawing locations
		Local sc:float = scale * _size
		Local sc2:float = sc * 2
		Local x0:int = _drawX - sc
		Local x1:int = x0 + sc2
		Local y0:int = _drawY - sc
		Local y1:int = y0 + sc2

		'check if the mouse is over it
		_over = True
		If mouseX &lt; x0 Then _over = false
		If mouseX &gt; x1 Then _over = false
		If mouseY &lt; y0 Then _over = false
		If mouseY &gt; y1 Then _over = False
		
	End method

	
	method DrawBackOrbit( canvas:Canvas, scale:Float )
		canvas.Color = Color.Orange
		canvas.Alpha = 0.4

		DrawCircleDashBack( canvas, _drawOrbitX, _drawOrbitY, _orbitDistance * scale, _orbitDistance * scale * _eye )
		canvas.Alpha = 1
	End method

	method Draw( canvas:Canvas, scale:Float )
		If _orbitDistance &gt; 0 Then
			If _over Then
				canvas.Color = Color.Sky
				canvas.Alpha = 0.35
			Else
				canvas.Color = Color.Orange
				canvas.Alpha = 0.15
			End If

			DrawCircleDashBack( canvas, _drawOrbitX, _drawOrbitY, _orbitDistance * scale, _orbitDistance * scale * _eye )
			canvas.Alpha = 1
		End If

		If _over Then
			canvas.Color = Color.Sky
			Local sc:float = scale*(_size+(Sin(_gameTime * 0.01)*5 )+5)
			canvas.LineWidth = 10 * scale
	        DrawCircle( canvas, _drawX, _drawY, sc, sc )
			canvas.LineWidth = 1
		Else
			canvas.Color = Color.White
		End If

		'draw the unit
		Select _kind
			Case UNIT_SHIP
				canvas.DrawImage( _image, _drawX, _drawY, _rotate, scale, scale )
				
			Case UNIT_STAR
				Local sc:float = scale * _size
		        canvas.DrawCircle( _drawX, _drawY, sc )
		        canvas.Color = Color.DarkGrey
		        canvas.DrawCircle( _drawX, _drawY, sc-2 )
		End Select
		
		'and any front orbit
		If _orbitDistance &gt; 0 Then
			If _over Then
				canvas.Color = Color.Sky
				canvas.Alpha = 0.8
			Else
				canvas.Color = Color.Orange
				canvas.Alpha = 0.3
			End If
			DrawCircleDashFront( canvas, _drawOrbitX, _drawOrbitY, _orbitDistance * scale, _orbitDistance * scale * _eye )
			canvas.Alpha = 1
		End if
	End method
	
Private
	'this is any image we might be drawing
	field _image:Image
	
	'this is the kind of thing the unit is
	field _kind:int

	'size is the drawing size radius,  so we could have different sizes for stuff
	'currently there is 25 for the ships (50 width) and 30 radius for the planets
	field _size:float

	'the distance the unit orbits around
	field _orbitDistance:float = 0
	field _orbitX:float
	field _orbitY:float
	field _drawOrbitX:float
	field _drawOrbitY:float
	
	'is the mouse over it
	field _over:bool = False
	
	'this is our view position
	field _eye:float = 1
	
	'does this unit have a parent. -1 (PARENT_NONE) means it does not
	field _parent:int = PARENT_NONE
	'ok and now we need a sort reference position. this is going to become very important
	field _reference:int
	
	'and here are some vars to tell us where and what way it's facing
	Field _x:float = 600
	Field _y:float = 600
	Field _rotate:float = 0
	
	'the actual drawing positions
	field _drawX:float
	field _drawY:float
	
	'how fast is the unit moving
	field _velocity:float = 0
End Class


class UnitManager
	'what will be the maximum number of units avaialable
	' a unit is anything like a planet or ship,  so we need 16 for the base planets stuff and...
	' lets say 100 other units
	' a missile could be classed as a unit as well,  so lets have 256 units
	const MAX_UNITS:int = 256

	method New()
	End method
	

	'the eye is our watch position. 1 is above,  0 is from the side and -1 is from below. we wont be going below 0.1!
	Property Eye:float()
		Return _eye
	Setter( eye:float )
		_eye = Clamp( eye, 0.1, 1.0 )

		'update all the units eye positions
		Local k:int
		For k = 0 Until _count
			_unit[k].Eye = _eye
		Next
	End

	'ok change here is the method now returns an int.
	'the int is the actual count/position in the array
	method AddShip:int( kind:int, parent:int, chitImage:Image, rotate:float, x:float, y:float )
		Local this:int = _count
		_unit[ _count ] = New Unit( kind, chitImage, rotate, x, y)
		_unit[ _count ].Parent = parent

		_count += 1
		
		Return this
	End method


	method AddPlanet:int( kind:int, parent:int, size:float, x:float, y:float, distance:float, velocity:float= 0 )
		Local this:int = _count

		_unit[ _count ] = New Unit( kind, 0, x, y)
		_unit[ _count ].Size = size
		_unit[ _count ].OrbitDistance = distance
		_unit[ _count ].Parent = parent
		_unit[ _count ].Rotate = Rnd( 360 )
		
		'moake sure that a planet at the center does not move
		If distance &lt; 2 Then velocity = 0
		
		'lets slow things down a bit
		velocity *= 0.001
		
		'we have got a parent,  we now need to do lots of fun things
		If parent &gt; -1 Then
			_unit[ _count ].OrbitDistance += _unit[ _count ].OrbitDistance
		End If
		
		_unit[ _count ].Velocity = velocity
		
		_count += 1
		
		Return this
	End method
	
	
	'new method update to keep everything where it makes more sense
	method UpdateUnits()
		Local k:int
		For k = 0 Until _count
		
			'only planets 'should' have parents. and we need to update their positions
			If _unit[k].Parent &gt; -1 Then
				_unit[k].X = _unit[_unit[k].Parent].OrbitX
				_unit[k].Y = _unit[_unit[k].Parent].OrbitY
			End If
			
		Next
	End method
	
	'we now need some form of sorting so that everything is displayed from the furthest to the nearest
	'if you look down on a map, table, game or whatever. any object with a low y is closer to you
	'so... throw out the x (not interested in that)
	'and do a simple (not the best) sort on the y values.
	'we will improve the sort later. lets just get it working first
	method SortUnits( mouseX:int, mouseY:int, midX:float, midY:float, scale:float )
		'this is a 2 step process.
		'first we reset the sort references
		Local k:int
		For k = 0 Until _count
			'first update the drawing and the sort references
			_unit[k].UpdateDraw( k, mouseX, mouseY, midX, midY, scale )
		Next
		
		'next we do the sort' this is a slow bubble sort. we can use other faster sorts later
		Local l:int
		Local tmp:int
		For k = 0 To _count-2
			For l = k+1 To _count-1
				If _unit[ _unit[ k ].Reference ].DrawY &gt; _unit[ _unit[ l ].Reference ].DrawY Then
					tmp = _unit[ k ].Reference
					_unit[ k ].Reference = _unit[ l ].Reference
					_unit[ l ].Reference = tmp
				End If
			Next
		Next

		'and now reverse search and pick the top most thing we are over
		k = _count-1
		Local over:int = -1
		While k &gt; -1
			If over = -1 then
				if _unit[ _unit[ k ].Reference ].Over Then over = k
			Else
				_unit[ _unit[ k ].Reference ].Over = false
			End If
			k -= 1
		Wend
'		Print over
		
	End method
	
	
	'and now draw them correctly
	method DrawUnits( canvas:Canvas, mouseX:int, mouseY:int, midX:float, midY:float, scale:float )
		SortUnits( mouseX, mouseY, midX, midY, scale )
		
		'and not the front facing units plus orbits
		local k:int
		For k = 0 Until _count

			'ok. this will draw the units just like before. uncomment it and comment out the other line to see it
'			_unit[ k ].Draw( canvas, scale )

			'but here is the magic version
			'We draw using the sort reference instead. sorted from back to front
			_unit[ _unit[k].Reference ].Draw( canvas, scale )
		Next
	End method

private
	'the units we have
	field _unit:Unit[] = New Unit[ MAX_UNITS ]
	
	'how many units we have got
	field _count:int = 0
	
	'is the mouse over a unit? if so what is it's number
	field _over:int = -1
	
	'where are we looking from
	field _eye:float = 1

End Class

'lets create a control class for all our ui elements
'we will call it a page and its called UXPageView. it will manage everything for us
'we are going to do this step by step

Class UXPageView
	Method New( title:string )
		_title = title
	End

	Property Title:string()
		Return _title
	Setter( title:string )
		_title = title
	End

	Property Visible:bool()
		Return _visible
	Setter( visible:bool )
		_visible = visible
	End

	Property Alpha:float()
		Return _alpha
	Setter( alpha:float )
		_alpha = Clamp( alpha,  0.0, 1.0 )
	End

	Property GridX:int()
		Return _gridX
	Setter( gridX:int )
		_gridX = gridX
	End

	Property GridY:int()
		Return _gridY
	Setter( gridY:int )
		_gridY = gridY
	End

	Property ShowGrid:bool()
		Return _showGrid
	Setter( showGrid:bool )
		_showGrid = showGrid
	End

	method SetGrid( x:int,  y:int )
		If x &lt; 1 or y &lt; 1 Then Return
		
		_gridX = x
		_gridY = y
	End method

	'the offset is how many pixels the page is offset from the top left corner
	method SetOffset( x:float, y:float )
		_offsetX = x
		_offsetY = y
		OnRecalcLayout( x, y, _width, _height )
		App.RequestRender()
	End method

	'these next three methods give us the power to add and remove things from the stack
	method AddControl( control:UXControl )
		If Not control Then Return
		
		_controls.Add( control )
	End method
	
	method RemoveControl( control:UXControl )
		If Not control Then return

		_controls.Remove( control )
	End method

	method RemoveAllControls()
		For Local control := Eachin _controls
			RemoveControl( control )
		Next
	End method
	
protected
	'we have come across OnRender before,  so lets use exact the same format
	'we draw the title of the page just for debug purposes
	method OnRender( canvas:Canvas )

		For Local control := Eachin _controls
			If control.Visible Then
				control.OnRender( canvas, _alpha )
			End If
		Next

		If _showGrid Then
			canvas.Alpha = _alpha
			RenderGrid( canvas, _x, _y, _width, _height )
			canvas.DrawText( _title, _x, _y )
		End If
	End method

	
	'render the grid which control align to
	Method OnMouseEvent:bool( event:MouseEvent )
		_mouseX = event.Location.X - _x
		_mouseY = event.Location.Y - _y
		_mouseOffsetX = _mouseX + _offsetX
		_mouseOffsetY = _mouseY + _offsetY
		If _mouseX &lt; 0 or _mouseY &lt; 0 or _mouseX &gt; _width or _mouseY &gt; _height Then
			NotOverControl()
			Return False
		End If

		'this returns the current control. or not. it does all the nasty stuff for us
		_currentControl = GetCurrentControl()
		If not _currentControl Then Return False

		'now lets process all the mouse events
		if Not Mouse.ButtonDown( MouseButton.Left ) Then
			_mouseDown = False
			_currentControl.MouseDown = False
			_currentCapturedControl = Null
		End if

		Select event.Type
			Case EventType.MouseDown
				_mouseDown = True
				_currentCapturedControl = _currentControl
				_currentControl.OnMouseDown( event )
				_currentControl.MouseDown = True
				'wave to the Lambda
				_currentControl.ClickDown()
				event.Eat()
				Return True

			Case EventType.MouseUp
				_mouseDown = False
				_currentCapturedControl = null
				_currentControl.OnMouseUp()
				_currentControl.MouseDown = False
				'wave to the Lambda
				_currentControl.Clicked()
				Return true

			case EventType.MouseWheel
				If event.Wheel.Y &lt;&gt; 0 Then
					_currentControl.OnMouseWheel( event.Wheel.Y )
					event.Eat()
					Return true
				End If

			Case EventType.MouseEnter
				_currentControl.OnMouseEnter()
				event.Eat()
				Return True
				
			Case EventType.MouseLeave
				_currentControl.OnMouseLeave()
				_currentCapturedControl = Null
				NotOverControl()
				event.Eat()
				Return True

			Case EventType.MouseMove
				If _mouseX &lt; 0 or _mouseY &lt; 0 or _mouseX &gt; _width or _mouseY &gt; _height Then
					_currentControl.OnMouseLeave()
				Else
					_currentControl.OnMouseEnter()
				End If
				if _mouseDown then _currentControl.OnMouseMove()
				event.Eat()
				Return true
		End Select
		
		Return False
	End method

	'when we find a new control,  tell it we are over it
	method OverControl( control:UXControl )
		If control = _currentControl Then Return
		
		control.MouseOver = true

'		Print "found control "
		_currentControl = control
	End method
		
	'when we are not over a control, make the control we were over null, and tell it we arent over it anymore
	method NotOverControl()
		If not _currentControl Then Return
		
		_currentControl.MouseOver = false
		
'		Print "exit control"
		_currentControl = null
	End method


	'this goes (backwards) through the controls and checks if the mouse is over them.
	'  it returns the control the mouse is over
	method GetCurrentControl:UXControl()
		'if there is a current control, check if the mouse is still in it
		If _currentControl Then
'			Print "checkStillOver "+_mouseOffsetX+" "+_mouseOffsetY+"   "+_currentControl.X+" "+_currentControl.Y
			If _mouseOffsetX &lt; _currentControl.X or _mouseOffsetY &lt; _currentControl.Y or _mouseOffsetX &gt; _currentControl.X1 or _mouseOffsetY &gt; _currentControl.Y1 Then
				NotOverControl()
			Else	
				Return _currentControl
			End If
		End If
		
		For Local control := Eachin _controls.Backwards()
		
			if _currentControl = Null and control.Visible Then
'				Print "check "+_mouseOffsetX+" "+_mouseOffsetY+"   "+control.X+" "+control.Y
				If _mouseOffsetX &lt; control.X or _mouseOffsetY &lt; control.Y or _mouseOffsetX &gt; control.X1 or _mouseOffsetY &gt; control.Y1 Then
					'we are not in this control
				Else
					'we are in this control
					OverControl( control )
					Return _currentControl
				End If
			End If
		Next
			
		Return Null
	End method
	
	
	Method OnKeyEvent:bool( event:KeyEvent )
'		Print "keyevent "

		Return false
	End method
	
	method RenderGrid( canvas:Canvas, x:int, y:int, width:int, height:int )
		canvas.Color = Color.Sky
		
		Local xx:float
		Local yy:float
		Local xp:float
		Local yp:float
		
		xx = 0
		xp = x
		Repeat
			canvas.DrawLine( xp, y, xp, y+height )
			xx += _gridDivX
			xp += _gridDivX
		Until xx &gt; width

		yy = 0
		yp = y
		Repeat
			canvas.DrawLine( x, yp, x+width, yp )
			yy += _gridDivY
			yp += _gridDivY
		Until yy &gt; height
	End method


	'when the main window is resized we will need to tell the page it has changed
	method OnRecalcLayout( x:int, y:int, width:int, height:int )
		'set up the position of the page
		_x = x + _offsetX
		_x1 = _x + width -1
		_y = y + _offsetY
		_y1 = _y + height -1
		_width = width
		_height = height
		
		'set up the grid divisions
		_gridDivX = float(width) / _gridX
		_gridDivY = float(height) / _gridY
		_gridDivXHalf = _gridDivX * 0.5
		_gridDivYHalf = _gridDivY * 0.5
		'And the ui scaling
		_uiScale = _gridDivY / 80

		'go through each control and reset its position correctly
		LayoutControls()
	End method
	
	
	'this goes through each control and reset its position correctly
	method LayoutControls()
		For Local control := Eachin _controls
			If control.Visible Then
				'send the control the page size information
				control.OnRecalcLayout( _x, _y, _width, _height, _gridDivX, _gridDivY )
			End If
		Next
	End method
	
private
	'the title of the page
	field _title:string
	
	'is the page visible
	field _visible:bool = True
	
	'what alpha does the page have
	field _alpha:float = 1
	
	'deal with mouse and keyboard events
	field _mouseX:int
	field _mouseY:int
	field _mouseOffsetX:int
	field _mouseOffsetY:int
	field _mouseDown:bool = False
	
	'what is the current control the mouse is over
	field _currentControl:UXControl = Null
	'when we press left mouse button we capture the current control
	field _currentCapturedControl:UXControl = Null
	
	' page offset from top left corner
	field _offsetX:float = 0
	field _offsetY:float = 0
	
	'the position of the page. this is recalculated by using OnRecalLayout
	field _x:int
	field _y:int
	field _x1:int
	field _y1:int
	field _width:int
	field _height:int

	'the grid sizes for the page
	field _gridX:int = 12
	field _gridY:int = 8
	'and show the grid or not
	field _showGrid:bool = false

	'internal grid division calculated when screen resized. controls use grids for quick alignment
	field _gridDivX:float
	field _gridDivY:float
	field _gridDivXHalf:float
	field _gridDivYHalf:float
	field _uiScale:float

	'dont worry what a stack is. think of it as a collection of things. in this case UXControl
	Field _controls := New Stack&lt;UXControl&gt;
End Class

'And then we need a button. lets call it UXControl &lt; this will became clear a bit later
class UXControl
	'these fields with void() are linked internally by the compiler to Lambdas &lt;- WTF????
	' ok Lambdas are nothing to get worried about. they are callers
	' think of a control having a flag. and that flag can wave at a Lambda with it's name on
	'the lambdas (which appear in the main program start waving. and you do somehting when they wave

	'clickdown is triggered when the mouse is clicked down in a control
	field ClickDown:void()
	'clicked is when a button is realsed
	field Clicked:void()

	Method New()
	End

	Property Visible:bool()
		Return _visible
	Setter( visible:bool )
		_visible = visible
	End

	Property MouseOver:bool()
		Return _mouseOver
	Setter( mouseOver:bool )
		_mouseOver = mouseOver
	End

	Property MouseDown:bool()
		Return _mouseDown
	Setter( mouseDown:bool )
		_mouseDown = mouseDown
	End

	Property X:float()
		Return _x
	Setter( x:float )
		_x = x
	End

	Property Y:float()
		Return _y
	Setter( y:float )
		_y = y
	End

	Property X1:float()
		Return _x1
	Setter( x1:float )
		_x1 = x1
	End

	Property Y1:float()
		Return _y1
	Setter( y1:float )
		_y1 = y1
	End
	
	'set the position of the control in grid steps
	method SetGridLayout( x:float, y:float, width:float, height:float )
		_gridX = x
		_gridY = y
		_gridWidth = Clamp( width, 1.0, 512.0 )
		_gridHeight = Clamp( height, 1.0, 512.0 )
	End method
	

	'the virtual command means we are going to use these as a forward reference
	' dont be alarmed if you don't understand what I mean.
	' it will become very clear when we create other controls using this as a base
	' (that is why the page and control classes are sooooo complex)
	
	'a control have a background - if we want it
	method RenderBackground( canvas:Canvas, alpha:float ) Virtual
	End method

	'a foreground - that looks like a sinple button,  but we can change this if we want
	' usually most of the drawing will be done here
	method RenderForeground( canvas:Canvas, alpha:float ) Virtual
		canvas.Color = Color.DarkGrey
		canvas.DrawRect( _x, _y, _width, _height )
		
		If Not _mouseOver Then Return
		
		canvas.Color = Color.Sky
		If _mouseDown Then
			canvas.Alpha = alpha
		Else
			canvas.Alpha = alpha * 0.5
		End If
		canvas.DrawRect( _x, _y, _width, _height )
	End method

	'and finally a top - which is drawn last
	method RenderTop( canvas:Canvas, alpha:float ) Virtual
	End method
	
	'this calls the individual part which make up a control: back, front and top
	method OnRender( canvas:Canvas, alpha:float ) Virtual
		canvas.Alpha = alpha
		RenderBackground( canvas, alpha )
		
		RenderForeground( canvas, alpha )

		RenderTop( canvas, alpha )
	End method

	'more virtual stuff
	method OnMouseEnter() virtual
	End method

	method OnMouseLeave() virtual
	End method

	method OnMouseDown( event:MouseEvent ) Virtual
	End method
	
	method OnMouseUp() Virtual
	End method

	method OnMouseMove() Virtual
	End method

	method OnMouseWheel( wheel:int ) Virtual
	End method

protected	
	method OnRecalcLayout( x:float, y:float, width:float, height:float, gridDivX:float, gridDivY:float )
		_x = x + ( _gridX * gridDivY )
		_y = y + ( _gridY * gridDivY )
		_width = _gridWidth * gridDivY
		_height = _gridHeight * gridDivY
		_x1 = _x + _width
		_y1 = _y + _height
	End method

private
	'is the control shown. is it visible or not
	field _visible:bool = True
	
	'is the mouse over the control
	field _mouseOver:bool = false
	field _mouseDown:bool = false

	'basic layout dimentions
	field _x:float = 0
	field _y:float = 0
	field _x1:float = 0
	field _y1:float = 0
	field _width:float
	field _height:float
	field _xMid:float
	field _yMid:float

	field _gridX:float
	field _gridY:float
	field _gridWidth:float
	field _gridHeight:float
	
End Class


Class MyWindow Extends Window

	Method New()
		Super.New( "My Window", Size.X, Size.Y, WindowFlags.Resizable )
	    
		'if you want a constant canvas size use this
'		Layout = "letterbox"
		'or If you want the canvas to always fill the window use this
		Layout = "fill"

		'this is a timer. it will 'tick' 60 times a second. calling OnUpdate
		_timer = New Timer( 60, OnUpdate )
		
		'initial rndseed
		SeedRnd( 747 )

		_maped = Image.Load( "asset::map.png" ) 'I used a 2000x2000 pixel PNG
		_maped.Handle=New Vec2f( .5,.5 )
	
		'lets now assign these to each chit
		'monkey2 will use internal referenceing systems,  so don't bother about resources
		' we will also deal with the image handle in the chit as well ;)
		Local chitImage1:Image = Image.Load( "asset::chit1.png" )
		Local chitImage2:Image = Image.Load( "asset::chit2.png" )

		'first we need a Page
		' the page MUST have it's layout called when the size of the window changes
		' this is done in OnRender
		Page = new UXPageView( "The page wot I created" )
		'set a grid size 16, 12 seems good. bit is terribly flexible
		Page.SetGrid( 16, 12 )
		' and show the pages grid. try commenting this out
'		Page.ShowGrid = True
		
		'now we need a button 'it doesn't do anything yet...
			local button1 := New UXControl()
			button1.SetGridLayout( 0, 2, 1, 1 )
			'this next command Lambda is really new
			'basically in UXControl we have a clicked flag
			'when we call it,  it calls home and ends up at the lambda
			' and we can do something with it
			button1.Clicked = Lambda()
				Print "Button 1 clicked"
			End
			Page.AddControl( button1 )
		'And another
			local button2 := New UXControl()
			button2.SetGridLayout( 0, 3, 1, 1 )
			button2.Clicked = Lambda()
				Print "Button 2 clicked"
			End
			Page.AddControl( button2 )
		'And another
			local button3 := New UXControl()
			button3.SetGridLayout( 0, 4, 1, 1 )
			button3.Clicked = Lambda()
				Print "Button 3 clicked"
			End
			Page.AddControl( button3 )
		
		'just so you feel happy about rotation...
		'0 - shows normal bitmap the right way up points east
		'90 is north, 180 points west, 270 south
		'so. lets assume that chit1 is a ship. to have it point the correct way. the bitmap MUST face EAST!
		
        'provide a PNG and variables for every chit on the map
		_unitManager.AddShip( UNIT_SHIP, PARENT_NONE, chitImage1, 0, 150, 150 )
		_unitManager.AddShip( UNIT_SHIP, PARENT_NONE, chitImage2, 45, -51, -80 )
		
		'And the star
		Local parent:int
		_unitManager.AddPlanet( UNIT_STAR, PARENT_NONE, 60, 0,0, 0 )
		'the addPlanet now returns a parent
		parent = _unitManager.AddPlanet( UNIT_STAR, PARENT_NONE, 20, 0,0, 170, 0.2 )
		'we now feed the parentinto the next addplanet
		
		Local parent2:int
		parent2 = _unitManager.AddPlanet( UNIT_STAR, parent, 10, 0,0, 30, 0.6 )
		_unitManager.AddPlanet( UNIT_STAR, parent2, 5, 0,0, 15, 6 )
		
		_unitManager.AddPlanet( UNIT_STAR, parent, 5, 0,0, 50, -0.7 )
		
		'last we want to set an eye poition the eye goes from 1 (from above),  to 0.1 (from the side)
		' 0.5 is about isometric view
		_unitManager.Eye = 0.25
	End

Protected
	Method OnUpdate()
		_gameTime = Millisecs()
		
		_unitManager.UpdateUnits()
		
		RequestRender()
	End Method
	
	
	Method OnRender( canvas:Canvas ) Override
		'set up a measure that will recalculate if the window is resized
		If _width &lt;&gt; Width or _height &lt;&gt; Height Then
			'The Page Must be laid out
			Page.OnRecalcLayout( 0, 0, Width, Height )
			
			_width = Width
			_height = Height
		End if

		'fill the screen canvas with a color
		canvas.Color = Color.Black
		canvas.DrawRect( 0, 0, Width, Height )

		Select _gameMode
			Case GAMEMODE_INTRO
				DrawTheIntro( canvas )
			Case GAMEMODE_GAME
				DrawTheGame( canvas )
		End Select
	End


	method DrawMap( canvas:Canvas, midX:float, midY:float )
		'draw the mapimage
		canvas.Alpha = 1
		canvas.Color = Color.Grey
		canvas.DrawImage( _maped, midX, midY, 0, _scale, _scale )
		
'		DrawCircleDash( canvas, midX, midY, 100 * _scale )
		
		'draw the 100 lines (100 spatial positions)
		Local k:float
		Local sc:float
		canvas.Color = Color.DarkGrey
		canvas.Alpha = 0.3
		Local xoffset:float = midX Mod (100 * _scale)
		Local yoffset:float = midY Mod (100 * _scale)
		For k = xoffset To Width Step (100 * _scale)
			canvas.DrawLine( k,  0, k, Height )
		Next
		For k = yoffset To Height Step (100 * _scale * _unitManager.Eye)
			canvas.DrawLine( 0, k, Width, k )
		Next
		
		'draw the center of the map lines
		canvas.Color = Color.Grey
		canvas.DrawLine( midX, 0, midX, Height )
		canvas.DrawLine( 0, midY, Width, midY )
	End method
	
	
	method DrawUI( canvas:Canvas )
		'draw the page. currently this is just showing the page grid
		Page.OnRender( canvas )
	End method
	
	
	Method DrawTheGame( canvas:Canvas )
		'find the midpoint from where all drawing is based
		Local midX:float = (Width * 0.5) + _mX
		Local midY:float = (Height * 0.5) + _mY
		
		
		'draw the map in a seperate method
		DrawMap( canvas, midX, midY )
		
        'lets move these into the unit class
		canvas.Color = Color.White
		canvas.Alpha = 1
		
'		canvas.DrawText( midX+" "+midY+"  "+(_mouseX-midX)+" "+(_mouseY-midY), 10, 10 )

		'we now have a unitmanager to handle all the units,  so just one call to it's draw routine
		' will allow it to do the rest
		_unitManager.DrawUnits( canvas, _mouseX, _mouseY, midX, midY, _scale )
		
		DrawUI( canvas )
	End Method
	
	
	Method DrawTheIntro( canvas:Canvas )
		canvas.Color = Color.White
	
		canvas.DrawText( " Scroller Map' First App By Mark Ainsworth ref 210665",200,20 )
		canvas.DrawText( " How To Scroll The Map Right Click To Pickup Board, Then Drag it Release to Drop it. ",200,60 )
		canvas.DrawText( " You can Move around the Map By Only RightClicking and Dragging.",200,80 )
		canvas.DrawText("- PRESS ENTER OR LRFT-CLICK MOUSE TO START MAP --&gt;",200,670)
		
	End Method

	
	'respond to any key presses
	Method OnKeyEvent( event:KeyEvent ) Override
		'send key stuff to the new page controls and exit if handled
		if Page.OnKeyEvent( event ) then return
		
		'heres the best way to check for shift keys etc
		Local command:Bool = event.Modifiers &amp; Modifier.Gui
		Local shift:Bool = event.Modifiers &amp; Modifier.Shift
		Local alt:bool = event.Modifiers &amp; Modifier.Alt
		
		Select event.Type
			case EventType.KeyDown
			
				Select event.Key
					Case Key.Enter
						Select _gameMode
							Case GAMEMODE_INTRO
								_gameMode = GAMEMODE_GAME
						End Select
							
				End Select
				
			Case EventType.KeyUp
			
				Select event.Key
					Case Key.Enter
				End Select
				
		End Select
	End

	'here we track the mouse and all mouse related stuff
	Method OnMouseEvent( event:MouseEvent ) Override
		'send mouse stuff to the new page controls. and exit if handled
		if Page.OnMouseEvent( event ) Then return
		
		'set up some global mouse vars so we can use these throught to program
		_mouseX = event.Location.X
		_mouseY = event.Location.Y

		'put a check to see if the mouse button is still pressed
		if Not Mouse.ButtonDown( MouseButton.Left ) Then
			_movemap = 0
		End If


		'here are the baci mouse events we are interested in
		Select event.Type
			Case EventType.MouseClick
				Select _gameMode
					Case GAMEMODE_INTRO
						_gameMode = GAMEMODE_GAME
						
					Case GAMEMODE_GAME
						_movemap = 1
						If _movemap = 1 'if you left click record current mouse location
							_oldX = _mX + -_mouseX 'plus map location
							_oldY = _mY + -_mouseY
						Endif
				End Select	
				
			Case EventType.MouseUp
				_movemap = 0 'if you move the mouse while dragging
				If _movemap = 0 'the map x,y is updated untill you Mouseup
					_oldX = _mX 
					_oldY = _mY 
				Endif
			Case EventType.MouseEnter
			Case EventType.MouseLeave
			case EventType.MouseWheel
				If event.Wheel.Y &lt;&gt; 0 Then
				
					'macs use inverted scroll wheels, so lets make it mac friendly
#If __TARGET__="macos"
					_scale = Clamp( _scale - event.Wheel.Y * 0.01, 0.25, 4.0 )
#else
					_scale = Clamp( _scale + event.Wheel.Y * 0.01, 0.25, 4.0 )
#end				
				End If
			Case EventType.MouseMove
				If _movemap = 1
					_mX = _mouseX + _oldX - 0
					_mY = _mouseY + _oldY - 0
				Endif
		End Select
		
	End Method
	
	'this is needed to allow the Size to be correct. this is called automatically
	Method OnMeasure:Vec2i() Override
		Return Size
	End
Private
	'the timer ticks 60 times a second and handles the screen update
	Field _timer:Timer
	
	'what mode is the game in, showing the intro, playing, ended, etc
	Field _gameMode:Int = GAMEMODE_GAME'INTRO
	
	'global mouse vars
	Field _mouseX:Int
	Field _mouseY:Int
	
	field _scale:float = 1

	'global window size to track when window has changed
	field _width:int = 0
	field _height:int = 0
	
	'and some control buttons
	field _myButton:UXControl

	'map location vars
	Field _mY:Int = 0
	Field _mX:Int = 0
	Field _oldX:Int 'used to store map location before you drag
	Field _oldY:Int 'used to store map location before you drag
	Field _movemap:Int 'switch to on to dragmap in conjuction with old position

	'image assets
	Field _maped:Image ' this is the map png ' lets say the center is 0, 0

	'set up some classes' these will need to be newed
	field _unitManager:UnitManager =  New UnitManager()

	'set up the page to hold our controls
	field Page:UXPageView
	'UI image and stuff
'	field _imageHex1:Image
'	field _imageHex2:Image
End

</textarea> <br><br></td></tr></table><br>
<a name="1339613"></a>

<a name="1339614"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#141">[#141]</a></td></tr></table></td></tr><tr ><td class="posttext"> wo, that was a jump in complexity, I am still following ,I'm glad your explaining makes it understandable,  never seen type  Eachin before, but I will look it up, and Lambdas never seen that, but I seen it in the help files. <br><br>but all in all this is very good stuff, I'm glad your going to complete the game, its what this is about, so happy about that.<br><br>I like the way you can drop classes into future apps too, as there practicaly self contained, its making sence. <br><br></td></tr></table><br>
<a name="1339615"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#142">[#142]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yep. I'm really sorry about the complexity. But you will like it in the end.<br><br>The page and control system is the most complex. I'm testing and debugging all the time and  it does just work. And its nice and portable and simple when you start to ignore the base classes...<br><br>I'll have another update soonish which will show some magic... <br><br></td></tr></table><br>
<a name="1339616"></a>

<a name="1339617"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#143">[#143]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok, you ready for some magic....?<br><br>what we are now going to do is subclass the UXControl.<br>This means use everything the UXControl has and add any bits we want.<br><br>In this case we are going to make a button that shows text<br>and an image button that shows an image<br>First you will need the images<br>the first is hex1.png<br><img src="https://vjointeractive.files.wordpress.com/2017/04/hex1.png"><br>the next hex2.png<br><img src="https://vjointeractive.files.wordpress.com/2017/04/hex2.png"><br><br>and now the code...<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Namespace myLetterboxApp

#Import "&lt;std&gt;"
#Import "&lt;mojo&gt;"

Using std..
Using mojo..

#Import "assets/map.png"
#Import "assets/chit1.png"
#Import "assets/chit2.png"

#Import "assets/hex1.png"
#Import "assets/hex2.png"


'here is a single global,  for tracking game time
'it is set by Millisecs(),  but if we use a global,  we only need to use Millisecs once when it is set.
'repeatedly calling stuff like mouse and timers may cause slowdowns
'so once it is set,  we just need to read it
'it is a global as everything will need to access it and drawing functions can use it as well
global _gameTime:long




Const Size := New Vec2i( 950,720 )

Const GAMEMODE_INTRO:Int = 1
Const GAMEMODE_GAME:int = 2

'used by the units to assign a none parent
const PARENT_NONE:int = -1


'ok blitzmax rotations were in degrees - simple ;)
'monkey2 reverts back to radians,  so we need a conversion
'so here is the best and quickest conversion I could come up with ;)
const Pi180:double = Pi / 180
function DegreesToRadian:float( degrees:float )
	return degrees * Pi180
End function
'and we will need another to revrse the process
function RadianToDegrees:float( radian:float )
	return radian / Pi180
End function


'monkey does not have any circle drawing routines,  so here is a basic one
function DrawCircle( canvas:Canvas, xc:float, yc:float, radiusX:float, radiusY:float )
	Local div:float = DegreesToRadian( 5 )
	
	Local angle:float = div
	Local xp0:float
	Local yp0:float
	Local xp1:float = xc + radiusX
	Local yp1:float = yc
	Local k:int
	
	For k = 5 To 360 Step 5
		xp0 = xc + Cos( angle ) * radiusX
		yp0 = yc + Sin( angle ) * radiusY
		canvas.DrawLine( xp0, yp0, xp1, yp1 )
		
		xp1 = xp0
		yp1 = yp0
		angle += div
	Next
End function

'monkey does not have any circle drawing routines.
'here is one that draws dashed lines
function DrawCircleDash( canvas:Canvas, xc:float, yc:float, radiusX:float, radiusY:float )
	Local div:float = DegreesToRadian( 5 )
	
	Local angle:float = div
	Local xp0:float
	Local yp0:float
	Local xp1:float = xc + radiusX
	Local yp1:float = yc
	Local k:int
	
	For k = 5 To 360 Step 5
		xp0 = xc + Cos( angle ) * radiusX
		yp0 = yc + Sin( angle ) * radiusY
		If k Mod 10 = 0 Then
			canvas.DrawLine( xp0, yp0, xp1, yp1 )
		End If
		
		xp1 = xp0
		yp1 = yp0
		angle += div
	Next
End function

'now we have seperated the front from the back drawing,  we can use these with the new depth sorting
function DrawCircleDashFront( canvas:Canvas, xc:float, yc:float, radiusX:float, radiusY:float )
	Local div:float = DegreesToRadian( 5 )
	
	Local angle:float = div
	Local xp0:float
	Local yp0:float
	Local xp1:float = xc + radiusX
	Local yp1:float = yc
	Local k:int
	
	For k = 5 To 180 Step 5
		xp0 = xc + Cos( angle ) * radiusX
		yp0 = yc + Sin( angle ) * radiusY
		If k Mod 10 = 0 Then
			canvas.DrawLine( xp0, yp0, xp1, yp1 )
		End If
		
		xp1 = xp0
		yp1 = yp0
		angle += div
	Next
End function

function DrawCircleDashBack( canvas:Canvas, xc:float, yc:float, radiusX:float, radiusY:float )
	Local div:float = DegreesToRadian( 5 )
	
	Local angle:float = DegreesToRadian( 185 )
	Local xp0:float
	Local yp0:float
	Local xp1:float = xc + Cos( 180 ) * radiusX
	Local yp1:float = yc + Sin( 180 ) * radiusY
	Local k:int
	
	For k = 185 To 360 Step 5
		xp0 = xc + Cos( angle ) * radiusX
		yp0 = yc + Sin( angle ) * radiusY
		If k Mod 10 = 0 Then
			canvas.DrawLine( xp0, yp0, xp1, yp1 )
		End If
		
		xp1 = xp0
		yp1 = yp0
		angle += div
	Next
End function

function DrawFrame( canvas:Canvas, x:Float,y:Float,w:Float,h:Float )
	Local x0 := x
	Local y0 := y
	Local x1 := x+w-1
	Local y1 := y+h-1
		
	canvas.DrawLine( x0, y0, x1, y0 )
	canvas.DrawLine( x1, y0, x1, y1 )
	canvas.DrawLine( x1, y1, x0, y1 )
	canvas.DrawLine( x0, y1, x0, y0 )
End

Function Main()
	New AppInstance
	
	New MyWindow
	
	App.Run()
End

'this is now moved into the unit manager
'what will be the maximum number of units avaialable
' a unit is anything like a planet or ship,  so we need 16 for the base planets stuff and...
' lets say 100 other units
' a missile could be classed as a unit as well,  so lets have 256 units
'const MAX_UNITS:int = 256


'lets have some const vars to make me happy
'ive dragged over the const from the universe just so we are talking the same language
const UNIT_BLACKHOLE:int = 0
const UNIT_STAR:int = 1
const UNIT_GASGIANT:int = 2
const UNIT_PLANET:int = 3
const UNIT_MOON:int = 4
const UNIT_ASTEROIDMOON:int = 5
const UNIT_ASTEROID:int = 6
const UNIT_ASTEROIDBELT:int = 7
const UNIT_DUSTBELT:int = 8
const UNIT_NEBULAE:int = 9
const UNIT_RADIATIONBELT:int = 10

'so lets say a ship starts at 100
const UNIT_SHIP:int = 100

'this will be the base class for all chits, anything can be a chit
'ok chit it is - unit would possibly be a better choice though?
'I have converted all int's to floats - this has already bourn fruit with the rotation
'sorry converted chit to unit
Class Unit
	'this is called when any new thing is derrived from this class
	Method New()
	End Method

	
	' so New(67) would give you a Chit with 67 rotation
	Method New( kind:int, chitImage:Image, rotate:float, x:float, y:float )
		'monkey2 uses radians,  so convert from degrees to radian
		_rotate = DegreesToRadian( rotate )

		_x = x 'just a var to initialise starting position of chit
		_y = y
		
		_kind = kind
		
		_size = 25
		
		_image = chitImage
		_image.Handle = New Vec2f( .5,.5 )
	End Method


	Method New( kind:int, rotate:float, x:float, y:float )
		'monkey2 uses radians,  so convert from degrees to radian
		_rotate = DegreesToRadian( rotate )

		_x = x 'just a var to initialise starting position of chit
		_y = y
		
		_kind = kind

		_size = 30
	End Method


	'because _twist is private,  we need a property and setter
	' we only then need to access by _chit.Twist = 40,  or twist = _chit.Twist
	'you can now see here that directly accessing the variables would have caused us a bit more hasslle (in the long term)
	'but using a property/setter,  means the nasty degrees radian stuff lives inside,  and doesn't bother us now
	Property Rotate:float()
		Return RadianToDegrees( _rotate )
	Setter( rotate:float )
		_rotate = DegreesToRadian( rotate )
	End

	'the eye is our watch position. 1 is above,  0 is from the side and -1 is from below
	Property Eye:float()
		Return _eye
	Setter( eye:float )
		_eye = Clamp( eye, -1.0, 1.0 )
	End

	Property X:float()
		Return _x
	Setter( x:float )
		_x = x
	End

	Property Y:float()
		Return _y
	Setter( y:float )
		_y = y
	End

	Property DrawY:float()
		Return _drawY
	End
	
	Property DrawOrbitY:float()
		Return _drawOrbitY
	End

	Property OrbitX:float()
		Return _orbitX
	Setter( orbitX:float )
		_orbitX = orbitX
	End

	Property OrbitY:float()
		Return _orbitY
	Setter( orbitY:float )
		_orbitY = orbitY
	End

	Property Reference:int()
		Return _reference
	Setter( reference:int )
		_reference = reference
	End

	Property Kind:int()
		Return _kind
	Setter( kind:int )
		_kind = kind
	End

	Property Size:float()
		Return _size
	Setter( size:float )
		_size = size
	End
	
	Property Over:bool()
		Return _over
	Setter( over:bool )
		_over = over
	End

	Property Velocity:float()
		Return _velocity
	Setter( velocity:float )
		_velocity = velocity
	End

	Property OrbitDistance:float()
		Return _orbitDistance
	Setter( orbitDistance:float )
		_orbitDistance = orbitDistance
	End

	Property Parent:int()
		Return _parent
	Setter( parent:int )
		_parent = parent
	End

protected
	'this is the new update draw routine. it is basically the old draw with all the drawing removed
	' so it sets everything up for a nice quick draw later.
	' what we really need is the final y draw location. this will be fed into our new sorting stuff
	method UpdateDraw( reference:int, mouseX:int, mouseY:int, x:float, y:float, scale:float )
		_reference = reference
		
		_drawX = (_x * scale) + x
		_drawY = y - (_y * scale) 'this is inverted!!!!
		
		If _orbitDistance &gt; 0 Then
'			canvas.Color = Color.Orange
'			canvas.Alpha = 0.4

			_drawOrbitX = _drawX
			_drawOrbitY = _drawY

'			DrawCircleDash( canvas, xx, yy, _orbitDistance * scale, _orbitDistance * scale * _eye )
			'and modify then xx
			Local rad:float = _orbitDistance
			_orbitX = Cos( _rotate ) * rad
			_orbitY = Sin( _rotate ) * rad * _eye

			_drawX += _orbitX * scale
			_drawY -= _orbitY * scale
			_rotate += _velocity

			'make sure that the orbit vars are correctly offset
			_orbitX += _x
			_orbitY += _y
		else	
			_drawY =  y - ((_y * scale)* _eye)
		End If

		'get the actual drawing locations
		Local sc:float = scale * _size
		Local sc2:float = sc * 2
		Local x0:int = _drawX - sc
		Local x1:int = x0 + sc2
		Local y0:int = _drawY - sc
		Local y1:int = y0 + sc2

		'check if the mouse is over it
		_over = True
		If mouseX &lt; x0 Then _over = false
		If mouseX &gt; x1 Then _over = false
		If mouseY &lt; y0 Then _over = false
		If mouseY &gt; y1 Then _over = False
		
	End method

	
	method DrawBackOrbit( canvas:Canvas, scale:Float )
		canvas.Color = Color.Orange
		canvas.Alpha = 0.4

		DrawCircleDashBack( canvas, _drawOrbitX, _drawOrbitY, _orbitDistance * scale, _orbitDistance * scale * _eye )
		canvas.Alpha = 1
	End method

	method Draw( canvas:Canvas, scale:Float )
		If _orbitDistance &gt; 0 Then
			If _over Then
				canvas.Color = Color.Sky
				canvas.Alpha = 0.35
			Else
				canvas.Color = Color.Orange
				canvas.Alpha = 0.15
			End If

			DrawCircleDashBack( canvas, _drawOrbitX, _drawOrbitY, _orbitDistance * scale, _orbitDistance * scale * _eye )
			canvas.Alpha = 1
		End If

		If _over Then
			canvas.Color = Color.Sky
			Local sc:float = scale*(_size+(Sin(_gameTime * 0.01)*5 )+5)
			canvas.LineWidth = 10 * scale
	        DrawCircle( canvas, _drawX, _drawY, sc, sc )
			canvas.LineWidth = 1
		Else
			canvas.Color = Color.White
		End If

		'draw the unit
		Select _kind
			Case UNIT_SHIP
				canvas.DrawImage( _image, _drawX, _drawY, _rotate, scale, scale )
				
			Case UNIT_STAR
				Local sc:float = scale * _size
		        canvas.DrawCircle( _drawX, _drawY, sc )
		        canvas.Color = Color.DarkGrey
		        canvas.DrawCircle( _drawX, _drawY, sc-2 )
		End Select
		
		'and any front orbit
		If _orbitDistance &gt; 0 Then
			If _over Then
				canvas.Color = Color.Sky
				canvas.Alpha = 0.8
			Else
				canvas.Color = Color.Orange
				canvas.Alpha = 0.3
			End If
			DrawCircleDashFront( canvas, _drawOrbitX, _drawOrbitY, _orbitDistance * scale, _orbitDistance * scale * _eye )
			canvas.Alpha = 1
		End if
	End method
	
Private
	'this is any image we might be drawing
	field _image:Image
	
	'this is the kind of thing the unit is
	field _kind:int

	'size is the drawing size radius,  so we could have different sizes for stuff
	'currently there is 25 for the ships (50 width) and 30 radius for the planets
	field _size:float

	'the distance the unit orbits around
	field _orbitDistance:float = 0
	field _orbitX:float
	field _orbitY:float
	field _drawOrbitX:float
	field _drawOrbitY:float
	
	'is the mouse over it
	field _over:bool = False
	
	'this is our view position
	field _eye:float = 1
	
	'does this unit have a parent. -1 (PARENT_NONE) means it does not
	field _parent:int = PARENT_NONE
	'ok and now we need a sort reference position. this is going to become very important
	field _reference:int
	
	'and here are some vars to tell us where and what way it's facing
	Field _x:float = 600
	Field _y:float = 600
	Field _rotate:float = 0
	
	'the actual drawing positions
	field _drawX:float
	field _drawY:float
	
	'how fast is the unit moving
	field _velocity:float = 0
End Class


class UnitManager
	'what will be the maximum number of units avaialable
	' a unit is anything like a planet or ship,  so we need 16 for the base planets stuff and...
	' lets say 100 other units
	' a missile could be classed as a unit as well,  so lets have 256 units
	const MAX_UNITS:int = 256

	method New()
	End method
	

	'the eye is our watch position. 1 is above,  0 is from the side and -1 is from below. we wont be going below 0.1!
	Property Eye:float()
		Return _eye
	Setter( eye:float )
		_eye = Clamp( eye, 0.1, 1.0 )

		'update all the units eye positions
		Local k:int
		For k = 0 Until _count
			_unit[k].Eye = _eye
		Next
	End

	'ok change here is the method now returns an int.
	'the int is the actual count/position in the array
	method AddShip:int( kind:int, parent:int, chitImage:Image, rotate:float, x:float, y:float )
		Local this:int = _count
		_unit[ _count ] = New Unit( kind, chitImage, rotate, x, y)
		_unit[ _count ].Parent = parent

		_count += 1
		
		Return this
	End method


	method AddPlanet:int( kind:int, parent:int, size:float, x:float, y:float, distance:float, velocity:float= 0 )
		Local this:int = _count

		_unit[ _count ] = New Unit( kind, 0, x, y)
		_unit[ _count ].Size = size
		_unit[ _count ].OrbitDistance = distance
		_unit[ _count ].Parent = parent
		_unit[ _count ].Rotate = Rnd( 360 )
		
		'moake sure that a planet at the center does not move
		If distance &lt; 2 Then velocity = 0
		
		'lets slow things down a bit
		velocity *= 0.001
		
		'we have got a parent,  we now need to do lots of fun things
		If parent &gt; -1 Then
			_unit[ _count ].OrbitDistance += _unit[ _count ].OrbitDistance
		End If
		
		_unit[ _count ].Velocity = velocity
		
		_count += 1
		
		Return this
	End method
	
	
	'new method update to keep everything where it makes more sense
	method UpdateUnits()
		Local k:int
		For k = 0 Until _count
		
			'only planets 'should' have parents. and we need to update their positions
			If _unit[k].Parent &gt; -1 Then
				_unit[k].X = _unit[_unit[k].Parent].OrbitX
				_unit[k].Y = _unit[_unit[k].Parent].OrbitY
			End If
			
		Next
	End method
	
	'we now need some form of sorting so that everything is displayed from the furthest to the nearest
	'if you look down on a map, table, game or whatever. any object with a low y is closer to you
	'so... throw out the x (not interested in that)
	'and do a simple (not the best) sort on the y values.
	'we will improve the sort later. lets just get it working first
	method SortUnits( mouseX:int, mouseY:int, midX:float, midY:float, scale:float )
		'this is a 2 step process.
		'first we reset the sort references
		Local k:int
		For k = 0 Until _count
			'first update the drawing and the sort references
			_unit[k].UpdateDraw( k, mouseX, mouseY, midX, midY, scale )
		Next
		
		'next we do the sort' this is a slow bubble sort. we can use other faster sorts later
		Local l:int
		Local tmp:int
		For k = 0 To _count-2
			For l = k+1 To _count-1
				If _unit[ _unit[ k ].Reference ].DrawY &gt; _unit[ _unit[ l ].Reference ].DrawY Then
					tmp = _unit[ k ].Reference
					_unit[ k ].Reference = _unit[ l ].Reference
					_unit[ l ].Reference = tmp
				End If
			Next
		Next

		'and now reverse search and pick the top most thing we are over
		k = _count-1
		Local over:int = -1
		While k &gt; -1
			If over = -1 then
				if _unit[ _unit[ k ].Reference ].Over Then over = k
			Else
				_unit[ _unit[ k ].Reference ].Over = false
			End If
			k -= 1
		Wend
'		Print over
		
	End method
	
	
	'and now draw them correctly
	method DrawUnits( canvas:Canvas, mouseX:int, mouseY:int, midX:float, midY:float, scale:float )
		SortUnits( mouseX, mouseY, midX, midY, scale )
		
		'and not the front facing units plus orbits
		local k:int
		For k = 0 Until _count

			'ok. this will draw the units just like before. uncomment it and comment out the other line to see it
'			_unit[ k ].Draw( canvas, scale )

			'but here is the magic version
			'We draw using the sort reference instead. sorted from back to front
			_unit[ _unit[k].Reference ].Draw( canvas, scale )
		Next
	End method

private
	'the units we have
	field _unit:Unit[] = New Unit[ MAX_UNITS ]
	
	'how many units we have got
	field _count:int = 0
	
	'is the mouse over a unit? if so what is it's number
	field _over:int = -1
	
	'where are we looking from
	field _eye:float = 1

End Class

'lets create a control class for all our ui elements
'we will call it a page and its called UXPageView. it will manage everything for us
'we are going to do this step by step

Class UXPageView
	Method New( title:string )
		_title = title
	End

	Property Title:string()
		Return _title
	Setter( title:string )
		_title = title
	End

	Property Visible:bool()
		Return _visible
	Setter( visible:bool )
		_visible = visible
	End

	Property Alpha:float()
		Return _alpha
	Setter( alpha:float )
		_alpha = Clamp( alpha,  0.0, 1.0 )
	End

	Property GridX:int()
		Return _gridX
	Setter( gridX:int )
		_gridX = gridX
	End

	Property GridY:int()
		Return _gridY
	Setter( gridY:int )
		_gridY = gridY
	End

	Property ShowGrid:bool()
		Return _showGrid
	Setter( showGrid:bool )
		_showGrid = showGrid
	End

	method SetGrid( x:int,  y:int )
		If x &lt; 1 or y &lt; 1 Then Return
		
		_gridX = x
		_gridY = y
	End method

	'the offset is how many pixels the page is offset from the top left corner
	method SetOffset( x:float, y:float )
		_offsetX = x
		_offsetY = y
		OnRecalcLayout( x, y, _width, _height )
		App.RequestRender()
	End method

	'these next three methods give us the power to add and remove things from the stack
	method AddControl( control:UXControl )
		If Not control Then Return
		
		_controls.Add( control )
	End method
	
	method RemoveControl( control:UXControl )
		If Not control Then return

		_controls.Remove( control )
	End method

	method RemoveAllControls()
		For Local control := Eachin _controls
			RemoveControl( control )
		Next
	End method
	
protected
	'we have come across OnRender before,  so lets use exact the same format
	'we draw the title of the page just for debug purposes
	method OnRender( canvas:Canvas )

		For Local control := Eachin _controls
			If control.Visible Then
				control.OnRender( canvas, _alpha )
			End If
		Next

		If _showGrid Then
			canvas.Alpha = _alpha
			RenderGrid( canvas, _x, _y, _width, _height )
			canvas.DrawText( _title, _x, _y )
		End If
	End method

	
	'render the grid which control align to
	Method OnMouseEvent:bool( event:MouseEvent )
		_mouseX = event.Location.X - _x
		_mouseY = event.Location.Y - _y
		_mouseOffsetX = _mouseX + _offsetX
		_mouseOffsetY = _mouseY + _offsetY
		If _mouseX &lt; 0 or _mouseY &lt; 0 or _mouseX &gt; _width or _mouseY &gt; _height Then
			NotOverControl()
			Return False
		End If

		'this returns the current control. or not. it does all the nasty stuff for us
		_currentControl = GetCurrentControl()
		If not _currentControl Then Return False

		'now lets process all the mouse events
		if Not Mouse.ButtonDown( MouseButton.Left ) Then
			_mouseDown = False
'			_currentControl.MouseDown = False
		End if

		Select event.Type
			Case EventType.MouseDown
				_mouseDown = True
				_currentCapturedControl = _currentControl
				_currentControl.OnMouseDown( event, _mouseOffsetX - _currentControl.X, _mouseOffsetY - _currentControl.Y )
				_currentControl.MouseDown = True
				'wave to the Lambda
				_currentControl.ClickDown()
				event.Eat()
				Return True

			Case EventType.MouseUp
				'wave to the Lambda
				if _currentCapturedControl = _currentControl then
					_currentControl.Clicked()
				End if
				_mouseDown = False
				_currentCapturedControl = null
				_currentControl.OnMouseUp( _mouseOffsetX - _currentControl.X, _mouseOffsetY - _currentControl.Y )
				_currentControl.MouseDown = False
				Return true

			case EventType.MouseWheel
				If event.Wheel.Y &lt;&gt; 0 Then
					_currentControl.OnMouseWheel( event.Wheel.Y )
					event.Eat()
					Return true
				End If

			Case EventType.MouseEnter
				_currentControl.OnMouseEnter()
				event.Eat()
				Return True
				
			Case EventType.MouseLeave
				_currentControl.OnMouseLeave()
				_currentCapturedControl = Null
				NotOverControl()
				event.Eat()
				Return True

			Case EventType.MouseMove
				If _mouseX &lt; 0 or _mouseY &lt; 0 or _mouseX &gt; _width or _mouseY &gt; _height Then
					_currentControl.OnMouseLeave()
				Else
					_currentControl.OnMouseEnter()
				End If
				_currentControl.OnMouseMove( _mouseOffsetX - _currentControl.X, _mouseOffsetY - _currentControl.Y )
				event.Eat()
				Return true
		End Select
		
		Return False
	End method

	'when we find a new control,  tell it we are over it
	method OverControl( control:UXControl )
		If control = _currentControl Then Return
		
		control.MouseOver = true

'		Print "found control "
		_currentControl = control
	End method
		
	'when we are not over a control, make the control we were over null, and tell it we arent over it anymore
	method NotOverControl()
		If not _currentControl Then Return
		
		_currentControl.MouseOver = false
		
'		Print "exit control"
		_currentControl = null
	End method


	'this goes (backwards) through the controls and checks if the mouse is over them.
	'  it returns the control the mouse is over
	method GetCurrentControl:UXControl()
		'if there is a current control, check if the mouse is still in it
		If _currentControl Then
'			Print "checkStillOver "+_mouseOffsetX+" "+_mouseOffsetY+"   "+_currentControl.X+" "+_currentControl.Y
			If _mouseOffsetX &lt; _currentControl.X or _mouseOffsetY &lt; _currentControl.Y or _mouseOffsetX &gt; _currentControl.X1 or _mouseOffsetY &gt; _currentControl.Y1 Then
				NotOverControl()
			Else	
				Return _currentControl
			End If
		End If
		
		For Local control := Eachin _controls.Backwards()
		
			if _currentControl = Null and control.Visible Then
'				Print "check "+_mouseOffsetX+" "+_mouseOffsetY+"   "+control.X+" "+control.Y
				If _mouseOffsetX &lt; control.X or _mouseOffsetY &lt; control.Y or _mouseOffsetX &gt; control.X1 or _mouseOffsetY &gt; control.Y1 Then
					'we are not in this control
				Else
					'we are in this control
					OverControl( control )
					Return _currentControl
				End If
			End If
		Next
			
		Return Null
	End method
	
	
	Method OnKeyEvent:bool( event:KeyEvent )
'		Print "keyevent "

		Return false
	End method
	
	method RenderGrid( canvas:Canvas, x:int, y:int, width:int, height:int )
		canvas.Color = Color.Sky
		
		Local xx:float
		Local yy:float
		Local xp:float
		Local yp:float
		
		xx = 0
		xp = x
		Repeat
			canvas.DrawLine( xp, y, xp, y+height )
			xx += _gridDivX
			xp += _gridDivX
		Until xx &gt; width

		yy = 0
		yp = y
		Repeat
			canvas.DrawLine( x, yp, x+width, yp )
			yy += _gridDivY
			yp += _gridDivY
		Until yy &gt; height
	End method


	'when the main window is resized we will need to tell the page it has changed
	method OnRecalcLayout( x:int, y:int, width:int, height:int )
		'set up the position of the page
		_x = x + _offsetX
		_x1 = _x + width -1
		_y = y + _offsetY
		_y1 = _y + height -1
		_width = width
		_height = height
		
		'set up the grid divisions
		_gridDivX = float(width) / _gridX
		_gridDivY = float(height) / _gridY
		_gridDivXHalf = _gridDivX * 0.5
		_gridDivYHalf = _gridDivY * 0.5
		'And the ui scaling
		_uiScale = _gridDivY / 80

		'go through each control and reset its position correctly
		LayoutControls()
	End method
	
	
	'this goes through each control and reset its position correctly
	method LayoutControls()
		For Local control := Eachin _controls
			If control.Visible Then
				'send the control the page size information
				control.OnRecalcLayout( _x, _y, _width, _height, _gridDivX, _gridDivY )
			End If
		Next
	End method
	
private
	'the title of the page
	field _title:string
	
	'is the page visible
	field _visible:bool = True
	
	'what alpha does the page have
	field _alpha:float = 1
	
	'deal with mouse and keyboard events
	field _mouseX:int
	field _mouseY:int
	field _mouseOffsetX:int
	field _mouseOffsetY:int
	field _mouseDown:bool = False
	
	'what is the current control the mouse is over
	field _currentControl:UXControl = Null
	'when we press left mouse button we capture the current control
	field _currentCapturedControl:UXControl = Null
	
	' page offset from top left corner
	field _offsetX:float = 0
	field _offsetY:float = 0
	
	'the position of the page. this is recalculated by using OnRecalLayout
	field _x:int
	field _y:int
	field _x1:int
	field _y1:int
	field _width:int
	field _height:int

	'the grid sizes for the page
	field _gridX:int = 12
	field _gridY:int = 8
	'and show the grid or not
	field _showGrid:bool = false

	'internal grid division calculated when screen resized. controls use grids for quick alignment
	field _gridDivX:float
	field _gridDivY:float
	field _gridDivXHalf:float
	field _gridDivYHalf:float
	field _uiScale:float

	'dont worry what a stack is. think of it as a collection of things. in this case UXControl
	Field _controls := New Stack&lt;UXControl&gt;
End Class

'And then we need a button. lets call it UXControl &lt; this will became clear a bit later
'border has now been added. A Border is a pixel offset from the edges inward. default is 2
class UXControl
	'these fields with void() are linked internally by the compiler to Lambdas &lt;- WTF????
	' ok Lambdas are nothing to get worried about. they are callers
	' think of a control having a flag. and that flag can wave at a Lambda with it's name on
	'the lambdas (which appear in the main program start waving. and you do somehting when they wave

	'clickdown is triggered when the mouse is clicked down in a control
	field ClickDown:void()
	'clicked is when a button is realsed
	field Clicked:void()

	Method New()
	End

	Property Visible:bool()
		Return _visible
	Setter( visible:bool )
		_visible = visible
	End

	Property MouseOver:bool()
		Return _mouseOver
	Setter( mouseOver:bool )
		_mouseOver = mouseOver
	End

	Property MouseDown:bool()
		Return _mouseDown
	Setter( mouseDown:bool )
		_mouseDown = mouseDown
	End

	Property Border:float()
		Return _border
	Setter( border:float )
		_border = border
		RecalcBorder()
	End

	'both BGImage And FGImage are not specifically set to be used
	' just the actual code is here so any derrived classes can simply use it
	Property BGColor:Color() Virtual
		Return _BGColor
	Setter( bgColor:Color ) Virtual
		_BGColor = bgColor
	End

	Property FGColor:Color() Virtual
		Return _FGColor
	Setter( fgColor:Color ) Virtual
		_FGColor = fgColor
	End

	Property BGImage:Image()
		Return _BGImage
	Setter( bgImage:Image )
		_BGImage = bgImage
	End

	Property TextColor:Color()
		Return _textColor
	Setter( textColor:Color )
		_textColor = textColor
	End

	Property ImageColor:Color()
		Return _imageColor
	Setter( imageColor:Color )
		_imageColor = imageColor
	End

	Property FGImage:Image()
		Return _FGImage
	Setter( fgImage:Image )
		_FGImage = fgImage
	End

	Property X:float()
		Return _x
	End

	Property Y:float()
		Return _y
	End

	Property X1:float()
		Return _x1
	End

	Property Y1:float()
		Return _y1
	End
	
	Property BX:float()
		Return _bx
	End

	Property BY:float()
		Return _by
	End

	Property BX1:float()
		Return _bx1
	End

	Property BY1:float()
		Return _by1
	End

	'set the position of the control in grid steps
	method SetGridLayout( x:float, y:float, width:float, height:float )
		_gridX = x
		_gridY = y
		_gridWidth = Clamp( width, 1.0, 512.0 )
		_gridHeight = Clamp( height, 1.0, 512.0 )
	End method
	

	'the virtual command means we are going to use these as a forward reference
	' dont be alarmed if you don't understand what I mean.
	' it will become very clear when we create other controls using this as a base
	' (that is why the page and control classes are sooooo complex)
	
	'a control have a background - if we want it
	method RenderBackground( canvas:Canvas, alpha:float ) Virtual
	End method

	'a foreground - that looks like a simple button,  but we can change this if we want
	' usually most of the drawing will be done here
	' perviously we used _x, _y, _width, _height,  we now use _bx, _by, _bwidth, _bheight
	method RenderForeground( canvas:Canvas, alpha:float ) Virtual
		If _BGColor &lt;&gt; Color.None Then
			canvas.Color = _BGColor
			canvas.DrawRect( _x, _y, _width, _height )
		End If

		canvas.Color = _FGColor
		canvas.DrawRect( _bx, _by, _bwidth, _bheight )
		
		If Not _mouseOver Then Return
		
		canvas.Color = Color.Sky
		If _mouseDown Then
			canvas.Alpha = alpha
		Else
			canvas.Alpha = alpha * 0.75
		End If
		canvas.DrawRect( _bx, _by, _bwidth, _bheight )
	End method

	'and finally a top - which is drawn last
	method RenderTop( canvas:Canvas, alpha:float ) Virtual
	End method
	
	'this calls the individual part which make up a control: back, front and top
	method OnRender( canvas:Canvas, alpha:float ) Virtual
		canvas.Alpha = alpha
		RenderBackground( canvas, alpha )
		
		RenderForeground( canvas, alpha )

		RenderTop( canvas, alpha )
	End method

	'more virtual stuff. the mouse routines now have correct mouseX and mouseY transferred
	method OnMouseEnter() virtual
	End method

	method OnMouseLeave() virtual
	End method

	method OnMouseDown( event:MouseEvent, mouseX:int, mouseY:int  ) Virtual
	End method
	
	method OnMouseUp( mouseX:int, mouseY:int ) Virtual
	End method

	method OnMouseMove( mouseX:int, mouseY:int ) Virtual
	End method

	method OnMouseWheel( wheel:int ) Virtual
	End method

protected	
	method OnRecalcLayout( x:float, y:float, width:float, height:float, gridDivX:float, gridDivY:float )
		_x = x + ( _gridX * gridDivY )
		_y = y + ( _gridY * gridDivY )
		_width = _gridWidth * gridDivY
		_height = _gridHeight * gridDivY
		
		_midX = (_x + _x1) * 0.5
		_midY = (_y + _y1) * 0.5
		
		RecalcBorder()
	End method
	
	method RecalcBorder()
		_x1 = _x + _width
		_y1 = _y + _height

		_bx = _x + _border
		_by = _y + _border
		_bx1 = _x1 - _border
		_by1 = _y1 - _border
		
		_bwidth = _bx1 - _bx
		_bheight = _by1 - _by
	End method

private
	'is the control shown. is it visible or not
	field _visible:bool = True
	
	'is the mouse over the control
	field _mouseOver:bool = false
	field _mouseDown:bool = false

	'basic layout dimentions
	field _x:float = 0
	field _y:float = 0
	field _x1:float = 0
	field _y1:float = 0
	field _width:float
	field _height:float
	field _midX:float
	field _midY:float
	
	'border vars
	'these are the same as the layout dimentions with a border inset a certain number of pixels
	field _border:float = 2
	field _bx:float
	field _by:float
	field _bx1:float
	field _by1:float
	field _bwidth:float
	field _bheight:float
	
	'grid vars
	field _gridX:float
	field _gridY:float
	field _gridWidth:float
	field _gridHeight:float
	
	'color vars
	field _BGColor:Color = Color.None
	field _FGColor:Color = Color.DarkGrey
	field _textColor:Color = Color.White
	field _imageColor:Color = Color.White
	
	'image vars
	field _BGImage:Image
	field _FGImage:Image
End Class


'OK this is something new. we are going to use our previous UXControl as a base
'and create a proper button from it
'it inherits everything that is public or protected from UXControl
'but we are going to write a new.

class UXButton Extends UXControl
	'if we dont give it any variables - deal with this
	method New( )
		_text = "Button"
	End method

	'we really would like a button the show some text
	'so when we New it lets give it some text
	method New( text:string )
		_text = text
	End method

	'as we have a new text string. lets give it a property	
	Property Text:string()
		Return _text
	Setter( text:string )
		_text = text
	End

	'lets draw the text on top of any forground and selection,  down etc
	' as the original is vertual we must override it
	method RenderTop( canvas:Canvas, alpha:float ) Override
		'and now draw some text
		canvas.Color = _textColor
		canvas.Alpha = alpha
		
		'lets make the text drop by the border size when clicked
		If _mouseDown Then
			canvas.DrawText( _text, _bx, _by + _border )
		Else
			canvas.DrawText( _text, _bx, _by )
		End If
	End method
	
private
	field _text:string
End Class


'lets do the same with an image
class UXImageButton Extends UXControl
	'if we dont give it any variables - deal with this
	method New( )
	End method

	'we really would like a button the show and image
	'so when we New it lets give it one
	method New( image:Image )
		If Not image Then Print "ERROR LOADING IMAGE"
		_image = image
	End method

	'as we have a new image. lets give it a property
	Property Image:Image()
		Return _image
	Setter( image:Image )
		_image = image
	End

	'we dont want to draw the fgbackground rect,  so lets remove it
	method RenderForeground( canvas:Canvas, alpha:float ) Override
		If Not _mouseOver Then Return
	End method

	'lets draw the text on top of any forground and selection,  down etc
	' as the original is vertual we must override it
	method RenderTop( canvas:Canvas, alpha:float ) Override
		'make sure we check the image is valid
		If Not _image Then
			Print "error"
			Return
		End If
		
		'and now draw the image,  with different color if the mouse is over
		If _mouseOver Then
			canvas.Color = Color.Sky
			canvas.Alpha = alpha * 0.8
		Else
			canvas.Color = _imageColor
			canvas.Alpha = alpha * 0.6
		End If
		
		'and drop it when clicked
		Local ypos:int = _by
		If _mouseDown Then
			ypos += _border
		End If

		'this is a new way to draw images. using a rect
		canvas.DrawRect( _bx, ypos, _bwidth, _bheight, _image )
	End method
	
private
	field _image:Image
End Class


Class MyWindow Extends Window

	Method New()
		Super.New( "My Window", Size.X, Size.Y, WindowFlags.Resizable )
	    
		'if you want a constant canvas size use this
'		Layout = "letterbox"
		'or If you want the canvas to always fill the window use this
		Layout = "fill"

		'this is a timer. it will 'tick' 60 times a second. calling OnUpdate
		_timer = New Timer( 60, OnUpdate )
		
		'initial rndseed
		SeedRnd( 747 )

		_maped = Image.Load( "asset::map.png" ) 'I used a 2000x2000 pixel PNG
		_maped.Handle=New Vec2f( .5,.5 )
	
		'lets now assign these to each chit
		'monkey2 will use internal referenceing systems,  so don't bother about resources
		' we will also deal with the image handle in the chit as well ;)
		Local chitImage1:Image = Image.Load( "asset::chit1.png" )
		Local chitImage2:Image = Image.Load( "asset::chit2.png" )

		Local hexImage2:Image = Image.Load( "asset::hex2.png" )

		'first we need a Page
		' the page MUST have it's layout called when the size of the window changes
		' this is done in OnRender
		Page = new UXPageView( "The page wot I created" )
		'set a grid size 16, 12 seems good. bit is terribly flexible
		Page.SetGrid( 16, 12 )
		' and show the pages grid. try commenting this out
		Page.ShowGrid = True
		
		'now we need a button 'it doesn't do anything yet...
		'NEW we have now created a class based on uxcontrol,  so lets use it
			local button1:UXButton = New UXButton()
			button1.SetGridLayout( 0, 2, 1, 2 )
			button1.TextColor = Color.Red
			'this next command Lambda is really new
			'basically in UXControl we have a clicked flag
			'when we call it,  it calls home and ends up at the lambda
			' and we can do something with it
			button1.Clicked = Lambda()
				Print "Button 1 clicked"
			End
			Page.AddControl( button1 )
		'And another
			local button2:UXButton = New UXButton()
			button2.SetGridLayout( 1, 3, 1, 1 )
			button2.FGColor = Color.Pine
			button2.Clicked = Lambda()
				Print "Button 2 clicked"
			End
			Page.AddControl( button2 )
		'And another. this time using the old UXControl
			local button3:UXControl = New UXControl()
			button3.SetGridLayout( 2, 4, 1, 1 )
			button3.Clicked = Lambda()
				Print "Button 3 clicked"
			End
			Page.AddControl( button3 )
			
		'And one with an image as a button	
			local button4:UXImageButton = New UXImageButton( hexImage2 )
			button4.SetGridLayout( 2, 5, 2, 2 )
			button4.Clicked = Lambda()
				Print "Button 4 clicked"
			End
			Page.AddControl( button4 )
		
		'just so you feel happy about rotation...
		'0 - shows normal bitmap the right way up points east
		'90 is north, 180 points west, 270 south
		'so. lets assume that chit1 is a ship. to have it point the correct way. the bitmap MUST face EAST!
		
        'provide a PNG and variables for every chit on the map
		_unitManager.AddShip( UNIT_SHIP, PARENT_NONE, chitImage1, 0, 150, 150 )
		_unitManager.AddShip( UNIT_SHIP, PARENT_NONE, chitImage2, 45, -51, -80 )
		
		'And the star
		Local parent:int
		_unitManager.AddPlanet( UNIT_STAR, PARENT_NONE, 60, 0,0, 0 )
		'the addPlanet now returns a parent
		parent = _unitManager.AddPlanet( UNIT_STAR, PARENT_NONE, 20, 0,0, 170, 0.2 )
		'we now feed the parentinto the next addplanet
		
		Local parent2:int
		parent2 = _unitManager.AddPlanet( UNIT_STAR, parent, 10, 0,0, 30, 0.6 )
		_unitManager.AddPlanet( UNIT_STAR, parent2, 5, 0,0, 15, 6 )
		
		_unitManager.AddPlanet( UNIT_STAR, parent, 5, 0,0, 50, -0.7 )
		
		'last we want to set an eye poition the eye goes from 1 (from above),  to 0.1 (from the side)
		' 0.5 is about isometric view
		_unitManager.Eye = 0.25
	End

Protected
	Method OnUpdate()
		_gameTime = Millisecs()
		
		_unitManager.UpdateUnits()
		
		RequestRender()
	End Method
	
	
	Method OnRender( canvas:Canvas ) Override
		'set up a measure that will recalculate if the window is resized
		If _width &lt;&gt; Width or _height &lt;&gt; Height Then
			'The Page Must be laid out
			Page.OnRecalcLayout( 0, 0, Width, Height )
			
			_width = Width
			_height = Height
		End if

		'fill the screen canvas with a color
		canvas.Color = Color.Black
		canvas.DrawRect( 0, 0, Width, Height )

		Select _gameMode
			Case GAMEMODE_INTRO
				DrawTheIntro( canvas )
			Case GAMEMODE_GAME
				DrawTheGame( canvas )
		End Select
	End


	method DrawMap( canvas:Canvas, midX:float, midY:float )
		'draw the mapimage
		canvas.Alpha = 1
		canvas.Color = Color.Grey
		canvas.DrawImage( _maped, midX, midY, 0, _scale, _scale )
		
'		DrawCircleDash( canvas, midX, midY, 100 * _scale )
		
		'draw the 100 lines (100 spatial positions)
		Local k:float
		Local sc:float
		canvas.Color = Color.DarkGrey
		canvas.Alpha = 0.3
		Local xoffset:float = midX Mod (100 * _scale)
		Local yoffset:float = midY Mod (100 * _scale)
		For k = xoffset To Width Step (100 * _scale)
			canvas.DrawLine( k,  0, k, Height )
		Next
		For k = yoffset To Height Step (100 * _scale * _unitManager.Eye)
			canvas.DrawLine( 0, k, Width, k )
		Next
		
		'draw the center of the map lines
		canvas.Color = Color.Grey
		canvas.DrawLine( midX, 0, midX, Height )
		canvas.DrawLine( 0, midY, Width, midY )
	End method
	
	
	method DrawUI( canvas:Canvas )
		'draw the page. currently this is just showing the page grid
		Page.OnRender( canvas )
	End method
	
	
	Method DrawTheGame( canvas:Canvas )
		'find the midpoint from where all drawing is based
		Local midX:float = (Width * 0.5) + _mX
		Local midY:float = (Height * 0.5) + _mY
		
		
		'draw the map in a seperate method
		DrawMap( canvas, midX, midY )
		
        'lets move these into the unit class
		canvas.Color = Color.White
		canvas.Alpha = 1
		
'		canvas.DrawText( midX+" "+midY+"  "+(_mouseX-midX)+" "+(_mouseY-midY), 10, 10 )

		'we now have a unitmanager to handle all the units,  so just one call to it's draw routine
		' will allow it to do the rest
		_unitManager.DrawUnits( canvas, _mouseX, _mouseY, midX, midY, _scale )
		
		DrawUI( canvas )
	End Method
	
	
	Method DrawTheIntro( canvas:Canvas )
		canvas.Color = Color.White
	
		canvas.DrawText( " Scroller Map' First App By Mark Ainsworth ref 210665",200,20 )
		canvas.DrawText( " How To Scroll The Map Right Click To Pickup Board, Then Drag it Release to Drop it. ",200,60 )
		canvas.DrawText( " You can Move around the Map By Only RightClicking and Dragging.",200,80 )
		canvas.DrawText("- PRESS ENTER OR LRFT-CLICK MOUSE TO START MAP --&gt;",200,670)
		
	End Method

	
	'respond to any key presses
	Method OnKeyEvent( event:KeyEvent ) Override
		'send key stuff to the new page controls and exit if handled
		if Page.OnKeyEvent( event ) then return
		
		'heres the best way to check for shift keys etc
		Local command:Bool = event.Modifiers &amp; Modifier.Gui
		Local shift:Bool = event.Modifiers &amp; Modifier.Shift
		Local alt:bool = event.Modifiers &amp; Modifier.Alt
		
		Select event.Type
			case EventType.KeyDown
			
				Select event.Key
					Case Key.Enter
						Select _gameMode
							Case GAMEMODE_INTRO
								_gameMode = GAMEMODE_GAME
						End Select
							
				End Select
				
			Case EventType.KeyUp
			
				Select event.Key
					Case Key.Enter
				End Select
				
		End Select
	End

	'here we track the mouse and all mouse related stuff
	Method OnMouseEvent( event:MouseEvent ) Override
		'send mouse stuff to the new page controls. and exit if handled
		if Page.OnMouseEvent( event ) Then return
		
		'set up some global mouse vars so we can use these throught to program
		_mouseX = event.Location.X
		_mouseY = event.Location.Y

		'put a check to see if the mouse button is still pressed
		if Not Mouse.ButtonDown( MouseButton.Left ) Then
			_movemap = 0
		End If


		'here are the baci mouse events we are interested in
		Select event.Type
			Case EventType.MouseClick
				Select _gameMode
					Case GAMEMODE_INTRO
						_gameMode = GAMEMODE_GAME
						
					Case GAMEMODE_GAME
						_movemap = 1
						If _movemap = 1 'if you left click record current mouse location
							_oldX = _mX + -_mouseX 'plus map location
							_oldY = _mY + -_mouseY
						Endif
				End Select	
				
			Case EventType.MouseUp
				_movemap = 0 'if you move the mouse while dragging
				If _movemap = 0 'the map x,y is updated untill you Mouseup
					_oldX = _mX 
					_oldY = _mY 
				Endif
			Case EventType.MouseEnter
			Case EventType.MouseLeave
			case EventType.MouseWheel
				If event.Wheel.Y &lt;&gt; 0 Then
				
					'macs use inverted scroll wheels, so lets make it mac friendly
#If __TARGET__="macos"
					_scale = Clamp( _scale - event.Wheel.Y * 0.01, 0.25, 4.0 )
#else
					_scale = Clamp( _scale + event.Wheel.Y * 0.01, 0.25, 4.0 )
#end				
				End If
			Case EventType.MouseMove
				If _movemap = 1
					_mX = _mouseX + _oldX - 0
					_mY = _mouseY + _oldY - 0
				Endif
		End Select
		
	End Method
	
	'this is needed to allow the Size to be correct. this is called automatically
	Method OnMeasure:Vec2i() Override
		Return Size
	End
Private
	'the timer ticks 60 times a second and handles the screen update
	Field _timer:Timer
	
	'what mode is the game in, showing the intro, playing, ended, etc
	Field _gameMode:Int = GAMEMODE_GAME'INTRO
	
	'global mouse vars
	Field _mouseX:Int
	Field _mouseY:Int
	
	field _scale:float = 1

	'global window size to track when window has changed
	field _width:int = 0
	field _height:int = 0
	
	'and some control buttons
	field _myButton:UXControl

	'map location vars
	Field _mY:Int = 0
	Field _mX:Int = 0
	Field _oldX:Int 'used to store map location before you drag
	Field _oldY:Int 'used to store map location before you drag
	Field _movemap:Int 'switch to on to dragmap in conjuction with old position

	'image assets
	Field _maped:Image ' this is the map png ' lets say the center is 0, 0

	'set up some classes' these will need to be newed
	field _unitManager:UnitManager =  New UnitManager()

	'set up the page to hold our controls
	field Page:UXPageView
	'UI image and stuff
'	field _imageHex1:Image
'	field _imageHex2:Image
End

</textarea><br><br>you should see a number of different buttons, some with different colors and text. and an image that is clickable.<br><br>You can also see the page grid has been made visible, so you can see how it all fits.<br>try changing some of the variables for the grid settings<br><br>or maybe give a different image for the image button<br><br>Here is a pic of this in operation, so you can see what it should look like:<br><img src="https://vjointeractive.files.wordpress.com/2017/04/screen-shot-2017-04-25-at-15-20-071.png"><br><br>Check out the new() of the main app to see how these are set up <br><br></td></tr></table><br>
<a name="1339618"></a>

<a name="1339620"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#144">[#144]</a></td></tr></table></td></tr><tr ><td class="posttext"> Wow, Ive got to look closer at the code, but wow, setting up buttons and positions is great!<br><br>I can see how building a flexible UI would well fit into this App. <br><br></td></tr></table><br>
<a name="1339629"></a>

<a name="1339630"></a>

<a name="1339631"></a>

<a name="1339632"></a>

<a name="1339633"></a>

<a name="1339634"></a>

<a name="1339635"></a>

<a name="1339636"></a>

<a name="1339638"></a>

<a name="1339639"></a>

<a name="1339640"></a>

<a name="1339641"></a>

<a name="1339642"></a>

<a name="1339643"></a>

<a name="1339644"></a>

<a name="1339650"></a>

<a name="1339651"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#145">[#145]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok ,I am taking a back seat, just playing with code, I'm doing an App from the beginning that I will plug into yours when you've done it, so I can develop some extra parts of the game if you wanted that is, its not pretty yet but I'm learning as I go. Ive got a similar type setup map and chits,But I totally rewritten it, but I'm thinking of it being a separate entity for displaying cargo images on a big ship display, or something of use to us, I love the way these classes can be added ontop of an app. you may not want my code in the game I'm studying the method of creating an App.<br><br>I've not used setters yet, but the code is working, you can move chits and rotate them. figured out all the formulas that was fun :) the chit selection is 50x50 from top, but it scales with the map.<br><br>Adam, you need to remember I'm experimenting, and its not ready for use by others yet, but I thought you would like a preview of it for fun,it uses right and left mouseclicks at the moment sorry, and I'm using a simple menu built into the window class , It can be slid into your UI, you may like the formulas too they are crazy but they worked,  I now know why you used a unitmanger class :) I love monkey2 now.<br><br>rightclick on an empty part of the map to deselect.<br><br>I HAD TO SIMPLIFY AN APP FOR MYSELF TO ALLOW ME TO CONTRIBUTE AT A LATTER STAGE, AS YOUR CODE IS ULTRA PERFECT AND TAILORED FOR YOU, I KNOW I SHOULD PROGRAM LIKE YOUR SHOWING ME , MAYBE WHEN IM MORE FAMILIAR WITH IT. I CAN ADD TO YOUR CODE IN THE GAMECODE YOUR SHOWING ME AND I CAN USE THE SIMPLE METHODS FOR SOME THINGS AND IT WILL GIVE ME A BASE TO DO THINGS LATER. <br><br>I DONT WANT TO STOP WITH WHAT WERE DOING, I JUST THOUGHT YOU WOULD APPRECIATE I'M LEARNING A LOT, AND YOUR TIME ISN'T WASTED, AND MY LEARNING IS EXTRA TO CREATING THE GAME. I THINK I MAY WRITE A UI LIKE YOURS IN THE FUTURE TOO, BUT USEING YOURS IS GREAT<br><br>you will need some files THEY START AT 1 NOT 0<br><br>#Import "assets/map.png"<br>#Import "assets/chit1.png"<br>#Import "assets/chit2.png"<br>#Import "assets/chit3.png"<br>#Import "assets/chit4.png"<br>#Import "assets/chit5.png"<br>#Import "assets/chit6.png"<br>#Import "assets/chit7.png"<br>#Import "assets/chit8.png"<br>#Import "assets/dashed.png"<br><br><br>NAME THIS FILE dashed.png<br><br><img src="https://img.itch.zone/aW1hZ2UvOTI5ODAvNjM2Mjk5LnBuZw==/original/9k6Jgn.png"><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Namespace myApp

#Import "&lt;std&gt;"
#Import "&lt;mojo&gt;"

Using std..
Using mojo..

#Import "assets/map.png"
#Import "assets/chit1.png"
#Import "assets/chit2.png"
#Import "assets/chit3.png"
#Import "assets/chit4.png"
#Import "assets/chit5.png"
#Import "assets/chit6.png"
#Import "assets/chit7.png"
#Import "assets/chit8.png"
#Import "assets/dashed.png"
Const Size := New Vec2i( 950,720 )

Const GAME_INTRO:Int = 1
Const GAME_GAME:int = 2
Global unitnumb:Int = -1
Global moveit:Int = -1
Function Main()
	New AppInstance
	
	New MyWindow
	
	App.Run()
End


'this will be the base class for all chits, anything can be a chit
Class Chit
	'this is called when any new thing is derrived from this class
	Method New()
	End Method

	
	'we can now have a different new which can be fed with an int which becomes the energy
	' so New(67) would give you a Chit with 67 rotation
	Method New( twist:Int,chx:Int,chy:int,id:int, anImage:Image, big:int )
		_id = id
		_twist = twist *  (Pi / 180)
		_chitx = chx 'just a var to initialise starting posision of chit
		_chity = chy 
		_big = big
		_chitimage = anImage
		_chitimage.Handle = New Vec2f( .5,.5 )
	End Method


	'because _twist is private,  we need a property and setter
	' we only then need to access by _chit[_number].Twist = 40,  or twist = _chit[_number].Twist
	'Property Twist:int()
	'	Return _twist
	'Setter( twist:int )
	'	_twist = twist
	'End

    Field _chitx:int = 600
	Field _chity:int = 600
	Field _twist:int = 0
	Field _id:Int = 0
	Field _big:float = 1
	Field _light:Int = 1
	Field _chitimage:Image

Private
	'how much rotation does the chit start with 0  but we could change this with a different New
	'Field _twist:int = 0
	

	
End Class


Class MyWindow Extends Window

	Method New()
		'Super.New( "My Window", Size.X, Size.Y, WindowFlags.Resizable )
	    Super.New( "My Window", Size.X, Size.Y, WindowFlags.Center )
		'if you want a constant canvas size use this
'		Layout = "letterbox"
		'or If you want the canvas to always fill the window use this
		Layout = "fill"

		'this is a timer. it will 'tick' 60 times a second. calling OnUpdate
		_timer = New Timer( 60, OnUpdate )
		_maped = Image.Load( "asset::map.png" ) 'I used a 2000x2000 pixel PNG
	
		_unit1 = Image.Load( "asset::chit1.png" ) 'I used a 50x50 pixel PNG
		'_unit1.Handle=New Vec2f( .5,.5 )
		_unit2 = Image.Load( "asset::chit2.png" ) 'I used a 50x50 pixel PNG
		'_unit2.Handle=New Vec2f( .5,.5 )
		_unit3 = Image.Load( "asset::chit3.png" ) 'I used a 50x50 pixel PNG
		'_unit3.Handle=New Vec2f( .5,.5 )
		_unit4 = Image.Load( "asset::chit4.png" ) 'I used a 50x50 pixel PNG
		'_unit4.Handle=New Vec2f( .5,.5 )
		_unit5 = Image.Load( "asset::chit5.png" ) 'I used a 50x50 pixel PNG
		'_unit5.Handle=New Vec2f( .5,.5 )
		_unit6 = Image.Load( "asset::chit6.png" ) 'I used a 50x50 pixel PNG
		'_unit6.Handle=New Vec2f( .5,.5 )
		_unit7 = Image.Load( "asset::chit7.png" ) 'I used a 50x50 pixel PNG
		'_unit7.Handle=New Vec2f( .5,.5 )
		_unit8 = Image.Load( "asset::chit8.png" ) 'I used a 50x50 pixel PNG
		'_unit8.Handle=New Vec2f( .5,.5 )
				dashy = Image.Load( "asset::dashed.png" ) 'I used a 2000x2000 pixel PNG
		
		
		
        'provide a PNG and variables for every chit on the map
		_chit[1] = New Chit(0,650,650,1,_unit1,25) ' rotatio,X,Y (x,y in relation to the map
		_chit[2] = New Chit(68,701,780,2,_unit2,25) ' the map you see starts at -x500 y-500
		_chit[3] = New Chit(0,600,650,3,_unit3,25) ' rotatio,X,Y (x,y in relation to the map
		_chit[4] = New Chit(68,701,760,4,_unit4,25) ' the map you see starts at -x500 y-500
		_chit[5] = New Chit(0,650,630,5,_unit5,25) ' rotatio,X,Y (x,y in relation to the map
		_chit[6] = New Chit(68,721,780,6,_unit6,25) ' the map you see starts at -x500 y-500
		_chit[7] = New Chit(0,680,650,7,_unit7,25) ' rotatio,X,Y (x,y in relation to the map
		_chit[8] = New Chit(68,601,780,8,_unit8,25) ' the map you see starts at -x500 y-500
		
		
	End

Protected
	Method OnUpdate()
		RequestRender()
	End Method
	
	
	Method OnRender( canvas:Canvas ) Override

		'fill the screen canvas with a color
		canvas.Color = Color.Black
		canvas.DrawRect( 0, 0, Width, Height )

		Select _gameMode
			Case GAME_INTRO
				DrawTheIntro( canvas )
			Case GAME_GAME
				DrawTheGame( canvas )
		End Select
	End


	Method DrawTheGame( canvas:Canvas )
		canvas.Color = Color.White
		'draw the map
		
		
		canvas.DrawImage( _maped,  _mX * _big  , _mY * _big ,0,_big,_big )		
		'draw the chits with a twist
		' debug _twist = _twist + 1
		'If _twisted &gt; 360 Then _twisted = _twisted - 360
		Local f:Int = 0
	    For f = 1 To 8
           'canvas.DrawCircle(800+_mX,  800+_mY,30 ) 'draw	800x800 plus map offset	
	        'loop to draw the chits
	     	canvas.DrawImage ( _chit[f]._chitimage, (_chit[f]._chitx +_mX)*_big, (_chit[f]._chity + _mY)*_big,_chit[f]._twist,_big,_big )
		Next
	    'bottom dashboard overlay image for UI
    	canvas.DrawImage( dashy, 0, 570 )
	    
	    'loop to draw selected chit on the dashboard
	    f = 0
	    For f = 1 To 8
	         If unitnumb &gt; 0 And unitnumb = _chit[f]._id then canvas.DrawImage (_chit[f]._chitimage, 870, 640,_chit[f]._twist,1,1 )
	    Next
	    '_hold is a flag to tell us were holding a chit
	    If _hold &gt; -1 Then _use = 3 'need to set the menu option to 3 if a chit is held
	    ' if a chit is held display it at mouse and highlight it
	    canvas.Color = Color.Sky
		    if _hold &gt; -1 then canvas.DrawImage (_chit[unitnumb]._chitimage, _mouseX, _mouseY,_chit[unitnumb]._twist,_big,_big )
	    canvas.Color = Color.White
	    
	
	    'If unitnumb &gt; 0 Then canvas.DrawText( "ID = "+unitnumb+"  Big "+_big+"radians = "+_chit[unitnumb]._twist,500,640)
	End Method
	
	
	Method DrawTheIntro( canvas:Canvas )
		canvas.Color = Color.White
	
		canvas.DrawText( " Gamer Map' Second App By Mark Ainsworth ref 210665",200,20 )
		canvas.DrawText( " How To Scroll The Map Right Click To Pickup Board, Then Drag it Release to Drop it. ",200,60 )
		canvas.DrawText( " You can Move around the Map By Only RightClicking and Dragging.",200,80 )
		canvas.DrawText("- PRESS ENTER OR LEFT-CLICK MOUSE TO START MAP --&gt;",200,670)
		
	End Method

	
	'respond to any key presses
	Method OnKeyEvent( event:KeyEvent ) Override
		'heres the best way to check for shift keys etc
		Local command:Bool = event.Modifiers &amp; Modifier.Gui
		Local shift:Bool = event.Modifiers &amp; Modifier.Shift
		Local alt:bool = event.Modifiers &amp; Modifier.Alt
		
		Select event.Type
			Case EventType.KeyDown
			
				Select event.Key
					Case Key.Enter
						Select _gameMode
							Case GAME_INTRO
								_gameMode = GAME_GAME
						End Select
							
				End Select
				
			Case EventType.KeyUp
			
				Select event.Key
					Case Key.Enter
				End Select
				
		End Select
	End

	'here we track the mouse and all mouse related stuff
	Method OnMouseEvent( event:MouseEvent ) Override
		'set up some global mouse cars so we can use these throught to program
		_mouseX = event.Location.X
		_mouseY = event.Location.Y

		'here are the baci mouse events we are interested in
		Select event.Type
	        'Right-click deselects all options and moves map
			Case EventType.MouseRightClick
				_movemap = 1
				'_use = 0
				'_hold = -1
				'unitnumb = 0
				If _movemap = 1 'if you right click record current mouse location
				_oldX = _mX +  -_mouseX 'plus map location
				_oldY = _mY + -_mouseY
				
				Endif

			Case EventType.MouseClick
		    'use 3 places held chit at the mouse cursor
			If _use = 3
			Local _newX:Int
			Local _newY:Int	
			If _hold &gt; -1
			_newX =  ((_mouseX + (-_mX * _big) ) / _big)   'this is the formula for screem   
			_newY =  ((_mouseY + (-_mY * _big) ) / _big)   'position of mouse in the map
		        _chit[unitnumb]._chitx = _newX
		        _chit[unitnumb]._chity = _newY
			    _use = 0 
			    _hold = -1
		    	unitnumb = 0
		    Endif
		    	
			Endif	
			'use 2 is the button has been pressed to pickup chit	
			If _use = 2
				_hold = -1
				Local f:Int = 0
	            For f = 1 To 8
		           ' If _hold &gt; -1 Then unitnumb = 0
		        If unitnumb = _chit[f]._id And _hold = -1 Then	_hold = unitnumb
			        
			    Next
			Endif
			    
				
			'use 1, rotates the selected chit in radians, I will have to lookup radian use
			'but the wheel rotates, this is a click version, dont use it
			If _use = 1
				'Local f:Int = 0
	            'For f = 1 To 8
		        'If unitnumb = _chit[f]._id Then _twist = _twist / (Pi / 180)    
				'If unitnumb = _chit[f]._id Then _chit[f]._twist = _chit[f]._twist + 1
				'If _chit[f]._twist &gt; 360 Then _chit[f]._twist = _chit[f]._twist - 360
		        '_twist = _twist *  (Pi / 180)
					
				
				'Next
				
				Endif
		
			    'this selects the chit the mouse is over every time you click
				Local f:Int = 0
	            For f = 1 To 8
				
				If _mouseX &gt; (_chit[f]._chitx )*_big +5000 - (_big*25) - ((-(_mX*_big))+5000)   And _mouseX &lt; (_chit[f]._chitx )*_big + (25*_big) +5000 - (((-_mX*_big))+5000)   And _mouseY &gt; (_chit[f]._chity )*_big +5000- (_big*25) - (((-_mY*_big))+5000)   And _mouseY &lt; (_chit[f]._chity )*_big + (25*_big) +5000 - (((-_mY*_big))+5000)  
			 	unitnumb = _chit[f]._id
			 	Endif
				Next
				
				
				
				
				
			 	
			 	'If unitnumb = _chit[0]._id And moveit = 1
				 	
				'Endif 	
				
				If _mouseX &gt; 10 And _mouseX &lt; 90 And _mouseY &gt; 575 And _mouseY &lt; 610
				 _use = 1 'if you click dashboard top left button then your
				          'selecting this, to rotate a chit option on
				 If unitnumb &gt; 0 Then _chit[unitnumb]._twist = 0 'reset totation
				Endif
				
				If _mouseX &gt; 10 And _mouseX &lt; 90 And _mouseY &gt; 575+50 And _mouseY &lt; 610+50
				 _use = 2  'if you click second button down on the left, you picking
				           ' a chit to move
				 _hold = -1 'reset to not holding,
				Local f:Int = 0
	            For f = 1 To 8
		           ' pickup selected chit unitnumb is the current selected chit
		        If unitnumb = _chit[f]._id And _hold = -1 Then	_hold = unitnumb
			        
			    Next
				Endif
				Select _gameMode
					Case GAME_INTRO
						_gameMode = GAME_GAME
				End Select
					
			Case EventType.MouseUp
				_movemap = 0 'if you move the mouse while dragging
					If _movemap = 0 'the map x,y is updated untill you Mouseup
						_oldX = _mX 
						_oldY = _mY 
		
					Endif
				
			Case EventType.MouseWheel
				
				If event.Wheel.Y &lt;&gt; 0 And _use &gt; 1 Then
			    'set scale with mouse wheel, unless rotating with use 1
                     _big = Clamp( _big + event.Wheel.Y * 0.01, 0.25, 4.0 )
				
				End If
				
				If event.Wheel.Y &lt;&gt; 0 And _use = 0 Then
			    'rotate
                      _big = Clamp( _big + event.Wheel.Y * 0.01, 0.25, 4.0 )
				
				End If	
                	If _use = 1 And event.Wheel.Y &lt;&gt; 0
					Local f:Int = 0
	            		For f = 1 To 8
		            'I will have to do this radians properly
                			If unitnumb = _chit[f]._id Then _chit[f]._twist =  _chit[f]._twist + (event.Wheel.Y / .05)        
                			If _chit[f]._twist &lt; -1000 Then  _chit[f]._twist = 1000 		            
                			If _chit[f]._twist &gt; 1000  Then  _chit[f]._twist = -1000	            		            
		           
				
						Next
				
					Endif
					
										
			Case EventType.MouseEnter
			Case EventType.MouseLeave
			Case EventType.MouseMove
				If _movemap = 1
					_mX = _mouseX + _oldX - 0
					_mY = _mouseY + _oldY - 0
				Endif	
				End Select					
		
	End Method
    	field unitnumb:Int = -1 'this is selected chit
		Field number:Int = 0
		Field _big:Float = 1 'this is scale
				
        Field moveit:Int = -1
		Field _mY:Int = -500 'position of map -500 so we start 500 in from top
	    Field _mX:Int = -500 'position of map -500 so we start 500 in from left
		Field _twist:Int  'rotate
		Field _oldX:Int 'used to store map location before you drag
		Field _oldY:Int 'used to store map location before you drag
		Field _movemap:Int 'switch to on to dragmap in conjuction with old position

	'this is needed to allow the Size to be correct. this is called automatically
	Method OnMeasure:Vec2i() Override
		Return Size
	End
Private
	'the timer ticks 60 times a second and handles the screen update
	Field _timer:Timer
	
	'what mode is the game in, showing the intro, playing, ended, etc
	Field _gameMode:Int = GAME_INTRO
	
	'global mouse vars
	Field _mouseX:Int
	Field _mouseY:Int
	Field _use:Int = -1 'this is menu selection
	Field _hold:Int = -1 'flag to tell us if were holding a chit
	'image assets
	Field _maped:Image ' this is the map png
	Field _unit1:Image ' this is the chit1 png
	Field _unit2:Image ' this is the chit2 png
	Field _unit3:Image ' this is the chit1 png
	Field _unit4:Image ' this is the chit2 png
	Field _unit5:Image ' this is the chit1 png
	Field _unit6:Image ' this is the chit2 png
	Field _unit7:Image ' this is the chit1 png
	Field _unit8:Image ' this is the chit2 png
	Field dashy:Image ' this is the map png ' lets say the center is 0, 0
	'set up some classes' these will need to be newed
	
	field _chit:Chit[] = New Chit[ 10 ]

	
End



</textarea> <br><br></td></tr></table><br>
<a name="1339653"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#146">[#146]</a></td></tr></table></td></tr><tr ><td class="posttext"> You know what. brilliant<br><br>My thoughts are dashed.png would be better replaced by a draw rect and some UXButtons - but that code still doesn't exist, so what you have done is brilliant!<br><br>my only complaint would be indenting.<br>use tab and not space<br><br>Apart from that... brilliant <br><br></td></tr></table><br>
<a name="1339656"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#147">[#147]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok. Here's a quick change.<br><br>I've been working on the UI controls. added text text align, sorted out some problems.<br><br>Using the basis of what you just showed:<br>I added a panel with three buttons, like above<br><br>Check the new to see how you set up a UI to do this:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Namespace myLetterboxApp

#Import "&lt;std&gt;"
#Import "&lt;mojo&gt;"

Using std..
Using mojo..

#Import "assets/map.png"
#Import "assets/chit1.png"
#Import "assets/chit2.png"

#Import "assets/hex1.png"
#Import "assets/hex2.png"


'here is a single global,  for tracking game time
'it is set by Millisecs(),  but if we use a global,  we only need to use Millisecs once when it is set.
'repeatedly calling stuff like mouse and timers may cause slowdowns
'so once it is set,  we just need to read it
'it is a global as everything will need to access it and drawing functions can use it as well
global _gameTime:long




Const Size := New Vec2i( 950,720 )

Const GAMEMODE_INTRO:Int = 1
Const GAMEMODE_GAME:int = 2

'used by the units to assign a none parent
const PARENT_NONE:int = -1


'ok blitzmax rotations were in degrees - simple ;)
'monkey2 reverts back to radians,  so we need a conversion
'so here is the best and quickest conversion I could come up with ;)
const Pi180:double = Pi / 180
function DegreesToRadian:float( degrees:float )
	return degrees * Pi180
End function
'and we will need another to revrse the process
function RadianToDegrees:float( radian:float )
	return radian / Pi180
End function


'monkey does not have any circle drawing routines,  so here is a basic one
function DrawCircle( canvas:Canvas, xc:float, yc:float, radiusX:float, radiusY:float )
	Local div:float = DegreesToRadian( 5 )
	
	Local angle:float = div
	Local xp0:float
	Local yp0:float
	Local xp1:float = xc + radiusX
	Local yp1:float = yc
	Local k:int
	
	For k = 5 To 360 Step 5
		xp0 = xc + Cos( angle ) * radiusX
		yp0 = yc + Sin( angle ) * radiusY
		canvas.DrawLine( xp0, yp0, xp1, yp1 )
		
		xp1 = xp0
		yp1 = yp0
		angle += div
	Next
End function

'monkey does not have any circle drawing routines.
'here is one that draws dashed lines
function DrawCircleDash( canvas:Canvas, xc:float, yc:float, radiusX:float, radiusY:float )
	Local div:float = DegreesToRadian( 5 )
	
	Local angle:float = div
	Local xp0:float
	Local yp0:float
	Local xp1:float = xc + radiusX
	Local yp1:float = yc
	Local k:int
	
	For k = 5 To 360 Step 5
		xp0 = xc + Cos( angle ) * radiusX
		yp0 = yc + Sin( angle ) * radiusY
		If k Mod 10 = 0 Then
			canvas.DrawLine( xp0, yp0, xp1, yp1 )
		End If
		
		xp1 = xp0
		yp1 = yp0
		angle += div
	Next
End function

'now we have seperated the front from the back drawing,  we can use these with the new depth sorting
function DrawCircleDashFront( canvas:Canvas, xc:float, yc:float, radiusX:float, radiusY:float )
	Local div:float = DegreesToRadian( 5 )
	
	Local angle:float = div
	Local xp0:float
	Local yp0:float
	Local xp1:float = xc + radiusX
	Local yp1:float = yc
	Local k:int
	
	For k = 5 To 180 Step 5
		xp0 = xc + Cos( angle ) * radiusX
		yp0 = yc + Sin( angle ) * radiusY
		If k Mod 10 = 0 Then
			canvas.DrawLine( xp0, yp0, xp1, yp1 )
		End If
		
		xp1 = xp0
		yp1 = yp0
		angle += div
	Next
End function

function DrawCircleDashBack( canvas:Canvas, xc:float, yc:float, radiusX:float, radiusY:float )
	Local div:float = DegreesToRadian( 5 )
	
	Local angle:float = DegreesToRadian( 185 )
	Local xp0:float
	Local yp0:float
	Local xp1:float = xc + Cos( 180 ) * radiusX
	Local yp1:float = yc + Sin( 180 ) * radiusY
	Local k:int
	
	For k = 185 To 360 Step 5
		xp0 = xc + Cos( angle ) * radiusX
		yp0 = yc + Sin( angle ) * radiusY
		If k Mod 10 = 0 Then
			canvas.DrawLine( xp0, yp0, xp1, yp1 )
		End If
		
		xp1 = xp0
		yp1 = yp0
		angle += div
	Next
End function

function DrawFrame( canvas:Canvas, x:Float,y:Float,w:Float,h:Float )
	Local x0 := x
	Local y0 := y
	Local x1 := x+w-1
	Local y1 := y+h-1
		
	canvas.DrawLine( x0, y0, x1, y0 )
	canvas.DrawLine( x1, y0, x1, y1 )
	canvas.DrawLine( x1, y1, x0, y1 )
	canvas.DrawLine( x0, y1, x0, y0 )
End

'lets create some defines for text alignment
const ALIGN_NONE:int = 0

const ALIGN_LEFT:int = 1
const ALIGN_RIGHT:int = 2
const ALIGN_MIDDLE:int = 4
const ALIGN_CENTER:int = 4
const ALIGN_HORIZONTAL:int = ALIGN_LEFT | ALIGN_RIGHT | ALIGN_MIDDLE

const ALIGN_TOP:int = 8
const VALIGN_TOP:int = 8
const ALIGN_BOTTOM:int = 16
const VALIGN_BOTTOM:int = 16
const VALIGN_MIDDLE:int = 32
const VALIGN_CENTER:int = 32
const ALIGN_VERTICAL:int = VALIGN_TOP | VALIGN_BOTTOM | VALIGN_MIDDLE

const ALIGN_FILL:int = 64

const ALIGN_TOPLEFT:int = VALIGN_TOP | ALIGN_LEFT
const ALIGN_TOPRIGHT:int = VALIGN_TOP | ALIGN_RIGHT
const ALIGN_TOPMIDDLE:int = VALIGN_TOP | ALIGN_MIDDLE
const ALIGN_TOPCENTER:int = VALIGN_TOP | ALIGN_MIDDLE

const ALIGN_CENTERED:int = VALIGN_MIDDLE | ALIGN_MIDDLE
const ALIGN_CENTERLEFT:int = VALIGN_MIDDLE | ALIGN_LEFT
const ALIGN_CENTERRIGHT:int = VALIGN_MIDDLE | ALIGN_RIGHT

const ALIGN_MIDDLELEFT:int = VALIGN_MIDDLE | ALIGN_LEFT
const ALIGN_MIDDLERIGHT:int = VALIGN_MIDDLE | ALIGN_RIGHT

const ALIGN_BOTTOMLEFT:int = VALIGN_BOTTOM | ALIGN_LEFT
const ALIGN_BOTTOMRIGHT:int = VALIGN_BOTTOM | ALIGN_RIGHT
const ALIGN_BOTTOMMIDDLE:int = VALIGN_BOTTOM | ALIGN_MIDDLE
const ALIGN_BOTTOMCENTER:int = VALIGN_BOTTOM | ALIGN_MIDDLE

'yes I know I said don't use globals
' but sometimes there is a solid And good reason To do so.
' this is that reason
global g_TextLeft:int
global g_TextTop:int

'a new function to get the correct alignment for text. notice that it uses Font
'this will allow us to use custom fonts in the future
'the alignments are the new const vars we added above
'then we feed a rectangle, the text, and an alignment
'it will return the correct x,y position for the text
function SetTextAlign( x:int, y:int, width:int, height:int, text:string, textAlign:int, font:Font = App.DefaultFont )
	local textWidth:int = font.TextWidth( text )
	local textHeight:int = font.Height
	g_TextLeft = x
	g_TextTop = y
	
	If textAlign &amp; ALIGN_RIGHT = ALIGN_RIGHT Then
		g_TextLeft += width - textWidth
	Else If textAlign &amp; ALIGN_MIDDLE = ALIGN_MIDDLE Then
		g_TextLeft += (width - textWidth) * 0.5
	End If
	
	If textAlign &amp; VALIGN_BOTTOM = VALIGN_BOTTOM Then
		g_TextTop = y + height - textHeight
	Else If textAlign &amp; VALIGN_CENTER = VALIGN_MIDDLE Then
		g_TextTop = y + (height - textHeight) * 0.5
	End If
End function

'here we draw the text using a canvas and the new alignment system
function DrawText( canvas:Canvas, x:int, y:int, width:int, height:int, text:string, textAlign:int, font:Font = App.DefaultFont )
	canvas.Font = font
	
	SetTextAlign( x, y, width, height, text, textAlign, font )
	canvas.DrawText( text, g_TextLeft, g_TextTop )
End function

'and another that fakes boldtext
function DrawTextBold( canvas:Canvas, x:int, y:int, width:int, height:int, text:string, textAlign:int, font:Font = App.DefaultFont )
	canvas.Font = font
	
	SetTextAlign( x, y, width, height, text, textAlign, font )
	canvas.DrawText( text, g_TextLeft, g_TextTop )
	canvas.DrawText( text, g_TextLeft+1, g_TextTop )
End function



Function Main()
	New AppInstance
	
	New MyWindow
	
	App.Run()
End

'this is now moved into the unit manager
'what will be the maximum number of units avaialable
' a unit is anything like a planet or ship,  so we need 16 for the base planets stuff and...
' lets say 100 other units
' a missile could be classed as a unit as well,  so lets have 256 units
'const MAX_UNITS:int = 256


'lets have some const vars to make me happy
'ive dragged over the const from the universe just so we are talking the same language
const UNIT_BLACKHOLE:int = 0
const UNIT_STAR:int = 1
const UNIT_GASGIANT:int = 2
const UNIT_PLANET:int = 3
const UNIT_MOON:int = 4
const UNIT_ASTEROIDMOON:int = 5
const UNIT_ASTEROID:int = 6
const UNIT_ASTEROIDBELT:int = 7
const UNIT_DUSTBELT:int = 8
const UNIT_NEBULAE:int = 9
const UNIT_RADIATIONBELT:int = 10

'so lets say a ship starts at 100
const UNIT_SHIP:int = 100

'this will be the base class for all chits, anything can be a chit
'ok chit it is - unit would possibly be a better choice though?
'I have converted all int's to floats - this has already bourn fruit with the rotation
'sorry converted chit to unit
Class Unit
	'this is called when any new thing is derrived from this class
	Method New()
	End Method

	
	' so New(67) would give you a Chit with 67 rotation
	Method New( kind:int, chitImage:Image, rotate:float, x:float, y:float )
		'monkey2 uses radians,  so convert from degrees to radian
		_rotate = DegreesToRadian( rotate )

		_x = x 'just a var to initialise starting position of chit
		_y = y
		
		_kind = kind
		
		_size = 25
		
		_image = chitImage
		_image.Handle = New Vec2f( .5,.5 )
	End Method


	Method New( kind:int, rotate:float, x:float, y:float )
		'monkey2 uses radians,  so convert from degrees to radian
		_rotate = DegreesToRadian( rotate )

		_x = x 'just a var to initialise starting position of chit
		_y = y
		
		_kind = kind

		_size = 30
	End Method


	'because _twist is private,  we need a property and setter
	' we only then need to access by _chit.Twist = 40,  or twist = _chit.Twist
	'you can now see here that directly accessing the variables would have caused us a bit more hasslle (in the long term)
	'but using a property/setter,  means the nasty degrees radian stuff lives inside,  and doesn't bother us now
	Property Rotate:float()
		Return RadianToDegrees( _rotate )
	Setter( rotate:float )
		_rotate = DegreesToRadian( rotate )
	End

	'the eye is our watch position. 1 is above,  0 is from the side and -1 is from below
	Property Eye:float()
		Return _eye
	Setter( eye:float )
		_eye = Clamp( eye, -1.0, 1.0 )
	End

	Property X:float()
		Return _x
	Setter( x:float )
		_x = x
	End

	Property Y:float()
		Return _y
	Setter( y:float )
		_y = y
	End

	Property DrawY:float()
		Return _drawY
	End
	
	Property DrawOrbitY:float()
		Return _drawOrbitY
	End

	Property OrbitX:float()
		Return _orbitX
	Setter( orbitX:float )
		_orbitX = orbitX
	End

	Property OrbitY:float()
		Return _orbitY
	Setter( orbitY:float )
		_orbitY = orbitY
	End

	Property Reference:int()
		Return _reference
	Setter( reference:int )
		_reference = reference
	End

	Property Kind:int()
		Return _kind
	Setter( kind:int )
		_kind = kind
	End

	Property Size:float()
		Return _size
	Setter( size:float )
		_size = size
	End
	
	Property Over:bool()
		Return _over
	Setter( over:bool )
		_over = over
	End

	Property Velocity:float()
		Return _velocity
	Setter( velocity:float )
		_velocity = velocity
	End

	Property OrbitDistance:float()
		Return _orbitDistance
	Setter( orbitDistance:float )
		_orbitDistance = orbitDistance
	End

	Property Parent:int()
		Return _parent
	Setter( parent:int )
		_parent = parent
	End

protected
	'this is the new update draw routine. it is basically the old draw with all the drawing removed
	' so it sets everything up for a nice quick draw later.
	' what we really need is the final y draw location. this will be fed into our new sorting stuff
	method UpdateDraw( reference:int, mouseX:int, mouseY:int, x:float, y:float, scale:float )
		_reference = reference
		
		_drawX = (_x * scale) + x
		_drawY = y - (_y * scale) 'this is inverted!!!!
		
		If _orbitDistance &gt; 0 Then
'			canvas.Color = Color.Orange
'			canvas.Alpha = 0.4

			_drawOrbitX = _drawX
			_drawOrbitY = _drawY

'			DrawCircleDash( canvas, xx, yy, _orbitDistance * scale, _orbitDistance * scale * _eye )
			'and modify then xx
			Local rad:float = _orbitDistance
			_orbitX = Cos( _rotate ) * rad
			_orbitY = Sin( _rotate ) * rad * _eye

			_drawX += _orbitX * scale
			_drawY -= _orbitY * scale
			_rotate += _velocity

			'make sure that the orbit vars are correctly offset
			_orbitX += _x
			_orbitY += _y
		else	
			_drawY =  y - ((_y * scale)* _eye)
		End If

		'get the actual drawing locations
		Local sc:float = scale * _size
		Local sc2:float = sc * 2
		Local x0:int = _drawX - sc
		Local x1:int = x0 + sc2
		Local y0:int = _drawY - sc
		Local y1:int = y0 + sc2

		'check if the mouse is over it
		_over = True
		If mouseX &lt; x0 Then _over = false
		If mouseX &gt; x1 Then _over = false
		If mouseY &lt; y0 Then _over = false
		If mouseY &gt; y1 Then _over = False
		
	End method

	
	method DrawBackOrbit( canvas:Canvas, scale:Float )
		canvas.Color = Color.Orange
		canvas.Alpha = 0.4

		DrawCircleDashBack( canvas, _drawOrbitX, _drawOrbitY, _orbitDistance * scale, _orbitDistance * scale * _eye )
		canvas.Alpha = 1
	End method

	method Draw( canvas:Canvas, scale:Float )
		If _orbitDistance &gt; 0 Then
			If _over Then
				canvas.Color = Color.Sky
				canvas.Alpha = 0.35
			Else
				canvas.Color = Color.Orange
				canvas.Alpha = 0.15
			End If

			DrawCircleDashBack( canvas, _drawOrbitX, _drawOrbitY, _orbitDistance * scale, _orbitDistance * scale * _eye )
			canvas.Alpha = 1
		End If

		If _over Then
			canvas.Color = Color.Sky
			Local sc:float = scale*(_size+(Sin(_gameTime * 0.01)*5 )+5)
			canvas.LineWidth = 10 * scale
	        DrawCircle( canvas, _drawX, _drawY, sc, sc )
			canvas.LineWidth = 1
		Else
			canvas.Color = Color.White
		End If

		'draw the unit
		Select _kind
			Case UNIT_SHIP
				canvas.DrawImage( _image, _drawX, _drawY, _rotate, scale, scale )
				
			Case UNIT_STAR
				Local sc:float = scale * _size
		        canvas.DrawCircle( _drawX, _drawY, sc )
		        canvas.Color = Color.DarkGrey
		        canvas.DrawCircle( _drawX, _drawY, sc-2 )
		End Select
		
		'and any front orbit
		If _orbitDistance &gt; 0 Then
			If _over Then
				canvas.Color = Color.Sky
				canvas.Alpha = 0.8
			Else
				canvas.Color = Color.Orange
				canvas.Alpha = 0.3
			End If
			DrawCircleDashFront( canvas, _drawOrbitX, _drawOrbitY, _orbitDistance * scale, _orbitDistance * scale * _eye )
			canvas.Alpha = 1
		End if
	End method
	
Private
	'this is any image we might be drawing
	field _image:Image
	
	'this is the kind of thing the unit is
	field _kind:int

	'size is the drawing size radius,  so we could have different sizes for stuff
	'currently there is 25 for the ships (50 width) and 30 radius for the planets
	field _size:float

	'the distance the unit orbits around
	field _orbitDistance:float = 0
	field _orbitX:float
	field _orbitY:float
	field _drawOrbitX:float
	field _drawOrbitY:float
	
	'is the mouse over it
	field _over:bool = False
	
	'this is our view position
	field _eye:float = 1
	
	'does this unit have a parent. -1 (PARENT_NONE) means it does not
	field _parent:int = PARENT_NONE
	'ok and now we need a sort reference position. this is going to become very important
	field _reference:int
	
	'and here are some vars to tell us where and what way it's facing
	Field _x:float = 600
	Field _y:float = 600
	Field _rotate:float = 0
	
	'the actual drawing positions
	field _drawX:float
	field _drawY:float
	
	'how fast is the unit moving
	field _velocity:float = 0
End Class


class UnitManager
	'what will be the maximum number of units avaialable
	' a unit is anything like a planet or ship,  so we need 16 for the base planets stuff and...
	' lets say 100 other units
	' a missile could be classed as a unit as well,  so lets have 256 units
	const MAX_UNITS:int = 256

	method New()
	End method
	

	'the eye is our watch position. 1 is above,  0 is from the side and -1 is from below. we wont be going below 0.1!
	Property Eye:float()
		Return _eye
	Setter( eye:float )
		_eye = Clamp( eye, 0.1, 1.0 )

		'update all the units eye positions
		Local k:int
		For k = 0 Until _count
			_unit[k].Eye = _eye
		Next
	End

	'ok change here is the method now returns an int.
	'the int is the actual count/position in the array
	method AddShip:int( kind:int, parent:int, chitImage:Image, rotate:float, x:float, y:float )
		Local this:int = _count
		_unit[ _count ] = New Unit( kind, chitImage, rotate, x, y)
		_unit[ _count ].Parent = parent

		_count += 1
		
		Return this
	End method


	method AddPlanet:int( kind:int, parent:int, size:float, x:float, y:float, distance:float, velocity:float= 0 )
		Local this:int = _count

		_unit[ _count ] = New Unit( kind, 0, x, y)
		_unit[ _count ].Size = size
		_unit[ _count ].OrbitDistance = distance
		_unit[ _count ].Parent = parent
		_unit[ _count ].Rotate = Rnd( 360 )
		
		'moake sure that a planet at the center does not move
		If distance &lt; 2 Then velocity = 0
		
		'lets slow things down a bit
		velocity *= 0.001
		
		'we have got a parent,  we now need to do lots of fun things
		If parent &gt; -1 Then
			_unit[ _count ].OrbitDistance += _unit[ _count ].OrbitDistance
		End If
		
		_unit[ _count ].Velocity = velocity
		
		_count += 1
		
		Return this
	End method
	
	
	'new method update to keep everything where it makes more sense
	method UpdateUnits()
		Local k:int
		For k = 0 Until _count
		
			'only planets 'should' have parents. and we need to update their positions
			If _unit[k].Parent &gt; -1 Then
				_unit[k].X = _unit[_unit[k].Parent].OrbitX
				_unit[k].Y = _unit[_unit[k].Parent].OrbitY
			End If
			
		Next
	End method
	
	'we now need some form of sorting so that everything is displayed from the furthest to the nearest
	'if you look down on a map, table, game or whatever. any object with a low y is closer to you
	'so... throw out the x (not interested in that)
	'and do a simple (not the best) sort on the y values.
	'we will improve the sort later. lets just get it working first
	method SortUnits( mouseX:int, mouseY:int, midX:float, midY:float, scale:float )
		'this is a 2 step process.
		'first we reset the sort references
		Local k:int
		For k = 0 Until _count
			'first update the drawing and the sort references
			_unit[k].UpdateDraw( k, mouseX, mouseY, midX, midY, scale )
		Next
		
		'next we do the sort' this is a slow bubble sort. we can use other faster sorts later
		Local l:int
		Local tmp:int
		For k = 0 To _count-2
			For l = k+1 To _count-1
				If _unit[ _unit[ k ].Reference ].DrawY &gt; _unit[ _unit[ l ].Reference ].DrawY Then
					tmp = _unit[ k ].Reference
					_unit[ k ].Reference = _unit[ l ].Reference
					_unit[ l ].Reference = tmp
				End If
			Next
		Next

		'and now reverse search and pick the top most thing we are over
		k = _count-1
		Local over:int = -1
		While k &gt; -1
			If over = -1 then
				if _unit[ _unit[ k ].Reference ].Over Then over = k
			Else
				_unit[ _unit[ k ].Reference ].Over = false
			End If
			k -= 1
		Wend
'		Print over
		
	End method
	
	
	'and now draw them correctly
	method DrawUnits( canvas:Canvas, mouseX:int, mouseY:int, midX:float, midY:float, scale:float )
		SortUnits( mouseX, mouseY, midX, midY, scale )
		
		'and not the front facing units plus orbits
		local k:int
		For k = 0 Until _count

			'ok. this will draw the units just like before. uncomment it and comment out the other line to see it
'			_unit[ k ].Draw( canvas, scale )

			'but here is the magic version
			'We draw using the sort reference instead. sorted from back to front
			_unit[ _unit[k].Reference ].Draw( canvas, scale )
		Next
	End method

private
	'the units we have
	field _unit:Unit[] = New Unit[ MAX_UNITS ]
	
	'how many units we have got
	field _count:int = 0
	
	'is the mouse over a unit? if so what is it's number
	field _over:int = -1
	
	'where are we looking from
	field _eye:float = 1

End Class

'lets create a control class for all our ui elements
'we will call it a page and its called UXPageView. it will manage everything for us
'we are going to do this step by step

Class UXPageView
	Method New( title:string )
		_title = title
	End

	Property Title:string()
		Return _title
	Setter( title:string )
		_title = title
	End

	Property Visible:bool()
		Return _visible
	Setter( visible:bool )
		_visible = visible
	End

	Property Alpha:float()
		Return _alpha
	Setter( alpha:float )
		_alpha = Clamp( alpha,  0.0, 1.0 )
	End

	Property GridX:int()
		Return _gridX
	Setter( gridX:int )
		_gridX = gridX
	End

	Property GridY:int()
		Return _gridY
	Setter( gridY:int )
		_gridY = gridY
	End

	Property ShowGrid:bool()
		Return _showGrid
	Setter( showGrid:bool )
		_showGrid = showGrid
	End

	method SetGrid( x:int,  y:int )
		If x &lt; 1 or y &lt; 1 Then Return
		
		_gridX = x
		_gridY = y
	End method

	'the offset is how many pixels the page is offset from the top left corner
	method SetOffset( x:float, y:float )
		_offsetX = x
		_offsetY = y
		OnRecalcLayout( x, y, _width, _height )
		App.RequestRender()
	End method

	'these next three methods give us the power to add and remove things from the stack
	method AddControl( control:UXControl )
		If Not control Then Return
		
		_controls.Add( control )
	End method
	
	method RemoveControl( control:UXControl )
		If Not control Then return

		_controls.Remove( control )
	End method

	method RemoveAllControls()
		For Local control := Eachin _controls
			RemoveControl( control )
		Next
	End method
	
protected
	'we have come across OnRender before,  so lets use exact the same format
	'we draw the title of the page just for debug purposes
	method OnRender( canvas:Canvas )

		For Local control := Eachin _controls
			If control.Visible Then
				control.OnRender( canvas, _alpha )
			End If
		Next

		If _showGrid Then
			canvas.Alpha = _alpha
			RenderGrid( canvas, _x, _y, _width, _height )
			canvas.DrawText( _title, _x, _y )
		End If
	End method

	
	'render the grid which control align to
	Method OnMouseEvent:bool( event:MouseEvent )
		_mouseX = event.Location.X - _x
		_mouseY = event.Location.Y - _y
		_mouseOffsetX = _mouseX + _offsetX
		_mouseOffsetY = _mouseY + _offsetY
		If _mouseX &lt; 0 or _mouseY &lt; 0 or _mouseX &gt; _width or _mouseY &gt; _height Then
			NotOverControl()
			Return False
		End If

		'this returns the current control. or not. it does all the nasty stuff for us
		_currentControl = GetCurrentControl()
		If not _currentControl Then Return False
		
		'if the control has no user interaction,  then return
		If not _currentControl.Active Then Return False

		'now lets process all the mouse events
		if Not Mouse.ButtonDown( MouseButton.Left ) Then
			_mouseDown = False
'			_currentControl.MouseDown = False
		End if

		Select event.Type
			Case EventType.MouseDown
				_mouseDown = True
				_currentCapturedControl = _currentControl
				_currentControl.OnMouseDown( event, _mouseOffsetX - _currentControl.X, _mouseOffsetY - _currentControl.Y )
				_currentControl.MouseDown = True
				'wave to the Lambda
				_currentControl.ClickDown()
				event.Eat()
				Return True

			Case EventType.MouseUp
				'wave to the Lambda
				if _currentCapturedControl = _currentControl then
					_currentControl.Clicked()
				End if
				_mouseDown = False
				_currentCapturedControl = null
				_currentControl.OnMouseUp( _mouseOffsetX - _currentControl.X, _mouseOffsetY - _currentControl.Y )
				_currentControl.MouseDown = False
				Return true

			case EventType.MouseWheel
				If event.Wheel.Y &lt;&gt; 0 Then
					_currentControl.OnMouseWheel( event.Wheel.Y )
					event.Eat()
					Return true
				End If

			Case EventType.MouseEnter
				_currentControl.OnMouseEnter()
				event.Eat()
				Return True
				
			Case EventType.MouseLeave
				_currentControl.OnMouseLeave()
				_currentCapturedControl = Null
				NotOverControl()
				event.Eat()
				Return True

			Case EventType.MouseMove
				If _mouseX &lt; 0 or _mouseY &lt; 0 or _mouseX &gt; _width or _mouseY &gt; _height Then
					_currentControl.OnMouseLeave()
				Else
					_currentControl.OnMouseEnter()
				End If
				_currentControl.OnMouseMove( _mouseOffsetX - _currentControl.X, _mouseOffsetY - _currentControl.Y )
				event.Eat()
				Return true
		End Select
		
		Return False
	End method

	'when we find a new control,  tell it we are over it
	method OverControl( control:UXControl )
		If control = _currentControl Then Return
		
		control.MouseOver = true

'		Print "found control "
		_currentControl = control
	End method
		
	'when we are not over a control, make the control we were over null, and tell it we arent over it anymore
	method NotOverControl()
		If not _currentControl Then Return
		
		_currentControl.MouseOver = false
		
'		Print "exit control"
		_currentControl = null
	End method


	'this goes (backwards) through the controls and checks if the mouse is over them.
	'  it returns the control the mouse is over
	method GetCurrentControl:UXControl()
		If _currentControl Then
			If not _currentControl.Active Then
				_currentControl = null
			Else	
	'			Print "checkStillOver "+_mouseOffsetX+" "+_mouseOffsetY+"   "+_currentControl.X+" "+_currentControl.Y
				If _mouseOffsetX &lt; _currentControl._rect.X or _mouseOffsetY &lt; _currentControl._rect.Y or _mouseOffsetX &gt; _currentControl._rect.Right or _mouseOffsetY &gt; _currentControl._rect.Bottom Then
					NotOverControl()
				Else	
					Return _currentControl
				End If
			End If
		End If

'		_currentControl = Null
		For Local control := Eachin _controls.Backwards()
			if _currentControl = Null and control.Visible Then
'				Print "control "+control.Text
				If control.Active Then
					If _mouseOffsetX &lt; control._rect.X or _mouseOffsetY &lt; control._rect.Y or _mouseOffsetX &gt; control._rect.Right or _mouseOffsetY &gt; control._rect.Bottom Then
						'we are not in this control
					Else
						'we are in this control
						OverControl( control )
						Return _currentControl
					End If
				End if
			End If
		Next

		Return Null
	End method
	
	
	Method OnKeyEvent:bool( event:KeyEvent )
		'_currentControl is set by the mouse being over it
		If _currentControl and not _currentControl.Active Then Return False
		

'		Print "keyevent "

		Return false
	End method
	
	method RenderGrid( canvas:Canvas, x:int, y:int, width:int, height:int )
		canvas.Color = Color.Sky
		
		Local xx:float
		Local yy:float
		Local xp:float
		Local yp:float
		
		xx = 0
		xp = x
		Repeat
			canvas.DrawLine( xp, y, xp, y+height )
			xx += _gridDivX
			xp += _gridDivX
		Until xx &gt; width

		yy = 0
		yp = y
		Repeat
			canvas.DrawLine( x, yp, x+width, yp )
			yy += _gridDivY
			yp += _gridDivY
		Until yy &gt; height
	End method


	'when the main window is resized we will need to tell the page it has changed
	method OnRecalcLayout( x:int, y:int, width:int, height:int )
		'set up the position of the page
		_x = x + _offsetX
		_x1 = _x + width -1
		_y = y + _offsetY
		_y1 = _y + height -1
		_width = width
		_height = height
		
		'set up the grid divisions
		_gridDivX = float(width) / _gridX
		_gridDivY = float(height) / _gridY
		_gridDivXHalf = _gridDivX * 0.5
		_gridDivYHalf = _gridDivY * 0.5
		'And the ui scaling
		_uiScale = _gridDivY / 80

		'go through each control and reset its position correctly
		LayoutControls()
	End method
	
	
	'this goes through each control and reset its position correctly
	method LayoutControls()
		For Local control := Eachin _controls
			If control.Visible Then
				'send the control the page size information
				control.OnRecalcLayout( _x, _y, _width, _height, _gridDivX, _gridDivY )
			End If
		Next
	End method
	
private
	'the title of the page
	field _title:string
	
	'is the page visible
	field _visible:bool = True
	
	'what alpha does the page have
	field _alpha:float = 1
	
	'deal with mouse and keyboard events
	field _mouseX:int
	field _mouseY:int
	field _mouseOffsetX:int
	field _mouseOffsetY:int
	field _mouseDown:bool = False
	
	'what is the current control the mouse is over
	field _currentControl:UXControl = Null
	'when we press left mouse button we capture the current control
	field _currentCapturedControl:UXControl = Null
	
	' page offset from top left corner
	field _offsetX:float = 0
	field _offsetY:float = 0
	
	'the position of the page. this is recalculated by using OnRecalLayout
	field _x:int
	field _y:int
	field _x1:int
	field _y1:int
	field _width:int
	field _height:int

	'the grid sizes for the page
	field _gridX:int = 12
	field _gridY:int = 8
	'and show the grid or not
	field _showGrid:bool = false

	'internal grid division calculated when screen resized. controls use grids for quick alignment
	field _gridDivX:float
	field _gridDivY:float
	field _gridDivXHalf:float
	field _gridDivYHalf:float
	field _uiScale:float

	'dont worry what a stack is. think of it as a collection of things. in this case UXControl
	Field _controls := New Stack&lt;UXControl&gt;
End Class

'And then we need a button. lets call it UXControl &lt; this will became clear a bit later
'border has now been added. A Border is a pixel offset from the edges inward. default is 2
class UXControl
	'these fields with void() are linked internally by the compiler to Lambdas &lt;- WTF????
	' ok Lambdas are nothing to get worried about. they are callers
	' think of a control having a flag. and that flag can wave at a Lambda with it's name on
	'the lambdas (which appear in the main program start waving. and you do somehting when they wave

	'clickdown is triggered when the mouse is clicked down in a control
	field ClickDown:void()
	'clicked is when a button is realsed
	field Clicked:void()

	Method New()
	End

	Property Visible:bool()
		Return _visible
	Setter( visible:bool )
		_visible = visible
	End

	Property Active:bool()
		Return _active
	Setter( active:bool )
		_active = active
	End

	Property MouseOver:bool()
		Return _mouseOver
	Setter( mouseOver:bool )
		_mouseOver = mouseOver
	End

	Property MouseDown:bool()
		Return _mouseDown
	Setter( mouseDown:bool )
		_mouseDown = mouseDown
	End

	Property Border:float()
		Return _border
	Setter( border:float )
		_border = border
		RecalcBorder()
	End

	'both BGImage And FGImage are not specifically set to be used
	' just the actual code is here so any derrived classes can simply use it
	Property BGColor:Color() Virtual
		Return _BGColor
	Setter( bgColor:Color ) Virtual
		_BGColor = bgColor
	End

	Property FGColor:Color() Virtual
		Return _FGColor
	Setter( fgColor:Color ) Virtual
		_FGColor = fgColor
	End

	Property BGImage:Image()
		Return _BGImage
	Setter( bgImage:Image )
		_BGImage = bgImage
	End

	'as we have a new text string. lets give it a property	
	Property Text:string()
		Return _text
	Setter( text:string )
		_text = text
	End

	Property TextAlign:int() Virtual
		Return _textAlign
	Setter( textAlign:int ) virtual
		_textAlign = textAlign
	End

	Property TextColor:Color()
		Return _textColor
	Setter( textColor:Color )
		_textColor = textColor
	End

	property TextFont:Font()
		Return _textFont
	Setter( textFont:Font )
		_textFont = textFont
	End

	Property TextBold:bool()
		Return _textBold
	Setter( textBold:bool )
		_textBold = textBold
	End

	Property ImageColor:Color()
		Return _imageColor
	Setter( imageColor:Color )
		_imageColor = imageColor
	End

	Property FGImage:Image()
		Return _FGImage
	Setter( fgImage:Image )
		_FGImage = fgImage
	End

	Property X:float()
		Return _x
	End

	Property Y:float()
		Return _y
	End

	Property X1:float()
		Return _x1
	End

	Property Y1:float()
		Return _y1
	End
	
	Property BX:float()
		Return _bx
	End

	Property BY:float()
		Return _by
	End

	Property BX1:float()
		Return _bx1
	End

	Property BY1:float()
		Return _by1
	End

	'set the position of the control in grid steps
	method SetGridLayout( x:float, y:float, width:float, height:float )
		_gridX = x
		_gridY = y
		_gridWidth = Clamp( width, 1.0, 512.0 )
		_gridHeight = Clamp( height, 1.0, 512.0 )
	End method
	

	'the virtual command means we are going to use these as a forward reference
	' dont be alarmed if you don't understand what I mean.
	' it will become very clear when we create other controls using this as a base
	' (that is why the page and control classes are sooooo complex)
	
	'a control have a background - if we want it
	method RenderBackground( canvas:Canvas, alpha:float ) Virtual
	End method

	'a foreground - that looks like a simple button,  but we can change this if we want
	' usually most of the drawing will be done here
	' perviously we used _x, _y, _width, _height,  we now use _bx, _by, _bwidth, _bheight
	method RenderForeground( canvas:Canvas, alpha:float ) Virtual
		If _BGColor &lt;&gt; Color.None Then
			canvas.Color = _BGColor
			canvas.DrawRect( _x, _y, _width, _height )
		End If

		canvas.Color = _FGColor
		canvas.DrawRect( _bx, _by, _bwidth, _bheight )
		
		If Not _mouseOver Then Return
		
		canvas.Color = Color.Sky
		If _mouseDown Then
			canvas.Alpha = alpha
		Else
			canvas.Alpha = alpha * 0.75
		End If
		canvas.DrawRect( _bx, _by, _bwidth, _bheight )
	End method

	'and finally a top - which is drawn last
	method RenderTop( canvas:Canvas, alpha:float ) Virtual
	End method
	
	'this calls the individual part which make up a control: back, front and top
	method OnRender( canvas:Canvas, alpha:float ) Virtual
		If Visible Then
'			Print _rect.X+" "+_rect.Right
			canvas.Viewport = _rect
'			canvas.DrawRect(0, 0, 10, 10)
		End If
		
		canvas.Alpha = alpha
		RenderBackground( canvas, alpha )
		
		RenderForeground( canvas, alpha )

		RenderTop( canvas, alpha )
	End method

	'virtual call for proper drawing of text so we can override it later if we want to
	method OnDrawText( canvas:Canvas, x:int, y:int, width:int, height:int, text:string, align:int ) virtual
		If _textBold Then
			DrawTextBold( canvas, x, y, width, height, text, align, _textFont )
		Else
			DrawText( canvas, x, y, width, height, text, align, _textFont )
		End If
	End method

	'more virtual stuff. the mouse routines now have correct mouseX and mouseY transferred
	method OnMouseEnter() virtual
	End method

	method OnMouseLeave() virtual
	End method

	method OnMouseDown( event:MouseEvent, mouseX:int, mouseY:int  ) Virtual
	End method
	
	method OnMouseUp( mouseX:int, mouseY:int ) Virtual
	End method

	method OnMouseMove( mouseX:int, mouseY:int ) Virtual
	End method

	method OnMouseWheel( wheel:int ) Virtual
	End method

	method Initialize() virtual
	End method
	
protected	
	'the variables have been moved from private to protected
	'private vars cant be access from extended classes
	'protected ones can. so we move the private to protected
	
	'is the control shown. is it visible or not
	field _visible:bool = True
	
	'does the control use user input. things like panels are not active don't track the mouse
	field _active:bool = True
	
	'is the mouse over the control
	field _mouseOver:bool = false
	field _mouseDown:bool = false

	'basic layout dimentions
	field _x:float = 0
	field _y:float = 0
	field _x1:float = 0
	field _y1:float = 0
	field _width:float
	field _height:float
	field _midX:float
	field _midY:float
	
	'border vars
	'these are the same as the layout dimentions with a border inset a certain number of pixels
	field _border:float = 2
	field _bx:float
	field _by:float
	field _bx1:float
	field _by1:float
	field _bwidth:float
	field _bheight:float
	
	'grid vars
	field _gridX:float
	field _gridY:float
	field _gridWidth:float
	field _gridHeight:float

	'image vars
	field _BGImage:Image
	field _FGImage:Image

	'color vars
	field _BGColor:Color = Null
	field _FGColor:Color = Color.DarkGrey
	field _imageColor:Color = Color.White
	
	'internal drawing rect
	field _realX:float
	field _realY:float
	field _rect:Recti = new Recti

	'text vars
	field _textColor:Color = Color.White
	field _text:string = ""
	field _textFont:Font = App.DefaultFont
	field _textAlign:int = ALIGN_CENTERED
	field _textBold:bool = false


	method OnRecalcLayout( x:float, y:float, width:float, height:float, gridDivX:float, gridDivY:float )
		_realX = x + ( _gridX * gridDivX )
		_realY = y + ( _gridY * gridDivY )
		_width = _gridWidth * gridDivX
		_height = _gridHeight * gridDivY
		
		RecalcBorder()
	End method
	
	method RecalcBorder()
		_x = 0
		_y = 0
		_x1 = _x + _width
		_y1 = _y + _height

		_midX = (_x + _x1) * 0.5
		_midY = (_y + _y1) * 0.5
		

		_bx = _x + _border
		_by = _y + _border
		_bx1 = _x1 - _border
		_by1 = _y1 - _border
		
		_bwidth = _bx1 - _bx
		_bheight = _by1 - _by
		
		_rect.X = _realX
		_rect.Y = _realY
		_rect.Right = _realX + _width
		_rect.Bottom = _realY + _height
	End method

private
End Class



'OK this is something new. we are going to use our previous UXControl as a base
'and create a proper button from it
'it inherits everything that is public or protected from UXControl
'but we are going to write a new.
class UXButton Extends UXControl
	'if we dont give it any variables - deal with this
	method New( )
		_text = "Button"
	End method

	'we really would like a button the show some text
	'so when we New it lets give it some text
	method New( text:string )
		_text = text
	End method

	'lets draw the text on top of any forground and selection,  down etc
	' as the original is vertual we must override it
	method RenderTop( canvas:Canvas, alpha:float ) Override
		'and now draw some text
		canvas.Color = _textColor
		canvas.Alpha = alpha
		
		'lets make the text drop by 1 pixel when clicked
		'now we are going to use the new drawtext we wrote
		If _mouseDown Then
'			canvas.DrawText( _text, _bx, _by + _border )
			OnDrawText( canvas, _bx, _by + 1, _bwidth, _bheight, _text, ALIGN_CENTERED )
			
		Else
'			canvas.DrawText( _text, _bx, _by )
			OnDrawText( canvas, _bx, _by, _bwidth, _bheight, _text, ALIGN_CENTERED )
		End If
	End method
	
private
End Class


'lets do the same with an image
class UXImageButton Extends UXControl
	'if we dont give it any variables - deal with this
	method New( )
		Initialize()
	End method

	'we really would like a button the show and image
	'so when we New it lets give it one
	method New( image:Image )
		If Not image Then Print "ERROR LOADING IMAGE"
		_image = image
		
		Initialize()
	End method

	'as we have a new image. lets give it a property
	Property Image:Image()
		Return _image
	Setter( image:Image )
		_image = image
	End

	'we dont want to draw the fgbackground rect,  so lets remove it
	method RenderForeground( canvas:Canvas, alpha:float ) Override
		If Not _mouseOver Then Return
	End method

	'lets draw the text on top of any forground and selection,  down etc
	' as the original is vertual we must override it
	method RenderTop( canvas:Canvas, alpha:float ) Override
		'make sure we check the image is valid
		If Not _image Then
			Print "error"
			Return
		End If
		
		'and now draw the image,  with different color if the mouse is over
		If _mouseOver Then
			canvas.Color = Color.Sky
			canvas.Alpha = alpha * 0.8
		Else
			canvas.Color = _imageColor
			canvas.Alpha = alpha * 0.6
		End If
		
		'and drop it when clicked
		Local ypos:int = _by
		If _mouseDown Then
			ypos += _border
		End If

		'this is a new way to draw images. using a rect
		canvas.DrawRect( _bx, ypos, _bwidth, _bheight, _image )
	End method
	
private
	method Initialize() Override
		Border = 0
		Text = "imageButton"
	End method

	field _image:Image
End Class

'and now a color panel
'lets do the same with an image
class UXPanel Extends UXControl
	'if we dont give it any variables - deal with this
	method New( )
		'do any setup the panel might need
		Initialize()
	End method

	'we really would like a button the show and image
	'so when we New it lets give it one
	method New( image:Image )
		If Not image Then Print "ERROR LOADING IMAGE"
		_image = image
		'do any setup the panel might need
		Initialize()
	End method

	'we really would like a button the show and image
	'so when we New it lets give it one
	method New( color:Color )
		FGColor = color
		'do any setup the panel might need
		Initialize()
	End method

	'as we have a new image. lets give it a property
	Property Image:Image()
		Return _image
	Setter( image:Image )
		_image = image
	End

	'we dont want to draw the fgbackground rect,  so lets remove it
	method RenderForeground( canvas:Canvas, alpha:float ) Override
		canvas.Color = FGColor
		canvas.Alpha = alpha
		
		canvas.DrawRect( _bx, _by, _bwidth, _bheight )

		'this is a new way to draw images. using a rect
'		canvas.DrawRect( _bx, ypos, _bwidth, _bheight, _image )
	End method

private
	method Initialize() Override
		Active = false
		Border = 0
		Text = "Panel"
	End method
	
	field _image:Image
End Class


Class MyWindow Extends Window

	Method New()
		Super.New( "My Window", Size.X, Size.Y, WindowFlags.Resizable )
	    
		'if you want a constant canvas size use this
'		Layout = "letterbox"
		'or If you want the canvas to always fill the window use this
		Layout = "fill"

		'this is a timer. it will 'tick' 60 times a second. calling OnUpdate
		_timer = New Timer( 60, OnUpdate )
		
		'initial rndseed
		SeedRnd( 747 )

		_maped = Image.Load( "asset::map.png" ) 'I used a 2000x2000 pixel PNG
		_maped.Handle=New Vec2f( .5, .5 )
	
		'lets now assign these to each chit
		'monkey2 will use internal referenceing systems,  so don't bother about resources
		' we will also deal with the image handle in the chit as well ;)
		Local chitImage1:Image = Image.Load( "asset::chit1.png" )
		Local chitImage2:Image = Image.Load( "asset::chit2.png" )

		Local hexImage2:Image = Image.Load( "asset::hex2.png" )

		'first we need a Page
		' the page MUST have it's layout called when the size of the window changes
		' this is done in OnRender
		Page = new UXPageView( "The page wot I created" )
		'set a grid size 16, 12 seems good. bit is terribly flexible
		Page.SetGrid( 24, 18 )
		' and show the pages grid. try commenting this out
'		Page.ShowGrid = True

		'lets draw a panel
			local panel1:UXPanel = New UXPanel( Color.Brown )
			panel1.SetGridLayout( 0, 15, 24, 3 )
			Page.AddControl( panel1 )
		
		'now we need a button 'it doesn't do anything yet...
		'NEW we have now created a class based on uxcontrol,  so lets use it
			local button1:UXButton = New UXButton( "Rotate" )
			button1.SetGridLayout( 0, 15, 2, 1 )
			button1.FGColor = Color.White
			button1.TextColor = Color.DarkGrey
			button1.TextBold = true
			button1.Border = 5
			button1.Clicked = Lambda()
				Print "Button 1 clicked"
			End
			Page.AddControl( button1 )
		'And another
			local button2:UXButton = New UXButton( "Move" )
			button2.SetGridLayout( 0, 16, 2, 1 )
			button2.FGColor = Color.White
			button2.TextColor = Color.DarkGrey
			button2.TextBold = true
			button2.Border = 5
			button2.Clicked = Lambda()
				Print "Button 2 clicked"
			End
			Page.AddControl( button2 )
		'And another. this time using the old UXControl
			local button3:UXControl = New UXControl()
			button3.SetGridLayout( 0, 17, 2, 1 )
			button3.FGColor = Color.White
			button3.TextColor = Color.DarkGrey
			button3.TextBold = true
			button3.Border = 5
			button3.Clicked = Lambda()
				Print "Button 3 clicked"
			End
			Page.AddControl( button3 )
			
		'And one with an image as a button	
			local button4:UXImageButton = New UXImageButton( hexImage2 )
			button4.SetGridLayout( 2, 5, 2, 2 )
			button4.Clicked = Lambda()
				Print "Button 4 clicked"
			End
			Page.AddControl( button4 )
		
		'just so you feel happy about rotation...
		'0 - shows normal bitmap the right way up points east
		'90 is north, 180 points west, 270 south
		'so. lets assume that chit1 is a ship. to have it point the correct way. the bitmap MUST face EAST!
		
        'provide a PNG and variables for every chit on the map
		_unitManager.AddShip( UNIT_SHIP, PARENT_NONE, chitImage1, 0, 150, 150 )
		_unitManager.AddShip( UNIT_SHIP, PARENT_NONE, chitImage2, 45, -51, -80 )
		
		'And the star
		Local parent:int
		_unitManager.AddPlanet( UNIT_STAR, PARENT_NONE, 60, 0,0, 0 )
		'the addPlanet now returns a parent
		parent = _unitManager.AddPlanet( UNIT_STAR, PARENT_NONE, 20, 0,0, 170, 0.2 )
		'we now feed the parentinto the next addplanet
		
		Local parent2:int
		parent2 = _unitManager.AddPlanet( UNIT_STAR, parent, 10, 0,0, 30, 0.6 )
		_unitManager.AddPlanet( UNIT_STAR, parent2, 5, 0,0, 15, 6 )
		
		_unitManager.AddPlanet( UNIT_STAR, parent, 5, 0,0, 50, -0.7 )
		
		'last we want to set an eye poition the eye goes from 1 (from above),  to 0.1 (from the side)
		' 0.5 is about isometric view
		_unitManager.Eye = 0.25
	End

Protected
	Method OnUpdate()
		_gameTime = Millisecs()
		
		_unitManager.UpdateUnits()
		
		RequestRender()
	End Method
	
	
	Method OnRender( canvas:Canvas ) Override
		'set up a measure that will recalculate if the window is resized
		If _width &lt;&gt; Width or _height &lt;&gt; Height Then
			'The Page Must be laid out
			Page.OnRecalcLayout( 0, 0, Width, Height )
			
			_width = Width
			_height = Height
		End if

		'fill the screen canvas with a color
		canvas.Color = Color.Black
		canvas.DrawRect( 0, 0, Width, Height )

		Select _gameMode
			Case GAMEMODE_INTRO
				DrawTheIntro( canvas )
			Case GAMEMODE_GAME
				DrawTheGame( canvas )
		End Select
	End


	method DrawMap( canvas:Canvas, midX:float, midY:float )
		'draw the mapimage
		canvas.Alpha = 1
		canvas.Color = Color.Grey
		canvas.DrawImage( _maped, midX, midY, 0, _scale, _scale )
		
'		DrawCircleDash( canvas, midX, midY, 100 * _scale )
		
		'draw the 100 lines (100 spatial positions)
		Local k:float
		Local sc:float
		canvas.Color = Color.DarkGrey
		canvas.Alpha = 0.3
		Local xoffset:float = midX Mod (100 * _scale)
		Local yoffset:float = midY Mod (100 * _scale)
		For k = xoffset To Width Step (100 * _scale)
			canvas.DrawLine( k,  0, k, Height )
		Next
		For k = yoffset To Height Step (100 * _scale * _unitManager.Eye)
			canvas.DrawLine( 0, k, Width, k )
		Next
		
		'draw the center of the map lines
		canvas.Color = Color.Grey
		canvas.DrawLine( midX, 0, midX, Height )
		canvas.DrawLine( 0, midY, Width, midY )
	End method
	
	
	method DrawUI( canvas:Canvas )
		'draw the page. currently this is just showing the page grid
		Page.OnRender( canvas )
	End method
	
	
	Method DrawTheGame( canvas:Canvas )
		'find the midpoint from where all drawing is based
		Local midX:float = (Width * 0.5) + _mX
		Local midY:float = (Height * 0.5) + _mY
		
		
		'draw the map in a seperate method
		DrawMap( canvas, midX, midY )
		
        'lets move these into the unit class
		canvas.Color = Color.White
		canvas.Alpha = 1
		
'		canvas.DrawText( midX+" "+midY+"  "+(_mouseX-midX)+" "+(_mouseY-midY), 10, 10 )

		'we now have a unitmanager to handle all the units,  so just one call to it's draw routine
		' will allow it to do the rest
		_unitManager.DrawUnits( canvas, _mouseX, _mouseY, midX, midY, _scale )
		
		DrawUI( canvas )
	End Method
	
	
	Method DrawTheIntro( canvas:Canvas )
		canvas.Color = Color.White
	
		canvas.DrawText( " Scroller Map' First App By Mark Ainsworth ref 210665",200,20 )
		canvas.DrawText( " How To Scroll The Map Right Click To Pickup Board, Then Drag it Release to Drop it. ",200,60 )
		canvas.DrawText( " You can Move around the Map By Only RightClicking and Dragging.",200,80 )
		canvas.DrawText("- PRESS ENTER OR LRFT-CLICK MOUSE TO START MAP --&gt;",200,670)
		
	End Method

	
	'respond to any key presses
	Method OnKeyEvent( event:KeyEvent ) Override
		'send key stuff to the new page controls and exit if handled
		if Page.OnKeyEvent( event ) then return
		
		'heres the best way to check for shift keys etc
		Local command:Bool = event.Modifiers &amp; Modifier.Gui
		Local shift:Bool = event.Modifiers &amp; Modifier.Shift
		Local alt:bool = event.Modifiers &amp; Modifier.Alt
		
		Select event.Type
			case EventType.KeyDown
			
				Select event.Key
					Case Key.Enter
						Select _gameMode
							Case GAMEMODE_INTRO
								_gameMode = GAMEMODE_GAME
						End Select
							
				End Select
				
			Case EventType.KeyUp
			
				Select event.Key
					Case Key.Enter
				End Select
				
		End Select
	End

	'here we track the mouse and all mouse related stuff
	Method OnMouseEvent( event:MouseEvent ) Override
		'send mouse stuff to the new page controls. and exit if handled
		if Page.OnMouseEvent( event ) Then return
		
		'set up some global mouse vars so we can use these throught to program
		_mouseX = event.Location.X
		_mouseY = event.Location.Y

		'put a check to see if the mouse button is still pressed
		if Not Mouse.ButtonDown( MouseButton.Left ) Then
			_movemap = 0
		End If


		'here are the baci mouse events we are interested in
		Select event.Type
			Case EventType.MouseClick
				Select _gameMode
					Case GAMEMODE_INTRO
						_gameMode = GAMEMODE_GAME
						
					Case GAMEMODE_GAME
						_movemap = 1
						If _movemap = 1 'if you left click record current mouse location
							_oldX = _mX + -_mouseX 'plus map location
							_oldY = _mY + -_mouseY
						Endif
				End Select	
				
			Case EventType.MouseUp
				_movemap = 0 'if you move the mouse while dragging
				If _movemap = 0 'the map x,y is updated untill you Mouseup
					_oldX = _mX 
					_oldY = _mY 
				Endif
			Case EventType.MouseEnter
			Case EventType.MouseLeave
			case EventType.MouseWheel
				If event.Wheel.Y &lt;&gt; 0 Then
				
					'macs use inverted scroll wheels, so lets make it mac friendly
#If __TARGET__="macos"
					_scale = Clamp( _scale - event.Wheel.Y * 0.01, 0.25, 4.0 )
#else
					_scale = Clamp( _scale + event.Wheel.Y * 0.01, 0.25, 4.0 )
#end				
				End If
			Case EventType.MouseMove
				If _movemap = 1
					_mX = _mouseX + _oldX - 0
					_mY = _mouseY + _oldY - 0
				Endif
		End Select
		
	End Method
	
	'this is needed to allow the Size to be correct. this is called automatically
	Method OnMeasure:Vec2i() Override
		Return Size
	End
Private
	'the timer ticks 60 times a second and handles the screen update
	Field _timer:Timer
	
	'what mode is the game in, showing the intro, playing, ended, etc
	Field _gameMode:Int = GAMEMODE_GAME'INTRO
	
	'global mouse vars
	Field _mouseX:Int
	Field _mouseY:Int
	
	field _scale:float = 1

	'global window size to track when window has changed
	field _width:int = 0
	field _height:int = 0
	
	'and some control buttons
	field _myButton:UXControl

	'map location vars
	Field _mY:Int = 0
	Field _mX:Int = 0
	Field _oldX:Int 'used to store map location before you drag
	Field _oldY:Int 'used to store map location before you drag
	Field _movemap:Int 'switch to on to dragmap in conjuction with old position

	'image assets
	Field _maped:Image ' this is the map png ' lets say the center is 0, 0

	'set up some classes' these will need to be newed
	field _unitManager:UnitManager =  New UnitManager()

	'set up the page to hold our controls
	field Page:UXPageView
	'UI image and stuff
'	field _imageHex1:Image
'	field _imageHex2:Image
End

</textarea> <br><br></td></tr></table><br>
<a name="1339663"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#148">[#148]</a></td></tr></table></td></tr><tr ><td class="posttext"> working on modularising the planets into a single galaxy.<br>galaxy has solarsytems (up to 255)<br>solar systems have planets (up to 16)<br><br>My thought here is that each solar system will have a mission tree. <br>You can do the missions or not, just trade, fight, or whatever. &lt;- this will be the same as the missions in rogue 3<br><br>But. I thought that missions could be completed in batches.<br>say there were 12 missions. grouped in 4 (which gives 3)<br>only the first set of missions were available. the next set would not by unlocked until you have completed all the first 4.<br><br>One a sub set of missions are complete you would get something - don't know what? upgrade, points, gold, unlock new system??? <br><br></td></tr></table><br>
<a name="1339664"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#149">[#149]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok, here's a pic<br><img src="https://vjointeractive.files.wordpress.com/2017/04/screen-shot-2017-04-26-at-15-01-26.png"><br><br>This shows the new galaxy map with 3 solar systems. I think it would be nice to show the current system at the bottom using the new planet drawing code? <br><br></td></tr></table><br>
<a name="1339665"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#150">[#150]</a></td></tr></table></td></tr><tr ><td class="posttext"> mmmmmm. thoughts<br><br>Lets assume that each solar system can accept/trade a number of base things<br><br>to keep it simple lets keep these to a small amount<br><br>we could list the available 'things' in a list on the top right going down.<br>select the thing you are interested in and the systems that match will be highlighted on the map<br><br>on the right we could list factions/alliences. again keep this simple and small.<br>so you could be aligned to a certain faction/alience and get more favourable results.<br>factions could then have desires, which might lead to conflict with other factions... etc <br><br></td></tr></table><br>
<a name="1339666"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#151">[#151]</a></td></tr></table></td></tr><tr ><td class="posttext"> Do not forget to add taxes... So exporting and importing costs a bit. There might wven be taxes for "cross solar system trade". And these taxes change according wbo leads a galaxy ("secures" it). Imho this is who owns the most planets in that system.<br><br><br>This allows to "smuggle* ...means to not pay exports/imports with the danger of getting stopped by a ship of the "leader" who then attack you / seize goods ...<br><br><br>Taxes bring in some economical strategy... To whom you export to (they know you then and chances for checks of your cargo lower a bit) also knowing about wars between leaders allow to predict ownership changes and therefor changes in taxes and prices of goods.<br><br><br><br>Bye<br>Ron <br><br></td></tr></table><br>
<a name="1339673"></a>

<a name="1339674"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#152">[#152]</a></td></tr></table></td></tr><tr ><td class="posttext"> Ok I'm following along, I will be interested in how you move a Unit around. <br><br>I thought a goal for the player could be cyborg implants as a reward , to allow longer life or more abilities :)<br><br>Derron Tax &amp; smuggling tax avoidance is great idea <br><br></td></tr></table><br>
<a name="1339702"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#153">[#153]</a></td></tr></table></td></tr><tr ><td class="posttext"> yep smuggling and taxes is a great concept <br><br></td></tr></table><br>
<a name="1339705"></a>

<a name="1339706"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#154">[#154]</a></td></tr></table></td></tr><tr ><td class="posttext"> <img src="https://img.itch.zone/aW1hZ2UvOTI5NDYvNjM3NzY0LnBuZw==/original/uzxOkK.png"><br><br>I'm making tons of mistakes, but the compiler is the best Ive ever used, very good at spotting errors and telling you what they are,<br><br>I tried making a few classes that messedup, tried feeding events into classes messed up, tried to setup arrays of chits but ended up with a big list of chits, that unitmanager sure looks good now, I thought that having to enter every image name, I would not need a unitmanager, but forgot I could have copies.<br><br>Here is my crapy code so far, but it works and some elements may be of use, just remember I'm still at noob at this<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Namespace myApp

#Import "&lt;std&gt;"
#Import "&lt;mojo&gt;"

Using std..
Using mojo..

#Import "assets/map.png"
#Import "assets/chit1.png"
#Import "assets/chit2.png"
#Import "assets/chit3.png"
#Import "assets/chit4.png"
#Import "assets/chit5.png"
#Import "assets/chit6.png"
#Import "assets/chit7.png"
#Import "assets/chit8.png"
#Import "assets/chit9.png"
#Import "assets/chit10.png"

#Import "assets/chit11.png"
#Import "assets/chit12.png"
#Import "assets/chit13.png"
#Import "assets/chit14.png"
#Import "assets/chit15.png"
#Import "assets/chit16.png"
#Import "assets/chit17.png"
#Import "assets/chit18.png"
#Import "assets/chit19.png"
#Import "assets/chit20.png"

#Import "assets/chit21.png"
#Import "assets/chit22.png"
#Import "assets/chit23.png"
#Import "assets/chit24.png"
#Import "assets/chit25.png"
#Import "assets/chit26.png"
#Import "assets/chit27.png"
#Import "assets/chit28.png"
#Import "assets/chit29.png"
#Import "assets/chit30.png"

#Import "assets/chit31.png"
#Import "assets/chit32.png"
#Import "assets/chit33.png"
#Import "assets/chit34.png"
#Import "assets/chit35.png"
#Import "assets/chit36.png"
#Import "assets/chit37.png"
#Import "assets/chit38.png"
#Import "assets/chit39.png"
#Import "assets/chit40.png"

#Import "assets/chit41.png"
#Import "assets/chit42.png"
#Import "assets/chit43.png"
#Import "assets/chit44.png"
#Import "assets/chit45.png"
#Import "assets/chit46.png"
#Import "assets/chit47.png"
#Import "assets/chit48.png"
#Import "assets/chit49.png"
#Import "assets/chit50.png"

#Import "assets/chit51.png"
#Import "assets/chit52.png"
#Import "assets/chit53.png"
#Import "assets/chit54.png"
#Import "assets/chit55.png"
#Import "assets/chit56.png"
#Import "assets/chit57.png"
#Import "assets/chit58.png"
#Import "assets/chit59.png"
#Import "assets/chit60.png"

#Import "assets/chit61.png"
#Import "assets/chit62.png"
#Import "assets/chit63.png"
#Import "assets/chit64.png"
#Import "assets/chit65.png"
#Import "assets/chit66.png"
#Import "assets/chit67.png"
#Import "assets/chit68.png"
#Import "assets/chit69.png"
#Import "assets/chit70.png"

#Import "assets/chit71.png"
#Import "assets/chit72.png"
#Import "assets/chit73.png"
#Import "assets/chit74.png"
#Import "assets/chit75.png"
#Import "assets/chit76.png"
#Import "assets/chit77.png"
#Import "assets/chit78.png"
#Import "assets/chit79.png"
#Import "assets/chit80.png"

#Import "assets/chit81.png"
#Import "assets/chit82.png"
#Import "assets/chit83.png"
#Import "assets/chit84.png"
#Import "assets/chit85.png"
#Import "assets/chit86.png"
#Import "assets/chit87.png"
#Import "assets/chit88.png"
#Import "assets/chit89.png"
#Import "assets/chit90.png"

#Import "assets/chit91.png"
#Import "assets/chit92.png"
#Import "assets/chit93.png"
#Import "assets/chit94.png"
#Import "assets/chit95.png"
#Import "assets/chit96.png"
#Import "assets/chit97.png"
#Import "assets/chit98.png"
#Import "assets/chit99.png"
#Import "assets/chit100.png"
'#Import "assets/dashed.png"
Const Size := New Vec2i( 950,720 )

Const GAME_INTRO:Int = 1
Const GAME_GAME:int = 2
Global unitnumb:Int = -1
Global moveit:Int = -1
Function Main()
	New AppInstance
	
	New MyWindow
	
	App.Run()
End

Class Cargos
    Method New()
	End Method	
	
	
	
	Method trades(canvas:Canvas,Un:Int,Yoff:Int,Xoff:Int,n1:int,n2:int,n3:int,n4:int,n5:int,n6:int,n7:int,n8:int,n9:int,n10:int )
	    
	   
		
	    _yoff = Xoff
		_xoff = Yoff
		
		_numb1 = n1
		_numb2 = n2
		_numb3 = n3
		_numb4 = n4
		_numb5 = n5
		_numb6 = n6
		_numb7 = n7
		_numb8 = n8
		_numb9 = n9
		_numb10 = n10
		
		unitnumb = Un
		
		canvas.Color = Color.DarkGrey
	    canvas.DrawRect(450+_xoff,575,250,130)
	    
	    canvas.Color = Color.Red
	    canvas.DrawRect(470+_xoff,585+_yoff,30,18)
	    canvas.DrawRect(470+_xoff,605+_yoff,30,18)
	    canvas.DrawRect(470+_xoff,625+_yoff,30,18)
	    canvas.DrawRect(470+_xoff,645+_yoff,30,18)
	    canvas.DrawRect(470+_xoff,665+_yoff,30,18)
	    
	    canvas.Color = Color.Blue
	    canvas.DrawRect(500+_xoff,585+_yoff,30,18)
	    canvas.DrawRect(500+_xoff,605+_yoff,30,18)
	    canvas.DrawRect(500+_xoff,625+_yoff,30,18)
	    canvas.DrawRect(500+_xoff,645+_yoff,30,18)
	    canvas.DrawRect(500+_xoff,665+_yoff,30,18)
	    
	    canvas.Color = Color.White
		If unitnumb &gt; 0 Then canvas.DrawText( "&lt; - / + &gt;  = "+ _numb1,470+_xoff,585+_yoff)
		If unitnumb &gt; 0 Then canvas.DrawText( "&lt; - / + &gt;  = "+ _numb2,470+_xoff,605+_yoff)
		If unitnumb &gt; 0 Then canvas.DrawText( "&lt; - / + &gt;  = "+ _numb3,470+_xoff,625+_yoff)
	    If unitnumb &gt; 0 Then canvas.DrawText( "&lt; - / + &gt;  = "+ _numb4,470+_xoff,645+_yoff)
		If unitnumb &gt; 0 Then canvas.DrawText( "&lt; - / + &gt;  = "+ _numb5,470+_xoff,665+_yoff)

        _xoff = _xoff - 300
        
        canvas.Color = Color.DarkGrey
	    canvas.DrawRect(450+_xoff,575+_yoff,250,130)
	    
	    canvas.Color = Color.Red
	    canvas.DrawRect(470+_xoff,585+_yoff,30,18)
	    canvas.DrawRect(470+_xoff,605+_yoff,30,18)
	    canvas.DrawRect(470+_xoff,625+_yoff,30,18)
	    canvas.DrawRect(470+_xoff,645+_yoff,30,18)
	    canvas.DrawRect(470+_xoff,665+_yoff,30,18)
	    
	    canvas.Color = Color.Blue
	    canvas.DrawRect(500+_xoff,585+_yoff,30,18)
	    canvas.DrawRect(500+_xoff,605+_yoff,30,18)
	    canvas.DrawRect(500+_xoff,625+_yoff,30,18)
	    canvas.DrawRect(500+_xoff,645+_yoff,30,18)
	    canvas.DrawRect(500+_xoff,665+_yoff,30,18)
	    
	    canvas.Color = Color.White
		If unitnumb &gt; 0 Then canvas.DrawText( "&lt; - / + &gt;  = "+ _numb6,470+_xoff,585+_yoff)
		If unitnumb &gt; 0 Then canvas.DrawText( "&lt; - / + &gt;  = "+ _numb7,470+_xoff,605+_yoff)
		If unitnumb &gt; 0 Then canvas.DrawText( "&lt; - / + &gt;  = "+ _numb8,470+_xoff,625+_yoff)
	    If unitnumb &gt; 0 Then canvas.DrawText( "&lt; - / + &gt;  = "+ _numb9,470+_xoff,645+_yoff)
		If unitnumb &gt; 0 Then canvas.DrawText( "&lt; - / + &gt;  = "+ _numb10,470+_xoff,665+_yoff)
        
        
          
        
        End Method
        
        
        
				
				
      
        

	
	Field _xoff:Int = 0
	Field _yoff:Int = 0
    Field _numb1:Int = 0
	Field _numb2:Int = 0
	Field _numb3:Int = 0
	Field _numb4:Int = 0
	Field _numb5:Int = 0
	Field _numb6:Int = 0
	Field _numb7:Int = 0
	Field _numb8:Int = 0
	Field _numb9:Int = 0
	Field _numb10:Int = 0
	Field _mouseX:Int
	Field _mouseY:Int
Private
	

	
End Class


'this will be the base class for all chits, anything can be a chit
Class Chit
	'this is called when any new thing is derrived from this class
	Method New()
	End Method

	
	'we can now have a different new which can be fed with an int which becomes the energy
	' so New(67) would give you a Chit with 67 rotation
	Method New( twist:Int,chx:Int,chy:int,id:int, anImage:Image, big:Int,type:Int,n1:int,n2:int,n3:int,n4:int,n5:int,n6:int,n7:int,n8:int,n9:int,n10:int )
		_id = id
		_twist = twist *  (Pi / 180)
		_chitx = chx 'just a var to initialise starting posision of chit
		_chity = chy 
		_big = big
		_type = type
		_numb1 = n1
		_numb2 = n2
		_numb3 = n3
		_numb4 = n4
		_numb5 = n5
		_numb6 = n6
		_numb7 = n7
		_numb8 = n8
		_numb9 = n9
		_numb10 = n10
		
		
		
		_chitimage = anImage
		_chitimage.Handle = New Vec2f( .5,.5 )
	End Method


	'because _twist is private,  we need a property and setter
	' we only then need to access by _chit[_number].Twist = 40,  or twist = _chit[_number].Twist
	'Property Twist:int()
	'	Return _twist
	'Setter( twist:int )
	'	_twist = twist
	'End
	Field _numb1:Int = 0
	Field _numb2:Int = 0
	Field _numb3:Int = 0
	Field _numb4:Int = 0
	Field _numb5:Int = 0
	Field _numb6:Int = 0
	Field _numb7:Int = 0
	Field _numb8:Int = 0
	Field _numb9:Int = 0
	Field _numb10:Int = 0
	
	
    Field _chitx:int = 600
	Field _chity:int = 600
	Field _twist:int = 0
	Field _id:Int = 0
	Field _big:float = 1
	Field _light:Int = 1
	Field _type:int = 0
	Field _chitimage:Image

Private
	'how much rotation does the chit start with 0  but we could change this with a different New
	'Field _twist:int = 0
	

	
End Class


Class MyWindow Extends Window

	Method New()
		'Super.New( "My Window", Size.X, Size.Y, WindowFlags.Resizable )
	    Super.New( "My Window", Size.X, Size.Y, WindowFlags.Center )
		'if you want a constant canvas size use this
'		Layout = "letterbox"
		'or If you want the canvas to always fill the window use this
		Layout = "fill"

		'this is a timer. it will 'tick' 60 times a second. calling OnUpdate
		_timer = New Timer( 60, OnUpdate )
		_maped = Image.Load( "asset::map.png" ) 'I used a 2000x2000 pixel PNG
	
		_unit1 = Image.Load( "asset::chit1.png" ) 'I used a 50x50 pixel PNG
		'_unit1.Handle=New Vec2f( .5,.5 )
		_unit2 = Image.Load( "asset::chit2.png" ) 'I used a 50x50 pixel PNG
		'_unit2.Handle=New Vec2f( .5,.5 )
		_unit3 = Image.Load( "asset::chit3.png" ) 'I used a 50x50 pixel PNG
		'_unit3.Handle=New Vec2f( .5,.5 )
		_unit4 = Image.Load( "asset::chit4.png" ) 'I used a 50x50 pixel PNG
		'_unit4.Handle=New Vec2f( .5,.5 )
		_unit5 = Image.Load( "asset::chit5.png" ) 'I used a 50x50 pixel PNG
		'_unit5.Handle=New Vec2f( .5,.5 )
		_unit6 = Image.Load( "asset::chit6.png" ) 'I used a 50x50 pixel PNG
		'_unit6.Handle=New Vec2f( .5,.5 )
		_unit7 = Image.Load( "asset::chit7.png" ) 'I used a 50x50 pixel PNG
		'_unit7.Handle=New Vec2f( .5,.5 )
		_unit8 = Image.Load( "asset::chit8.png" ) 'I used a 50x50 pixel PNG
		'_unit8.Handle=New Vec2f( .5,.5 )
				'dashy = Image.Load( "asset::dashed.png" ) 'I used a 2000x2000 pixel PNG

	_unit9 = Image.Load( "asset::chit9.png" ) 'I used a 50x50 pixel PNG
	_unit10 = Image.Load( "asset::chit10.png" ) 'I used a 50x50 pixel PNG
	
	_unit11 = Image.Load( "asset::chit11.png" ) 'I used a 50x50 pixel PNG
	_unit12 = Image.Load( "asset::chit12.png" ) 'I used a 50x50 pixel PNG
	_unit13 = Image.Load( "asset::chit13.png" ) 'I used a 50x50 pixel PNG	
	_unit14 = Image.Load( "asset::chit14.png" ) 'I used a 50x50 pixel PNG
	_unit15 = Image.Load( "asset::chit15.png" ) 'I used a 50x50 pixel PNG
	_unit16= Image.Load( "asset::chit16.png" ) 'I used a 50x50 pixel PNG
	_unit17 = Image.Load( "asset::chit17.png" ) 'I used a 50x50 pixel PNG
	_unit18 = Image.Load( "asset::chit18.png" ) 'I used a 50x50 pixel PNG
	_unit19 = Image.Load( "asset::chit19.png" ) 'I used a 50x50 pixel PNG
	_unit20 = Image.Load( "asset::chit20.png" ) 'I used a 50x50 pixel PNG
	
		_unit21 = Image.Load( "asset::chit21.png" ) 'I used a 50x50 pixel PNG
	_unit22 = Image.Load( "asset::chit22.png" ) 'I used a 50x50 pixel PNG
	_unit23 = Image.Load( "asset::chit23.png" ) 'I used a 50x50 pixel PNG	
	_unit24 = Image.Load( "asset::chit24.png" ) 'I used a 50x50 pixel PNG
	_unit25 = Image.Load( "asset::chit25.png" ) 'I used a 50x50 pixel PNG
	_unit26= Image.Load( "asset::chit26.png" ) 'I used a 50x50 pixel PNG
	_unit27 = Image.Load( "asset::chit27.png" ) 'I used a 50x50 pixel PNG
	_unit28 = Image.Load( "asset::chit28.png" ) 'I used a 50x50 pixel PNG
	_unit29 = Image.Load( "asset::chit29.png" ) 'I used a 50x50 pixel PNG
	_unit30 = Image.Load( "asset::chit30.png" ) 'I used a 50x50 pixel PNG
	
		_unit31 = Image.Load( "asset::chit31.png" ) 'I used a 50x50 pixel PNG
	_unit32 = Image.Load( "asset::chit32.png" ) 'I used a 50x50 pixel PNG
	_unit33 = Image.Load( "asset::chit33.png" ) 'I used a 50x50 pixel PNG	
	_unit34 = Image.Load( "asset::chit34.png" ) 'I used a 50x50 pixel PNG
	_unit35 = Image.Load( "asset::chit35.png" ) 'I used a 50x50 pixel PNG
	_unit36= Image.Load( "asset::chit36.png" ) 'I used a 50x50 pixel PNG
	_unit37 = Image.Load( "asset::chit37.png" ) 'I used a 50x50 pixel PNG
	_unit38 = Image.Load( "asset::chit38.png" ) 'I used a 50x50 pixel PNG
	_unit39 = Image.Load( "asset::chit39.png" ) 'I used a 50x50 pixel PNG
	_unit40 = Image.Load( "asset::chit40.png" ) 'I used a 50x50 pixel PNG
	
		_unit41 = Image.Load( "asset::chit41.png" ) 'I used a 50x50 pixel PNG
	_unit42 = Image.Load( "asset::chit42.png" ) 'I used a 50x50 pixel PNG
	_unit43 = Image.Load( "asset::chit43.png" ) 'I used a 50x50 pixel PNG	
	_unit44 = Image.Load( "asset::chit44.png" ) 'I used a 50x50 pixel PNG
	_unit45 = Image.Load( "asset::chit45.png" ) 'I used a 50x50 pixel PNG
	_unit46= Image.Load( "asset::chit46.png" ) 'I used a 50x50 pixel PNG
	_unit47 = Image.Load( "asset::chit47.png" ) 'I used a 50x50 pixel PNG
	_unit48 = Image.Load( "asset::chit48.png" ) 'I used a 50x50 pixel PNG
	_unit49 = Image.Load( "asset::chit49.png" ) 'I used a 50x50 pixel PNG
	_unit50 = Image.Load( "asset::chit50.png" ) 'I used a 50x50 pixel PNG
	
		_unit51 = Image.Load( "asset::chit51.png" ) 'I used a 50x50 pixel PNG
	_unit52 = Image.Load( "asset::chit52.png" ) 'I used a 50x50 pixel PNG
	_unit53 = Image.Load( "asset::chit53.png" ) 'I used a 50x50 pixel PNG	
	_unit54 = Image.Load( "asset::chit54.png" ) 'I used a 50x50 pixel PNG
	_unit55 = Image.Load( "asset::chit55.png" ) 'I used a 50x50 pixel PNG
	_unit56= Image.Load( "asset::chit56.png" ) 'I used a 50x50 pixel PNG
	_unit57 = Image.Load( "asset::chit57.png" ) 'I used a 50x50 pixel PNG
	_unit58 = Image.Load( "asset::chit58.png" ) 'I used a 50x50 pixel PNG
	_unit59 = Image.Load( "asset::chit59.png" ) 'I used a 50x50 pixel PNG
	_unit60 = Image.Load( "asset::chit60.png" ) 'I used a 50x50 pixel PNG
	
	
		_unit61 = Image.Load( "asset::chit61.png" ) 'I used a 60x60 pixel PNG
	_unit62 = Image.Load( "asset::chit62.png" ) 'I used a 60x60 pixel PNG
	_unit63 = Image.Load( "asset::chit63.png" ) 'I used a 60x60 pixel PNG	
	_unit64 = Image.Load( "asset::chit64.png" ) 'I used a 60x60 pixel PNG
	_unit65 = Image.Load( "asset::chit65.png" ) 'I used a 60x60 pixel PNG
	_unit66= Image.Load( "asset::chit66.png" ) 'I used a 60x60 pixel PNG
	_unit67 = Image.Load( "asset::chit67.png" ) 'I used a 60x60 pixel PNG
	_unit68 = Image.Load( "asset::chit68.png" ) 'I used a 60x60 pixel PNG
	_unit69 = Image.Load( "asset::chit69.png" ) 'I used a 60x60 pixel PNG
	_unit70 = Image.Load( "asset::chit70.png" ) 'I used a 60x60 pixel PNG
	
		_unit71 = Image.Load( "asset::chit71.png" ) 'I used a 70x70 pixel PNG
	_unit72 = Image.Load( "asset::chit72.png" ) 'I used a 70x70 pixel PNG
	_unit73 = Image.Load( "asset::chit73.png" ) 'I used a 70x70 pixel PNG	
	_unit74 = Image.Load( "asset::chit74.png" ) 'I used a 70x70 pixel PNG
	_unit75 = Image.Load( "asset::chit75.png" ) 'I used a 70x70 pixel PNG
	_unit76= Image.Load( "asset::chit76.png" ) 'I used a 70x70 pixel PNG
	_unit77 = Image.Load( "asset::chit77.png" ) 'I used a 70x70 pixel PNG
	_unit78 = Image.Load( "asset::chit78.png" ) 'I used a 70x70 pixel PNG
	_unit79 = Image.Load( "asset::chit79.png" ) 'I used a 70x70 pixel PNG
	_unit80 = Image.Load( "asset::chit80.png" ) 'I used a 70x70 pixel PNG
	
		_unit81 = Image.Load( "asset::chit81.png" ) 'I used a 80x80 pixel PNG
	_unit82 = Image.Load( "asset::chit82.png" ) 'I used a 80x80 pixel PNG
	_unit83 = Image.Load( "asset::chit83.png" ) 'I used a 80x80 pixel PNG	
	_unit84 = Image.Load( "asset::chit84.png" ) 'I used a 80x80 pixel PNG
	_unit85 = Image.Load( "asset::chit85.png" ) 'I used a 80x80 pixel PNG
	_unit86= Image.Load( "asset::chit86.png" ) 'I used a 80x80 pixel PNG
	_unit87 = Image.Load( "asset::chit87.png" ) 'I used a 80x80 pixel PNG
	_unit88 = Image.Load( "asset::chit88.png" ) 'I used a 80x80 pixel PNG
	_unit89 = Image.Load( "asset::chit89.png" ) 'I used a 80x80 pixel PNG
	_unit90 = Image.Load( "asset::chit90.png" ) 'I used a 80x80 pixel PNG
	
		_unit91 = Image.Load( "asset::chit91.png" ) 'I used a 90x90 pixel PNG
	_unit92 = Image.Load( "asset::chit92.png" ) 'I used a 90x90 pixel PNG
	_unit93 = Image.Load( "asset::chit93.png" ) 'I used a 90x90 pixel PNG	
	_unit94 = Image.Load( "asset::chit94.png" ) 'I used a 90x90 pixel PNG
	_unit95 = Image.Load( "asset::chit95.png" ) 'I used a 90x90 pixel PNG
	_unit96= Image.Load( "asset::chit96.png" ) 'I used a 90x90 pixel PNG
	_unit97 = Image.Load( "asset::chit97.png" ) 'I used a 90x90 pixel PNG
	_unit98 = Image.Load( "asset::chit98.png" ) 'I used a 90x90 pixel PNG
	_unit99 = Image.Load( "asset::chit99.png" ) 'I used a 90x90 pixel PNG
	_unit100 = Image.Load( "asset::chit100.png" ) 'I used a 90x90 pixel PNG
		
        'provide a PNG and variables for every chit on the map
		_chit[1] = New Chit(0,650,650,1,_unit1,25,1,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[2] = New Chit(68,701,780,2,_unit2,25,2,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[3] = New Chit(0,600,650,3,_unit3,25,30,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[4] = New Chit(68,701,760,4,_unit4,25,4,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[5] = New Chit(0,650,630,5,_unit5,25,50,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[6] = New Chit(68,721,780,6,_unit6,25,6,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[7] = New Chit(0,680,650,7,_unit7,25,70,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[8] = New Chit(68,601,780,8,_unit8,25,8,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[9] = New Chit(0,-7000,-7000,9,_unit9,25,90,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[10] = New Chit(68,-7000,-7000,10,_unit10,25,10,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500

		_chit[11] = New Chit(0,-7000,-7000,11,_unit11,25,110,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[12] = New Chit(68,-7000,-7000,12,_unit12,25,12,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[13] = New Chit(0,-7000,-7000,13,_unit13,25,130,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[14] = New Chit(68,-7000,-7000,14,_unit14,25,14,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[15] = New Chit(0,-7000,-7000,15,_unit15,25,150,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[16] = New Chit(68,-7000,-7000,16,_unit16,25,16,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[17] = New Chit(0,-7000,-7000,17,_unit17,25,170,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[18] = New Chit(68,-7000,-7000,18,_unit18,25,18,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[19] = New Chit(0,-7000,-7000,19,_unit19,25,190,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[20] = New Chit(68,-7000,-7000,20,_unit20,25,20,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
	
	
    	_chit[21] = New Chit(0,-7000,-7000,21,_unit21,25,210,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[22] = New Chit(68,-7000,-7000,22,_unit22,25,22,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[23] = New Chit(0,-7000,-7000,23,_unit23,25,230,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[24] = New Chit(68,-7000,-7000,24,_unit24,25,24,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[25] = New Chit(0,-7000,-7000,25,_unit25,25,250,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[26] = New Chit(68,-7000,-7000,26,_unit26,25,26,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[27] = New Chit(0,-7000,-7000,27,_unit27,25,270,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[28] = New Chit(68,-7000,-7000,28,_unit28,25,28,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[29] = New Chit(0,-7000,-7000,29,_unit29,25,290,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[30] = New Chit(68,-7000,-7000,30,_unit30,25,30,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		
		_chit[31] = New Chit(0,-7000,-7000,31,_unit31,25,310,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[32] = New Chit(68,-7000,-7000,32,_unit32,25,32,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[33] = New Chit(0,-7000,-7000,33,_unit33,25,330,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[34] = New Chit(68,-7000,-7000,34,_unit34,25,34,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[35] = New Chit(0,-7000,-7000,35,_unit35,25,350,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[36] = New Chit(68,-7000,-7000,36,_unit36,25,36,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[37] = New Chit(0,-7000,-7000,37,_unit37,25,370,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[38] = New Chit(68,-7000,-7000,38,_unit38,25,38,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[39] = New Chit(0,-7000,-7000,39,_unit39,25,390,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[40] = New Chit(68,-7000,-7000,40,_unit40,25,40,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		
		_chit[41] = New Chit(0,-7000,-7000,41,_unit41,25,410,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[42] = New Chit(68,-7000,-7000,42,_unit42,25,42,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[43] = New Chit(0,-7000,-7000,43,_unit43,25,430,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[44] = New Chit(68,-7000,-7000,44,_unit44,25,44,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[45] = New Chit(0,-7000,-7000,45,_unit45,25,450,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[46] = New Chit(68,-7000,-7000,46,_unit46,25,46,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[47] = New Chit(0,-7000,-7000,47,_unit47,25,470,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[48] = New Chit(68,-7000,-7000,48,_unit48,25,48,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[49] = New Chit(0,-7000,-7000,49,_unit49,25,490,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[50] = New Chit(68,-7000,-7000,50,_unit50,25,50,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		
		_chit[51] = New Chit(0,-7000,-7000,51,_unit51,25,510,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[52] = New Chit(68,-7000,-7000,52,_unit52,25,52,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[53] = New Chit(0,-7000,-7000,53,_unit53,25,530,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[54] = New Chit(68,-7000,-7000,54,_unit54,25,54,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[55] = New Chit(0,-7000,-7000,55,_unit55,25,550,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[56] = New Chit(68,-7000,-7000,56,_unit56,25,56,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[57] = New Chit(0,-7000,-7000,57,_unit57,25,570,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[58] = New Chit(68,-7000,-7000,58,_unit58,25,58,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[59] = New Chit(0,-7000,-7000,59,_unit59,25,590,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[60] = New Chit(68,-7000,-7000,60,_unit60,25,60,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
	
	
		_chit[61] = New Chit(0,-7000,-7000,61,_unit61,25,610,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[62] = New Chit(68,-7000,-7000,62,_unit62,25,62,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[63] = New Chit(0,-7000,-7000,63,_unit63,25,630,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[64] = New Chit(68,-7000,-7000,64,_unit64,25,64,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[65] = New Chit(0,-7000,-7000,65,_unit65,25,650,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[66] = New Chit(68,-7000,-7000,66,_unit66,25,66,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[67] = New Chit(0,-7000,-7000,67,_unit67,25,670,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[68] = New Chit(68,-7000,-7000,68,_unit68,25,68,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[69] = New Chit(0,-7000,-7000,69,_unit69,25,690,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[70] = New Chit(68,-7000,-7000,70,_unit70,25,70,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		
		_chit[71] = New Chit(0,-7000,-7000,71,_unit71,25,710,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[72] = New Chit(68,-7000,-7000,72,_unit72,25,72,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[73] = New Chit(0,-7000,-7000,73,_unit73,25,730,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[74] = New Chit(68,-7000,-7000,74,_unit74,25,74,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[75] = New Chit(0,-7000,-7000,75,_unit75,25,750,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[76] = New Chit(68,-7000,-7000,76,_unit76,25,76,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[77] = New Chit(0,-7000,-7000,77,_unit77,25,770,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[78] = New Chit(68,-7000,-7000,78,_unit78,25,78,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[79] = New Chit(0,-7000,-7000,79,_unit79,25,790,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[80] = New Chit(68,-7000,-7000,80,_unit80,25,80,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
			
		_chit[81] = New Chit(0,-7000,-7000,81,_unit81,25,810,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[82] = New Chit(68,-7000,-7000,82,_unit82,25,82,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[83] = New Chit(0,-7000,-7000,83,_unit83,25,830,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[84] = New Chit(68,-7000,-7000,84,_unit84,25,84,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[85] = New Chit(0,-7000,-7000,85,_unit85,25,850,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[86] = New Chit(68,-7000,-7000,86,_unit86,25,86,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[87] = New Chit(0,-7000,-7000,87,_unit87,25,870,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[88] = New Chit(68,-7000,-7000,88,_unit88,25,88,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[89] = New Chit(0,-7000,-7000,89,_unit89,25,890,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[90] = New Chit(68,-7000,-7000,90,_unit90,25,90,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		
		_chit[91] = New Chit(0,-7000,-7000,91,_unit91,25,910,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[92] = New Chit(68,-7000,-7000,92,_unit92,25,92,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[93] = New Chit(0,-7000,-7000,93,_unit93,25,930,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[94] = New Chit(68,-7000,-7000,94,_unit94,25,94,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[95] = New Chit(0,-7000,-7000,95,_unit95,25,950,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[96] = New Chit(68,-7000,-7000,96,_unit96,25,96,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[97] = New Chit(0,-7000,-7000,97,_unit97,25,970,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[98] = New Chit(68,-7000,-7000,98,_unit98,25,98,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		_chit[99] = New Chit(0,-7000,-7000,99,_unit99,25,990,0,0,0,0,0,0,0,0,0,0) ' rotatio,X,Y (x,y in relation to the map
		_chit[100] = New Chit(68,-7000,-7000,100,_unit100,25,100,0,0,0,0,0,0,0,0,0,0) ' the map you see starts at -x500 y-500
		
		_cargos[1] = New Cargos() ' the map you see starts at -x500 y-500
			
	End

Protected
	Method OnUpdate()
		RequestRender()
	End Method
	
	
	Method OnRender( canvas:Canvas ) Override

		'fill the screen canvas with a color
		canvas.Color = Color.Black
		canvas.DrawRect( 0, 0, Width, Height )

		Select _gameMode
			Case GAME_INTRO
				DrawTheIntro( canvas )
			Case GAME_GAME
				DrawTheGame( canvas )
		End Select
	End


	Method DrawTheGame( canvas:Canvas )
		canvas.Color = Color.White
		'draw the map
		
		
		canvas.DrawImage( _maped,  _mX * _big  , _mY * _big ,0,_big,_big )		
		'draw the chits with a twist
		' debug _twist = _twist + 1
		'If _twisted &gt; 360 Then _twisted = _twisted - 360
		Local f:Int = 0
	    For f = 1 To 100
           'canvas.DrawCircle(800+_mX,  800+_mY,30 ) 'draw	800x800 plus map offset	
	        'loop to draw the chits
	     	canvas.DrawImage ( _chit[f]._chitimage, (_chit[f]._chitx +_mX)*_big, (_chit[f]._chity + _mY)*_big,_chit[f]._twist,_big,_big )
		    
		Next
	    'bottom dashboard overlay image for UI
    	'canvas.DrawImage( dashy, 0, 570 )
    	'If _mouseX &gt; 10 And _mouseX &lt; 90 And _mouseY &gt; 575 And _mouseY &lt; 610
    	canvas.Color = Color.DarkGrey
	    canvas.DrawRect(750,575,195,140)
	    canvas.Color = Color.LightGrey
	    canvas.DrawRect(10,575,90,35)
	    canvas.Color = Color.LightGrey
	    canvas.DrawRect(10,575+50,90,35)
	    
	    canvas.Color = Color.LightGrey
	    canvas.DrawRect(10,575+100,90,35)
	    
	    If _use = 1
		 canvas.Color = Color.Red
	    canvas.DrawRect(10,575,90,35)   
		    
		Endif
		If _use = 2
		 canvas.Color = Color.Red
	    canvas.DrawRect(10,575+50,90,35)   
		    
		Endif    
	    If _use = 3
		 canvas.Color = Color.Brown
	    canvas.DrawRect(10,575+50,90,35)   
		    
		Endif
		If _use = 4
		 canvas.Color = Color.Red
	    canvas.DrawRect(10,575+100,90,35)   
		    
		Endif   
	    canvas.Color = Color.Black
	    canvas.DrawText( "  ROTATE",15,585)
	    canvas.DrawText( "MOVE CHIT",15,585+50)
	    canvas.DrawText( " PUT AWAY",15,585+100)
	    canvas.Color = Color.Blue
	    canvas.DrawRect(750,535,195,40)
	    canvas.Color = Color.White
		canvas.DrawText( "&lt; CLICK HERE FOR UNITS &gt;",750,535)
		canvas.DrawText( "      THEN MOVE CHIT",760,555)
	    canvas.Color = Color.White
	    'loop to draw selected chit on the dashboard
	    f = 0
	    For f = 1 To 100
	         If unitnumb &gt; 0 And unitnumb = _chit[f]._id then canvas.DrawImage (_chit[f]._chitimage, 845, 645 )
	    Next
	    '_hold is a flag to tell us were holding a chit
	    If _hold &gt; -1 And _use = 2 Then _use = 3 'need to set the menu option to 3 if a chit is held
	    If _hold &gt; -1 And _use = 4 Then _use = 5 'need to set the menu option to 3 if a chit is held
	    ' if a chit is held display it at mouse and highlight it
	    canvas.Color = Color.Sky
		    if _hold &gt; -1 then canvas.DrawImage (_chit[unitnumb]._chitimage, _mouseX, _mouseY,_chit[unitnumb]._twist,_big,_big )
	    canvas.Color = Color.White
	    
	
	    If unitnumb &gt; 0 And _chit[unitnumb]._chitx = -7000 And _chit[unitnumb]._chity = -7000 
		canvas.Color = Color.Red
	    canvas.DrawRect(750,535,195,40)
	    canvas.Color = Color.White
		canvas.DrawText( "&lt; IT'S IN THE BOX = "+unitnumb+" &gt;",750,535)
		canvas.DrawText( "MOVE CHIT TO PLACE",770,555)
		Endif
		
		If _trading = 1 And unitnumb &gt; 0
			
		_cargos[1].trades(canvas,unitnumb,0,0,_cargos[1]._numb1,_cargos[1]._numb2,_cargos[1]._numb3,_cargos[1]._numb4,_cargos[1]._numb5,_cargos[1]._numb6,_cargos[1]._numb7,_cargos[1]._numb8,_cargos[1]._numb9,_cargos[1]._numb10)
		_chit[unitnumb]._numb1 = _cargos[stuf]._numb1
		_chit[unitnumb]._numb2 = _cargos[stuf]._numb2
		_chit[unitnumb]._numb3 = _cargos[stuf]._numb3
		_chit[unitnumb]._numb4 = _cargos[stuf]._numb4
		_chit[unitnumb]._numb5 = _cargos[stuf]._numb5
		_chit[unitnumb]._numb6 = _cargos[stuf]._numb6
		_chit[unitnumb]._numb7 = _cargos[stuf]._numb7
		_chit[unitnumb]._numb8 = _cargos[stuf]._numb8
		_chit[unitnumb]._numb9 = _cargos[stuf]._numb9
		_chit[unitnumb]._numb10 = _cargos[stuf]._numb10								
		Endif
		
		
		
		
		
	
	End Method
	
	Method ReplaceChit( TWIST:Int,CHX:Int,CHY:int,ID:int, ANIMAGE:Image, BIG:int,TYPE:int )  
		
		_chit[ID]._id = ID
		_chit[ID]._twist = BIG
		_chit[ID]._chitx = CHX
		_chit[ID]._chity = CHY
		_chit[ID]._chitimage = ANIMAGE
		_chit[ID]._big = BIG
		_chit[ID]._type = TYPE
	End Method
	
	Method DrawTheIntro( canvas:Canvas )
		canvas.Color = Color.White
	
		canvas.DrawText( " Gamer Map' Second App By Mark Ainsworth ref 210665",200,20 )
		canvas.DrawText( " How To Scroll The Map Right Click To Pickup Board, Then Drag it Release to Drop it. ",200,60 )
		canvas.DrawText( " You can Move around the Map By Only RightClicking and Dragging.",200,80 )
		canvas.DrawText("- PRESS ENTER OR LEFT-CLICK MOUSE TO START MAP --&gt;",200,670)
		
	End Method

	
	'respond to any key presses
	Method OnKeyEvent( event:KeyEvent ) Override
		'heres the best way to check for shift keys etc
		Local command:Bool = event.Modifiers &amp; Modifier.Gui
		Local shift:Bool = event.Modifiers &amp; Modifier.Shift
		Local alt:bool = event.Modifiers &amp; Modifier.Alt
		
		Select event.Type
			Case EventType.KeyDown
			
				Select event.Key
					Case Key.Enter
						Select _gameMode
							Case GAME_INTRO
								_gameMode = GAME_GAME
						End Select
							
				End Select
				
			Case EventType.KeyUp
			
				Select event.Key
					Case Key.Enter
				End Select
				
		End Select
	End

	'here we track the mouse and all mouse related stuff
	Method OnMouseEvent( event:MouseEvent ) Override
		'set up some global mouse cars so we can use these throught to program
		_mouseX = event.Location.X
		_mouseY = event.Location.Y

		'here are the baci mouse events we are interested in
		Select event.Type
	        'Right-click deselects all options and moves map
			Case EventType.MouseRightClick
				_movemap = 1
				'_use = 0
				'_hold = -1
				'unitnumb = 0
				If _movemap = 1 'if you right click record current mouse location
				_oldX = _mX +  -_mouseX 'plus map location
				_oldY = _mY + -_mouseY
				
				Endif

			Case EventType.MouseClick
			'use 4 Adds chit at the mouse cursor
			If _use = 5
			
		    	
			Endif		
		    'use 3 places held chit at the mouse cursor
			If _use = 3
			Local _newX:Int
			Local _newY:Int	
			If _hold &gt; -1
			_newX =  ((_mouseX + (-_mX * _big) ) / _big)   'this is the formula for screem   
			_newY =  ((_mouseY + (-_mY * _big) ) / _big)   'position of mouse in the map
		        _chit[unitnumb]._chitx = _newX
		        _chit[unitnumb]._chity = _newY
			    '_use = 0 
			    _hold = -1
		    	'unitnumb = 0
		    Endif
		    	
			Endif	
			'use 2 is the button has been pressed to pickup chit	
			If _use = 2
				_hold = -1
				Local f:Int = 0
	            For f = 1 To 100
		           ' If _hold &gt; -1 Then unitnumb = 0
		        If unitnumb = _chit[f]._id And _hold = -1 Then	_hold = unitnumb
			        
			    Next
			Endif
			    
				
			'use 1, rotates the selected chit in radians, I will have to lookup radian use
			'but the wheel rotates, this is a click version, dont use it
			If _use = 1
				'Local f:Int = 0
	            'For f = 1 To 8
		        'If unitnumb = _chit[f]._id Then _twist = _twist / (Pi / 180)    
				'If unitnumb = _chit[f]._id Then _chit[f]._twist = _chit[f]._twist + 1
				'If _chit[f]._twist &gt; 360 Then _chit[f]._twist = _chit[f]._twist - 360
		        '_twist = _twist *  (Pi / 180)
					
				
				'Next
				
				Endif
		
			    'this selects the chit the mouse is over every time you click
				Local f:Int = 0
	            For f = 1 To 100
				
				If _mouseX &gt; (_chit[f]._chitx )*_big +5000 - (_big*25) - ((-(_mX*_big))+5000)   And _mouseX &lt; (_chit[f]._chitx )*_big + (25*_big) +5000 - (((-_mX*_big))+5000)   And _mouseY &gt; (_chit[f]._chity )*_big +5000- (_big*25) - (((-_mY*_big))+5000)   And _mouseY &lt; (_chit[f]._chity )*_big + (25*_big) +5000 - (((-_mY*_big))+5000)  
			 	unitnumb = _chit[f]._id
			 	Endif
				Next
				
				If _trading = 1
				_xoff = 0
				_yoff = 0
				
				
			 If _mouseX &gt; 500+_xoff And _mouseX &lt; 530+_xoff And _mouseY &gt; 665+_yoff And _mouseY &lt; 685+_yoff
				  _cargos[stuf]._numb5 =  _cargos[stuf]._numb5 + 1
				 If  _cargos[stuf]._numb5 &gt; 1000 Then  _cargos[stuf]._numb5 = 0
				 If  _cargos[stuf]._numb5 &lt; 0 Then  _cargos[stuf]._numb5 = 1000
				Endif
				If _mouseX &gt; 470+_xoff And _mouseX &lt; 500+_xoff And _mouseY &gt; 665+_yoff And _mouseY &lt; 685+_yoff
				  _cargos[stuf]._numb5 =  _cargos[stuf]._numb5 - 1
				 If  _cargos[stuf]._numb5 &gt; 1000 Then  _cargos[stuf]._numb5 = 0
				 If  _cargos[stuf]._numb5 &lt; 0 Then  _cargos[stuf]._numb5 = 1000
				Endif
					If _mouseX &gt; 500+_xoff And _mouseX &lt; 530+_xoff And _mouseY &gt; 645+_yoff And _mouseY &lt; 665+_yoff
				  _cargos[stuf]._numb4 =  _cargos[stuf]._numb4 + 1
				 If  _cargos[stuf]._numb4 &gt; 1000 Then  _cargos[stuf]._numb4 = 0
				 If  _cargos[stuf]._numb4 &lt; 0 Then  _cargos[stuf]._numb4 = 1000
				Endif
				If _mouseX &gt; 470+_xoff And _mouseX &lt; 500+_xoff And _mouseY &gt; 645+_yoff And _mouseY &lt; 665+_yoff
				  _cargos[stuf]._numb4 =  _cargos[stuf]._numb4 - 1
				 If  _cargos[stuf]._numb4 &gt; 1000 Then  _cargos[stuf]._numb4 = 0
				 If  _cargos[stuf]._numb4 &lt; 0 Then  _cargos[stuf]._numb4 = 1000
				Endif

			 	If _mouseX &gt; 500+_xoff And _mouseX &lt; 530+_xoff And _mouseY &gt; 625+_yoff And _mouseY &lt; 645+_yoff
				  _cargos[stuf]._numb3 =  _cargos[stuf]._numb3 + 1
				 If  _cargos[stuf]._numb3 &gt; 1000 Then  _cargos[stuf]._numb3 = 0
				 If  _cargos[stuf]._numb3 &lt; 0 Then  _cargos[stuf]._numb3 = 1000
				Endif
				If _mouseX &gt; 470+_xoff And _mouseX &lt; 500+_xoff And _mouseY &gt; 625+_yoff And _mouseY &lt; 645+_yoff
				  _cargos[stuf]._numb3 =  _cargos[stuf]._numb3 - 1
				 If  _cargos[stuf]._numb3 &gt; 1000 Then  _cargos[stuf]._numb3 = 0
				 If  _cargos[stuf]._numb3 &lt; 0 Then  _cargos[stuf]._numb3 = 1000
				Endif
			 	If _mouseX &gt; 500+_xoff And _mouseX &lt; 530+_xoff And _mouseY &gt; 605+_yoff And _mouseY &lt; 625+_yoff
				  _cargos[stuf]._numb2 =  _cargos[stuf]._numb2 + 1
				 If  _cargos[stuf]._numb2 &gt; 1000 Then  _cargos[stuf]._numb2 = 0
				 If  _cargos[stuf]._numb2 &lt; 0 Then  _cargos[stuf]._numb2 = 1000
				Endif
				If _mouseX &gt; 470+_xoff And _mouseX &lt; 500+_xoff And _mouseY &gt; 605+_yoff And _mouseY &lt; 625+_yoff
				  _cargos[stuf]._numb2 =  _cargos[stuf]._numb2 - 1
				 If  _cargos[stuf]._numb2 &gt; 1000 Then  _cargos[stuf]._numb2 = 0
				 If  _cargos[stuf]._numb2 &lt; 0 Then  _cargos[stuf]._numb2 = 1000
				Endif

	            If _mouseX &gt; 500+_xoff And _mouseX &lt; 530+_xoff And _mouseY &gt; 585+_yoff And _mouseY &lt; 605+_yoff
				  _cargos[stuf]._numb1 =  _cargos[stuf]._numb1 + 1
				 If  _cargos[stuf]._numb1 &gt; 1000 Then  _cargos[stuf]._numb1 = 0
				 If  _cargos[stuf]._numb1 &lt; 0 Then  _cargos[stuf]._numb1 = 1000
				Endif
				If _mouseX &gt; 470+_xoff And _mouseX &lt; 500+_xoff And _mouseY &gt; 585+_yoff And _mouseY &lt; 605+_yoff
				  _cargos[stuf]._numb1 =  _cargos[stuf]._numb1 - 1
				 If  _cargos[stuf]._numb1 &gt; 1000 Then  _cargos[stuf]._numb1 = 0
				 If  _cargos[stuf]._numb1 &lt; 0 Then  _cargos[stuf]._numb1 = 1000
				Endif
				
				_xoff = _xoff - 300
				
					If _mouseX &gt; 500+_xoff And _mouseX &lt; 530+_xoff And _mouseY &gt; 665+_yoff And _mouseY &lt; 685+_yoff
				  _cargos[stuf]._numb10 =  _cargos[stuf]._numb10 + 1
				 If  _cargos[stuf]._numb10 &gt; 1000 Then  _cargos[stuf]._numb10 = 0
				 If  _cargos[stuf]._numb10 &lt; 0 Then  _cargos[stuf]._numb10 = 1000
				Endif
				If _mouseX &gt; 470+_xoff And _mouseX &lt; 500+_xoff And _mouseY &gt; 665+_yoff And _mouseY &lt; 685+_yoff
				  _cargos[stuf]._numb10 =  _cargos[stuf]._numb10 - 1
				 If  _cargos[stuf]._numb10 &gt; 1000 Then  _cargos[stuf]._numb10 = 0
				 If  _cargos[stuf]._numb10 &lt; 0 Then  _cargos[stuf]._numb10 = 1000
				Endif
					If _mouseX &gt; 500+_xoff And _mouseX &lt; 530+_xoff And _mouseY &gt; 645+_yoff And _mouseY &lt; 665+_yoff
				  _cargos[stuf]._numb9 =  _cargos[stuf]._numb9 + 1
				 If  _cargos[stuf]._numb9 &gt; 1000 Then  _cargos[stuf]._numb9 = 0
				 If  _cargos[stuf]._numb9 &lt; 0 Then  _cargos[stuf]._numb9 = 1000
				Endif
				If _mouseX &gt; 470+_xoff And _mouseX &lt; 500+_xoff And _mouseY &gt; 645+_yoff And _mouseY &lt; 665+_yoff
				  _cargos[stuf]._numb9 =  _cargos[stuf]._numb9 - 1
				 If  _cargos[stuf]._numb9 &gt; 1000 Then  _cargos[stuf]._numb9 = 0
				 If  _cargos[stuf]._numb9 &lt; 0 Then  _cargos[stuf]._numb9 = 1000
				Endif

			 	If _mouseX &gt; 500+_xoff And _mouseX &lt; 530+_xoff And _mouseY &gt; 625+_yoff And _mouseY &lt; 645+_yoff
				  _cargos[stuf]._numb8 =  _cargos[stuf]._numb8 + 1
				 If  _cargos[stuf]._numb8 &gt; 1000 Then  _cargos[stuf]._numb8 = 0
				 If  _cargos[stuf]._numb8 &lt; 0 Then  _cargos[stuf]._numb8 = 1000
				Endif
				If _mouseX &gt; 470+_xoff And _mouseX &lt; 500+_xoff And _mouseY &gt; 625+_yoff And _mouseY &lt; 645+_yoff
				  _cargos[stuf]._numb8 =  _cargos[stuf]._numb8 - 1
				 If  _cargos[stuf]._numb8 &gt; 1000 Then  _cargos[stuf]._numb8 = 0
				 If  _cargos[stuf]._numb8 &lt; 0 Then  _cargos[stuf]._numb8 = 1000
				Endif
			 	If _mouseX &gt; 500+_xoff And _mouseX &lt; 530+_xoff And _mouseY &gt; 605+_yoff And _mouseY &lt; 625+_yoff
				  _cargos[stuf]._numb7 =  _cargos[stuf]._numb7 + 1
				 If  _cargos[stuf]._numb7 &gt; 1000 Then  _cargos[stuf]._numb7 = 0
				 If  _cargos[stuf]._numb7 &lt; 0 Then  _cargos[stuf]._numb7 = 1000
				Endif
				If _mouseX &gt; 470+_xoff And _mouseX &lt; 500+_xoff And _mouseY &gt; 605+_yoff And _mouseY &lt; 625+_yoff
				  _cargos[stuf]._numb7 =  _cargos[stuf]._numb7 - 1
				 If  _cargos[stuf]._numb7 &gt; 1000 Then  _cargos[stuf]._numb7 = 0
				 If  _cargos[stuf]._numb7 &lt; 0 Then  _cargos[stuf]._numb7 = 1000
				Endif

	            If _mouseX &gt; 500+_xoff And _mouseX &lt; 530+_xoff And _mouseY &gt; 585+_yoff And _mouseY &lt; 605+_yoff
				  _cargos[stuf]._numb6 =  _cargos[stuf]._numb6 + 1
				 If  _cargos[stuf]._numb6 &gt; 1000 Then  _cargos[stuf]._numb6 = 0
				 If  _cargos[stuf]._numb6 &lt; 0 Then  _cargos[stuf]._numb6 = 1000
				Endif
				If _mouseX &gt; 470+_xoff And _mouseX &lt; 500+_xoff And _mouseY &gt; 585+_yoff And _mouseY &lt; 605+_yoff
				  _cargos[stuf]._numb6 =  _cargos[stuf]._numb6 - 1
				 If  _cargos[stuf]._numb6 &gt; 1000 Then  _cargos[stuf]._numb6 = 0
				 If  _cargos[stuf]._numb6 &lt; 0 Then  _cargos[stuf]._numb6 = 1000
				Endif	
			
				
				Endif
				
				
				
				
				If _mouseX &gt; 750 And _mouseX &lt; 850 And _mouseY &gt; 535 And _mouseY &lt; 575
				 unitnumb = unitnumb + 1
				 If unitnumb &gt; 100 Then unitnumb = 1
				 If unitnumb = 0 Then unitnumb = 1
				Endif
				If _mouseX &gt; 850 And _mouseX &lt; 950 And _mouseY &gt; 535 And _mouseY &lt; 575
				 unitnumb = unitnumb - 1
				 If unitnumb &lt; 1 Then unitnumb = 100
				 If unitnumb = 0 Then unitnumb = 1
				Endif
				

				
				
				
				
				If _mouseX &gt; 10 And _mouseX &lt; 100 And _mouseY &gt; 575 And _mouseY &lt; 610
				 _use = 1 'if you click dashboard top left button then your
				          'selecting this, to rotate a chit option on
				 If unitnumb &gt; 0 Then _chit[unitnumb]._twist = 0 'reset totation
				Endif
				
				If _mouseX &gt; 10 And _mouseX &lt; 100 And _mouseY &gt; 575+50 And _mouseY &lt; 610+50
				 _use = 2  'if you click second button down on the left, you picking
				           ' a chit to move
				 _hold = -1 'reset to not holding,
				Local f:Int = 0
	            For f = 1 To 100
		           ' pickup selected chit unitnumb is the current selected chit
		        If unitnumb = _chit[f]._id And _hold = -1 Then	_hold = unitnumb
			        
			    Next
				Endif
				
				If _mouseX &gt; 10 And _mouseX &lt; 100 And _mouseY &gt; 675 And _mouseY &lt; 710
				 _use = 4 'if you click dashboard top left button then your
				          'selecting this, to ADD a chit option on
				_chit[unitnumb]._chitx = -7000
		        _chit[unitnumb]._chity = -7000
			    '_use = 0 
			    _hold = -1
		    	'unitnumb = 0
			    
				Endif
				
				Select _gameMode
					Case GAME_INTRO
						_gameMode = GAME_GAME
				End Select
					
			Case EventType.MouseUp
				_movemap = 0 'if you move the mouse while dragging
					If _movemap = 0 'the map x,y is updated untill you Mouseup
						_oldX = _mX 
						_oldY = _mY 
		
					Endif
				
			Case EventType.MouseWheel
				
				If event.Wheel.Y &lt;&gt; 0 And _use &gt; 1 Then
			    'set scale with mouse wheel, unless rotating with use 1
                     _big = Clamp( _big + event.Wheel.Y * 0.01, 0.25, 4.0 )
				
				End If
				
				If event.Wheel.Y &lt;&gt; 0 And _use = 0 Then
			    'rotate
                      _big = Clamp( _big + event.Wheel.Y * 0.01, 0.25, 4.0 )
				
				End If	
                	If _use = 1 And event.Wheel.Y &lt;&gt; 0
					Local f:Int = 0
	            		For f = 1 To 100
		            'I will have to do this radians properly
                			If unitnumb = _chit[f]._id Then _chit[f]._twist =  _chit[f]._twist + (event.Wheel.Y / .05)        
                			If _chit[f]._twist &lt; -1000 Then  _chit[f]._twist = 1000 		            
                			If _chit[f]._twist &gt; 1000  Then  _chit[f]._twist = -1000	            		            
		           
				
						Next
				
					Endif
					
										
			Case EventType.MouseEnter
			Case EventType.MouseLeave
			Case EventType.MouseMove
				If _movemap = 1
					_mX = _mouseX + _oldX - 0
					_mY = _mouseY + _oldY - 0
				Endif	
				End Select					
		
	End Method
	
	Field _numb1:Int = 0
	Field _numb2:Int = 0
	Field _numb3:Int = 0
	Field _numb4:Int = 0
	Field _numb5:Int = 0
	Field _numb6:Int = 0
	Field _numb7:Int = 0
	Field _numb8:Int = 0
	Field _numb9:Int = 0
	Field _numb10:Int = 0
		Field stuf:Int = 1
	    field _xoff:Int = 0 
	    Field _yoff:Int = 0 
    	field unitnumb:Int = -1 'this is selected chit
		Field number:Int = 0
		Field _big:Float = 1 'this is scale
				
        Field moveit:Int = -1
		Field _mY:Int = -500 'position of map -500 so we start 500 in from top
	    Field _mX:Int = -500 'position of map -500 so we start 500 in from left
		Field _twist:Int  'rotate
		Field _oldX:Int 'used to store map location before you drag
		Field _oldY:Int 'used to store map location before you drag
		Field _movemap:Int 'switch to on to dragmap in conjuction with old position

	'this is needed to allow the Size to be correct. this is called automatically
	Method OnMeasure:Vec2i() Override
		Return Size
	End
Private
	'the timer ticks 60 times a second and handles the screen update
	Field _timer:Timer
		    field _cargos:Cargos[] = New Cargos[ 100 ]
	'what mode is the game in, showing the intro, playing, ended, etc
	Field _gameMode:Int = GAME_INTRO
	
	'global mouse vars
	
	Field _trading:Int = 1
	Field _mouseX:Int
	Field _mouseY:Int
	Field _use:Int = -1 'this is menu selection
	Field _hold:Int = -1 'flag to tell us if were holding a chit
	'image assets
	Field _maped:Image ' this is the map png
	Field _unit1:Image ' this is the chit1 png
	Field _unit2:Image ' this is the chit2 png
	Field _unit3:Image ' this is the chit1 png
	Field _unit4:Image ' this is the chit2 png
	Field _unit5:Image ' this is the chit1 png
	Field _unit6:Image ' this is the chit2 png
	Field _unit7:Image ' this is the chit1 png
	Field _unit8:Image ' this is the chit2 png
	Field _unit9:Image ' this is the chit2 png
	Field _unit10:Image ' this is the chit2 png
	
	Field _unit11:Image ' this is the chit1 png
	Field _unit12:Image ' this is the chit2 png
	Field _unit13:Image ' this is the chit1 png
	Field _unit14:Image ' this is the chit2 png
	Field _unit15:Image ' this is the chit1 png
	Field _unit16:Image ' this is the chit2 png
	Field _unit17:Image ' this is the chit1 png
	Field _unit18:Image ' this is the chit2 png
	Field _unit19:Image ' this is the chit2 png
	Field _unit20:Image ' this is the chit2 png
	
	Field _unit21:Image ' this is the chit1 png
	Field _unit22:Image ' this is the chit2 png
	Field _unit23:Image ' this is the chit1 png
	Field _unit24:Image ' this is the chit2 png
	Field _unit25:Image ' this is the chit1 png
	Field _unit26:Image ' this is the chit2 png
	Field _unit27:Image ' this is the chit1 png
	Field _unit28:Image ' this is the chit2 png
	Field _unit29:Image ' this is the chit2 png
	Field _unit30:Image ' this is the chit2 png
	
	
	Field _unit31:Image ' this is the chit1 png
	Field _unit32:Image ' this is the chit2 png
	Field _unit33:Image ' this is the chit1 png
	Field _unit34:Image ' this is the chit2 png
	Field _unit35:Image ' this is the chit1 png
	Field _unit36:Image ' this is the chit2 png
	Field _unit37:Image ' this is the chit1 png
	Field _unit38:Image ' this is the chit2 png
	Field _unit39:Image ' this is the chit2 png
	Field _unit40:Image ' this is the chit2 png
	
	
	Field _unit41:Image ' this is the chit1 png
	Field _unit42:Image ' this is the chit2 png
	Field _unit43:Image ' this is the chit1 png
	Field _unit44:Image ' this is the chit2 png
	Field _unit45:Image ' this is the chit1 png
	Field _unit46:Image ' this is the chit2 png
	Field _unit47:Image ' this is the chit1 png
	Field _unit48:Image ' this is the chit2 png
	Field _unit49:Image ' this is the chit2 png
	Field _unit50:Image ' this is the chit2 png
	
	
	Field _unit51:Image ' this is the chit1 png
	Field _unit52:Image ' this is the chit2 png
	Field _unit53:Image ' this is the chit1 png
	Field _unit54:Image ' this is the chit2 png
	Field _unit55:Image ' this is the chit1 png
	Field _unit56:Image ' this is the chit2 png
	Field _unit57:Image ' this is the chit1 png
	Field _unit58:Image ' this is the chit2 png
	Field _unit59:Image ' this is the chit2 png
	Field _unit60:Image ' this is the chit2 png
	
	
	Field _unit61:Image ' this is the chit1 png
	Field _unit62:Image ' this is the chit2 png
	Field _unit63:Image ' this is the chit1 png
	Field _unit64:Image ' this is the chit2 png
	Field _unit65:Image ' this is the chit1 png
	Field _unit66:Image ' this is the chit2 png
	Field _unit67:Image ' this is the chit1 png
	Field _unit68:Image ' this is the chit2 png
	Field _unit69:Image ' this is the chit2 png
	Field _unit70:Image ' this is the chit2 png
	
	Field _unit71:Image ' this is the chit1 png
	Field _unit72:Image ' this is the chit2 png
	Field _unit73:Image ' this is the chit1 png
	Field _unit74:Image ' this is the chit2 png
	Field _unit75:Image ' this is the chit1 png
	Field _unit76:Image ' this is the chit2 png
	Field _unit77:Image ' this is the chit1 png
	Field _unit78:Image ' this is the chit2 png
	Field _unit79:Image ' this is the chit2 png
	Field _unit80:Image ' this is the chit2 png
	
	Field _unit81:Image ' this is the chit1 png
	Field _unit82:Image ' this is the chit2 png
	Field _unit83:Image ' this is the chit1 png
	Field _unit84:Image ' this is the chit2 png
	Field _unit85:Image ' this is the chit1 png
	Field _unit86:Image ' this is the chit2 png
	Field _unit87:Image ' this is the chit1 png
	Field _unit88:Image ' this is the chit2 png
	Field _unit89:Image ' this is the chit2 png
	Field _unit90:Image ' this is the chit2 png
	
	Field _unit91:Image ' this is the chit1 png
	Field _unit92:Image ' this is the chit2 png
	Field _unit93:Image ' this is the chit1 png
	Field _unit94:Image ' this is the chit2 png
	Field _unit95:Image ' this is the chit1 png
	Field _unit96:Image ' this is the chit2 png
	Field _unit97:Image ' this is the chit1 png
	Field _unit98:Image ' this is the chit2 png
	Field _unit99:Image ' this is the chit2 png
	Field _unit100:Image ' this is the chit2 png
	

	'Field dashy:Image ' this is the map png ' lets say the center is 0, 0
	'set up some classes' these will need to be newed
	
	field _chit:Chit[] = New Chit[ 110 ]

	
End



</textarea><br><br>Ive not used setters yet, or commented, but its pretty simple what Ive done, I really messed up not having a dynamic addchit method and manager class, but at least I'm learning :) <br><br></td></tr></table><br>
<a name="1339716"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#155">[#155]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok, only comment so far just looking at the code<br>I only scrolled though the code and saw all the 'chits'.<br>Dump them all. keep 2 or 4 and just get rid of every other image load.<br><br>reasons:<br>1. they are just confusing everything. KEEP IT SIMPLE<br>2. You code is no longer testable by others without having access to all the images - not a good solution<br>3. what are there so many. you should be focussing on the code and not the images<br>4. theres a huge amount of 'if mouse is at this position'. Although I can guess what it is doing -&gt; checking for a position on screen that relates to a pseudo button. what happens if you need to alter the UI in any way? You would need to go through all the code and start working out where it is going wrong.<br><br>OK. That's just letting you know some pits that are before you.<br><br>I've been working separating the code I've got here into bits, so hopefully the UI stuff can be forgotten about. I'll post something today... <br><br></td></tr></table><br>
<a name="1339717"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#156">[#156]</a></td></tr></table></td></tr><tr ><td class="posttext"> Just to recap. get rid of all the chitimages - just use 2<br>enemy 1 and an enemy 2<br>When you create a new unit just set it to be either one or the other. You are NEVER going to have 100 different types of things and be able to work out how to get any further.<br><br>You MUST keep it simple at this stage<br><br>Just concentrate on your workflow and feeling happy about thing first.. please ;) <br><br></td></tr></table><br>
<a name="1339720"></a>

<a name="1339724"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#157">[#157]</a></td></tr></table></td></tr><tr ><td class="posttext"> Adam, I was working on a separate entity to you, to addon at a later stage I needed lots of images for creating a ships internal display, rockets cargo crew fuel lasers ore goods robots all that sort of stuff. I can visualise a massive ships mechanisms , I know were doing elite type, but I think this would be a cool addon maybe. I'm was doing what I was able as a noob, I'm still into your code, but I needed to learn at the same time, don't take my code to seriously I'm on a back seat.<br><br>This just fell into my lap, Ive added a couple of dice rollers and already created an app, its need artworks but the app is running ok for a tabletop miniatures game. <br><br><a href="https://numbergamer8.itch.io/miniatures-game-tool" target="_blank">https://numbergamer8.itch.io/miniatures-game-tool</a><br><br>I put the file here for download, I know I had lots of chits.<br><br>I understand workflow, and what we need to be doing, I was testing out what your showing me , I'm enjoying the project a lot , I'm finished with experimental side flow now, I will get right to reviewing more code. I think the game were are doing is incredible and you code like a professor, I'm wondering how you code so well, you've impressed me for ever.<br><br>PS: I could not keep up with workflow unless I tried a few things out, Ive got a sound idea now of what monkey and classes are, now I can look at your code with a better viewpoint. <br><br></td></tr></table><br>
<a name="1339725"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#158">[#158]</a></td></tr></table></td></tr><tr ><td class="posttext"> You do not need "graphics" in this stage at all.<br><br>-&gt; give your units class a "draw()" command - maybe even a "drawbackground, drawforeground"<br><br>If you unit has "weapons" then either have a "ship extends unit"-class or have "weapons" being of type "weapon" including a "DrawAsShipInteriour()" method<br><br>Principle is: Ship defines area to draw to (x,y,w,h) and it is up to the weapon to draw itself into that portion - how it does it? It does not matter - DrawOval() or DrawImage() - it is up to the implementation of the class and could be done in a later stage.<br><br><br>@ if mouse is at this position<br>You do need to abstract things.<br>Instead of <br>If mouseX() &gt; 10 and mouseX() &lt; 20 ... then HandleClickedButton1()<br><br>you need to have it that way (at another location in the code...):<br>UX.update()<br>and at the mouseX-line you need:<br>if button1.IsClicked() then HandleClickedButton1()<br><br>UX.update (or how Adam  supposes to handle it) is there to check all the GUI elements whether they get hovered and "hit" or "clicked" or maybe "dragged/dropped" ...<br>It refreshes states of the contained elements.<br><br><br>If you do not want to use that UXManager ... you could call "button.update()" which does the mouse-position checks in relation to its own ScreenCoordinates.<br>Using this approach allows to move or resize a button ("SetX(10)") and the update() will automatically handle it.<br>Yes, you could do this "procedurally" with your lines of "ifs" too but this allows to manipulate things where it belongs to: in the methods of an object, not somewhere in your application.<br><br><br><br>@ hundred different types<br>Think of these types to equal to "Red car", "blue car", "green car". you already knew before, that you could store the "color" as a property of a car. Similar things could be done with armory, weapons, ... of a ship.<br><br>So as soon as things share many properties it is a good thing to have them base on the same class (or use interfaces or "components").<br><br>To distinguish things, you just use what Adam (I believe at least) already did with the planet types - you create an "enum" (or just numbers) to define a distinguishable typeID for the ship.<br>TYPE_SHIP_DESTROYER<br>TYPE_SHIP_TRANSPORTER<br>...<br><br>But of course you could stay using individual classes for each of them - I would use that eg. to split "planets" from "ships" ... just to avoid checks like<br>"is type =TYPE_PLANET or type = TYPE_MOON or type = TYPE_SUN ..."<br>just to see whether a ship hit something "planetish". With planets extending from "TPlanet" you could do a<br>"if TPlanet(crashingObject) then ..."<br><br>Just to complete things. Of course a Method of the unit could be called "IsPlanet:int()" and returns true for the types listed above. <br><br><br>There are so many ways to Rome so do not see above things as a "must", they are more "suggestions" based on personal experiences. So if Adam says "do not do this at this stage" you should consider doing so.<br><br><br>bye<br>Ron <br><br></td></tr></table><br>
<a name="1339726"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#159">[#159]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok. lets step back a bit...<br><br>The current code with the UI stuff is getting complex.<br><br>So...<br>I've separated it out along with the nice drawing stuff.<br><br>I'll start a new app and just detail some of the UI stuff. that way we can keep things at a nice simple level, and everyone can focus on the important stuff which is getting a feel for how it all works.<br><br>..... we can then use this new knowledge in oodles of ways :) <br><br></td></tr></table><br>
<a name="1339727"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#160">[#160]</a></td></tr></table></td></tr><tr ><td class="posttext"> You guys are fantastic at this, and I have learned from you even when I didn't think I needed to, so I take everything you guys say seriously, my code was just a playabout, don't worry about it, if it became usefull all the good, else it was a learning lesson.<br><br>I found I did not know the rules of the class flow, I still cant pass a mouse event to a class that's whats Adams UI is doing. <br><br></td></tr></table><br>
<a name="1339728"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#161">[#161]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok, this is going to get a bit nasty...<br><br>But bear with me<br><br>You already have the graphic for chit1.png<br><br>now here are the sources.<br>There are 4:<br>GameUI.monkey2 is the core of the UI. i would not recommend changing anything in there, but please have a good look.<br><br>GameUIExtras.monkey2 is the nice other stuff like drawing frames, ellipses, etc. consider this a helper which the other UI stuff depend on. These are functions so they can be called outside of the UI in you own app.<br><br>GameUIBaseControls.monkey2 this is where the fun starts. All the stuff in gameui was the setup stuff. the nasty stuff.<br>We now use the base classes and create our own simple controls from these. don't worry if you don't understand. everything is commented.<br>Basically we now have custom ui controls for:<br>UXButton - nice clickys things<br>UXImageButton - nice clicks things with images on them<br>UXPanel - draw a nice coloured or textured panel with images if you want<br>UXText - simple text drawing with bold and different colors along with custom alignments<br><br>So here are those first three:<br>GameUI.monkey2<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Namespace GameUI
Using GameUI

#Import "&lt;std&gt;"


#Import "gameuiextras"
#Import "gameuibasecontrols"

'lets create some defines for text alignment
const ALIGN_NONE:int = 0

const ALIGN_LEFT:int = 1
const ALIGN_RIGHT:int = 2
const ALIGN_MIDDLE:int = 4
const ALIGN_CENTER:int = 4
const ALIGN_HORIZONTAL:int = ALIGN_LEFT | ALIGN_RIGHT | ALIGN_MIDDLE

const ALIGN_TOP:int = 8
const VALIGN_TOP:int = 8
const ALIGN_BOTTOM:int = 16
const VALIGN_BOTTOM:int = 16
const VALIGN_MIDDLE:int = 32
const VALIGN_CENTER:int = 32
const ALIGN_VERTICAL:int = VALIGN_TOP | VALIGN_BOTTOM | VALIGN_MIDDLE

const ALIGN_FILL:int = 64

const ALIGN_TOPLEFT:int = VALIGN_TOP | ALIGN_LEFT
const ALIGN_TOPRIGHT:int = VALIGN_TOP | ALIGN_RIGHT
const ALIGN_TOPMIDDLE:int = VALIGN_TOP | ALIGN_MIDDLE
const ALIGN_TOPCENTER:int = VALIGN_TOP | ALIGN_MIDDLE

const ALIGN_CENTERED:int = VALIGN_MIDDLE | ALIGN_MIDDLE
const ALIGN_CENTERLEFT:int = VALIGN_MIDDLE | ALIGN_LEFT
const ALIGN_CENTERRIGHT:int = VALIGN_MIDDLE | ALIGN_RIGHT

const ALIGN_MIDDLELEFT:int = VALIGN_MIDDLE | ALIGN_LEFT
const ALIGN_MIDDLERIGHT:int = VALIGN_MIDDLE | ALIGN_RIGHT

const ALIGN_BOTTOMLEFT:int = VALIGN_BOTTOM | ALIGN_LEFT
const ALIGN_BOTTOMRIGHT:int = VALIGN_BOTTOM | ALIGN_RIGHT
const ALIGN_BOTTOMMIDDLE:int = VALIGN_BOTTOM | ALIGN_MIDDLE
const ALIGN_BOTTOMCENTER:int = VALIGN_BOTTOM | ALIGN_MIDDLE

'yes I know I said don't use globals
' but sometimes there is a solid And good reason To do so.
' this is that reason
global g_TextLeft:int
global g_TextTop:int


'lets create a control class for all our ui elements
'we will call it a page and its called UXPageView. it will manage everything for us
'we are going to do this step by step

Class UXPageView
	Method New( title:string )
		_title = title
	End

	Property Title:string()
		Return _title
	Setter( title:string )
		_title = title
	End

	Property Visible:bool()
		Return _visible
	Setter( visible:bool )
		_visible = visible
	End

	Property Alpha:float()
		Return _alpha
	Setter( alpha:float )
		_alpha = Clamp( alpha,  0.0, 1.0 )
	End

	Property GridX:int()
		Return _gridX
	Setter( gridX:int )
		_gridX = gridX
	End

	Property GridY:int()
		Return _gridY
	Setter( gridY:int )
		_gridY = gridY
	End

	Property ShowGrid:bool()
		Return _showGrid
	Setter( showGrid:bool )
		_showGrid = showGrid
	End

	method SetGrid( x:int,  y:int )
		If x &lt; 1 or y &lt; 1 Then Return
		
		_gridX = x
		_gridY = y
	End method

	'the offset is how many pixels the page is offset from the top left corner
	method SetOffset( x:float, y:float )
		_offsetX = x
		_offsetY = y
		OnRecalcLayout( x, y, _width, _height )
		App.RequestRender()
	End method

	'these next three methods give us the power to add and remove things from the stack
	method AddControl( control:UXControl )
		If Not control Then Return
		
		_controls.Add( control )
	End method
	
	method RemoveControl( control:UXControl )
		If Not control Then return

		_controls.Remove( control )
	End method

	method RemoveAllControls()
		For Local control := Eachin _controls
			RemoveControl( control )
		Next
	End method
	
	'when the main window is resized we will need to tell the page it has changed
	method OnRecalcLayout( x:int, y:int, width:int, height:int )
		_rect.X = 0
		_rect.Y = 0
		_rect.Right = width
		_rect.Bottom = height
		
		'set up the position of the page
		_x = x + _offsetX
		_x1 = _x + width -1
		_y = y + _offsetY
		_y1 = _y + height -1
		_width = width
		_height = height
		
		'set up the grid divisions
		_gridDivX = float(width) / _gridX
		_gridDivY = float(height) / _gridY
		_gridDivXHalf = _gridDivX * 0.5
		_gridDivYHalf = _gridDivY * 0.5
		'And the ui scaling
		_uiScale = _gridDivY / 80

		'go through each control and reset its position correctly
		LayoutControls()
	End method
	
	
	Method OnKeyEvent:bool( event:KeyEvent )
		'_currentControl is set by the mouse being over it
		If _currentControl and not _currentControl.Active Then Return False
		

'		Print "keyevent "

		Return false
	End method
	
	method RenderGrid( canvas:Canvas, x:int, y:int, width:int, height:int )
		canvas.Color = Color.Sky
		
		Local xx:float
		Local yy:float
		Local xp:float
		Local yp:float
		
		xx = 0
		xp = x
		Repeat
			canvas.DrawLine( xp, y, xp, y+height )
			xx += _gridDivX
			xp += _gridDivX
		Until xx &gt; width

		yy = 0
		yp = y
		Repeat
			canvas.DrawLine( x, yp, x+width, yp )
			yy += _gridDivY
			yp += _gridDivY
		Until yy &gt; height
	End method


	'we have come across OnRender before,  so lets use exact the same format
	'we draw the title of the page just for debug purposes
	method OnRender( canvas:Canvas )

		For Local control := Eachin _controls
			If control.Visible Then
				control.OnRender( canvas, _alpha )
			End If
		Next


		If _showGrid Then
			canvas.Viewport = _rect
			canvas.Alpha = _alpha
			RenderGrid( canvas, _x, _y, _width, _height )
			canvas.DrawText( _title, _x, _y )
		End If
	End method

	
	'render the grid which control align to
	Method OnMouseEvent:bool( event:MouseEvent )
		_mouseX = event.Location.X - _x
		_mouseY = event.Location.Y - _y
		_mouseOffsetX = _mouseX + _offsetX
		_mouseOffsetY = _mouseY + _offsetY
		If _mouseX &lt; 0 or _mouseY &lt; 0 or _mouseX &gt; _width or _mouseY &gt; _height Then
			NotOverControl()
			Return False
		End If

		'this returns the current control. or not. it does all the nasty stuff for us
		_currentControl = GetCurrentControl()
		If not _currentControl Then Return False
		
		'if the control has no user interaction,  then return
		If not _currentControl.Active Then Return False

		'now lets process all the mouse events
		if Not Mouse.ButtonDown( MouseButton.Left ) Then
			_mouseDown = False
'			_currentControl.MouseDown = False
		End if

		Select event.Type
			Case EventType.MouseDown
				_mouseDown = True
				_currentCapturedControl = _currentControl
				_currentControl.OnMouseDown( event, _mouseOffsetX - _currentControl.X, _mouseOffsetY - _currentControl.Y )
				_currentControl.MouseDown = True
				'wave to the Lambda
				_currentControl.ClickDown()
				event.Eat()
				App.RequestRender()
				Return True

			Case EventType.MouseUp
				'wave to the Lambda
				if _currentCapturedControl = _currentControl then
					_currentControl.Clicked()
				End if
				_mouseDown = False
				_currentCapturedControl = null
				_currentControl.OnMouseUp( _mouseOffsetX - _currentControl.X, _mouseOffsetY - _currentControl.Y )
				_currentControl.MouseDown = False
				App.RequestRender()
				Return true

			case EventType.MouseWheel
				If event.Wheel.Y &lt;&gt; 0 Then
					_currentControl.OnMouseWheel( event.Wheel.Y )
					event.Eat()
					App.RequestRender()
					Return true
				End If

			Case EventType.MouseEnter
				_currentControl.OnMouseEnter()
				event.Eat()
				App.RequestRender()
				Return True
				
			Case EventType.MouseLeave
				_currentControl.OnMouseLeave()
				_currentCapturedControl = Null
				NotOverControl()
				event.Eat()
				Return True

			Case EventType.MouseMove
				If _mouseX &lt; 0 or _mouseY &lt; 0 or _mouseX &gt; _width or _mouseY &gt; _height Then
					_currentControl.OnMouseLeave()
				Else
					_currentControl.OnMouseEnter()
				End If
				_currentControl.OnMouseMove( _mouseOffsetX - _currentControl.X, _mouseOffsetY - _currentControl.Y )
				event.Eat()
				App.RequestRender()
				Return true
		End Select
		
		Return False
	End method

protected
	'when we find a new control,  tell it we are over it
	method OverControl( control:UXControl )
		If control = _currentControl Then Return
		
		control.MouseOver = true

'		Print "found control "
		_currentControl = control
		App.RequestRender()
	End method
		
	'when we are not over a control, make the control we were over null, and tell it we arent over it anymore
	method NotOverControl()
		If not _currentControl Then Return
		
		_currentControl.MouseOver = false
		
'		Print "exit control"
		_currentControl = null
		App.RequestRender()
	End method


	'this goes (backwards) through the controls and checks if the mouse is over them.
	'  it returns the control the mouse is over
	method GetCurrentControl:UXControl()
		If _currentControl Then
			If not _currentControl.Active Then
				_currentControl = null
			Else	
	'			Print "checkStillOver "+_mouseOffsetX+" "+_mouseOffsetY+"   "+_currentControl.X+" "+_currentControl.Y
				If _mouseOffsetX &lt; _currentControl._rect.X or _mouseOffsetY &lt; _currentControl._rect.Y or _mouseOffsetX &gt; _currentControl._rect.Right or _mouseOffsetY &gt; _currentControl._rect.Bottom Then
					NotOverControl()
				Else	
					Return _currentControl
				End If
			End If
		End If

'		_currentControl = Null
		For Local control := Eachin _controls.Backwards()
			if _currentControl = Null and control.Visible Then
'				Print "control "+control.Text
				If control.Active Then
					If _mouseOffsetX &lt; control._rect.X or _mouseOffsetY &lt; control._rect.Y or _mouseOffsetX &gt; control._rect.Right or _mouseOffsetY &gt; control._rect.Bottom Then
						'we are not in this control
					Else
						'we are in this control
						OverControl( control )
						Return _currentControl
					End If
				End if
			End If
		Next

		Return Null
	End method
	
	
	'this goes through each control and reset its position correctly
	method LayoutControls()
		For Local control := Eachin _controls
			If control.Visible Then
				'send the control the page size information
				control.OnRecalcLayout( _x, _y, _width, _height, _gridDivX, _gridDivY )
			End If
		Next
	End method
	
private
	'the title of the page
	field _title:string
	
	'is the page visible
	field _visible:bool = True
	
	'what alpha does the page have
	field _alpha:float = 1
	
	'deal with mouse and keyboard events
	field _mouseX:int
	field _mouseY:int
	field _mouseOffsetX:int
	field _mouseOffsetY:int
	field _mouseDown:bool = False
	
	'what is the current control the mouse is over
	field _currentControl:UXControl = Null
	'when we press left mouse button we capture the current control
	field _currentCapturedControl:UXControl = Null
	
	' page offset from top left corner
	field _offsetX:float = 0
	field _offsetY:float = 0
	
	'the position of the page. this is recalculated by using OnRecalLayout
	field _x:int
	field _y:int
	field _x1:int
	field _y1:int
	field _width:int
	field _height:int
	
	field _rect:Recti = New Recti

	'the grid sizes for the page
	field _gridX:int = 12
	field _gridY:int = 8
	'and show the grid or not
	field _showGrid:bool = false

	'internal grid division calculated when screen resized. controls use grids for quick alignment
	field _gridDivX:float
	field _gridDivY:float
	field _gridDivXHalf:float
	field _gridDivYHalf:float
	field _uiScale:float

	'dont worry what a stack is. think of it as a collection of things. in this case UXControl
	Field _controls := New Stack&lt;UXControl&gt;
End Class

'And then we need a button. lets call it UXControl &lt; this will became clear a bit later
'border has now been added. A Border is a pixel offset from the edges inward. default is 2
class UXControl
	'these fields with void() are linked internally by the compiler to Lambdas &lt;- WTF????
	' ok Lambdas are nothing to get worried about. they are callers
	' think of a control having a flag. and that flag can wave at a Lambda with it's name on
	'the lambdas (which appear in the main program start waving. and you do somehting when they wave

	'clickdown is triggered when the mouse is clicked down in a control
	field ClickDown:void()
	'clicked is when a button is realsed
	field Clicked:void()

	Method New()
	End

	Property Visible:bool()
		Return _visible
	Setter( visible:bool )
		_visible = visible
	End

	Property Active:bool()
		Return _active
	Setter( active:bool )
		_active = active
	End

	Property MouseOver:bool()
		Return _mouseOver
	Setter( mouseOver:bool )
		_mouseOver = mouseOver
	End

	Property MouseDown:bool()
		Return _mouseDown
	Setter( mouseDown:bool )
		_mouseDown = mouseDown
	End

	Property Border:float()
		Return _border
	Setter( border:float )
		_border = border
		RecalcBorder()
	End

	Property Alpha:float()
		Return _alpha
	Setter( alpha:float )
		_alpha = alpha
	End

	'both BGImage And FGImage are not specifically set to be used
	' just the actual code is here so any derrived classes can simply use it
	Property BGColor:Color() Virtual
		Return _BGColor
	Setter( bgColor:Color ) Virtual
		_BGColor = bgColor
	End

	Property FGColor:Color() Virtual
		Return _FGColor
	Setter( fgColor:Color ) Virtual
		_FGColor = fgColor
	End

	Property BGImage:Image()
		Return _BGImage
	Setter( bgImage:Image )
		_BGImage = bgImage
	End

	'as we have a new text string. lets give it a property	
	Property Text:string()
		Return _text
	Setter( text:string )
		_text = text
	End

	Property TextAlign:int() Virtual
		Return _textAlign
	Setter( textAlign:int ) virtual
		_textAlign = textAlign
	End

	Property TextColor:Color()
		Return _textColor
	Setter( textColor:Color )
		_textColor = textColor
	End

	property TextFont:Font()
		Return _textFont
	Setter( textFont:Font )
		_textFont = textFont
	End

	Property TextBold:bool()
		Return _textBold
	Setter( textBold:bool )
		_textBold = textBold
	End

	Property ImageColor:Color()
		Return _imageColor
	Setter( imageColor:Color )
		_imageColor = imageColor
	End

	Property FGImage:Image()
		Return _FGImage
	Setter( fgImage:Image )
		_FGImage = fgImage
	End

	Property X:float()
		Return _x
	End

	Property Y:float()
		Return _y
	End

	Property X1:float()
		Return _x1
	End

	Property Y1:float()
		Return _y1
	End
	
	Property BX:float()
		Return _bx
	End

	Property BY:float()
		Return _by
	End

	Property BX1:float()
		Return _bx1
	End

	Property BY1:float()
		Return _by1
	End

	'set the position of the control in grid steps
	method SetGridLayout( x:float, y:float, width:float, height:float )
		_gridX = x
		_gridY = y
		_gridWidth = Clamp( width, 1.0, 512.0 )
		_gridHeight = Clamp( height, 1.0, 512.0 )
	End method
	

	'the virtual command means we are going to use these as a forward reference
	' dont be alarmed if you don't understand what I mean.
	' it will become very clear when we create other controls using this as a base
	' (that is why the page and control classes are sooooo complex)
	
	'a control have a background - if we want it
	method RenderBackground( canvas:Canvas, alpha:float ) Virtual
	End method

	'a foreground - that looks like a simple button,  but we can change this if we want
	' usually most of the drawing will be done here
	' perviously we used _x, _y, _width, _height,  we now use _bx, _by, _bwidth, _bheight
	method RenderForeground( canvas:Canvas, alpha:float ) Virtual
		If _BGColor &lt;&gt; Color.None Then
			canvas.Color = _BGColor
			canvas.DrawRect( _x, _y, _width, _height )
		End If

		canvas.Color = _FGColor
		canvas.DrawRect( _bx, _by, _bwidth, _bheight )
		
		If Not _mouseOver Then Return
		
		canvas.Color = Color.Sky
		If _mouseDown Then
			canvas.Alpha = alpha
		Else
			canvas.Alpha = alpha * 0.75
		End If
		canvas.DrawRect( _bx, _by, _bwidth, _bheight )
	End method

	'and finally a top - which is drawn last
	method RenderTop( canvas:Canvas, alpha:float ) Virtual
	End method
	
	'this calls the individual part which make up a control: back, front and top
	method OnRender( canvas:Canvas, alpha:float ) Virtual
		If Visible Then
'			Print _rect.X+" "+_rect.Right
			canvas.Viewport = _rect
'			canvas.DrawRect(0, 0, 10, 10)
		End If
		
		canvas.Alpha = alpha * _alpha
		RenderBackground( canvas, alpha )
		
		RenderForeground( canvas, alpha )

		RenderTop( canvas, alpha )
	End method

	'virtual call for proper drawing of text so we can override it later if we want to
	method OnDrawText( canvas:Canvas, x:int, y:int, width:int, height:int, text:string, align:int ) virtual
		If _textBold Then
			DrawTextBold( canvas, x, y, width, height, text, align, _textFont )
		Else
			DrawText( canvas, x, y, width, height, text, align, _textFont )
		End If
	End method

	'more virtual stuff. the mouse routines now have correct mouseX and mouseY transferred
	method OnMouseEnter() virtual
	End method

	method OnMouseLeave() virtual
	End method

	method OnMouseDown( event:MouseEvent, mouseX:int, mouseY:int  ) Virtual
	End method
	
	method OnMouseUp( mouseX:int, mouseY:int ) Virtual
	End method

	method OnMouseMove( mouseX:int, mouseY:int ) Virtual
	End method

	method OnMouseWheel( wheel:int ) Virtual
	End method

	method Initialize() virtual
	End method
	
protected	
	'the variables have been moved from private to protected
	'private vars cant be access from extended classes
	'protected ones can. so we move the private to protected
	
	'is the control shown. is it visible or not
	field _visible:bool = True
	
	'does the control use user input. things like panels are not active don't track the mouse
	field _active:bool = True
	
	'is the mouse over the control
	field _mouseOver:bool = false
	field _mouseDown:bool = false

	'basic layout dimentions
	field _x:float = 0
	field _y:float = 0
	field _x1:float = 0
	field _y1:float = 0
	field _width:float
	field _height:float
	field _midX:float
	field _midY:float
	
	'border vars
	'these are the same as the layout dimentions with a border inset a certain number of pixels
	field _border:float = 2
	field _bx:float
	field _by:float
	field _bx1:float
	field _by1:float
	field _bwidth:float
	field _bheight:float
	
	'grid vars
	field _gridX:float
	field _gridY:float
	field _gridWidth:float
	field _gridHeight:float

	'image vars
	field _BGImage:Image
	field _FGImage:Image

	'color vars
	field _BGColor:Color = Null
	field _FGColor:Color = Color.DarkGrey
	field _imageColor:Color = Color.White
	field _alpha:float = 1
	
	'internal drawing rect
	field _realX:float
	field _realY:float
	field _rect:Recti = new Recti

	'text vars
	field _textColor:Color = Color.White
	field _text:string = ""
	field _textFont:Font = App.DefaultFont
	field _textAlign:int = ALIGN_CENTERED
	field _textBold:bool = false


	method OnRecalcLayout( x:float, y:float, width:float, height:float, gridDivX:float, gridDivY:float )
		_realX = x + ( _gridX * gridDivX )
		_realY = y + ( _gridY * gridDivY )
		_width = _gridWidth * gridDivX
		_height = _gridHeight * gridDivY
		
		RecalcBorder()
	End method
	
	method RecalcBorder()
		_x = 0
		_y = 0
		_x1 = _x + _width
		_y1 = _y + _height

		_midX = (_x + _x1) * 0.5
		_midY = (_y + _y1) * 0.5
		

		_bx = _x + _border
		_by = _y + _border
		_bx1 = _x1 - _border
		_by1 = _y1 - _border
		
		_bwidth = _bx1 - _bx
		_bheight = _by1 - _by
		
		_rect.X = _realX
		_rect.Y = _realY
		_rect.Right = _realX + _width
		_rect.Bottom = _realY + _height
	End method

private
End Class


</textarea><br><br><br>GameUIExtras.monkey2<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Namespace GameUI
Using GameUI

#Import "&lt;std&gt;"



'ok blitzmax rotations were in degrees - simple ;)
'monkey2 reverts back to radians,  so we need a conversion
'so here is the best and quickest conversion I could come up with ;)
const Pi180:double = Pi / 180
function DegreesToRadian:float( degrees:float )
	return degrees * Pi180
End function
'and we will need another to revrse the process
function RadianToDegrees:float( radian:float )
	return radian / Pi180
End function


'monkey does not have any circle drawing routines,  so here is a basic one
function DrawCircle( canvas:Canvas, xc:float, yc:float, radiusX:float, radiusY:float )
	Local div:float = DegreesToRadian( 5 )
	
	Local angle:float = div
	Local xp0:float
	Local yp0:float
	Local xp1:float = xc + radiusX
	Local yp1:float = yc
	Local k:int
	
	For k = 5 To 360 Step 5
		xp0 = xc + Cos( angle ) * radiusX
		yp0 = yc + Sin( angle ) * radiusY
		canvas.DrawLine( xp0, yp0, xp1, yp1 )
		
		xp1 = xp0
		yp1 = yp0
		angle += div
	Next
End function

'monkey does not have any circle drawing routines.
'here is one that draws dashed lines
function DrawCircleDash( canvas:Canvas, xc:float, yc:float, radiusX:float, radiusY:float )
	Local div:float = DegreesToRadian( 5 )
	
	Local angle:float = div
	Local xp0:float
	Local yp0:float
	Local xp1:float = xc + radiusX
	Local yp1:float = yc
	Local k:int
	
	For k = 5 To 360 Step 5
		xp0 = xc + Cos( angle ) * radiusX
		yp0 = yc + Sin( angle ) * radiusY
		If k Mod 10 = 0 Then
			canvas.DrawLine( xp0, yp0, xp1, yp1 )
		End If
		
		xp1 = xp0
		yp1 = yp0
		angle += div
	Next
End function

'now we have seperated the front from the back drawing,  we can use these with the new depth sorting
function DrawCircleDashFront( canvas:Canvas, xc:float, yc:float, radiusX:float, radiusY:float )
	Local div:float = DegreesToRadian( 5 )
	
	Local angle:float = div
	Local xp0:float
	Local yp0:float
	Local xp1:float = xc + radiusX
	Local yp1:float = yc
	Local k:int
	
	For k = 5 To 180 Step 5
		xp0 = xc + Cos( angle ) * radiusX
		yp0 = yc + Sin( angle ) * radiusY
		If k Mod 10 = 0 Then
			canvas.DrawLine( xp0, yp0, xp1, yp1 )
		End If
		
		xp1 = xp0
		yp1 = yp0
		angle += div
	Next
End function

function DrawCircleDashBack( canvas:Canvas, xc:float, yc:float, radiusX:float, radiusY:float )
	Local div:float = DegreesToRadian( 5 )
	
	Local angle:float = DegreesToRadian( 185 )
	Local xp0:float
	Local yp0:float
	Local xp1:float = xc + Cos( 180 ) * radiusX
	Local yp1:float = yc + Sin( 180 ) * radiusY
	Local k:int
	
	For k = 185 To 360 Step 5
		xp0 = xc + Cos( angle ) * radiusX
		yp0 = yc + Sin( angle ) * radiusY
		If k Mod 10 = 0 Then
			canvas.DrawLine( xp0, yp0, xp1, yp1 )
		End If
		
		xp1 = xp0
		yp1 = yp0
		angle += div
	Next
End function

function DrawFrame( canvas:Canvas, x:Float,y:Float,w:Float,h:Float )
	Local x0 := x
	Local y0 := y
	Local x1 := x+w-1
	Local y1 := y+h-1
		
	canvas.DrawLine( x0, y0, x1, y0 )
	canvas.DrawLine( x1, y0, x1, y1 )
	canvas.DrawLine( x1, y1, x0, y1 )
	canvas.DrawLine( x0, y1, x0, y0 )
End

'a new function to get the correct alignment for text. notice that it uses Font
'this will allow us to use custom fonts in the future
'the alignments are the new const vars we added above
'then we feed a rectangle, the text, and an alignment
'it will return the correct x,y position for the text
function SetTextAlign( x:int, y:int, width:int, height:int, text:string, textAlign:int, font:Font = App.DefaultFont )
	local textWidth:int = font.TextWidth( text )
	local textHeight:int = font.Height
	g_TextLeft = x
	g_TextTop = y
	
	If textAlign &amp; ALIGN_RIGHT = ALIGN_RIGHT Then
		g_TextLeft += width - textWidth
'		Print "right"
	Else If textAlign &amp; ALIGN_MIDDLE = ALIGN_MIDDLE Then
		g_TextLeft += (width - textWidth) * 0.5
'		Print "middle"
	Else
'		Print "left"
	End If
	
	If textAlign &amp; VALIGN_BOTTOM = VALIGN_BOTTOM Then
		g_TextTop = y + height - textHeight
	Else If textAlign &amp; VALIGN_CENTER = VALIGN_MIDDLE Then
		g_TextTop = y + (height - textHeight) * 0.5
	End If
End function

'here we draw the text using a canvas and the new alignment system
function DrawText( canvas:Canvas, x:int, y:int, width:int, height:int, text:string, textAlign:int, font:Font = App.DefaultFont )
	canvas.Font = font
	
	SetTextAlign( x, y, width, height, text, textAlign, font )
	canvas.DrawText( text, g_TextLeft, g_TextTop )
End function

'and another that fakes boldtext
function DrawTextBold( canvas:Canvas, x:int, y:int, width:int, height:int, text:string, textAlign:int, font:Font = App.DefaultFont )
	canvas.Font = font
	
	SetTextAlign( x, y, width, height, text, textAlign, font )
	canvas.DrawText( text, g_TextLeft, g_TextTop )
	canvas.DrawText( text, g_TextLeft+1, g_TextTop )
End function


</textarea><br><br><br>and finally the controls: GameUIBaseControls.monkey2<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Namespace GameUI
Using GameUI

#Import "&lt;std&gt;"



class UXButton Extends UXControl
	'if we dont give it any variables - deal with this
	method New( )
		_text = "Button"
	End method

	'we really would like a button the show some text
	'so when we New it lets give it some text
	method New( text:string )
		_text = text
	End method

	'lets draw the text on top of any forground and selection,  down etc
	' as the original is vertual we must override it
	method RenderTop( canvas:Canvas, alpha:float ) Override
		'and now draw some text
		canvas.Color = _textColor
		canvas.Alpha = alpha
		
		'lets make the text drop by 1 pixel when clicked
		'now we are going to use the new drawtext we wrote
		If _mouseDown Then
'			canvas.DrawText( _text, _bx, _by + _border )
			OnDrawText( canvas, _bx, _by + 1, _bwidth, _bheight, _text, _textAlign )
			
		Else
'			canvas.DrawText( _text, _bx, _by )
			OnDrawText( canvas, _bx, _by, _bwidth, _bheight, _text, _textAlign )
		End If
	End method
	
private
End Class


'lets do the same with an image
class UXImageButton Extends UXControl
	'if we dont give it any variables - deal with this
	method New( )
		Initialize()
	End method

	'we really would like a button the show and image
	'so when we New it lets give it one
	method New( image:Image )
		If Not image Then Print "ERROR LOADING IMAGE"
		_FGImage = image
		
		Initialize()
	End method

	'we really would like a button the show and image
	'so when we New it lets give it one
	method New( text:String, image:Image )
		If Not image Then Print "ERROR LOADING IMAGE"
		_FGImage = image
		_text = text
		
		Initialize()
	End method

	'we dont want to draw the fgbackground rect,  so lets remove it
	method RenderForeground( canvas:Canvas, alpha:float ) Override
		If _FGColor &lt;&gt; Color.None Then
			If _mouseOver Then
				canvas.Color = Color.Sky
				canvas.Alpha = alpha * 0.8
			Else
				canvas.Color = _FGColor
				canvas.Alpha = alpha * 0.6
			End If
			canvas.DrawRect( _bx, _by, _bwidth, _bheight )
		End if
		
		If Not _mouseOver Then Return
	End method

	'lets draw the text on top of any forground and selection,  down etc
	' as the original is vertual we must override it
	method RenderTop( canvas:Canvas, alpha:float ) Override
		'make sure we check the image is valid
		If _FGImage Then
			'and now draw the image,  with different color if the mouse is over
			If _FGColor &lt;&gt; Color.None Then
				canvas.Color = _imageColor
				canvas.Alpha = alpha * 0.6
			Else
				If _mouseOver Then
					canvas.Color = Color.Sky
					canvas.Alpha = alpha * 0.8
				Else
					canvas.Color = _imageColor
					canvas.Alpha = alpha * 0.6
				End If
			End If
		
			'and drop it when clicked
			Local ypos:int = _by
			If _mouseDown Then
				ypos += _border
			End If

			'this is a new way to draw images. using a rect
			canvas.DrawRect( _bx, ypos, _bwidth, _bheight, _FGImage )
		End if

		If _text =  "" then return
		
		'and now draw some text
		canvas.Color = _textColor
		canvas.Alpha = alpha
		
		'lets make the text drop by 1 pixel when clicked
		'now we are going to use the new drawtext we wrote
		If _mouseDown Then
'			canvas.DrawText( _text, _bx, _by + _border )
			OnDrawText( canvas, _bx, _by + 1, _bwidth, _bheight, _text, _textAlign )
			
		Else
'			canvas.DrawText( _text, _bx, _by )
			OnDrawText( canvas, _bx, _by, _bwidth, _bheight, _text, _textAlign )
		End If
	End method
	
private
	method Initialize() Override
		Border = 0
		_FGColor = Color.None
	End method
End Class

'and now a color panel
'lets do the same with an image
class UXPanel Extends UXControl
	'if we dont give it any variables - deal with this
	method New( )
		'do any setup the panel might need
		Initialize()
	End method

	'we really would like a button the show and image
	'so when we New it lets give it one
	method New( image:Image )
		If Not image Then Print "ERROR LOADING IMAGE"
		_FGImage = image
		_FGColor = Color.None
		'do any setup the panel might need
		Initialize()
	End method

	'we really would like a button the show and image
	'so when we New it lets give it one
	method New( image:Image, color:Color )
		If Not image Then Print "ERROR LOADING IMAGE"
		_FGImage = image
		_imageColor = color
		'do any setup the panel might need
		Initialize()
	End method

	'we really would like a button the show and image
	'so when we New it lets give it one
	method New( color:Color )
		_FGColor = color
		'do any setup the panel might need
		Initialize()
	End method

	'we dont want to draw the fgbackground rect,  so lets remove it
	method RenderForeground( canvas:Canvas, alpha:float ) Override
		If FGColor = Null or FGColor = Color.None Then
		Else
			canvas.Color = _FGColor
			canvas.DrawRect( _bx, _by, _bwidth, _bheight )
		End If

		If Not _FGImage Then Return
		
		If _imageColor = Color.None or _imageColor = Null Then
		Else
			canvas.Color = _imageColor
			'this is a new way to draw images. using a rect
			canvas.DrawRect( _bx, _by, _bwidth, _bheight, _FGImage )
		End If
	End method

private
	method Initialize() Override
		Active = false
		Border = 0
		Text = "Panel"
	End method
End Class

'and while we are at it lets have some text
'and now a color panel
'lets do the same with an image
class UXText Extends UXControl
	'so when we New it lets give it some text
	method New( text:string )
		_text = text
		_textColor = Color.White
		
		'do any setup the panel might need
		Initialize()
	End method


	'so when we New it lets give it some text and a color
	method New( text:string, color:Color )
		_text = text
		_textColor = color
		
		'do any setup the panel might need
		Initialize()
	End method

	'we dont want to draw the fgbackground rect,  so lets remove it
	method RenderForeground( canvas:Canvas, alpha:float ) Override
		'and now draw some text
		canvas.Color = _textColor
		canvas.Alpha = alpha

		'And some text Using the New text drawing we have written
		OnDrawText( canvas, _bx, _by, _bwidth, _bheight, _text, _textAlign )
	End method

private
	method Initialize() Override
		Active = false
	End method
End Class
</textarea><br><br><br>Now we need a demo...<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">


'namespace is what we call the app.
'Other files with the same namespace will behave as if they are a single unified file
Namespace myLetterboxApp

#Import "&lt;std&gt;"
#Import "&lt;mojo&gt;"
Using std..
Using mojo..


'we are not going to have any OnMouse or OnKeypress,  but pass the data into the gameui so it can deal with it for us
'We are just going To focus on the UI

'ok. now we Import the brand new UI base code
#import "gameui"


'import any assets like images
#Import "assets/chit1.png"

'the size of our basic window
Const Size := New Vec2i( 950,720 )

'And now some constants
const PAGE_PANELS:int = 1
const PAGE_BUTTONS:int = 2
const PAGE_IMAGEBUTTONS:int = 3


Function Main()
	New AppInstance
	
	New MyWindow
	
	App.Run()
End


'this is the core class the new app is based from. it is a window!
Class MyWindow Extends Window

	
	Method New()
		Super.New( "My Window", Size.X, Size.Y, WindowFlags.Resizable )
	
		Layout = "fill"
		
		'load an images
		Local chitImage1:Image = Image.Load( "asset::chit1.png" )
		

		'first we need a Page
		' the page MUST have it's layout called when the size of the window changes
		' this is done in OnRender
		Page = new UXPageView( "The page wot I created" )
		'set a grid size 16, 12 seems good. but this is terribly flexible
		Page.SetGrid( 24, 18 )
		' and show the pages grid. try commenting this on/off out so you can see how the grid works
		' also try moving the window size and see what happens....
'		Page.ShowGrid = True
		
		
		'NEW we have now created a class based on uxcontrol,  so lets use it
			local text1:UXText = New UXText( "Lesson 1" )
			text1.SetGridLayout( 1, 0, 3, 1 )
			Page.AddControl( text1 )

			local button1:UXButton = New UXButton( "Panels" )
			button1.SetGridLayout( 1, 1, 3, 1 )
			'lamdbas are a way of the controls waving back at us and say do this code
			'in this case 'clicked means you have clicked the button with the mouse
			button1.Clicked = Lambda()
				Print "Button 1 clicked"
				_currentPage = PAGE_PANELS
				RequestRender()
			End
			Page.AddControl( button1 )
			
			'lesson 2 title and text
			local text2:UXText = New UXText( "Lesson 2" )
			text2.SetGridLayout( 5, 0, 3, 1 )
			Page.AddControl( text2 )

			local button2:UXButton = New UXButton( "Buttons" )
			button2.SetGridLayout( 5, 1, 3, 1 )
			button2.Clicked = Lambda()
				Print "Button 2 clicked"
				_currentPage = PAGE_BUTTONS
				RequestRender()
			End
			Page.AddControl( button2 )

			'lesson 3 title and text
			local text32:UXText = New UXText( "Lesson 3" )
			text32.SetGridLayout( 9, 0, 3, 1 )
			Page.AddControl( text32 )

			local button32:UXButton = New UXButton( "ImageButtons" )
			button32.SetGridLayout( 9, 1, 3, 1 )
			button32.Clicked = Lambda()
				Print "Button 2 clicked"
				_currentPage = PAGE_IMAGEBUTTONS
				RequestRender()
			End
			Page.AddControl( button32 )

			local text3:UXText = New UXText( "Show the Pages grid (24x18)" )
			text3.SetGridLayout( 17, 0, 6, 1 )
			Page.AddControl( text3 )

			local button3:UXButton = New UXButton( "ShowGrid" )
			button3.SetGridLayout( 17, 1, 3, 1 )
			button3.Clicked = Lambda()
				Page.ShowGrid = True
				RequestRender()
			End
			Page.AddControl( button3 )
			
			local button4:UXButton = New UXButton( "HideGrid" )
			button4.SetGridLayout( 20, 1, 3, 1 )
			button4.Clicked = Lambda()
				Page.ShowGrid = false
				RequestRender()
			End
			Page.AddControl( button4 )

			local text4:UXText = New UXText( "All controls fit to the grid" )
			text4.SetGridLayout( 17, 2, 6, 1 )
			Page.AddControl( text4 )


			'we are now going to set up some more pages
			'The first lesson is all about panels
			PagePanels = new UXPageView("panels page")
			'we are going to use the same grid as the first page
			PagePanels.SetGrid( 24, 18 )
			
			'and now some text and some panels for lesson 1
			local panelText1:UXText = New UXText( "Panels have no user interaction, and have a color,  and Alpha" )
			panelText1.SetGridLayout( 1, 3, 15, 1 )
			'alignment goes updown then leftright,  so MIDDLELEFT is in the middle of the y and aligned to the left
			panelText1.TextAlign = ALIGN_MIDDLELEFT
			PagePanels.AddControl( panelText1 )

			local panel1:UXPanel = New UXPanel( Color.Red )
			panel1.SetGridLayout( 1, 5, 5, 2 )
			PagePanels.AddControl( panel1 )

			local panel2:UXPanel = New UXPanel( Color.Blue )
			panel2.SetGridLayout( 3, 4, 1, 4 )
			panel2.Alpha = 0.5
			PagePanels.AddControl( panel2 )

			local panelText2:UXText = New UXText( "Panels can also have images as background... oooh!" )
			panelText2.SetGridLayout( 1, 8, 15, 1 )
			panelText2.TextAlign = ALIGN_MIDDLELEFT
			PagePanels.AddControl( panelText2 )

			local panel3:UXPanel = New UXPanel( chitImage1 )
			panel3.SetGridLayout( 1, 9, 5, 2 )
			PagePanels.AddControl( panel3 )

			local panelText3:UXText = New UXText( "Or even both image and color!" )
			panelText3.SetGridLayout( 1, 11, 15, 1 )
			panelText3.TextAlign = ALIGN_MIDDLELEFT
			PagePanels.AddControl( panelText3 )

			local panel4:UXPanel = New UXPanel( chitImage1 )
			panel4.SetGridLayout( 1, 12, 5, 2 )
			'FGColor is the color of the panel. Color.None is no color
			panel4.FGColor = Color.Brown
			PagePanels.AddControl( panel4 )

			local panelText4:UXText = New UXText( "Or even different colors!" )
			panelText4.SetGridLayout( 1, 14, 15, 1 )
			panelText4.TextAlign = ALIGN_MIDDLELEFT
			PagePanels.AddControl( panelText4 )

			local panel5:UXPanel = New UXPanel( chitImage1 )
			panel5.SetGridLayout( 1, 15, 5, 2 )
			panel5.FGColor = Color.Steel
			'by default the color of the image is white,  but we can use different colors too
			panel5.ImageColor = Color.Yellow
			PagePanels.AddControl( panel5 )
			
			
			
			'the second lesson is all about buttons
			PageButtons = new UXPageView("buttons page")
			'we are going to use the same grid as the first page
			PageButtons.SetGrid( 24, 18 )

			local buttonText1:UXText = New UXText( "Buttons are nice and simple,  clicky things. We Use Lambdas to tell us they have been clicked" )
			buttonText1.SetGridLayout( 1, 3, 20, 1 )
			buttonText1.TextAlign = ALIGN_MIDDLELEFT
			PageButtons.AddControl( buttonText1 )

			local pageButton1:UXButton = New UXButton( "Click" )
			pageButton1.SetGridLayout( 1, 4,  3, 1 )
			PageButtons.AddControl( pageButton1 )

			local pageButton2:UXButton = New UXButton( "Click" )
			pageButton2.SetGridLayout( 5, 4,  1, 2 )
			PageButtons.AddControl( pageButton2 )

			local pageButton3:UXButton = New UXButton( "Click" )
			pageButton3.SetGridLayout( 8, 4,  2, 2 )
			PageButtons.AddControl( pageButton3 )

			local buttonText2:UXText = New UXText( "we can change the color of the button and the text" )
			buttonText2.SetGridLayout( 1, 7, 20, 1 )
			buttonText2.TextAlign = ALIGN_MIDDLELEFT
			PageButtons.AddControl( buttonText2 )

			local pageButton4:UXButton = New UXButton( "Sausages" )
			pageButton4.SetGridLayout( 1, 8,  5, 1 )
			pageButton4.FGColor = Color.Skin
			PageButtons.AddControl( pageButton4 )

			local pageButton5:UXButton = New UXButton( "EGGS" )
			pageButton5.SetGridLayout( 8, 8,  2, 2 )
			pageButton5.FGColor = Color.White
			pageButton5.TextColor = Color.Orange
			PageButtons.AddControl( pageButton5 )



			'the third lesson is all about imagebuttons
			PageImageButtons = new UXPageView("imageButtons page")
			'we are going to use the same grid as the first page
			PageImageButtons.SetGrid( 24, 18 )

			local imageText1:UXText = New UXText( "UXImageButtons are the same as UXButton,  but with images instead of text" )
			imageText1.SetGridLayout( 1, 3, 20, 1 )
			imageText1.TextAlign = ALIGN_MIDDLELEFT
			PageImageButtons.AddControl( imageText1 )

			local imageButton1:UXImageButton = New UXImageButton( chitImage1 )
			imageButton1.SetGridLayout( 1, 4,  3, 1 )
			PageImageButtons.AddControl( imageButton1 )

			local imageButton2:UXImageButton = New UXImageButton( chitImage1 )
			imageButton2.SetGridLayout( 5, 4,  1, 2 )
			PageImageButtons.AddControl( imageButton2 )

			local imageButton3:UXImageButton = New UXImageButton( chitImage1 )
			imageButton3.SetGridLayout( 8, 4,  2, 2 )
			PageImageButtons.AddControl( imageButton3 )

			local imageText2:UXText = New UXText( "you can set a FGColor to show the button" )
			imageText2.SetGridLayout( 1, 6, 20, 1 )
			imageText2.TextAlign = ALIGN_MIDDLELEFT
			PageImageButtons.AddControl( imageText2 )

			local imageButton4:UXImageButton = New UXImageButton( chitImage1 )
			imageButton4.SetGridLayout( 1, 7,  3, 1 )
			imageButton4.FGColor = Color.Grey
			PageImageButtons.AddControl( imageButton4 )

			local imageButton5:UXImageButton = New UXImageButton( chitImage1 )
			imageButton5.SetGridLayout( 5, 7,  1, 2 )
			imageButton5.FGColor = Color.Red
			PageImageButtons.AddControl( imageButton5 )

			local imageButton6:UXImageButton = New UXImageButton( chitImage1 )
			imageButton6.SetGridLayout( 8, 7,  2, 2 )
			imageButton6.FGColor = Color.Blue
			PageImageButtons.AddControl( imageButton6 )
	End

protected
	Method OnRender( canvas:Canvas ) Override
		'set up a measure that will recalculate if the window is resized
		If _width &lt;&gt; Width or _height &lt;&gt; Height Then
			
			'The Page Must be laid out
			Page.OnRecalcLayout( 0, 0, Width, Height )
			
			'make sure we lay out the other pages as well
			PagePanels.OnRecalcLayout( 0, 0, Width, Height )
			PageButtons.OnRecalcLayout( 0, 0, Width, Height )
			PageImageButtons.OnRecalcLayout( 0, 0, Width, Height )
			
			_width = Width
			_height = Height
		End if

		'give the window a black color
		canvas.Alpha = 1
		canvas.Color = Color.Black
		canvas.DrawRect( 0, 0, Width, Height )
		
		'draw the page and controls
		Page.OnRender( canvas )

		'depending on what lesson we want, show the correct lesson page
		Select _currentPage
			Case PAGE_PANELS
				PagePanels.OnRender( canvas )
			Case PAGE_BUTTONS
				PageButtons.OnRender( canvas )
			Case PAGE_IMAGEBUTTONS
				PageImageButtons.OnRender( canvas )
		End Select
	End

	
	'respond to any key presses by passing them into the gameui
	Method OnKeyEvent( event:KeyEvent ) Override
		'send key stuff to the new page controls and exit if handled
		if Page.OnKeyEvent( event ) then Return
	End method

	'here we track the mouse and all mouse related stuff
	Method OnMouseEvent( event:MouseEvent ) Override
		'send mouse stuff to the new page controls. and exit if handled
		'the buttons page is layer on top of the Page,  so we deal with that first
		Select _currentPage
			Case PAGE_BUTTONS
				if PageButtons.OnMouseEvent( event ) Then Return
			Case PAGE_IMAGEBUTTONS
				if PageImageButtons.OnMouseEvent( event ) Then Return
		End Select
		
		'and now the Page
		if Page.OnMouseEvent( event ) Then return
	End method

	
	'this is needed to allow the Size to be correct. this is called automatically
	Method OnMeasure:Vec2i() Override
		Return Size
	End
private
	'set up the page to hold our controls for the lessons
	field Page:UXPageView
	
	'and now some more pages for the lessons
	field PagePanels:UXPageView
	field PageButtons:UXPageView
	field PageImageButtons:UXPageView
	
	'and now a variableto decide which page to show
	field _currentPage:int = PAGE_PANELS

	'global window size to track when window has changed
	field _width:int = 0
	field _height:int = 0
	
End

</textarea><br><br>Have a play and then have a look at this source. notice how it operates?<br>There is no processing, just set up each control, where it lives and any other  bits we might want. and it just does it. I've sorted out virtually all the nasty stuff for us...<br><br>it is arranged into three lessons, with 4 pages. 3 of which are dynamically shown and hidden as needed.<br><br>The best thing I can suggest is to have a play around with this and get a feel for it.<br><br>Also. UI design is not the simplest thing. there is always lots of setting up and stuff like that. but... <br><br></td></tr></table><br>
<a name="1339730"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#162">[#162]</a></td></tr></table></td></tr><tr ><td class="posttext"> Page.ShowGrid = false<br>RequestRender()<br>...<br><br>I would suggest do use setters (showGrid(falae)).<br><br>As soon as a setter changes something (so it was not false before) you mark the widget as "dirty".<br><br>If a widget is dirty then a render is requested. That way you could handle multiple things in ine turn without multiple renderrequests..<br>If you do not do partial rendering (only area of a widget) you could also have "dirty" stored globally for all widgets in the uxmanager class.<br><br><br>PS: good to see sources split into files. This will ease to follow the changes in the main project.<br><br><br><br>Bye<br>Ron <br><br></td></tr></table><br>
<a name="1339731"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#163">[#163]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok. I've been brainstorming<br><br>1. the galaxy has 256 solar systems<br>2. each solar system is unique<br>3. there are 7 factions, each based in a home solar system<br>4. the central system is also present and generally where you start. But you could align yourself to anyone of the 7 factions and start there instead<br><br>5. The other solarsytems are unknown, and you can't visit them when you start<br><br>I will see about giving factions colors and icons and also see about spreading outwards from each home system. that way we could have potential systems that have more than one faction, and therefore possibly have trouble... <br><br></td></tr></table><br>
<a name="1339733"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#164">[#164]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here's a shot of the galaxy map showing the location of the seven factions and the center.<br><br>The colors are also correct. with grey being a system that has no dominant faction.<br><br>There is also a work in progress UI<br><br><img src="https://vjointeractive.files.wordpress.com/2017/04/screen-shot-2017-04-27-at-15-27-20.png"> <br><br></td></tr></table><br>
<a name="1339754"></a>

<a name="1339755"></a>

<a name="1339756"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >skidracer</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#165">[#165]</a></td></tr></table></td></tr><tr ><td class="posttext"> Mainsworthy, what do you mean by pass a mouse event?<br><br>Typically, as an application, you catch events. <br><br></td></tr></table><br>
<a name="1339758"></a>

<a name="1339762"></a>

<a name="1339764"></a>

<a name="1339768"></a>

<a name="1339769"></a>

<a name="1339791"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#166">[#166]</a></td></tr></table></td></tr><tr ><td class="posttext"> @skidracer,  I know its simple, will get it soon, Ive only been at this a couple of days.<br><br><br>@Adam thankyou for those Apps, I am going to look in a little while, .<br><br>@Derron your like the sound of a Air traffic controller guideing us in :) <br><br></td></tr></table><br>
<a name="1339792"></a>

<a name="1339796"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#167">[#167]</a></td></tr></table></td></tr><tr ><td class="posttext"> code box wont let me post,<br><br>what I've done is put a switch on one of your buttons to allow normal UIs to coexist, I know this isn't what you intended with your UI, but 2 UIs are better than one :) it seems to work fine. maybe you could extend a class for this aswell.. <br><br>don't worry as always my code is not for use. <br><br></td></tr></table><br>
<a name="1339797"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#168">[#168]</a></td></tr></table></td></tr><tr ><td class="posttext"> Possibly this is now too long. lets start a new one... <br><br></td></tr></table><br>
<a name="1339798"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#169">[#169]</a></td></tr></table></td></tr><tr ><td class="posttext"> I got your buttons incorporated now, deleted most screen capture events, that button app is great , it scared me when I first saw it, but moving buttons around is a doddle.<br><br>codebox dosnt work in a n empty thread either <br><br></td></tr></table><br>
<a name="1339799"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#170">[#170]</a></td></tr></table></td></tr><tr ><td class="posttext"> Your the leader, you should start the thread . <br><br></td></tr></table><br>
<a name="1339800"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#171">[#171]</a></td></tr></table></td></tr><tr ><td class="posttext"> <img src="https://img.itch.zone/aW1hZ2UvMTM5NTQxLzYzODk1Ni5wbmc=/original/619iex.png"><br><br><a href="https://numbergamer8.itch.io/theelite" target="_blank">https://numbergamer8.itch.io/theelite</a><br><br>Ok I uploaded it to itch.io <br><br>I can develop this a bit now its using the buttons, thankyou for the help. <br><br></td></tr></table><br>
<a name="1339801"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#172">[#172]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok.<br>The Page system is very powerful ;}<br><br>Let me know how you get on. and also if there are controls that you would like added, or altered.<br>I can add vertical and horizontal sliders next?<br>similar to that I can add a -+ control (like the one you are doing above?<br>So it will be even simpler for you ;) ? <br><br></td></tr></table><br>
<a name="1339804"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#173">[#173]</a></td></tr></table></td></tr><tr ><td class="posttext"> My blitzmax guisystem has some widgets ...if you want to have a look (github.com/GWRon/Dig.git). <br><br>The -+ thing is called a spinner.<br><br>Good things to have are "list" and "dropdown". Both could contain children of type uxbase (or how you call it). This allows to add every widget to a list. <br>It might be good to have scrollers too.. and add them to the panel so you could create a scrollable area (uxpage instead of uxpanel).<br><br>Why list? Imagine a list of ships "near me". You will end up with a scrollable list.<br>Why dropdown? Imagine a list of potential "fly to" targets. Or a big list of small adjustable properties. A list for each of them needs way too much screen space<br>Why? So Adam gets something to do :-)<br><br>Bye<br>Ron <br><br></td></tr></table><br>
<a name="1339815"></a>

<a name="1339816"></a>

<a name="1339817"></a>

<a name="1339818"></a>

<a name="1339819"></a>

<a name="1339820"></a>

<a name="1339821"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#174">[#174]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Adam how do I do my own mouse method that will take priority over the window class, I now know its :MouseEvent and Location.X etc.. just wondering if I can have a class running indipendant from window class until it finishes? <br><br>Yes a set of small + - s and a normal size - +, I want a button that can change its text. I'm thinking of a nav computer where you enter precise jump locations, like the back to the future delurian flux capasitor :) I was also thinking there should be a margin of error on where you endup. And to be able to tune into nav beacons. can you make a liquid slider for things like fuel ?<br><br>You App is best for open space &amp; I will do stuff with it,what I want to do is, a set of scrollable locations like the ship, or a base, or a planet, and you can actualy move cargo etc.. instead of buying with spinners, you actualy move rockets into the tubes etc...<br><br>@adam I realy would prefer the combat etc... be turn-based, I'm not a button twitcher, but I don't know what you want.?<br><br>@thx Derron, you may have some good stuff already done <br><br></td></tr></table><br>
<a name="1339823"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#175">[#175]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm going to switch to your map setup now, I will leave my experiment for later use. <br><br></td></tr></table><br>
<a name="1339824"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#176">[#176]</a></td></tr></table></td></tr><tr ><td class="posttext"> who do we tell about not being able to add codebox code? <br><br></td></tr></table><br>
<a name="1339832"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Derron</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#177">[#177]</a></td></tr></table></td></tr><tr ><td class="posttext"> Skidracer<br><br><br>Bye<br>Ron <br><br></td></tr></table><br>
<a name="1339843"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#178">[#178]</a></td></tr></table></td></tr><tr ><td class="posttext"> I always thought you Derron was a big wheel here, and could fix this sort of thing :) <br><br></td></tr></table><br>
<a name="1339845"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#179">[#179]</a></td></tr></table></td></tr><tr ><td class="posttext"> Sorry for not posting today.... System rebuild... EEEK! <br><br></td></tr></table><br>
<a name="1339847"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#180">[#180]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Adam that's ok, but I look forward to your progress :) win10 is telling me Its about to update eeer2.. <br><br></td></tr></table><br>
<a name="1339855"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#181">[#181]</a></td></tr></table></td></tr><tr ><td class="posttext"> yep. 8 hour rebuild this end. But now fully operational<br><br><div class="quote">  I want a button that can change its text.[/quote/<br>OK, you have the button class UXButton. you can change the text at any time with <br>yourButtonName.Text = "your text"<br>you might need App.RequestRender() after the change...<br><br>[quote]I realy would prefer the combat etc... be turn-based, I'm not a button twitcher, but I don't know what you want.? <br></div><br>I haven't got as far as that. lol <br><br></td></tr></table><br>
<a name="1339869"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#182">[#182]</a></td></tr></table></td></tr><tr ><td class="posttext"> I'm trying to save and load an internal array, ive got this so far, Its not an array, it compiles but I cant find copy.txt, does anyone know what I should be doing<br><br>local	data:DataBuffer = DataBuffer.Load("asset::save.txt")<br>If data<br>     Local file:= FileStream.Open("asset::copy.txt", "w")<br>     If file<br>          file.Write (data, 0,1)<br>	  file.OnClose()<br>     EndIf<br>EndIf<br>			<br>Endif <br><br></td></tr></table><br>
<a name="1339880"></a>

<a name="1339881"></a>

<a name="1339882"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#183">[#183]</a></td></tr></table></td></tr><tr ><td class="posttext"> <textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Method Load()
 
	Local Binary := DesktopDir() + "test1.dat"
	Local file := FileStream.Open(Binary, "r")
	file.ReadInt()
	file.Close()

	
End
 
'--------------

Method Save()
 
    Local count:Int = 1
    Local out:Int = 0
    out = _chit[1]._chitx
	Local Binary := DesktopDir() + "test1.dat"
	Local file := FileStream.Open(Binary, "w")
	file.WriteInt(count)
	file.Close()
	

End </textarea><br><br>its a methos to save game arrays, not quite finished, got to put a loop to output whole array, but, its working <br><br></td></tr></table><br>
<a name="1339888"></a>

<a name="1339890"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#184">[#184]</a></td></tr></table></td></tr><tr ><td class="posttext"> <textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">Method Load()
	
        
	Local Binary := DesktopDir() + "test1.dat"
	Local file := FileStream.Open(Binary, "r")
	Local f:Int = 1
	For f = 1 To 100
		_chit[f]._id = file.ReadInt()
		_chit[f]._twist = file.ReadInt()
		_chit[f]._chitx = file.ReadInt() 
		_chit[f]._chity = file.ReadInt() 
		_chit[f]._big = file.ReadInt()
		_chit[f]._type = file.ReadInt()
		_chit[f]._numb1 = file.ReadInt()
		_chit[f]._numb2 = file.ReadInt()
		_chit[f]._numb3 = file.ReadInt()
		_chit[f]._numb4 = file.ReadInt()
		_chit[f]._numb5 = file.ReadInt()
		_chit[f]._numb6 = file.ReadInt()
		_chit[f]._numb7 = file.ReadInt()
		_chit[f]._numb8 = file.ReadInt()
		_chit[f]._numb9 = file.ReadInt()
		_chit[f]._numb10 = file.ReadInt()
	Next
	
	file.Close()

	
End
 
'--------------

Method Save()
    
    Local Binary := DesktopDir() + "test1.dat"
	Local file := FileStream.Open(Binary, "w")
       
    Local f:Int = 1
 '   For f = 0 To 16
     
    
For f = 1 To 100
file.WriteInt(_chit[f]._id  )
		file.WriteInt(_chit[f]._twist)  
		file.WriteInt(_chit[f]._chitx )  
		file.WriteInt(_chit[f]._chity )  
		file.WriteInt(_chit[f]._big ) 
		file.WriteInt(_chit[f]._type ) 
		file.WriteInt(_chit[f]._numb1 ) 
		file.WriteInt(_chit[f]._numb2  )
		file.WriteInt(_chit[f]._numb3  )
		file.WriteInt(_chit[f]._numb4  )
		file.WriteInt(_chit[f]._numb5  )
		file.WriteInt(_chit[f]._numb6  )
		file.WriteInt(_chit[f]._numb7  )
		file.WriteInt(_chit[f]._numb8  )
		file.WriteInt(_chit[f]._numb9  )
		file.WriteInt(_chit[f]._numb10  )
	
Next

	
	file.Close()
	

End
 
'-------------- </textarea><br><br>Ok finished the array save and load methods. <br><br></td></tr></table><br>
<a name="1339889"></a>

<a name="1339891"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#185">[#185]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Adam I know you would know how to save &amp; load, but I found it difficult as a noob to find a way to save a game, so for noobs here I put a quick and dirty gamesave method, and I hope I'm making this thread a little bit interesting in my way, but I'm still on a back seat :) I'm happy on the back seat, as those moons orbiting was like stardust <br><br></td></tr></table><br>
<a name="1339903"></a>

<a name="1339904"></a>

<a name="1339906"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#186">[#186]</a></td></tr></table></td></tr><tr ><td class="posttext"> <img src="https://img.itch.zone/aW1hZ2UvMTM5MzcyLzY0MDA2OS5wbmc=/original/iUJ%2FQa.png"><br><br>done a wargame app, with what I ve learned here, <br><br>I put you in the Text File credits Adam ;)<br><br><a href="https://numbergamer8.itch.io/miniatures-game-tool" target="_blank">https://numbergamer8.itch.io/miniatures-game-tool</a> <br><br></td></tr></table><br>
<a name="1339905"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#187">[#187]</a></td></tr></table></td></tr><tr ><td class="posttext"> yep. that basically how I do file stuff - so kudos to you for getting it right.<br><br>You know what? I'm not going to say anything about the war-game app either. I generally like what I see.<br>OK. Here's something for you:<br><img src="https://vjointeractive.files.wordpress.com/2017/04/bgfade.png"><br><br>it's a faded square blurred box<br><br>with a bit of scaling, you 'could' draw this first before drawing a chit. offset say 10,10 pixels. you then draw the chit. and you would have a drop shadow which would make the chit 'pop' a bit... <br><br></td></tr></table><br>
<a name="1339908"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#188">[#188]</a></td></tr></table></td></tr><tr ><td class="posttext"> yES THATS A SUPA COOL IDEA. thanks Adam <br><br></td></tr></table><br>
<a name="1339930"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#189">[#189]</a></td></tr></table></td></tr><tr ><td class="posttext"> here's the latest shot of the solar system display:<br><img src="https://vjointeractive.files.wordpress.com/2017/04/screen-shot-2017-04-29-at-10-49-16.png"><br>the orbital system has yet to be included.<br><br>I'm sorta working from the big to the small<br><br>Looking through the generated systems, I can gauge if a system has space capability and can use that to show exploration, etc <br><br></td></tr></table><br>
<a name="1339939"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#190">[#190]</a></td></tr></table></td></tr><tr ><td class="posttext"> last pic for today<br><img src="https://vjointeractive.files.wordpress.com/2017/04/screen-shot-2017-04-29-at-14-22-48.png"><br><br>showing the completed solar system view with planetary map <br><br></td></tr></table><br>
<a name="1339943"></a>

<a name="1339945"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#191">[#191]</a></td></tr></table></td></tr><tr ><td class="posttext"> realy good Adam, I cant wait to run them planets on my computer,<br><br>I did the wargame version, to motivate me to find answers to programing questions, .<br><br>I like your map system, with the add unit etc.. and your is the one I will use to do things with this project, I could not do much because I don't know yet how the code will fit together, but looking forward to your next update. <br><br></td></tr></table><br>
<a name="1339954"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#192">[#192]</a></td></tr></table></td></tr><tr ><td class="posttext"> Adam, I have to appolagise, you did the map part for me to develop, where I thought we were waiting for you to finish before we could do anything with it, I reproogramed it because I thought it was a waste of time using your code if you were updating it. I may be able to program a bit, but I'm dense at some things :) <br><br></td></tr></table><br>
<a name="1339960"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#193">[#193]</a></td></tr></table></td></tr><tr ><td class="posttext"> Adam, I have to appolagise, you did the map part for me to develop, where I thought we were waiting for you to finish before we could do anything with it, I reproogramed it because I thought it was a waste of time using your code if you were updating it. I may be able to program a bit, but I'm dense at some things :)<br><br><b>I need to double post this</b> <br><br></td></tr></table><br>
<a name="1339962"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#194">[#194]</a></td></tr></table></td></tr><tr ><td class="posttext"> <textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80"> 	If savpic = 1
			_mX = -500
			_mY = -500	
			'Global screens10:Pixmap = New Pixmap(2850,760)
			'Global image:=New Image( 2860,2180,TextureFlags.Dynamic )
			DrawTheGame2( canvas )
			RequestRender()	
			Local fname:String=DesktopDir()+"screen9.png" 
 			'Local screenshot:Pixmap = canvas.CopyPixmap(New Recti(-3000, -3000, 6000, 6000)) 
 			Local screens:Pixmap = canvas.CopyPixmap(New Recti(0, 0, 950, 720)) 
 			'image.Texture.PastePixmap( screens,0,0 )
 			SavePixmap(screens, fname)  
 			_mX = -500 + 950
			_mY = -500 + 0	
			DrawTheGame2( canvas )	
			RequestRender()
			Local fname2:String=DesktopDir()+"screen8.png" 
 			'Local screenshot:Pixmap = canvas.CopyPixmap(New Recti(-3000, -3000, 6000, 6000)) 
 			Local screens2:Pixmap = canvas.CopyPixmap(New Recti(0, 0, 950, 720)) 
 			SavePixmap(screens2, fname2) 
 			'image.Texture.PastePixmap( screens2,950,0 ) 
 			_mX = -500 + 950 +950
			_mY = -500 + 0	
			DrawTheGame2( canvas )	
			RequestRender()
			Local fname3:String=DesktopDir()+"screen7.png" 
 			'Local screenshot:Pixmap = canvas.CopyPixmap(New Recti(-3000, -3000, 6000, 6000)) 
 			Local screens3:Pixmap = canvas.CopyPixmap(New Recti(0, 0, 950, 720)) 
 			SavePixmap(screens3, fname3) 
 			 'image.Texture.PastePixmap( screens3,1900,0 )
 			_mX = -500 + 0
			_mY = -500 + 720	
			DrawTheGame2( canvas )	
			RequestRender()
			Local fname4:String=DesktopDir()+"screen6.png" 
 			'Local screenshot:Pixmap = canvas.CopyPixmap(New Recti(-3000, -3000, 6000, 6000)) 
 			Local screens4:Pixmap = canvas.CopyPixmap(New Recti(0, 0, 950, 720)) 
 			SavePixmap(screens4, fname4)
 			 'image.Texture.PastePixmap( screens4,0,720 )
 			_mX = -500 + 950
			_mY = -500 + 720	
			DrawTheGame2( canvas )	
			RequestRender()
			Local fname5:String=DesktopDir()+"screen5.png" 
 			'Local screenshot:Pixmap = canvas.CopyPixmap(New Recti(-3000, -3000, 6000, 6000)) 
 			Local screens5:Pixmap = canvas.CopyPixmap(New Recti(0, 0, 950, 720)) 
 			SavePixmap(screens5, fname5)
 			 'image.Texture.PastePixmap( screens5,950,720 )
 			_mX = -500 + 950 + 950
			_mY = -500 + 720	
			DrawTheGame2( canvas )	
			RequestRender()
			Local fname6:String=DesktopDir()+"screen4.png" 
 			'Local screenshot:Pixmap = canvas.CopyPixmap(New Recti(-3000, -3000, 6000, 6000)) 
 			Local screens6:Pixmap = canvas.CopyPixmap(New Recti(0, 0, 950, 720)) 
 			SavePixmap(screens6, fname6)
 			'image.Texture.PastePixmap( screens6,1900,720 )
 			_mX = -500 - 0
			_mY = -500 + 720 + 720	
			DrawTheGame2( canvas )	
			RequestRender()
			Local fname7:String=DesktopDir()+"screen3.png" 
 			'Local screenshot:Pixmap = canvas.CopyPixmap(New Recti(-3000, -3000, 6000, 6000)) 
 			Local screens7:Pixmap = canvas.CopyPixmap(New Recti(0, 0, 950, 720)) 
 			SavePixmap(screens7, fname7)
 			'image.Texture.PastePixmap( screens7,0,1440 )
 			_mX = -500 + 950
			_mY = -500 + 720 + 720	
			DrawTheGame2( canvas )	
			RequestRender()
			Local fname8:String=DesktopDir()+"screen2.png" 
 			'Local screenshot:Pixmap = canvas.CopyPixmap(New Recti(-3000, -3000, 6000, 6000)) 
 			Local screens8:Pixmap = canvas.CopyPixmap(New Recti(0, 0, 950, 720)) 
 			SavePixmap(screens8, fname8)
 			'image.Texture.PastePixmap( screens8,950,1440 )
 			_mX = -500 + 950 + 950
			_mY = -500 + 720 + 720	
			DrawTheGame2( canvas )	
			RequestRender()
			Local fname9:String=DesktopDir()+"screen1.png" 
 			'Local screenshot:Pixmap = canvas.CopyPixmap(New Recti(-3000, -3000, 6000, 6000)) 
 			Local screens9:Pixmap = canvas.CopyPixmap(New Recti(0, 0, 950, 720)) 
 			SavePixmap(screens9, fname9)
 			'image.Texture.PastePixmap( screens9,1900,1440 )
 			
 			
 			Endif
 			savpic = 0 </textarea><br><br><br>I made a map capture function, s I could use chits to draw a map, the output it, so you could use trees and buidings etc.. as chits and draw a map, its not perfect, I just thought it may amuse, I have a question, how can I save an image to file ? I can save pixmaps, but cant find a way to either convert to pixmap or save as image. <br><br></td></tr></table><br>
<a name="1339965"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#195">[#195]</a></td></tr></table></td></tr><tr ><td class="posttext"> aha.... You are almost there.<br>the pixmap is the key to everything:<br><pre class=code>
	local _pix:Pixmap
	_pix = canvas.CopyPixmap( New Recti( 0, 0, wd, ht ) )
		
	_pix.Save( _filePath )

	_pix.Discard()
</pre><br>Beware with pixmaps. you MUST discard them <br><br></td></tr></table><br>
<a name="1339966"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#196">[#196]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, I got that bit working, but what I'm trying to do is convert an Image to a PixMap so I can save it, I'm trying to take 9 screenshots and stich them together and output one png, but I can only save a pixmap so I get 9 images, Images I cant do anything with except copy a pixmap into it.<br><br>or is there a better way to save the map, I know I'm distracting you from elite, so only if you get a momeny point me to the right direction. <br><br></td></tr></table><br>
<a name="1339975"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#197">[#197]</a></td></tr></table></td></tr><tr ><td class="posttext"> ok. What you need is a canvas. or more specifically a custom canvas.<br>You know how we draw everything to the canvas. and using the above we can save the canvas?<br>well, what if we just feed a custom created canvas, do all the drawing and then save it?<br><br><pre class=code>
local _iCanvas:Canvas = New Canvas( _arcadeFont.GetImage )
'do some drawing to _iCanvas
'this is all done offscreen. to fix it (flip) you need to flush!
_iCanvas.Flush()
'then copy it to a pixmap...
_pix =_iCanvas.Copy
</pre><br>this is being fed an image. so you could create the image the size you want first... ;) <br><br></td></tr></table><br>
<a name="1339977"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#198">[#198]</a></td></tr></table></td></tr><tr ><td class="posttext"> thx Adam, you have given me another avenue to look at, <br><br></td></tr></table><br>
<a name="1339981"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Mainsworthy</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#199">[#199]</a></td></tr></table></td></tr><tr ><td class="posttext"> That was amazing Adam, how you figured that out I don't know, it worked great, <br><br></td></tr></table><br>
<a name="1339982"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#200">[#200]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've been doing lots of research into doing lots of weird stuff... <br><br></td></tr></table><br>
<a name="1339988"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >AdamStrange</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#201">[#201]</a></td></tr></table></td></tr><tr ><td class="posttext"> okydoke... added planet selection<br>when the mouse is over a planet or name it will highlight and show a bigger version below it.<br><img src="https://vjointeractive.files.wordpress.com/2017/04/screen-shot-2017-04-30-at-14-41-581.png"><br><br>What will be here?<br>Basically the planet details, what it wants, produces, population, etc <br><br></td></tr></table><br>
<a name="1339991"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >skidracer</td><td align="right"><font class=tiny>(Posted April)</font>&nbsp;<a href="#202">[#202]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thread continued <a href="/posts.php?topic=107975" target="_blank">here</a>. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
