<!DOCTYPE html><html lang="en" ><head ><title >Diddy's Pathfinding</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Diddy's Pathfinding</h1><a href="forums.php" >Monkey Forums</a>/<a href="topics.php?forum=507" >Monkey Programming</a>/<a href="#bottom" >Diddy's Pathfinding</a><br><br>
<a name="2039022"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >c.k.</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've got a 2-dimensional tile maze. Can diddy find me the path through there? I'd also like to get 1) the number of steps in the final path (since it's a tile maze, how many blocks are in the path), and 2) the number of turns in the final path. <br><br></td></tr></table><br>
<a name="2039027"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gerry Quinn</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well, Diddy has a pathfinding algorithm, so presumably it can (I haven't tried it).<br><br>You need to get your maze into its format, then ask it for a route from start to finish.  By inspecting the resulting route you then can answer your other questions. <br><br></td></tr></table><br>
<a name="2039380"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rushino</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>I was exploring a lots how A* work.. and ive looked at how diddy pathfinding looking. There no real format except a standard x,y cols array. Just 'mirror' your maze into this format (If its what gerry meant) and the paths are stored inside a variable like this.. x1,y1,x2,y2,x3,y3,... so:<br><br>1- The number of steps is easy to find, just get the var where the path are virtually stored then its Lenght / 2 and you get the number of moves.<br>2- It can't get you the number of turns that would require a bit more programming or you could also compare the moves like compare what changed from x1,y1 to x2,y2 and then figure out there was a turn. <br><br></td></tr></table><br>
<a name="2039382"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gerry Quinn</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes, that's what I meant.  Inspect the path to count the turns.  Just run through the steps from beginning to end, determining if they are horizontal or vertical - and if the current step is a different direction from the last one, add 1 to the number of turns. <br><br></td></tr></table><br>
<a name="2039384"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Rushino</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Your explanation was better. lol English isnt my first language. <br><br></td></tr></table><br>
<a name="2039392"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Xaron</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> I've implemented A* pathfinding for a hexagonal grid. I can post that if anyone is interested? <br><br></td></tr></table><br>
<a name="2039394"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> <div class="quote"> I can post that if anyone is interested? <br></div><br>Please do :) <br><br></td></tr></table><br>
<a name="2039401"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Xaron</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Well here it is. Please note, this one is for hexagonal grids which I have that way in my 2d arrays:<br><br><pre class=code>
'That's for even y lines (the middle one to know how to access the neighbors!)
'-------------             | 0,1 | 1,1 |
'| 0,1 | 1,1 |            / \   / \   / \
'-------------------     /   \ /   \ /   \
'| 0,2 | 1,2 | 2,2 |    | 0,2 | 1,2 | 2,2 |
'-------------------     \   / \   / \   /
'| 0,3 | 1,3 |            \ /   \ /   \ /
'-------------             | 0,3 | 1,3 |
</pre><br><br><pre class=code>
'That's for odd y lines (the middle one to know how to access the neighbors!)
'      -------------       | 1,0 | 2,0 |
'      | 1,0 | 2,0 |      / \   / \   / \
'-------------------     /   \ /   \ /   \
'| 0,1 | 1,1 | 2,1 |    | 0,1 | 1,1 | 2,1 |
'-------------------     \   / \   / \   /
'      | 1,2 | 2,2 |      \ /   \ /   \ /
'      -------------       | 1,2 | 2,2 |
</pre><br><br>The hexagonal A* pathfinding is more complex than the "normal" one for classic 2d arrays. You should be able to easily simplify the code. If not I'll do that. ;)<br><br>Part I: the central part, the path finder from my game Warhex (which isn't finished yet):<br><br>Screw the includes, you won't need it. I just call findpath where I use units as parameters but use only the x and y coordinates here, so that won't be a problem to use it for your own purposes.<br>There's still some other stuff in it here (especially in the function walkable) but you should be able to sort out that as well. If not just ask, I'm glad to help!<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Strict

Import constants
Import globals
Import unit
Import utils

Class Path
  Field foundOne:Bool   'Flag, if a path has been found
  Field length:Int
  Field location:Int
  Field numberOfOpenListItems:Int
  Field newOpenListItemID:Int
  Field openList:Int[]            '1 dimensional array holding ID# of open list items
  Field whichList:Int[][]         '2 dimensional array used to record whether a cell is on the open list or on the closed list.
  Field openX:Int[]               '1d array stores the x location of an item on the open list
  Field openY:Int[]               '1d array stores the y location of an item on the open list
  Field parentX:Int[][]           '2d array to store parent of each cell (x)
  Field parentY:Int[][]           '2d array to store parent of each cell (y)
  Field Fcost:Int[]               '1d array to store F cost of a cell on the open list
  Field Gcost:Int[][]             '2d array to store G cost for each cell.
  Field Hcost:Int[]               '1d array to store H cost of a cell on the open list
  Field onClosedList:Int          'openList variable
  Field completePath:IntStack
  Field target:Unit
  
  Method New()
    foundOne = False
    length = 0
    location = 0
    onClosedList = 10
    numberOfOpenListItems = 0
    newOpenListItemID = 0
    openList = New Int[ MAP_WIDTH * MAP_HEIGHT + 2 ]
    whichList = CreateArray( MAP_WIDTH + 1, MAP_HEIGHT + 1 )
    openX = New Int[ MAP_WIDTH * MAP_HEIGHT + 2 ]
    openY = New Int[ MAP_WIDTH * MAP_HEIGHT + 2 ]
    parentX = CreateArray( MAP_WIDTH + 1, MAP_HEIGHT + 1 )
    parentY = CreateArray( MAP_WIDTH + 1, MAP_HEIGHT + 1 )
    Fcost = New Int[ MAP_WIDTH * MAP_HEIGHT + 2 ]
    Gcost = CreateArray( MAP_WIDTH + 1, MAP_HEIGHT + 1 )
    Hcost = New Int[ MAP_WIDTH * MAP_HEIGHT + 2 ]
    completePath = New IntStack()
  End Method
  
  Method walkable:Bool( x:Int, y:Int, dir:Int, isStartField:Bool )
    Local ownUnit:Bool = False
    Local unit:Unit = gMapUnits.Get( x + y * MAP_WIDTH )
    If( unit &lt;&gt; Null )
      If( gPlayerFraction &lt;&gt; unit.fraction ) Then ownUnit = True
    End If
    If( gMapBorders[x][y] &amp; dir = 0 And ( unit = Null Or ownUnit = True Or isStartField = True ) )
      Return True 'And gMapUnits.Get( x + y * MAP_WIDTH ) = Null
    End If
    Return False
  End Method

  Method doSearch:Void( u:Unit, x:Int, y:Int, dir:Int, parentXVal:Int, parentYVal:Int, targetX:Int, targetY:Int, onOpenList:Int, isStartField:Bool )
    If( x &lt;&gt; -1 And y &lt;&gt; -1 And x &lt;&gt; MAP_WIDTH And y &lt;&gt; MAP_HEIGHT )
      'If not already on the closed list (items on the closed list have
      'already been considered and can now be ignored).			
      If( Self.whichList[x][y] &lt;&gt; Self.onClosedList )
        'If not a wall/obstacle square.
        'Don't cut across corners (this is optional)
        Local corner:Bool = walkable( parentXVal, parentYVal, dir, isStartField )
        If( corner = True )
          'If not already on the open list, add it to the open list.			
          If( Self.whichList[x][y] &lt;&gt; onOpenList )
            'Create a new open list item in the binary heap.
            Self.newOpenListItemID += 1   'each new item has a unique ID #
            Local m:Int = Self.numberOfOpenListItems + 1
            Self.openList[m] = Self.newOpenListItemID    'place the new open list item (actually, its ID#) at the bottom of the heap
            Self.openX[ Self.newOpenListItemID ] = x
            Self.openY[ Self.newOpenListItemID ] = y 'record the x and y coordinates of the new item
            'Figure out its G cost
            Local addedGCost:Int = 10
            If( u.platingType = PLATING_SOFT )
              addedGCost += gMapAIThreatForSoftPlating[ parentXVal ][ parentYVal ]
            Else
              addedGCost += gMapAIThreatForHardPlating[ parentXVal ][ parentYVal ]
            End If
            Self.Gcost[x][y] = Self.Gcost[ parentXVal ][ parentYVal ] + addedGCost
            'Figure out its H and F costs and parent
            Self.Hcost[ Self.openList[m] ] = 10 * ( Abs( x - targetX ) + Abs( y - targetY ) ) 'record the H cost of the new square
            Self.Fcost[ Self.openList[m] ] = Self.Gcost[x][y] + Self.Hcost[ Self.openList[m] ] 'record the F cost of the new square
            Self.parentX[x][y] = parentXVal
            Self.parentY[x][y] = parentYVal   'record the parent of the new square	

            'Move the new open list item to the proper place in the binary heap.
            'Starting at the bottom, successively compare to parent items,
            'swapping as needed until the item finds its place in the heap
            'or bubbles all the way to the top (if it has the lowest F cost).
            While( m &lt;&gt; 1 )   'While item hasn't bubbled to the top (m=1)	
              'Check if child's F cost is &lt; parent's F cost. If so, swap them.	
              If( Self.Fcost[ Self.openList[m] ] &lt;= Self.Fcost[ Self.openList[m/2] ] )
                Local temp:Int = Self.openList[m/2]
                Self.openList[m/2] = Self.openList[m]
                Self.openList[m] = temp
                m = m / 2
              Else
                Exit
              End If
            Wend 
            Self.numberOfOpenListItems += 1 'add one to the number of items in the heap

            'Change whichList to show that the new item is on the open list.
            Self.whichList[x][y] = onOpenList

            'If adjacent cell is already on the open list, check to see if this
            'path to that cell from the starting location is a better one.
            'If so, change the parent of the cell and its G and F costs.
          Else' If whichList(a,b) = onOpenList
            'Figure out the G cost of this possible new path
            Local addedGCost:Int = 10
            Local tempGcost:Int = Self.Gcost[ parentXVal ][ parentYVal ] + addedGCost

            'If this path is shorter (G cost is lower) then change
            'the parent cell, G cost and F cost. 		
            If( tempGcost &lt; Self.Gcost[x][y] )  'if G cost is less,
              Self.parentX[x][y] = parentXVal   'change the square's parent
              Self.parentY[x][y] = parentYVal
              Self.Gcost[x][y] = tempGcost      'change the G cost			

              'Because changing the G cost also changes the F cost, if
              'the item is on the open list we need to change the item's
              'recorded F cost and its position on the open list to make
              'sure that we maintain a properly ordered open list.
              For Local a:Int = 1 To numberOfOpenListItems  'look for the item in the heap
                If( Self.openX[ Self.openList[a] ] = x And Self.openY[ Self.openList[a] ] = y ) 'item found
                  Self.Fcost[ Self.openList[a] ] = Self.Gcost[x][y] + Self.Hcost[ Self.openList[a] ]  'change the F cost

                  'See if changing the F score bubbles the item up from it's current location in the heap
                  Local m:Int = a
                  While( m &lt;&gt; 1 )   'While item hasn't bubbled to the top (m=1)	
                    'Check if child is &lt; parent. If so, swap them.	
                    If( Self.Fcost[ Self.openList[m] ] &lt; Self.Fcost[ Self.openList[m/2] ] )
                      Local temp:Int = Self.openList[m/2]
                      Self.openList[m/2] = Self.openList[m]
                      Self.openList[m] = temp
                      m = m / 2
                    Else
                      Exit  'while/wend
                    End If
                  Wend 
                  Exit    'for x = loop
                End If    'If openX(openList(x)) = a
              Next        'For x = 1 To numberOfOpenListItems
            End If        'If tempGcost &lt; Gcost(a,b) Then			
          End If          'If not already on the open list				
        End If            'If corner = walkable
      End If              'If not already on the closed list	
    End If                'If not off the map.	
  End Method
End Class

Function findPath:Path( unitA:Unit, unitB:Unit )
  Local path:Path = New Path()
  path.target = unitB
  'We take the start position of unitA and target position of unitB
  Local startX:Int = unitA.xPos
  Local startY:Int = unitA.yPos
  Local targetX:Int = unitB.xPos
  Local targetY:Int = unitB.yPos
  Local newOpenListItemID:Int = 0
  'Jetzt berechnen wir die Kosten zu allen angrenzenden Feldern
  path.onClosedList += 2
  Local onOpenList:Int = path.onClosedList - 1
  'Add the starting location to the open list of squares to be checked.
  path.numberOfOpenListItems = 1
  path.openList[1] = 1      'assign it as the top (and currently only) item in the open list, which is maintained as a binary heap (explained below)
  path.openX[1] = startX
  path.openY[1] = startY

  'Do the following until a path is found or deemed nonexistent.  
  Repeat
    'If the open list is not empty, take the first cell off of the list.
    'This is the lowest F cost cell on the open list.
    If( path.numberOfOpenListItems &lt;&gt; 0 )
      'Pop the first item off the open list.
      Local parentXVal:Int = path.openX[ path.openList[1] ]
      Local parentYVal:Int = path.openY[ path.openList[1] ] 'record cell coordinates of the item
      path.whichList[ parentXVal ][ parentYVal ] = path.onClosedList 'add the item to the closed list
      'Open List = Binary Heap: Delete this item from the open list, which
      'is maintained as a binary heap.
      path.numberOfOpenListItems -= 1 'reduce number of open list items by 1	
      path.openList[1] = path.openList[ path.numberOfOpenListItems + 1 ] 'move the last item in the heap up to slot #1
      Local v:Int = 1	

      Repeat  'Repeat the following until the new item in slot #1 sinks to its proper spot in the heap.
        Local u:Int = v	
        If( 2 * u + 1 &lt;= path.numberOfOpenListItems ) 'if both children exist
          'Check if the F cost of the parent is greater than each child.
          'Select the lowest of the two children.	
          If( path.Fcost[ path.openList[u] ] &gt;= path.Fcost[ path.openList[2*u] ] ) Then v = 2 * u
          If( path.Fcost[ path.openList[v] ] &gt;= path.Fcost[ path.openList[2*u+1] ] ) Then v = 2 * u + 1		
        Else
          If( 2 * u &lt;= path.numberOfOpenListItems ) 'if only child #1 exists
            'Check if the F cost of the parent is greater than child #1	
            If( path.Fcost[ path.openList[u] ] &gt;= path.Fcost[ path.openList[2*u] ] ) Then v = 2 * u
          End If	
        End If
        If( u &lt;&gt; v ) 'if parent's F is &gt; one of its children, swap them
          Local temp:Int = path.openList[u]
          path.openList[u] = path.openList[v]
          path.openList[v] = temp				
        Else
          Exit 'otherwise, exit loop
        End If	
      Forever

      'Check the adjacent squares. (Its "children" -- these path children
      'are similar, conceptually, to the binary heap children mentioned
      'above, but don't confuse them. They are different. Path children
      'are portrayed in Demo 1 with grey pointers pointing toward
      'their parents.) Add these adjacent child squares to the open list
      'for later consideration if appropriate (see various if statements
      'below).
      Local isStartField:Bool = False
      If( unitA.xPos = parentXVal And unitA.yPos = parentYVal ) Then isStartField = True
      If( parentYVal Mod 2 = 0 )
        'Gerade Zeile.
        path.doSearch( unitA, parentXVal-1, parentYVal-1, MAP_BORDER_UL, parentXVal, parentYVal, targetX, targetY, onOpenList, isStartField )
        path.doSearch( unitA, parentXVal  , parentYVal-1, MAP_BORDER_UR, parentXVal, parentYVal, targetX, targetY, onOpenList, isStartField )
        path.doSearch( unitA, parentXVal+1, parentYVal  , MAP_BORDER_R , parentXVal, parentYVal, targetX, targetY, onOpenList, isStartField )
        path.doSearch( unitA, parentXVal  , parentYVal+1, MAP_BORDER_LR, parentXVal, parentYVal, targetX, targetY, onOpenList, isStartField )
        path.doSearch( unitA, parentXVal-1, parentYVal+1, MAP_BORDER_LL, parentXVal, parentYVal, targetX, targetY, onOpenList, isStartField )
        path.doSearch( unitA, parentXVal-1, parentYVal  , MAP_BORDER_L , parentXVal, parentYVal, targetX, targetY, onOpenList, isStartField )
      Else
        'Ungerade Zeile.
        path.doSearch( unitA, parentXVal  , parentYVal-1, MAP_BORDER_UL, parentXVal, parentYVal, targetX, targetY, onOpenList, isStartField )
        path.doSearch( unitA, parentXVal+1, parentYVal-1, MAP_BORDER_UR, parentXVal, parentYVal, targetX, targetY, onOpenList, isStartField )
        path.doSearch( unitA, parentXVal+1, parentYVal  , MAP_BORDER_R , parentXVal, parentYVal, targetX, targetY, onOpenList, isStartField )
        path.doSearch( unitA, parentXVal+1, parentYVal+1, MAP_BORDER_LR, parentXVal, parentYVal, targetX, targetY, onOpenList, isStartField )
        path.doSearch( unitA, parentXVal  , parentYVal+1, MAP_BORDER_LL, parentXVal, parentYVal, targetX, targetY, onOpenList, isStartField )
        path.doSearch( unitA, parentXVal-1, parentYVal  , MAP_BORDER_L , parentXVal, parentYVal, targetX, targetY, onOpenList, isStartField )
      End If
      'If open list is empty then there is no path.
    Else
      path.foundOne = False
      Exit
    End If

    'If target is added to open list then path has been found.
    If( path.whichList[ targetX ][ targetY ] = onOpenList )
      path.foundOne = True
      Exit
    End If
  Forever 'repeat until path is found or deemed nonexistent

  'Save the path if it exists. Copy it to a bank. 
  If( path.foundOne = True )
    'a. Working backwards from the target to the starting location by checking
    'each cell's parent, figure out the length of the path.
    Local pathX:Int = targetX
    Local pathY:Int = targetY
    Repeat
      Local tempx:Int = path.parentX[ pathX ][ pathY ]
      pathY = path.parentY[ pathX ][ pathY ]
      pathX = tempx
      path.length += 1
    Until pathX = startX And pathY = startY

    'b. Now copy the path information over to the databank. Since we are
    'working backwards from the target to the start location, we copy
    'the information to the data bank in reverse order. The result is
    'a properly ordered set of path data, from the first step to the
    'last.
    pathX = targetX
    pathY = targetY
    While( Not ( pathX = startX And pathY = startY ) )
      path.completePath.Push( pathX ) 'store x value	
      path.completePath.Push( pathY ) 'store y value	
      Local tempx:Int = path.parentX[ pathX ][ pathY ]
      pathY = path.parentY[ pathX ][ pathY ]
      pathX = tempx
    Wend
    path.completePath.Push( startX ) 'store starting x value	
    path.completePath.Push( startY ) 'store starting y value	
  End If 'If path = found Then 

  'Return info on whether a path has been found.
  Return path
End Function
</textarea> <br><br></td></tr></table><br>
<a name="2039428"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gerry Quinn</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> I must admit, I've always found the simple Dijkstra algorithm adequate for my needs.<br><br>With classic narrow-corridor mazes etc., it's probably faster too.  In a good maze, heuristics shouldn't work in which case the A* is just overhead. <br><br></td></tr></table><br>
<a name="2039640"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >maltic</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> @Gerry Quinn<br>You may as well just use a breadth first search if you don't have edge weights. That will have even less overhead. In fact its asymptotically better (O(V+E) vs O((E+V)lg V) assuming a binary heap)<br><br>In fact, if all you want is ANY path in a maze from some starting location to some finishing location, with no edge weights. A depth first search will be the absolute fastest algorithm possible. It has the same time complexity as BFS (O(V+E)) however the space complexity of DFS is O(n) where n is the length of the longest possible path, whereas in BFS the space complexity is O(b^d) where b is the branching factor and d is the depth of the first solution. The fact that DFS uses less space in the average case, and the fact that the most recent vertex is the top of the stack, makes it faster due to better cache usage. <br><br></td></tr></table><br>
<a name="2039638"></a>

<a name="2039654"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Gerry Quinn</td><td align="right"><font class=tiny>(Posted 2012)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> Breadth-first is what I understand by the Dijkstra algorithm.  I.e. you expand from a start location marked '1', marking all unmarked squares adjacent to a '1' with '2' and so on.  If you stop when you reach the target, I would call that a breadth-first search.<br><br>You can also have a couple of variations: <br><br>(1) You can expand to a fixed distance if you have no particular target, or multiple targets in mind.<br><br>(2) If movement is symmetrical as well as unweighted, you can expand from the target location instead.  This could be useful if you have (say) a roguelike in which many monsters are trying to find a path to a single player character.  Though in practice, you would probably be hard-pressed to find a situation in which this optimisation would be necessary these days, and you also have to be careful if moving objects cannot pass over each other, because the map will change when one of the monsters moves.  However this can also create an interesting form of artificial stupidity, where monsters tend to block one other in a semi-consistent way.<br><br>[I'm making a roguelike at the moment, so these things are on my mind.  In practice, at the moment I'm using plain Dijkstra for each monster that is within a reasonable range of the player character.] <br><br></td></tr></table><br>
<a name="2039653"></a>

<a name="2085198"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Curlew Eskimo</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#12">[#12]</a></td></tr></table></td></tr><tr ><td class="posttext"> Thanks Xaron,<br><br>Curlew Eskimo <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
