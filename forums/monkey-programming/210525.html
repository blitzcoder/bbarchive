<!DOCTYPE html><html lang="en" ><head ><title >When do circular imports fail?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >When do circular imports fail?</h1><a href="forums.php" >Monkey Forums</a>/<a href="topics.php?forum=507" >Monkey Programming</a>/<a href="#bottom" >When do circular imports fail?</a><br><br>
<a name="2119197"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sicilica</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> So, context, I'm in the process of wrapping a C library and realized that I needed circular imports - two structs, A and B, needed to each contain an instance of the other. I was really worried for a while because, unlike C, you can't declare a function/struct/class definition early to my knowledge (ie, in C you would declare that there will be some struct B, then give struct A with it's implementation, then implement struct B with it's implementation).<br><br>It turns out that circular imports DO get resolved in Monkey, which really surprised me! I knew you could do this if the two classes were declared in the same file, but I also know that I've run into problems with circular imports failing before in Monkey.<br><br>So, my question is this: what circumstances would prevent Monkey from resolving this sort of import situation? Or even better, is there some way to resolve the dependencies in a C-style way by predeclaring definitions in a header or something and I just didn't know about it? <br><br></td></tr></table><br>
<a name="2119207"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ImmutableOctet(SKNG)</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> Monkey uses a multi-pass compiler, this means the parsing, semantics and compilation (Translation) are handled one after the other, processing the source code in phases. This is in contrast to C and C++, which process the code as it appears in the source file.<br><br>Monkey is similar to Java and C# in this regard, as the compiler doesn't have to care about the order declarations appear.<br><br>In Monkey, a global variable can be assigned to another global variable declared after it. The same goes for constants, and of course, calling functions. Functions can be called when assigning a global variable or global array's content. This does not require the declaration of the function or variable to be provided beforehand, because the compiler has already processed the source code enough to know both where and what everything is.<br><br>As an example, this code structure is valid in Monkey, but not in C++:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Function Main:Int()
	Local oldX:= X
	
	X += 1
	
	Print("The current value of X: " + String(X))
	Print("The previous value of X: " + String(oldX))
	
	Return 0
End

Global X:= ((MyFunction() * MyOtherFunction()) / Y)
Const Y:Int = 10

Function MyFunction:Int()
	Return (Y * Y)
End

Function MyOtherFunction:Int()
	Return (MyFunction() / 4) + Z
End

Const Z:Int = 64
</textarea><br><b><i><a href="http://regal-internet-brothers.github.io/webcc" target="_blank">Compile Online</a></i></b><br><pre class=code>
The current value of X: 891
The previous value of X: 890
</pre><br><br>There's ways of getting around the limitations restricting this code structure in C++, but in Monkey it's a trait of the language.<br><br>There's some "magic" going on behind the scenes to make sure that certain details like pre-executed functions work, but that's its own topic.<br><br>With C and C++, you're dealing with a sort of "single-pass" compilation model. There's a bit more to it when it comes to optimization (Especially with C++'s templates), but that's an implementation detail. From the programmer's perspective, C and C++ compilers don't understand anything until they're declared somewhere. Usually, this is in a header.<br><br>In these languages, a header is basically how everything is declared. Including a regular source file (c, cpp) is the same as including a header file (h, hpp, etc). The only thing special about a header is that they're less confusing, and functionally, they allow two source files to reference the same declarations. (Types, functions, etc.)<br><br>When you use <i>forward declarations</i>, you're essentially making a contract that the type you're using will be resolved with the same symbolic name internally. However, since you're not defining the contents/implementation of the type, you're unable to give the compiler a means to allocate it, nor are you giving it enough information to access the members of the type. This is why C++ uses headers, they display how the type works to the compiler, and are symbolically the same to the linker.<br><br>This is in contrast to Monkey, which is module based. In Monkey, modules contain both an implementation, and an interface (Declarations). In order to provide the ability to perform out-of-order access, Monkey needs to first map out what can be referenced. When a module is imported, you're essentially allowing the compiler to load the symbolic information for the code in the module(s) you import. This can later be used to ensure your code is correct, as well as understand what piece of code you're talking about.<br><br>In C++, this all has to be understood using declarations and definitions ahead of time, where all of the information is compiled and passed to the linker. The linker of course makes sure all of your declarations match up, and of course, cover the other parts of the ABI.<br><br><b>So, does Monkey have circular dependencies?</b> Yes, but mostly just when it comes to external code. External files have to be imported and loaded into the translator's output, meaning the order has to matter for languages like C and C++. There's ways around this, especially since Monkey 1 uses pointers for everything, but it's still a potential problem.<br><br>In pure Monkey, however, the only circular dependencies are related to the actual code structure, not the semantics of the compiler.<br><br>For example, function X can't call function Y if it calls X. Similarly, classes can't inherit themselves.<br><br>As a side note, Monkey 1 actually has a hard-coded trigger to ban references to the active type when using 'Extends'. There's actually some good reasons to write classes like this, so Monkey 2 supposedly behaves differently about this. This means <i>regular</i> CRTP software models would be possible in Monkey 2, but are restricted in Monkey 1.<br><br>There's a decent bit about these languages that I didn't cover, but I hope I got the idea across. C and C++ share a single-pass compilation model (With a linker step), and Monkey only has to deal with this when it hits the native side of the compilation process. There's some cool things about C's compilation model that are worth mentioning, though. For one thing, every source file is considered its own compilation unit, meaning they can be built largely in parallel.<br><br>Monkey also has some nice conceptual traits, like build optimization, but that's getting into Monkey 2 territory. <br><br></td></tr></table><br>
<a name="2119206"></a>

<a name="2119205"></a>

<a name="2119204"></a>

<a name="2119203"></a>

<a name="2119202"></a>

<a name="2119201"></a>

<a name="2119200"></a>

<a name="2119214"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Sicilica</td><td align="right"><font class=tiny>(Posted 2016)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Dangit, SKNG, every time you post I feel bad for taking so much of your time. Don't you ever write normal size posts?<br><br>I definitely understand everything with linking in C, etc, but that's probably some really important concepts for someone. It can be odd at first - though never as bad as a big project I worked on where the other guy who had written most of the code believed in using extern's for EVERYTHING. Makes it dang near impossible to know where anything is declared, and since it was C and not C++, it also means you can't guarantee ANY encapsulation.<br><br>Does your function X calling Y calling X really not work in Monkey? I guess I've probably never tried, but I would assume that would work since you could read all the function signatures (so you can know there's an X and a Y) and then give their implementations afterwards. The situation that I was confused about was where two classes reference each other in their fields, since those are part of the class signature. In C there are several workarounds (use a void* and change it later, or declare the class without an implementation), but I wasn't sure if Monkey would be cool with that. I would never worry about that in other languages that use multi-pass compilation like say Java, because in Java everything is always in scope and you don't really "import" anything. I thought Monkey's "Import" worked more like an actual inline copy, but I guess it doesn't then?<br><br>Come to think of it, I think Mark mentioned once that that's why Import wasn't a preprocessor command, so I should have realized. Although I think it is now in Monkey2?<br><br>IN ANY CASE, I guess the tl;dr from what you wrote is, if Monkey can compile it if it's all in one file, it will still compile in multiple modules. Certainly things like a self-extending class cause circular dependency errors in Monkey already. <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
