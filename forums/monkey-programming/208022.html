<!DOCTYPE html><html lang="en" ><head ><title >Draw sprites in '3D'?</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Draw sprites in '3D'?</h1><a href="forums.php" >Monkey Forums</a>/<a href="topics.php?forum=507" >Monkey Programming</a>/<a href="#bottom" >Draw sprites in '3D'?</a><br><br>
<a name="2079772"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> Im wondering if anyone has a system of rotating monkey images in 3D like 3D sprites? (with roll/pitch/yaw co-ordinates)<br><br>I dont want to use MiniB3D unless absolutely necessary because I like to use HTML5 but my PC cant run webgl. So everytime I compile I would have wait extra time for flash or GLFW to compile. <br><br></td></tr></table><br>
<a name="2079777"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >therevills</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> You could play with the matrix commands:<br>SetMatrix<br>PushMatrix<br>PopMatrix <br><br></td></tr></table><br>
<a name="2080092"></a>

<a name="2080093"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zoqfotpik</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> That essentially requires texture mapped quads which can be done in software.  <br><br>You can get a ghetto 3d rotation effect by varying the x and y scale, eg. <br><br>Scale sin(ticks),cos(ticks) <br><br>which should make it look like it is rotating in 3d.<br><br>One note about scale that's strange: if you set scale to 2,2 you have to set it back by setting it to .5,.5 because it is cumulative.  I presume this is because Scale abstracts the matrix scaling commands so maybe popmatrix woukd fix it.<br><br>I have toyed with the idea of setting up software normal mapping for lighting effects.  I think that should be possible with up-rezzing from a low resolution and might look pretty good.<br><br>At any rate I'm interested in this as well so let's discuss what we could do.  I've had some ideas for simple 3d engines including a Comanche style fakevoxel terrain engine. <br><br></td></tr></table><br>
<a name="2080191"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nobuyuki</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> something like this?<br><a href="http://nobuyuki.gpknow.com/lab/vectorball/" target="_blank">http://nobuyuki.gpknow.com/lab/vectorball/</a><br><br>Once you have the points projected in 3d you can just use the DrawPoly overload to map a texture to a quad, if you want that sorta effect. <br><br></td></tr></table><br>
<a name="2080337"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >ordigdug</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Nobuyuki, would you be willing to share your code for the above example? <br><br></td></tr></table><br>
<a name="2080536"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >zoqfotpik</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Here's some Processing source for a vectorball effect.  I agree that it would be nice to see Nobuyuki's.<br><br><a href="http://luis.net/projects/processing/vectorball/vectorball.pde" target="_blank">http://luis.net/projects/processing/vectorball/vectorball.pde</a> <br><br></td></tr></table><br>
<a name="2080537"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> Yes that would be great, I only need 'quads' just the ability to alter monkey images to different 3d positions and rotations<br>(With parent child relationships) <br><br></td></tr></table><br>
<a name="2080561"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> I think this works<br>(just rotates points so far)<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Import mojo

Const WIDTH#=320'/4
Const HEIGHT#=240'/4

Class Point
Global list:List&lt;Point&gt;
Field x#,y#,z#
End Class


Class MyApp Extends App

	Field time,frames,fps
	Field image:Image
	Field sprites:=New Stack&lt;Sprite&gt;

	Method OnCreate()
	
		image=LoadImage( "smalltilefloor.png",Image.MidHandle )
		
		
		Point.list=New List&lt;Point&gt;
		Local p:Point=New Point()
		
		Point.list.AddLast(p)
		p=New Point()
		Point.list.AddLast(p)
		p.x=100
		p=New Point()
		p.x=100
		p.y=100
		Point.list.AddLast(p)
		
		time=Millisecs
		
		SetUpdateRate 60
		
		
	End
	
	Method OnUpdate()
			angx+=1
	If angx&gt;359
	angx=1
	Endif
	End Method

	Field angx:Float
	Field angy:Float
	Field angz:Float

	Method OnRender()

		
		Cls

	For Local p:Point=Eachin Point.list
 Local   x:Int = p.x
 Local   y:Int = p.y
 Local   z:Int = p.z

    ' Rotate about x axis
    Local x2:Float = x
    Local y2:Float = y * fcos(Int(angx)) - z * fsin(Int(angx))
       Local z2:Float = y * fsin(Int(angx)) + z * fcos(Int(angx))

    ' Rotate about y axis
    Local x3:Float = x2 * fcos(Int(angy)) + z2 * fsin(Int(angy))
    Local y3:Float = y2
    Local z3:Float = -x2 * fsin(Int(angy)) + z2 * fcos(Int(angy))

    ' Rotate about z axis
    Local x4:Float = x3 * fcos(Int(angz)) - y3 * fsin(Int(angz))
    Local y4:Float = x3 * fsin(Int(angz)) + y3 * fcos(Int(angz))
    Local z4:Float = z3

    DrawPoint(x4,y4)
    'ballZ[n] = z4;
	next
	End

End



Function fcos:Float(angle:Int)
  Return Cos(angle)'/127.0)
End Function

Function fsin:Float(angle:Int)
  Return Sin(angle)'/127.0) 
End Function

Function Main()

	New MyApp
	
End</textarea> <br><br></td></tr></table><br>
<a name="2080552"></a>

<a name="2080555"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Nobuyuki</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#9">[#9]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi guys, sorry for not getting back to you right away.  Here's the source code;  it's old, ugly and you might not like it!<br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Import mojo

Function Main:Int()
	New Game()
End Function

Class Game Extends App
	Field Balls:= New SpriteList
	Field font:Image

	Field usePerspective:Bool = True
	Field xOffset:Float, yOffset:Float, zOffset:Float
	
	Field xRot:Float, yRot:Float, zRot:Float
	
	Method OnCreate:Int()
		SetUpdateRate 60
		font = LoadImage("font.png", 91)
		SetFont(font)

		Seed = Millisecs * MouseY + MouseX
		MakeSphere()
		
	End Method
	
	Method MakeSphere:Void()
		Balls.Clear()
		Const sphereR:Float = 160
		Const rings:Int = 7
		Local ringStep:Float = 360 / rings / 2

		For Local j:Int = 1 To rings - 1
			For Local i:Int = 0 To 15
				Local o:= New Ball(0, 0, 0)
				Local k:Float = Sin(j * ringStep) * sphereR
				o.x = k * Sin( (i + j) * 24)
				o.y = k * Cos( (i + j) * 24)
				o.z = (Cos(j * ringStep) * sphereR)
				
				o.r = Rnd(256)
				o.g = Rnd(256)
				o.b = Rnd(256)
			 	o.text = String.FromChar(Rnd(43) + 48)
				
				Balls.AddLast(o)
			Next
		Next
		
		xRot = Rnd(-1.25, 1.25)
		yRot = Rnd(-2, 2)
		zRot = Rnd(-1.5, 1.5)
	End Method
	
	Method OnUpdate:Int()
		
			If KeyHit(KEY_BACK) Then Error("")
	
			Balls.Sort()
	
			For Local o:Ball = EachIn Balls
				o.Rot3(Ball.Z_AXIS, o.GetAngle(Ball.Z_AXIS) + xRot)
				o.Rot3(Ball.X_AXIS, o.GetAngle(Ball.X_AXIS) + yRot)
				o.Rot3(Ball.Y_AXIS, o.GetAngle(Ball.Y_AXIS) + zRot)

			Next
				
			
			If KeyHit(KEY_SPACE)
				If usePerspective = True Then usePerspective = False Else usePerspective = True
			End If
			
			If KeyDown(KEY_A) or KeyDown(KEY_LEFT)
				xOffset -= 4
			End If
			If KeyDown(KEY_D) or KeyDown(KEY_RIGHT)
				xOffset += 4
			End If
			If KeyDown(KEY_W) or KeyDown(KEY_PAGEUP)
				zOffset -= 4
			End If
			If KeyDown(KEY_S) or KeyDown(KEY_PAGEDOWN)
				zOffset += 4
			End If
			If KeyDown(KEY_UP)
				yOffset -= 4
			End If
			If KeyDown(KEY_DOWN)
				yOffset += 4
			End If
			
			If MouseHit()
				MakeSphere
			End If
	End Method
	
	Method OnRender:Int()
		#If TARGET="glfw"
			SetAlpha(0.3); SetColor(0, 0, 0)
			DrawRect(0, 0, DeviceWidth(), DeviceHeight())
			SetAlpha(1); SetColor(255, 255, 255)
		#Else
			Cls
		#End
				
		For Local o:Ball = EachIn Balls
			
			Local u:Float, v:Float, w:Float, l:Float, t:Float

			If usePerspective
				Local pFactor:Float 'Perspective
				'If pFactor &gt;= 0 Then pFactor = o.z / 480 Else pFactor = - ( (480 + o.z) / 480)
				pFactor = Max( ( (o.z + zOffset) / 320) + 1, 0.001)
				'If pFactor &gt;= 0 Then pFactor = 1 + pFactor 'Else l = pFactor
				
				l = Dist(0, 0, o.x, o.y) * pFactor
				t = ATan2(o.y, o.x)
				
				u = (Cos(t) * l) + xOffset
				v = (Sin(t) * l) + yOffset
				w = ( (o.z + zOffset) / 480) + 1
			Else
				u = o.x + xOffset
				v = o.y + yOffset
				w = 1
			End If
				
			SetColor(o.r, o.g, o.b); SetAlpha(Clamp(0.5 * w - 0.05, 0.0, 1.0))
			 DrawCircle(u + DeviceWidth() / 2, v + DeviceHeight() / 2, 16 * w)
			SetColor(255, 255, 255); SetAlpha(1)
						
			If w &gt; 0.32 Then DrawText(o.text, u + DeviceWidth() / 2, v + DeviceHeight() / 2, 0.5, 0.5)
		Next
		
		Local isOrtho:String
		If usePerspective = True Then isOrtho = "Enable" Else isOrtho = "Disable"
		DrawParagraph("vectorball.monkey~nSpacebar: Ortho '" + isOrtho +
					"~n~nX: " + xOffset + "~nY: " + yOffset + "~nZ: " + zOffset, 8, 8,,, 3)
					
		DrawText("Click to regenerate", DeviceWidth() -8, DeviceHeight - 8, 1, 1)

	End Method
End Class


Class Ball
	Field x:Float, y:Float, z:Float
	Field r:Int, g:Int, b:Int
	Field text:String
		Method New(X:Float, Y:Float, Z:Float)
			x = X; y = Y; z = Z
		End Method

	Method Rot3:Void(axis:Int, amount:Float)
		Local a:Float, b:Float, c:Float
		Select axis
		  Case X_AXIS
			a = z; b = y; c = x
		  Case Y_AXIS
		  	a = x; b = z; c = y
		  Case Z_AXIS
			a = x; b = y; c = z
		End Select
		'Find existing point in polar
		Local l:Float = Dist(0, 0, a, b)
		'Local t:Float = ATan2(b, a)
		't += amount
		
		a = Cos(amount) * l
		b = Sin(amount) * l

		Select axis
		  Case X_AXIS
			z = a; y = b; x = c
		  Case Y_AXIS
		  	x = a; z = b; y = c
		  Case Z_AXIS
			x = a; y = b; z = c
		End Select			
	End Method

	Method GetAngle:Float(axis:Int)
		Local a:Float, b:Float, c:Float
		Select axis
		  Case X_AXIS
			a = z; b = y; c = x
		  Case Y_AXIS
		  	a = x; b = z; c = y
		  Case Z_AXIS
			a = x; b = y; c = z
		End Select
		Return ATan2(b, a)
	End Method
		
	Const X_AXIS:Int = 0
	Const Y_AXIS:Int = 1
	Const Z_AXIS:Int = 2
End Class

Class SpriteList Extends List&lt;Ball&gt;
	'Comparator method.  Use [SpriteList].Sort on an instance to do this.  Uses undocumented methods...
	Method Compare:Int(e1:Ball, e2:Ball)
		If e1.z &lt; e2.z Then Return - 1
		Return e1.z &gt; e2.z
	End Method
End Class


Function Dist:Float(x1:Float, y1:Float, x2:Float, y2:Float)
	Return Sqrt(Pow(x2 - x1, 2) + Pow(y2 - y1, 2))
End Function


Function DrawParagraph:Void(input:String, x:Float, y:Float, xAlign:Float = 0, yAlign:Float = 0, leading:Float = 0)
		Local piece:String[] = input.Split("~n")

		For Local i:Int = 0 Until piece.Length
			
			DrawText(piece[i], x, y + (i * (GetFont().Height +leading)), xAlign, yAlign)
		Next 
End Function
</textarea><br><br>Rotation is Euler, prepare for gimbal lock<br><br>Edit:  And here's the font<br><img src="http://www.gpknow.com/nobuyuki/lab/vectorball/data/font.png"> <br><br></td></tr></table><br>
<a name="2080554"></a>

<a name="2080553"></a>

<a name="2080557"></a>

<a name="2080558"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#10">[#10]</a></td></tr></table></td></tr><tr ><td class="posttext"> thanks<br><br>I managed to get a polygon to rotate:<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">

Import mojo

Const WIDTH#=320'/4
Const HEIGHT#=240'/4

Class Point
Field x#,y#,z#
Field x2d:Float
Field y2d:Float
End Class

Class Shape
Global list:List&lt;Shape&gt;
Field Points:Point[4]
End Class

Class MyApp Extends App

	Field time,frames,fps
	Field image:Image
	Field sprites:=New Stack&lt;Sprite&gt;

	Method OnCreate()
	
		image=LoadImage( "smalltilefloor.png",Image.MidHandle )
		
		
		Shape.list=New List&lt;Shape&gt;
		Local s:Shape=New Shape()
		Shape.list.AddLast(s)
		s.Points[0]=New Point()
		s.Points[0].x=100
		s.Points[0].y=100
		s.Points[0].z=0
		
		s.Points[1]=New Point()
		s.Points[1].x=200
		s.Points[1].y=100
		s.Points[1].z=0
		
		s.Points[2]=New Point()
		s.Points[2].x=200
		s.Points[2].y=200
		s.Points[2].z=0
		
		s.Points[3]=New Point()
		s.Points[3].x=100
		s.Points[3].y=200
		s.Points[3].z=0
		
		time=Millisecs
		
		SetUpdateRate 60
		
		
	End Method
	
	Method OnUpdate()
	angy+=1
	If angy&gt;359
	angy=1
	Endif
	'angz+=1
	'If angz&gt;359
	'angz=1
	'Endif
	
	End Method

	Field angx:Float
	Field angy:Float
	Field angz:Float

	Method OnRender()
Cls
		
For Local S:Shape=Eachin Shape.list

	For Local iter:Int=0 To 3
	 Local   x:Int = S.Points[iter].x
	 Local   y:Int = S.Points[iter].y
	 Local   z:Int = S.Points[iter].z

    ' Rotate about x axis
    Local x2:Float = x
    Local y2:Float = y * fcos(Int(angx)) - z * fsin(Int(angx))
       Local z2:Float = y * fsin(Int(angx)) + z * fcos(Int(angx))

    ' Rotate about y axis
    Local x3:Float = x2 * fcos(Int(angy)) + z2 * fsin(Int(angy))
    Local y3:Float = y2
    Local z3:Float = -x2 * fsin(Int(angy)) + z2 * fcos(Int(angy))

    ' Rotate about z axis
    Local x4:Float = x3 * fcos(Int(angz)) - y3 * fsin(Int(angz))
    Local y4:Float = x3 * fsin(Int(angz)) + y3 * fcos(Int(angz))
    Local z4:Float = z3
	S.Points[iter].x2d=x4
	S.Points[iter].y2d=y4
	
    DrawPoint(x4,y4)
	Next
	DrawPoly([S.Points[0].x2d,S.Points[0].y2d,S.Points[1].x2d,S.Points[1].y2d,S.Points[2].x2d,S.Points[2].y2d,S.Points[3].x2d,S.Points[3].y2d])
Next
' DrawPoly( ,image)
	End

End



Function fcos:Float(angle:Int)
  Return Cos(angle)'/127.0)
End Function

Function fsin:Float(angle:Int)
  Return Sin(angle)'/127.0) 
End Function

Function Main()

	New MyApp
	
End
</textarea><br>It seems to rotate every point around the co-ordinates 0,0,0 so I wonder how someone would change that?<br>I tried the undocumented textured polygon command but it didnt work <br><br></td></tr></table><br>
<a name="2080556"></a>

<a name="2080893"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >slenkar</td><td align="right"><font class=tiny>(Posted 2014)</font>&nbsp;<a href="#11">[#11]</a></td></tr></table></td></tr><tr ><td class="posttext"> I ripped out the matrix stuff from minib3d:<br><br><br><br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Import monkey.math
'Import minib3d.monkeyutility
'Import minib3d.math.vector
'Import minib3d.math.geom

'' opengl is column-major order m[column][row]
''m0 m4 m8 m12
''m1 m5 m9 m13
''m2 m6 m10 m14
''m3 m7 m11 m15
''

''matrix methods act on themselves, to speed up garbage collection
''this is different than vector, line, plane
Class Vector

	Field x#,y#,z#
	
	Const EPSILON=.0001

	Method New(xx#=0.0,yy#=0.0,zz#=0.0)
		
		x=xx
		y=yy
		z=zz
		
	End 

	Function Create:Vector(xx#,yy#,zz#)
	
		Return New Vector(xx,yy,zz)
		
	End 
	
	Method Copy:Vector()
	
		Return New Vector(x,y,z)
	
	End 
	
	Method Add:Vector(vec:Vector) 
		
		Return New Vector(x+vec.x, y+vec.y, z+vec.z)
	
	End
	
	Method Add:Vector(vx:Float, vy:Float, vz:Float) 

		Return New Vector(x+vx, y+vy, z+vz)
	
	End
	
	Method Subtract:Vector(vec:Vector) 

		Return New Vector(x-vec.x, y-vec.y, z-vec.z)
	
	End 
	
	Method Subtract:Vector(vx:Float, vy:Float, vz:Float) 

		Return New Vector(x-vx, y-vy, z-vz)
	
	End
	
	Method Multiply:Vector(v:Vector) 
		
		Return New Vector(x*v.x,y*v.y,z*v.z)
	
	End 
	
	Method Multiply:Vector(val#) 
		
		Return New Vector(x*val,y*val,z*val)
	
	End 
	
	Method Multiply:Vector(a#,b#,c#) 
		
		Return New Vector(x*a,y*b,z*c)
	
	End
	
	Method Divide:Vector(val#) 
	
		Local inv:Float = 1.0/val
		Return New Vector(x*inv,y*inv,z*inv)
	
	End
	
	Method Divide:Vector(v:Vector) 
		
		Return New Vector(x/v.x,y/v.y,z/v.z)
	
	End
	
	Method Dot:Float(vec:Vector) 
	
		Return (x*vec.x)+(y*vec.y)+(z*vec.z)
	
	End 
	
	Method Cross:Vector(vec:Vector) 
		
		Return New Vector( (y*vec.z)-(z*vec.y), (z*vec.x)-(x*vec.z), (x*vec.y)-(y*vec.x) )
	
	End 
	
	Method Normalize:Vector() 
	
		If x=0 And y=0 And z=0 Then Return New Vector(0,0,0)
		
		Local d#=1.0/Sqrt(x*x+y*y+z*z)
		Return New Vector(x*d,y*d,z*d)
	End 
	
	Method Normalise:Vector() 
	
		If x=0 And y=0 And z=0 Then Return New Vector(0,0,0)
		
		Local d#=1.0/Sqrt(x*x+y*y+z*z)
		Return New Vector(x*d,y*d,z*d)
	End 
	
	Method Length#() 
			
		Return Sqrt(x*x+y*y+z*z)

	End 
	
	Method SquaredLength#() 
	
		Return x*x+y*y+z*z

	End
	
	Method DistanceSquared:Float () 
	
		Return x*x+y*y+z*z

	End
	
	Method DistanceSquared:Float ( q:Vector) 
		Local xx:Float = x-q.x
		Local yy:Float = y-q.y
		Local zz:Float = z-q.z
		Return (xx*xx + yy*yy + zz*zz)
	End 
	
	Method Distance:Float ( q:Vector) 
		Local xx:Float = x-q.x
		Local yy:Float = y-q.y
		Local zz:Float = z-q.z
		Return Sqrt(xx*xx + yy*yy + zz*zz)
	End
	
	Method SetLength(val#) 
	
		Local vec:Vector = Normalize()
		x=vec.x*val
		y=vec.y*val
		z=vec.z*val

	End 
	
	Method Compare:Int ( with:Object ) 
		Local q:Vector=Vector(with)
		If x-q.x&gt;EPSILON Return 1
		If q.x-x&gt;EPSILON Return -1
		If y-q.y&gt;EPSILON Return 1
		If q.y-y&gt;EPSILON Return -1
		If z-q.z&gt;EPSILON Return 1
		If q.z-z&gt;EPSILON Return -1
		Return 0
	End 

	' Function by patmaba
	Function VectorYaw#(vx#,vy#,vz#)

		Return ATan2(-vx,vz)
	
	End 

	' Function by patmaba
	Function VectorPitch#(vx#,vy#,vz#)

		Local ang#=ATan2(Sqrt(vx*vx+vz*vz),vy)-90.0

		If ang&lt;=0.0001 And ang&gt;=-0.0001 Then ang=0
	
		Return ang
	
	End 
	
	Method PointOnSegment:Vector(o:Vector, d:Vector) 
		Local d2:Vector = d.Subtract(o)
		
		Local dx# = x-o.x
		Local dy# = y-o.y
		Local dz# = z-o.z
		Local v:Float = (d2.x*dx + d2.y*dy + d2.z*dz) / (d2.x*d2.x + d2.y*d2.y + d2.z*d2.z)
		If v&gt;1.0 Then Return d
		If v&lt;0.0 Then Return o
		Return New Vector(o.x+d2.x*v, o.y+d2.y*v, o.z+d2.z*v)'o.Add(d.Multiply(v))
		
	End
	
	
	Method Negate:Vector() 
		Return New Vector(-x, -y, -z)
	End
	
	Method Update( xx:Float, yy:Float, zz:Float) 
		x=xx; y=yy; z=zz
	End
	
	Method Overwrite( xx:Float, yy:Float, zz:Float) 
		x=xx; y=yy; z=zz
	End
	
	Method Overwrite( v:Vector) 
		x=v.x; y=v.y; z=v.z
	End
	
	Method ToString:String()
		Return "x:"+x+" y:"+y+" z:"+z
	End
	
End 

Class Matrix

	Field grid:Float[4][]''4x4

Private
	
	Global temp:Matrix =New Matrix
	
Public

	Method New()
		
		'grid = AllocateFloatArray(4,4)
		grid = [[0.0,0.0,0.0,0.0],[0.0,0.0,0.0,0.0],[0.0,0.0,0.0,0.0],[0.0,0.0,0.0,0.0]]

		
	End
	
	Method New( a:Vector, b:Vector, c:Vector)

		grid[0] = [a.x,a.y,a.z,0.0]
		grid[1] = [b.x,b.y,b.z,0.0]
		grid[2] = [c.x,c.y,c.z,0.0]
		grid[3] = [0.0,0.0,0.0,1.0]
		
	End
	
	
	Method LoadIdentity:Void()
	
		grid[0][0] = 1.0; grid[0][1] = 0.0; grid[0][2] = 0.0; grid[0][3] = 0.0
		grid[1][0] = 0.0; grid[1][1] = 1.0; grid[1][2] = 0.0; grid[1][3] = 0.0
		grid[2][0] = 0.0; grid[2][1] = 0.0; grid[2][2] = 1.0; grid[2][3] = 0.0
		grid[3][0] = 0.0; grid[3][1] = 0.0; grid[3][2] = 0.0; grid[3][3] = 1.0
	
	End
	
	' copy - create new copy and returns it
	
	Method Copy:Matrix()
	
		Local mat:Matrix=New Matrix
	
		mat.grid[0][0]=grid[0][0]
		mat.grid[1][0]=grid[1][0]
		mat.grid[2][0]=grid[2][0]
		mat.grid[3][0]=grid[3][0]
		
		mat.grid[0][1]=grid[0][1]
		mat.grid[1][1]=grid[1][1]
		mat.grid[2][1]=grid[2][1]
		mat.grid[3][1]=grid[3][1]
		
		mat.grid[0][2]=grid[0][2]
		mat.grid[1][2]=grid[1][2]
		mat.grid[2][2]=grid[2][2]
		mat.grid[3][2]=grid[3][2]
		
		mat.grid[0][3]=grid[0][3]
		mat.grid[1][3]=grid[1][3]
		mat.grid[2][3]=grid[2][3]
		mat.grid[3][3]=grid[3][3]

		Return mat
	
	End
	
	' overwrite - overwrites self with matrix passed as parameter
	
	Method Overwrite:Void(mat:Matrix)
	
		grid[0][0]=mat.grid[0][0]
		grid[1][0]=mat.grid[1][0]
		grid[2][0]=mat.grid[2][0]
		grid[3][0]=mat.grid[3][0]
		grid[0][1]=mat.grid[0][1]
		grid[1][1]=mat.grid[1][1]
		grid[2][1]=mat.grid[2][1]
		grid[3][1]=mat.grid[3][1]
		grid[0][2]=mat.grid[0][2]
		grid[1][2]=mat.grid[1][2]
		grid[2][2]=mat.grid[2][2]
		grid[3][2]=mat.grid[3][2]
		
		grid[0][3]=mat.grid[0][3]
		grid[1][3]=mat.grid[1][3]
		grid[2][3]=mat.grid[2][3]
		grid[3][3]=mat.grid[3][3]
		
	End
	
	Method Inverse:Matrix()
		'' only good for orthogonal matrixes
		'' (ie. no scaling)
		'' if there are problems, need to use the determinate-style inverse (many calculations)
		
		Local mat:Matrix=New Matrix
	
		Local tx#=0
		Local ty#=0
		Local tz#=0
	
	  	' The rotational part of the matrix is simply the transpose of the
	  	' original matrix.
	  	mat.grid[0][0] = grid[0][0]
	  	mat.grid[1][0] = grid[0][1]
	  	mat.grid[2][0] = grid[0][2]
	
		mat.grid[0][1] = grid[1][0]
		mat.grid[1][1] = grid[1][1]
		mat.grid[2][1] = grid[1][2]
	
		mat.grid[0][2] = grid[2][0]
		mat.grid[1][2] = grid[2][1]
		mat.grid[2][2] = grid[2][2]
	
		' The right column vector of the matrix should always be [ 0 0 0 1 ]
		' in most cases. . . you don't need this column at all because it'll 
		' never be used in the program, but since this code is used with GL
		' and it does consider this column, it is here.
		mat.grid[0][3] = 0 
		mat.grid[1][3] = 0
		mat.grid[2][3] = 0
		mat.grid[3][3] = 1
	
		' The translation components of the original matrix.
		tx = grid[3][0]
		ty = grid[3][1]
		tz = grid[3][2]
	
		' Result = -(Tm * Rm) To get the translation part of the inverse
		mat.grid[3][0] = -( (grid[0][0] * tx) + (grid[0][1] * ty) + (grid[0][2] * tz) )
		mat.grid[3][1] = -( (grid[1][0] * tx) + (grid[1][1] * ty) + (grid[1][2] * tz) )
		mat.grid[3][2] = -( (grid[2][0] * tx) + (grid[2][1] * ty) + (grid[2][2] * tz) )
	
		Return mat

	End 

	Method Inverse4:Matrix()
		
		Local matrix:Matrix=New Matrix
		Local d:Float ''determinant
		
		Local m10_00# = grid[1][0]*grid[0][0]
		Local m10_01# = grid[1][0]*grid[0][1]
		Local m10_02# = grid[1][0]*grid[0][2]
		Local m10_03# = grid[1][0]*grid[0][3]
		Local m11_00# = grid[1][1]*grid[0][0]
		Local m11_01# = grid[1][1]*grid[0][1]
		Local m11_02# = grid[1][1]*grid[0][2]
		Local m11_03# = grid[1][1]*grid[0][3]
		Local m12_00# = grid[1][2]*grid[0][0]
		Local m12_01# = grid[1][2]*grid[0][1]
		Local m12_02# = grid[1][2]*grid[0][2]
		Local m12_03# = grid[1][2]*grid[0][3]
		Local m13_00# = grid[1][3]*grid[0][0]
		Local m13_01# = grid[1][3]*grid[0][1]
		Local m13_02# = grid[1][3]*grid[0][2]
		Local m13_03# = grid[1][3]*grid[0][3]
		
		matrix.grid[0][0] = (grid[1][1]*grid[2][2]*grid[3][3] + grid[1][2]*grid[2][3]*grid[3][1] + grid[1][3]*grid[2][1]*grid[3][2] - grid[1][1]*grid[2][3]*grid[3][2] - grid[1][2]*grid[2][1]*grid[3][3] - grid[1][3]*grid[2][2]*grid[3][1])'*d
		matrix.grid[1][0] = (grid[1][0]*grid[2][3]*grid[3][2] + grid[1][2]*grid[2][0]*grid[3][3] + grid[1][3]*grid[2][2]*grid[3][0] - grid[1][0]*grid[2][2]*grid[3][3] - grid[1][2]*grid[2][3]*grid[3][0] - grid[1][3]*grid[2][0]*grid[3][2])'*d
		matrix.grid[2][0] = (grid[1][0]*grid[2][1]*grid[3][3] + grid[1][1]*grid[2][3]*grid[3][0] + grid[1][3]*grid[2][0]*grid[3][1] - grid[1][0]*grid[2][3]*grid[3][1] - grid[1][1]*grid[2][0]*grid[3][3] - grid[1][3]*grid[2][1]*grid[3][0])'*d
		matrix.grid[3][0] = (grid[1][0]*grid[2][2]*grid[3][1] + grid[1][1]*grid[2][0]*grid[3][2] + grid[1][2]*grid[2][1]*grid[3][0] - grid[1][0]*grid[2][1]*grid[3][2] - grid[1][1]*grid[2][2]*grid[3][0] - grid[1][2]*grid[2][0]*grid[3][1])'*d
		
		''determinate &amp; check
		d = grid[0][0]*matrix.grid[0][0] + grid[0][1]*matrix.grid[1][0] + grid[0][2]*matrix.grid[2][0] + grid[0][3]*matrix.grid[3][0]
		
		If d = 0
			matrix.grid[0][0]=0.0; matrix.grid[1][0]=0.0; matrix.grid[2][0]=0.0; matrix.grid[3][0]=0.0
			Return matrix
		Endif
		d = 1.0/d
		
		matrix.grid[0][0] *= d
		matrix.grid[1][0] *= d
		matrix.grid[2][0] *= d
		matrix.grid[3][0] *= d
		matrix.grid[0][1] = (grid[0][1]*grid[2][3]*grid[3][2] + grid[0][2]*grid[2][1]*grid[3][3] + grid[0][3]*grid[2][2]*grid[3][1] - grid[0][1]*grid[2][2]*grid[3][3] - grid[0][2]*grid[2][3]*grid[3][1] - grid[0][3]*grid[2][1]*grid[3][2])*d
		matrix.grid[0][2] = (m12_01               *grid[3][3] + m13_02               *grid[3][1] + m11_03               *grid[3][2] - m13_01               *grid[3][2] - m11_02               *grid[3][3] - m12_03               *grid[3][1])*d
		matrix.grid[0][3] = (m13_01               *grid[2][2] + m11_02               *grid[2][3] + m12_03               *grid[2][1] - m12_01               *grid[2][3] - m13_02               *grid[2][1] - m11_03               *grid[2][2])*d
		matrix.grid[1][1] = (grid[0][0]*grid[2][2]*grid[3][3] + grid[0][2]*grid[2][3]*grid[3][0] + grid[0][3]*grid[2][0]*grid[3][2] - grid[0][0]*grid[2][3]*grid[3][2] - grid[0][2]*grid[2][0]*grid[3][3] - grid[0][3]*grid[2][2]*grid[3][0])*d
		matrix.grid[1][2] = (m13_00               *grid[3][2] + m10_02               *grid[3][3] + m12_03               *grid[3][0] - m12_00               *grid[3][3] - m13_02               *grid[3][0] - m10_03               *grid[3][2])*d
		matrix.grid[1][3] = (m12_00               *grid[2][3] + m13_02               *grid[2][0] + m10_03               *grid[2][2] - m13_00               *grid[2][2] - m10_02               *grid[2][3] - m12_03               *grid[2][0])*d
		matrix.grid[2][1] = (grid[0][0]*grid[2][3]*grid[3][1] + grid[0][1]*grid[2][0]*grid[3][3] + grid[0][3]*grid[2][1]*grid[3][0] - grid[0][0]*grid[2][1]*grid[3][3] - grid[0][1]*grid[2][3]*grid[3][0] - grid[0][3]*grid[2][0]*grid[3][1])*d
		matrix.grid[2][2] = (m11_00               *grid[3][3] + m13_01               *grid[3][0] + m10_03               *grid[3][1] - m13_00               *grid[3][1] - m10_01               *grid[3][3] - m11_03               *grid[3][0])*d
		matrix.grid[2][3] = (m13_00               *grid[2][1] + m10_01               *grid[2][3] + m11_03               *grid[2][0] - m11_00               *grid[2][3] - m13_01               *grid[2][0] - m10_03               *grid[2][1])*d
		matrix.grid[3][1] = (grid[0][0]*grid[2][1]*grid[3][2] + grid[0][1]*grid[2][2]*grid[3][0] + grid[0][2]*grid[2][0]*grid[3][1] - grid[0][0]*grid[2][2]*grid[3][1] - grid[0][1]*grid[2][0]*grid[3][2] - grid[0][2]*grid[2][1]*grid[3][0])*d
		matrix.grid[3][2] = (m12_00               *grid[3][1] + m10_01               *grid[3][2] + m11_02               *grid[3][0] - m11_00               *grid[3][2] - m12_01               *grid[3][0] - m10_02               *grid[3][1])*d
		matrix.grid[3][3] = (m11_00               *grid[2][2] + m12_01               *grid[2][0] + m10_02               *grid[2][1] - m12_00               *grid[2][1] - m10_01               *grid[2][2] - m11_02               *grid[2][0])*d

		Return matrix
		
	End

	Method Multiply:Void(mat:Matrix)
		'' 3x4 multiply
	
		Local m00# = grid[0][0]*mat.grid[0][0] + grid[1][0]*mat.grid[0][1] + grid[2][0]*mat.grid[0][2] + grid[3][0]*mat.grid[0][3]
		Local m01# = grid[0][1]*mat.grid[0][0] + grid[1][1]*mat.grid[0][1] + grid[2][1]*mat.grid[0][2] + grid[3][1]*mat.grid[0][3]
		Local m02# = grid[0][2]*mat.grid[0][0] + grid[1][2]*mat.grid[0][1] + grid[2][2]*mat.grid[0][2] + grid[3][2]*mat.grid[0][3]
		'Local m03# = grid[0][3]*mat.grid[0][0] + grid[1][3]*mat.grid[0][1] + grid[2][3]*mat.grid[0][2] + grid[3][3]*mat.grid[0][3]
		Local m10# = grid[0][0]*mat.grid[1][0] + grid[1][0]*mat.grid[1][1] + grid[2][0]*mat.grid[1][2] + grid[3][0]*mat.grid[1][3]
		Local m11# = grid[0][1]*mat.grid[1][0] + grid[1][1]*mat.grid[1][1] + grid[2][1]*mat.grid[1][2] + grid[3][1]*mat.grid[1][3]
		Local m12# = grid[0][2]*mat.grid[1][0] + grid[1][2]*mat.grid[1][1] + grid[2][2]*mat.grid[1][2] + grid[3][2]*mat.grid[1][3]
		'Local m13# = grid[0][3]*mat.grid[1][0] + grid[1][3]*mat.grid[1][1] + grid[2][3]*mat.grid[1][2] + grid[3][3]*mat.grid[1][3]
		Local m20# = grid[0][0]*mat.grid[2][0] + grid[1][0]*mat.grid[2][1] + grid[2][0]*mat.grid[2][2] + grid[3][0]*mat.grid[2][3]
		Local m21# = grid[0][1]*mat.grid[2][0] + grid[1][1]*mat.grid[2][1] + grid[2][1]*mat.grid[2][2] + grid[3][1]*mat.grid[2][3]
		Local m22# = grid[0][2]*mat.grid[2][0] + grid[1][2]*mat.grid[2][1] + grid[2][2]*mat.grid[2][2] + grid[3][2]*mat.grid[2][3]
		'Local m23# = grid[0][3]*mat.grid[2][0] + grid[1][3]*mat.grid[2][1] + grid[2][3]*mat.grid[2][2] + grid[3][3]*mat.grid[2][3]
		Local m30# = grid[0][0]*mat.grid[3][0] + grid[1][0]*mat.grid[3][1] + grid[2][0]*mat.grid[3][2] + grid[3][0]*mat.grid[3][3]
		Local m31# = grid[0][1]*mat.grid[3][0] + grid[1][1]*mat.grid[3][1] + grid[2][1]*mat.grid[3][2] + grid[3][1]*mat.grid[3][3]
		Local m32# = grid[0][2]*mat.grid[3][0] + grid[1][2]*mat.grid[3][1] + grid[2][2]*mat.grid[3][2] + grid[3][2]*mat.grid[3][3]
		'Local m33# = grid[0][3]*mat.grid[3][0] + grid[1][3]*mat.grid[3][1] + grid[2][3]*mat.grid[3][2] + grid[3][3]*mat.grid[3][3]
		
		grid[0][0]=m00
		grid[0][1]=m01
		grid[0][2]=m02
		'grid[0][3]=m03
		grid[1][0]=m10
		grid[1][1]=m11
		grid[1][2]=m12
		'grid[1][3]=m13
		grid[2][0]=m20
		grid[2][1]=m21
		grid[2][2]=m22
		'grid[2][3]=m23
		grid[3][0]=m30
		grid[3][1]=m31
		grid[3][2]=m32
		'grid[3][3]=m33
		
	End

	Method Multiply4:Void(mat:Matrix)
		'' 4x4 multiply
	
		Local m00# = grid[0][0]*mat.grid[0][0] + grid[1][0]*mat.grid[0][1] + grid[2][0]*mat.grid[0][2] + grid[3][0]*mat.grid[0][3]
		Local m01# = grid[0][1]*mat.grid[0][0] + grid[1][1]*mat.grid[0][1] + grid[2][1]*mat.grid[0][2] + grid[3][1]*mat.grid[0][3]
		Local m02# = grid[0][2]*mat.grid[0][0] + grid[1][2]*mat.grid[0][1] + grid[2][2]*mat.grid[0][2] + grid[3][2]*mat.grid[0][3]
		Local m03# = grid[0][3]*mat.grid[0][0] + grid[1][3]*mat.grid[0][1] + grid[2][3]*mat.grid[0][2] + grid[3][3]*mat.grid[0][3]
		Local m10# = grid[0][0]*mat.grid[1][0] + grid[1][0]*mat.grid[1][1] + grid[2][0]*mat.grid[1][2] + grid[3][0]*mat.grid[1][3]
		Local m11# = grid[0][1]*mat.grid[1][0] + grid[1][1]*mat.grid[1][1] + grid[2][1]*mat.grid[1][2] + grid[3][1]*mat.grid[1][3]
		Local m12# = grid[0][2]*mat.grid[1][0] + grid[1][2]*mat.grid[1][1] + grid[2][2]*mat.grid[1][2] + grid[3][2]*mat.grid[1][3]
		Local m13# = grid[0][3]*mat.grid[1][0] + grid[1][3]*mat.grid[1][1] + grid[2][3]*mat.grid[1][2] + grid[3][3]*mat.grid[1][3]
		Local m20# = grid[0][0]*mat.grid[2][0] + grid[1][0]*mat.grid[2][1] + grid[2][0]*mat.grid[2][2] + grid[3][0]*mat.grid[2][3]
		Local m21# = grid[0][1]*mat.grid[2][0] + grid[1][1]*mat.grid[2][1] + grid[2][1]*mat.grid[2][2] + grid[3][1]*mat.grid[2][3]
		Local m22# = grid[0][2]*mat.grid[2][0] + grid[1][2]*mat.grid[2][1] + grid[2][2]*mat.grid[2][2] + grid[3][2]*mat.grid[2][3]
		Local m23# = grid[0][3]*mat.grid[2][0] + grid[1][3]*mat.grid[2][1] + grid[2][3]*mat.grid[2][2] + grid[3][3]*mat.grid[2][3]
		Local m30# = grid[0][0]*mat.grid[3][0] + grid[1][0]*mat.grid[3][1] + grid[2][0]*mat.grid[3][2] + grid[3][0]*mat.grid[3][3]
		Local m31# = grid[0][1]*mat.grid[3][0] + grid[1][1]*mat.grid[3][1] + grid[2][1]*mat.grid[3][2] + grid[3][1]*mat.grid[3][3]
		Local m32# = grid[0][2]*mat.grid[3][0] + grid[1][2]*mat.grid[3][1] + grid[2][2]*mat.grid[3][2] + grid[3][2]*mat.grid[3][3]
		Local m33# = grid[0][3]*mat.grid[3][0] + grid[1][3]*mat.grid[3][1] + grid[2][3]*mat.grid[3][2] + grid[3][3]*mat.grid[3][3]
		
		grid[0][0]=m00
		grid[0][1]=m01
		grid[0][2]=m02
		grid[0][3]=m03
		grid[1][0]=m10
		grid[1][1]=m11
		grid[1][2]=m12
		grid[1][3]=m13
		grid[2][0]=m20
		grid[2][1]=m21
		grid[2][2]=m22
		grid[2][3]=m23
		grid[3][0]=m30
		grid[3][1]=m31
		grid[3][2]=m32
		grid[3][3]=m33
		
	End

	Method Multiply:Vector(v1:Vector)
		'' 3x3 only
		Local v2:Vector = New Vector
		
		v2.x = grid[0][0]*v1.x + grid[1][0]*v1.y + grid[2][0]*v1.z
		v2.y = grid[0][1]*v1.x + grid[1][1]*v1.y + grid[2][1]*v1.z
		v2.z = grid[0][2]*v1.x + grid[1][2]*v1.y + grid[2][2]*v1.z
		
		Return v2
	End
	
	Method Multiply4:Vector(v1:Vector)
		'' 3x4 
		Local v2:Vector = New Vector
		
		v2.x = grid[0][0]*v1.x + grid[1][0]*v1.y + grid[2][0]*v1.z + grid[3][0]
		v2.y = grid[0][1]*v1.x + grid[1][1]*v1.y + grid[2][1]*v1.z + grid[3][1]
		v2.z = grid[0][2]*v1.x + grid[1][2]*v1.y + grid[2][2]*v1.z + grid[3][2]
		
		Return v2
	End

	Method Translate:Void(x:Float,y:Float,z:Float)
	
		grid[3][0] = grid[0][0]*x + grid[1][0]*y + grid[2][0]*z + grid[3][0]
		grid[3][1] = grid[0][1]*x + grid[1][1]*y + grid[2][1]*z + grid[3][1]
		grid[3][2] = grid[0][2]*x + grid[1][2]*y + grid[2][2]*z + grid[3][2]

	End 
	
	Method Translate4:Void(x#,y#,z#,w#=1.0)
	
		grid[3][0] = grid[0][0]*x + grid[1][0]*y + grid[2][0]*z + grid[3][0]*w
		grid[3][1] = grid[0][1]*x + grid[1][1]*y + grid[2][1]*z + grid[3][1]*w
		grid[3][2] = grid[0][2]*x + grid[1][2]*y + grid[2][2]*z + grid[3][2]*w
		grid[3][3] = grid[0][3]*x + grid[1][3]*y + grid[2][3]*z + grid[3][3]*w
		
	End Method
	
	Method Transpose:Matrix()
	
		'Local mat:Matrix = Self.Copy()
		temp.Overwrite(Self)
		
		grid[0][0]=temp.grid[0][0]
		grid[1][0]=temp.grid[0][1]
		grid[2][0]=temp.grid[0][2]
		grid[3][0]=temp.grid[0][3]
		
		grid[0][1]=temp.grid[1][0]
		grid[1][1]=temp.grid[1][1]
		grid[2][1]=temp.grid[1][2]
		grid[3][1]=temp.grid[1][3]
		
		grid[0][2]=temp.grid[2][0]
		grid[1][2]=temp.grid[2][1]
		grid[2][2]=temp.grid[2][2]
		grid[3][2]=temp.grid[2][3]
		
		grid[0][3]=temp.grid[3][0]
		grid[1][3]=temp.grid[3][1]
		grid[2][3]=temp.grid[3][2]
		grid[3][3]=temp.grid[3][3]
		
		Return Self
	End
		
	Method Scale:Void(sx:Float,sy:Float,sz:Float)
		
		If sx=1.0 And sy=1.0 And sz=1.0 Then Return
		
		grid[0][0] = grid[0][0]*sx
		grid[0][1] = grid[0][1]*sx
		grid[0][2] = grid[0][2]*sx

		grid[1][0] = grid[1][0]*sy
		grid[1][1] = grid[1][1]*sy
		grid[1][2] = grid[1][2]*sy

		grid[2][0] = grid[2][0]*sz
		grid[2][1] = grid[2][1]*sz
		grid[2][2] = grid[2][2]*sz
		
	End 
	
	''special function to remove global scale after a 3x3 inverse
	Method InverseScale:Void(sx#, sy#, sz#)
		If sx=1.0 And sy=1.0 And sz=1.0 Then Return
		
		sx = 1.0/(sx*sx); sy = 1.0/(sy*sy); sz = 1.0/(sz*sz)
		
		''3x4
		grid[0][0] = grid[0][0]*sx
		grid[0][1] = grid[0][1]*sx
		grid[0][2] = grid[0][2]*sx

		grid[1][0] = grid[1][0]*sy
		grid[1][1] = grid[1][1]*sy
		grid[1][2] = grid[1][2]*sy

		grid[2][0] = grid[2][0]*sz
		grid[2][1] = grid[2][1]*sz
		grid[2][2] = grid[2][2]*sz
		
		grid[3][0] = grid[3][0]*sx
		grid[3][1] = grid[3][1]*sy
		grid[3][2] = grid[3][2]*sz
		
	End
	
	Method FastRotateScale:Void(rx:Float,ry:Float,rz:Float,scx:Float,scy:Float,scz:Float)
		CreateMatrix(rx,ry,rz,scx,scy,scz,grid[3][0],grid[3][1],grid[3][2])
	end
	
	Method CreateMatrix:Void(rx:Float,ry:Float,rz:Float,scx:Float,scy:Float,scz:Float,px:Float,py:Float,pz:float)
		''this function will overwrite current matrix
		
		Local sx:Float, sy:Float, sz:Float, cx:Float, cy:Float, cz:Float, theta:Float
		
		'' rotation angle about X-axis (pitch) 
		sx = Sin(rx)
		cx = Cos(rx)
		
		'' rotation angle about Y-axis (yaw) 
		sy = Sin(ry)
		cy = Cos(ry)
		
		'' rotation angle about Z-axis (roll) 
		sz = Sin(rz)
		cz = Cos(rz)
		
		Local sycz:Float = sy*cz
		Local cysz:Float = cy*sz
		Local sysz:Float = sy*sz
		Local cycz:Float = cy*cz
		
		'' determine left axis
		grid[0][0] = (cycz+sysz*sx) *scx
		grid[0][1] = (cx*sz) *scx
		grid[0][2] = (-sycz+cysz*sx) *scx
		grid[0][3] = 0.0
		
		'' determine up axis
		grid[1][0] = (-cysz+sycz*sx) *scy
		grid[1][1] = (cx*cz) *scy
		grid[1][2] = (sysz+cycz*sx) *scy
		grid[1][3] = 0.0
		
		'' determine forward axis
		grid[2][0] = (sy*cx) *scz
		grid[2][1] = (-sx) *scz
		grid[2][2] = (cx*cy) *scz
		grid[2][3] = 0.0
	
		grid[3][0] = px
		grid[3][1] = py
		grid[3][2] = pz
		grid[3][3] = 1.0
		
	End
	
	Method Rotate:Void(rx:Float,ry:Float,rz:Float)
		'' yaw-pitch-roll = y-x-z
			
		Local cos_ang#,sin_ang#, m20#,m21#,m22#,m00#,m01#,m02#,r1#,r2#,r3#
	
		' yaw
	
		cos_ang=Cos(ry)
		sin_ang=Sin(ry)
	
		m00 = grid[0][0]*cos_ang + grid[2][0]*-sin_ang
		m01 = grid[0][1]*cos_ang + grid[2][1]*-sin_ang
		m02 = grid[0][2]*cos_ang + grid[2][2]*-sin_ang
	
		m20 = grid[0][0]*sin_ang + grid[2][0]*cos_ang
		m21 = grid[0][1]*sin_ang + grid[2][1]*cos_ang
		m22 = grid[0][2]*sin_ang + grid[2][2]*cos_ang
		
		' pitch
		
		cos_ang=Cos(rx)
		sin_ang=Sin(rx)
	
		Local m10# = grid[1][0]*cos_ang + m20*sin_ang
		Local m11# = grid[1][1]*cos_ang + m21*sin_ang
		Local m12# = grid[1][2]*cos_ang + m22*sin_ang
	
		grid[2][0] = grid[1][0]*-sin_ang + m20*cos_ang
		grid[2][1] = grid[1][1]*-sin_ang + m21*cos_ang
		grid[2][2] = grid[1][2]*-sin_ang + m22*cos_ang
		
		' roll
		
		cos_ang=Cos(rz)
		sin_ang=Sin(rz)
	
		grid[0][0] = m00*cos_ang + m10*sin_ang
		grid[0][1] = m01*cos_ang + m11*sin_ang
		grid[0][2] = m02*cos_ang + m12*sin_ang
	
		grid[1][0] = m00*-sin_ang + m10*cos_ang
		grid[1][1] = m01*-sin_ang + m11*cos_ang
		grid[1][2] = m02*-sin_ang + m12*cos_ang
	


	End 
	
	Method RotatePitch:Void(ang:Float)
	
		Local cos_ang#=Cos(ang)
		Local sin_ang#=Sin(ang)
	
		Local m10# = grid[1][0]*cos_ang + grid[2][0]*sin_ang
		Local m11# = grid[1][1]*cos_ang + grid[2][1]*sin_ang
		Local m12# = grid[1][2]*cos_ang + grid[2][2]*sin_ang

		grid[2][0] = grid[1][0]*-sin_ang + grid[2][0]*cos_ang
		grid[2][1] = grid[1][1]*-sin_ang + grid[2][1]*cos_ang
		grid[2][2] = grid[1][2]*-sin_ang + grid[2][2]*cos_ang

		grid[1][0]=m10
		grid[1][1]=m11
		grid[1][2]=m12

	End 
	
	Method RotateYaw:Void(ang:Float)
	
		Local cos_ang#=Cos(ang)
		Local sin_ang#=Sin(ang)
	
		Local m00# = grid[0][0]*cos_ang + grid[2][0]*-sin_ang
		Local m01# = grid[0][1]*cos_ang + grid[2][1]*-sin_ang
		Local m02# = grid[0][2]*cos_ang + grid[2][2]*-sin_ang

		grid[2][0] = grid[0][0]*sin_ang + grid[2][0]*cos_ang
		grid[2][1] = grid[0][1]*sin_ang + grid[2][1]*cos_ang
		grid[2][2] = grid[0][2]*sin_ang + grid[2][2]*cos_ang

		grid[0][0]=m00
		grid[0][1]=m01
		grid[0][2]=m02

	End 
	
	Method RotateRoll:Void(ang:Float)
	
		Local cos_ang#=Cos(ang)
		Local sin_ang#=Sin(ang)

		Local m00# = grid[0][0]*cos_ang + grid[1][0]*sin_ang
		Local m01# = grid[0][1]*cos_ang + grid[1][1]*sin_ang
		Local m02# = grid[0][2]*cos_ang + grid[1][2]*sin_ang

		grid[1][0] = grid[0][0]*-sin_ang + grid[1][0]*cos_ang
		grid[1][1] = grid[0][1]*-sin_ang + grid[1][1]*cos_ang
		grid[1][2] = grid[0][2]*-sin_ang + grid[1][2]*cos_ang

		grid[0][0]=m00
		grid[0][1]=m01
		grid[0][2]=m02

	End 
		

	'' bbdoc: Gets the current pitch of the matrix
	''
	Method GetPitch:Float()

		Local x# = grid[2][0]
		Local y# = grid[2][1]
		Local z# = grid[2][2]
		Return -ATan2( y, Sqrt( x*x+z*z ) )
		
	End 

	'' bbdoc: Gets the current yaw of the matrix
	''
	Method GetYaw:Float()
	
		Local x# = grid[2][0]
		Local z# = grid[2][2]	
		Return ATan2( x,z )
		
	End 
	
	'' bbdoc: Gets the current roll of the matrix
	''
	Method GetRoll:Float()
	
		Local iy# = grid[0][1]
		Local jy# = grid[1][1]
		Return ATan2( iy, jy )
	
	End 
	
	''
	'' new functions for monkey 2012
	''
	
	''bbdoc: Transforms a point through the matrix, returns a float array
	''bbdoc: may need to negate z... p[2] = -p[2]
	Method TransformPoint:Float[](x:Float, y:Float, z:Float, w:Float=1.0)
		
		Local p0:Float,p1:Float,p2:Float,p3:Float
		
		'' -z, opengl
		
		p0 = grid[0][0]*x + grid[1][0]*y + grid[2][0]*z + grid[3][0] *w
		p1 = grid[0][1]*x + grid[1][1]*y + grid[2][1]*z + grid[3][1] *w
		p2 = grid[0][2]*x + grid[1][2]*y + grid[2][2]*z + grid[3][2] *w

		
		Return [p0,p1,p2]
	End


	Method Multiply:Line( q:Line)
		Local t:Vector = Self.Multiply(q.o)
		Return New Line(t, Self.Multiply(q.o.Add(q.d)).Subtract(t) )
	End



	
	''bbdoc: returns a matrix class from an float array [16]
	''bbdoc: usually used for tranferring OpenGL data
	
	Method FromArray:Void( arr:Float[] )
	
		grid[0][0] = arr[0];  grid[0][1] = arr[1];  grid[0][2] = arr[2];  grid[0][3] = arr[3]
		grid[1][0] = arr[4];  grid[1][1] = arr[5];  grid[1][2] = arr[6];  grid[1][3] = arr[7]
		grid[2][0] = arr[8];  grid[2][1] = arr[9];  grid[2][2] = arr[10]; grid[2][3] = arr[11]
		grid[3][0] = arr[12]; grid[3][1] = arr[13]; grid[3][2] = arr[14]; grid[3][3] = arr[15]

	End
	

	
	Method ToArray:Float[]()
	
		Local arr:Float[16]
		
		arr[0] = grid[0][0]; arr[1]= grid[0][1]; arr[2]= grid[0][2]; arr[3]= grid[0][3]
		arr[4] = grid[1][0]; arr[5]= grid[1][1]; arr[6]= grid[1][2]; arr[7]= grid[1][3]
		arr[8] = grid[2][0]; arr[9]= grid[2][1]; arr[10]= grid[2][2]; arr[11]= grid[2][3]
		arr[12] = grid[3][0]; arr[13]= grid[3][1]; arr[14]= grid[3][2]; arr[15]= grid[3][3]

		Return arr
	End
	
	
	Method ToArray:Void(arr:Float[])
		
		arr[0] = grid[0][0]; arr[1]= grid[0][1]; arr[2]= grid[0][2]; arr[3]= grid[0][3]
		arr[4] = grid[1][0]; arr[5]= grid[1][1]; arr[6]= grid[1][2]; arr[7]= grid[1][3]
		arr[8] = grid[2][0]; arr[9]= grid[2][1]; arr[10]= grid[2][2]; arr[11]= grid[2][3]
		arr[12] = grid[3][0]; arr[13]= grid[3][1]; arr[14]= grid[3][2]; arr[15]= grid[3][3]

	End

	
	Method Update:Void( a:Vector, b:Vector, c:Vector)

		grid[0][0] = a.x; grid[0][1] = a.y; grid[0][2] = a.z
		grid[1][0] = b.x; grid[1][1] = b.y; grid[1][2] = b.z
		grid[2][0] = c.x; grid[2][1] = c.y; grid[2][2] = c.z

	End

		
End 

Function PrintMatrix:Void(mat:Matrix)
	
	Print mat.grid[0][0]+":"+mat.grid[1][0]+":"+mat.grid[2][0]+":"+mat.grid[3][0]
	Print mat.grid[0][1]+":"+mat.grid[1][1]+":"+mat.grid[2][1]+":"+mat.grid[3][1]
	Print mat.grid[0][2]+":"+mat.grid[1][2]+":"+mat.grid[2][2]+":"+mat.grid[3][2]	
	Print mat.grid[0][3]+":"+mat.grid[1][3]+":"+mat.grid[2][3]+":"+mat.grid[3][3]
	
End

</textarea><br><br>save it as Monkey/Modules/keef/matrix/matrix.monkey<br><br>then here is the demo<br><textarea class=codebox name="code" wrap=OFF readonly="true" rows="15" cols="80">
Import mojo
Import keef.matrix

Class MyApp Extends App

	Field image:Image

	Field mat:Matrix
	Method OnCreate()
	mat=New Matrix()
	mat.LoadIdentity()
		image=LoadImage( "smalltilefloor.png" )
		image.SetHandle(32,32)
		mat.Scale(2,1.5,1)
		mat.Translate(40,40,0)
	
		SetUpdateRate 60
		
		
	End Method
	
	Method OnUpdate()
	End Method

	Method OnRender()
Cls

Local matrix#[6]

mat.Rotate(0,1,1)
		
matrix[0]=mat.grid[0][0]
matrix[1]=mat.grid[0][1]
matrix[2]=mat.grid[1][0]
matrix[3]=mat.grid[1][1]
matrix[4]=mat.grid[3][0]
matrix[5]=mat.grid[3][1]

SetMatrix(matrix)

DrawImage(image,0,0)
End Method
End Class


Function Main()

	New MyApp
	
End</textarea> <br><br></td></tr></table><br>
<a name="2080892"></a>

<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
