<!DOCTYPE html><html lang="en" ><head ><title >Socket Questions</title><meta name='viewport' content='width=device-width, initial-scale=0.66'><meta name='description' content='language:basic, target:desktop, category:game development'><link rel="styleSheet" href="../skins/granite/style.css" type="text/css"><style type="text/css">div.bbcode {padding: 8px;background: #E5E5E5;color: #000000;border: 1px dashed #B4B4BE;}</style></head><body ><table width=100% cellspacing=0 cellpadding=0><tr ><td class="menubarleft"></td><td class="menubar"><table cellspacing="0" cellpadding="0"><tr ><td >&nbsp;</td><td class="menuitemleft"></td><td class="menuitem"><a href="/" class="menuitem">News</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/forums.php" class="menuitem">Forums</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/codearcs.php" class="menuitem">Code</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/logs.php" class="menuitem">Logs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/gallery.php" class="menuitem">Gallery</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/sdkspecs.php" class="menuitem">Specs</a></td><td class="menuitemright"></td><td class="menuitemleft"></td><td class="menuitem"><a href="/search.php" class="menuitem">Search</a></td><td class="menuitemright"></td></tr></table></td><td class="menubarright"></td></tr></table><div class="main"><h1 >Socket Questions</h1><a href="forums.php" >Monkey Forums</a>/<a href="topics.php?forum=507" >Monkey Programming</a>/<a href="#bottom" >Socket Questions</a><br><br>
<a name="2059322"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#1">[#1]</a></td></tr></table></td></tr><tr ><td class="posttext"> If I do:<br><br>_socket=New Socket( "datagram" )<br>_socket.Bind("localhost", port)<br>Print "Socket bound to " + _socket.LocalAddress.ToString()<br><br>Output is: <br>Socket bound to 127.0.0.1:51464<br><br>However if I do:<br><br>_socket=New Socket( "datagram" )<br>_socket.Bind("", port)<br>Print "Socket bound to " + _socket.LocalAddress.ToString()<br><br>Output is: <br>Socket bound to 0.0.0.0:51464<br><br>Is not "" that same as localhost? or is a "slower" dns lookup happening here behind the scenes? Does this mean that "" returns directly, and if using localhost, 127.0.0.1 or any other address I should use the Async version?<br><br>Also what happens when I close the App without closing the socket? Should it close or be left open? <br><br></td></tr></table><br>
<a name="2059327"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#2">[#2]</a></td></tr></table></td></tr><tr ><td class="posttext"> &gt; Socket bound to 0.0.0.0:51464<br><br>Not totally sure myself, but I think binding a socket to "localhost" means it can only be reached via a connection to "localhost", while binding a socket to "" means it can be reached via a connection to "localhost", "192.168.0.1" etc, basically 'any address that successfully identifies this machine'.<br><br>My advice would be to bind to "" (which is what I/bmx have always done in the past). I did in fact almost just leave it as just Bind( port ) but all targets support binding to host too, so I left it in there in case someone who knows what they're doing needs it. <br><br>As for BindAsync, I'm not sure what this is for either, but this is how winrt wants you to bind so I left it in there in case we need it later for some reason.<br><br>&gt; Also what happens when I close the App without closing the socket? Should it close or be left open?<br><br>I'm assuming socket will auto-close when app exits but am yet to confirm this on all targets. <br><br></td></tr></table><br>
<a name="2059340"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >DruggedBunny</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#3">[#3]</a></td></tr></table></td></tr><tr ><td class="posttext"> Looked this up out of curiosity. It seems that "" is treated by bind() as constant INADDR_ANY (0), which is considered to be IP address 0.0.0.0. Therefore "localhost" and "" should certainly be expected to produce different results:<br><br><a href="http://publib.boulder.ibm.com/infocenter/zvm/v6r1/index.jsp?topic=/com.ibm.zvm.v610.edclv/bind.htm" target="_blank">http://publib.boulder.ibm.com/infocenter/zvm/v6r1/index.jsp?topic=/com.ibm.zvm.v610.edclv/bind.htm</a><br><br><div class="quote"> <br>I think binding a socket to "localhost" means it can only be reached via a connection to "localhost", while binding a socket to "" means it can be reached via a connection to "localhost", "192.168.0.1" etc, basically 'any address that successfully identifies this machine'<br> <br></div><br><br>I get the same impression from the above link:<br><br><div class="quote"> <br>A couple things to notice: we used socket.gethostname() so that the socket would be visible to the outside world. If we had used s.bind(('localhost', 80)) or s.bind(('127.0.0.1', 80)) we would still have a “server” socket, but one that was only visible within the same machine. s.bind(('', 80)) specifies that the socket is reachable by any address the machine happens to have.<br> <br></div><br><br>... and that's interesting, as it seems to suggest that binding to "localhost" should mean that *only* a client running on the same machine as the server could access it... which I never knew! It also suggests a missed trick in BlitzMax, as this would presumably mean you could create a more secure server on your local network if you could specify "localhost" or a "192.168.x.x"-style address, preventing any outside access. <br><br></td></tr></table><br>
<a name="2059339"></a>

<a name="2059347"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#4">[#4]</a></td></tr></table></td></tr><tr ><td class="posttext"> &gt; It also suggests a missed trick in BlitzMax, as this would presumably mean you could create a more secure server on your local network if you could specify "localhost" or a "192.168.x.x"-style address, preventing any outside access.<br><br>Indeed! <br><br></td></tr></table><br>
<a name="2059373"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#5">[#5]</a></td></tr></table></td></tr><tr ><td class="posttext"> Great! <br><br>I found another thing I was confused about. It seems that when I call SendAsync that SendOnComplete and ReceiveOnComplete both called, even though no receive has happened?<br><br>Here is a runnable example:<br>[monkeycode]<br>Import mojo<br><br>Import brl.socket<br><br>Class PingClientUDP Implements IOnSendToComplete, IOnReceiveFromComplete<br>Private<br>	<br>	Field _socket:Socket<br>	Field _receivedata:= New DataBuffer(1024)<br>	Field _senddata:= New DataBuffer(1024)<br>	Field _localAddress:SocketAddress<br>	Field _serverAddress:SocketAddress<br>	Field _pingID:Int = 1<br>	Field _verbose:Bool = True<br>	<br>Public<br>	Method New(serverAddress:String, serverPort:Int)<br>		_serverAddress = New SocketAddress(serverAddress, serverPort)<br>		_localAddress = New SocketAddress()'"localhost", 0)<br>		_socket=New Socket( "datagram" )<br>		If Not _socket.Bind("", 0) Print "Bind failed"<br>		If _verbose Then Print "Socket bound to " + _socket.LocalAddress.ToString()<br>		_socket.ReceiveFromAsync(_receivedata, 0, _receivedata.Length, _localAddress, Self)<br>	End<br>	<br>	'Call this every few sec to send data to server<br>	Method SendPingToServer:Void()<br>		'DebugStop()<br>		Local dataToSend:String = "Ping" + _pingID<br>		Local n:= _senddata.PokeString(0, dataToSend)<br>		_socket.SendToAsync(_senddata, 0, n, _serverAddress, Self)<br>		_pingID += 1<br>	End<br>		<br>Private<br>	Method OnSendToComplete:Void( data:DataBuffer,offset:Int,count:Int,address:SocketAddress,source:Socket )<br>		If _verbose Then Print "Sent ping [" + (_pingID - 1) + "] to server [" + address.Host + ":" + address.Port + "]"<br>	End<br>	<br>	Method OnReceiveFromComplete:Void( data:DataBuffer,offset:Int,count:Int,address:SocketAddress,source:Socket )<br>		If count &gt;= 0<br>			If _verbose Then Print "Client Received [" + data.PeekString(offset, count).Length + "] bytes: " + data.PeekString(offset, count)<br>		Else<br>			If _verbose Then Print "Received nothing..."<br>		End<br>		_socket.ReceiveFromAsync _receivedata, 0, _receivedata.Length, _localAddress, Self<br>	End<br>	<br>End<br><br>Class MyPingClientApp Extends App<br><br>	Field _client:PingClientUDP<br>	<br>	Field _delta:Float = 1.0 / 60.0<br>	Field _clientSendTimer:Float<br><br>	Method OnCreate()<br>		_client = New PingClientUDP("localhost", 53568)<br>		_client.SendPingToServer()<br>		<br>		SetUpdateRate 60<br>	End<br>	<br>	Method OnUpdate()<br>		UpdateAsyncEvents<br>		<br>		Local clientSendFrequency:Int = 1<br>		_clientSendTimer += _delta<br>		If _clientSendTimer &gt; clientSendFrequency<br>			_client.SendPingToServer()<br>			_clientSendTimer = 0<br>		End<br>	End<br>	<br>	Method OnRender()<br>		Cls<br>		DrawText "UDP Client Online", 0, 0<br>	End<br><br>End<br><br>Function Main()<br><br>	New MyPingClientApp<br>	<br>End<br>[/monkeycode]<br><br>Notice that Received is called each send. Or is this intended?<br><br>I really liked before when I could tell the receive to "wait" for X number of bytes. Makes the packetizer code very simple. However the current "return each frame" approach is maybe more familiar since that basically how they do it in C# or nodejs. <br><br></td></tr></table><br>
<a name="2059372"></a>

<a name="2059371"></a>

<a name="2059370"></a>

<a name="2059405"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#6">[#6]</a></td></tr></table></td></tr><tr ><td class="posttext"> Hi,<br><br>Not quite sure what you mean. When I run, I get:<br><br><pre class=code>
Socket bound to 0.0.0.0:61657
Sent ping [1] to server [127.0.0.1:53568]
Sent ping [2] to server [127.0.0.1:53568]
Sent ping [3] to server [127.0.0.1:53568]
</pre><br><br>Which looks right because there's no 'ping' server running at port 53568 as far as I know...?<br><br>If there was, then I would imagine you'd get an OnReceiveFromComplete when data is sent - because the server will be 'echoing' the data and your client is ReceveAsync-ing all the time.<br><br>&gt; I really liked before when I could tell the receive to "wait" for X number of bytes. Makes the packetizer code very simple. <br><br>This could easily be added via a Read/ReadAsync 'flags' parameter - or perhaps a Socket.SetOptions method. It's probably easier for the Socket code to do this when necessary than it would be for app code, so it's probably a good idea. Send on the other hand should probably *always* send all bytes, correct? <br><br></td></tr></table><br>
<a name="2059404"></a>

<a name="2059403"></a>

<a name="2059402"></a>

<a name="2059618"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >marksibly</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#7">[#7]</a></td></tr></table></td></tr><tr ><td class="posttext"> &gt; I really liked before when I could tell the receive to "wait" for X number of bytes.<br><br>Ok, I've added ReceiveAll and ReceiveAllAsync to v71b - same params as plain Receive/ReceiveAsync (including same OnComplete handlers), only they wait until 'count' bytes have arrived (or the stream is closed) instead of 'at least 1' bytes. <br><br></td></tr></table><br>
<a name="2059629"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td class="posthead"><table width=100% cellspacing=0 cellpadding=0><tr ><td >Tibit</td><td align="right"><font class=tiny>(Posted 2013)</font>&nbsp;<a href="#8">[#8]</a></td></tr></table></td></tr><tr ><td class="posttext"> Cool :) <br><br></td></tr></table><br>
<a name="bottom"></a>
<table width=100% cellspacing=0 cellpadding=0><tr ><td align="right"><a href="http://monkeycoder.co.nz" target="_blank"><img src="/img/monkey2.svg" ></a> <a href="https://github.com/blitz-research" target="_blank"><img src="/img/github.svg" ></a> <a href="https://discord.gg/qJccbSp" target="_blank"><img src="/img/discord.svg" ></a></td></tr></table><br></div><br><table width="100%"><tr><td></body></html lang="en">
